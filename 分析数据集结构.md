# mbpp+

{
    "task_id": "Mbpp/2", 

    "prompt": "\"\"\"\nWrite a function to find the shared elements from the given two lists.\nassert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))\n\"\"\"\n", 
    
    "public_test_cases": ["assert similar_elements([3, 4, 5, 6], [5, 7, 4, 10]) == (4, 5)", "assert similar_elements([1, 2, 3, 4], [5, 4, 3, 7]) == (3, 4)", "assert similar_elements([11, 12, 14, 13], [17, 15, 14, 13]) == (13, 14)"], 
    
    "entry_point": "similar_elements", 
    "canonical_solution": "\ndef similar_elements(test_tup1, test_tup2):\n  return tuple(set(test_tup1) & set(test_tup2))\n"
}


# he+

{
    "task_id": "HumanEval/0", 

    "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", 
    
    "public_test_cases": ["assert has_close_elements([1.0, 2.0, 3.0], 0.5) == False", "assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True"], 
    
    "test": "\n\nimport numpy as np\n\ndef is_floats(x) -> bool:\n    # check if it is float; List[float",3
    
    "entry_point": "has_close_elements", 
    
    "canonical_solution": "\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n"
}


# LCB

{
    "question_title": "A. Short Sort", 
    
    "question_content": "There are three cards with letters $\\texttt{a}$, $\\texttt{b}$, $\\texttt{c}$ placed in a row in some order. You can do the following operation at most once: \n\n \n-  Pick two cards, and swap them.  Is it possible that the row becomes $\\texttt{abc}$ after the operation? Output \"YES\" if it is possible, and \"NO\" otherwise.\n\nInput\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 6$) — the number of test cases.\n\nThe only line of each test case contains a single string consisting of each of the three characters $\\texttt{a}$, $\\texttt{b}$, and $\\texttt{c}$ exactly once, representing the cards.\n\nOutput\n\nFor each test case, output \"YES\" if you can make the row $\\texttt{abc}$ with at most one operation, or \"NO\" otherwise.\n\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).Sample Input 1:\n6\n\nabc\n\nacb\n\nbac\n\nbca\n\ncab\n\ncba\n\n\n\nSample Output 1:\n\nYES\nYES\nYES\nNO\nNO\nYES\n\n\nNote\n\nIn the first test case, we don't need to do any operations, since the row is already $\\texttt{abc}$.\n\nIn the second test case, we can swap $\\texttt{c}$ and $\\texttt{b}$: $\\texttt{acb} \\to \\texttt{abc}$.\n\nIn the third test case, we can swap $\\texttt{b}$ and $\\texttt{a}$: $\\texttt{bac} \\to \\texttt{abc}$.\n\nIn the fourth test case, it is impossible to make $\\texttt{abc}$ using at most one operation.", 
    
    "platform": "codeforces", 
    
    "question_id": "1873_A", 
    
    "contest_id": "1873", 
    
    "contest_date": "2023-08-21T00:00:00", 
    
    "starter_code": "", 
    
    "difficulty": "easy", 
    
    "public_test_cases": "[{\"input\": \"6\\nabc\\nacb\\nbac\\nbca\\ncab\\ncba\\n\", \"output\": \"YES\\nYES\\nYES\\nNO\\nNO\\nYES\\n\", \"testtype\": \"stdin\"}]", 
    
    "metadata": "{}"
}

# CC

{
    "question_id": "1575_A. Another Sorting Problem", 
    
    "question_content": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nNote\n\nThe following illustrates the first example.\n\n<image>", 
    
    "public_test_cases": "[{\"input\": \"5 2\\nAA\\nAB\\nBB\\nBA\\nAZ\\n\", \"output\": \"5 2 1 3 4 \\n\", \"testtype\": \"stdin\"}]", 
    
    "private_test_cases": ""
}



# 正则摘取方法

```python
def extract_code(response, language="python"):
    pattern = rf"```{language.lower()}(.*?)```"
    match = re.search(pattern, response, re.DOTALL)
    if match:
        return match.group(1).strip()
    
    pattern = r"```(.*?)```"
    match = re.search(pattern, response, re.DOTALL)
    if match:
        return match.group(1).strip()
    return response.strip()
```



