{"task_id": "1873_A", "solution": "t = int(input())\ntarget = \"abc\"\n\nfor _ in range(t):\n    s = input().strip()\n    \n    # If already sorted, no operation needed\n    if s == target:\n        print(\"YES\")\n        continue\n    \n    # Convert to list for easy swapping\n    arr = list(s)\n    found = False\n\n    # Try all possible swaps (0-1, 0-2, 1-2)\n    for i in range(3):\n        for j in range(i + 1, 3):\n            # Perform swap\n            arr[i], arr[j] = arr[j], arr[i]\n            \n            # Check if it matches target\n            if ''.join(arr) == target:\n                print(\"YES\")\n                found = True\n                break\n            \n            # Revert the swap\n            arr[i], arr[j] = arr[j], arr[i]\n        \n        if found:\n            break\n    else:\n        print(\"NO\")"}
{"task_id": "1873_B", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        max_product = 0\n        \n        # Try incrementing each digit once\n        for i in range(n):\n            # Create a copy and increment the ith digit\n            temp = a[:]\n            temp[i] += 1\n            \n            # Calculate the product of all digits in temp\n            product = 1\n            for num in temp:\n                product *= num\n                \n            if product > max_product:\n                max_product = product\n                \n        results.append(str(max_product))\n        \n    print(\"\\n\".join(results))\n\n# Call the function to process input and print output\nsolve()"}
{"task_id": "1873_D", "solution": "def min_operations(n, k, s):\n    operations = 0\n    last_end = -1  # Last index that is covered by some operation\n    \n    i = 0\n    while i < n:\n        if s[i] == 'B':\n            if i > last_end:\n                # Need to start a new operation here\n                operations += 1\n                last_end = i + k - 1  # This operation covers [i, i+k-1]\n        i += 1\n        \n    return operations\n\n# Read input and solve\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index+1])\n    s = data[index+2]\n    index += 3\n    \n    result = min_operations(n, k, s)\n    results.append(str(result))\n\n# Print all results\nprint(\"\\n\".join(results))"}
{"task_id": "1883_B", "solution": "def can_form_palindrome_after_deletion(s, k):\n    n = len(s)\n    from collections import Counter\n    \n    # Count frequency of each character\n    freq = Counter(s)\n    \n    # Count how many characters have odd frequencies\n    odd_count = sum(1 for count in freq.values() if count % 2 == 1)\n    \n    # After removing k characters, the target number of odd counts\n    # should be (n - k) % 2 for forming a palindrome\n    target_odd = (n - k) % 2\n    \n    # The difference between current odd count and target\n    diff = abs(odd_count - target_odd)\n    \n    # We can adjust the odd count by at most k through deletions\n    return diff <= k\n\n# Read number of test cases\nt = int(input())\n\nfor _ in range(t):\n    # Read n and k\n    n, k = map(int, input().split())\n    \n    # Read the string\n    s = input().strip()\n    \n    # Check if it's possible to form a palindrome after removing exactly k characters\n    if can_form_palindrome_after_deletion(s, k):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"task_id": "1883_C", "solution": "import math\nfrom collections import defaultdict\nimport heapq\n\ndef get_prime_factors(n):\n    \"\"\"Return dictionary of prime factors and their counts.\"\"\"\n    factors = defaultdict(int)\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] += 1\n            n //= d\n        d += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\n# Precompute factorizations for numbers 1 to 10\nnum_factorizations = {}\nfor i in range(1, 11):\n    num_factorizations[i] = get_prime_factors(i)\n\n# Primes involved in k values 2, 3, 4, 5\nprimes_needed = {\n    2: {2: 1},\n    3: {3: 1},\n    4: {2: 2},\n    5: {5: 1}\n}\n\ndef min_operations_to_divisible(a, k):\n    # Get required prime factors for k\n    req_factors = primes_needed[k]\n    \n    # Count current prime factors in array\n    current_factors = defaultdict(int)\n    for num in a:\n        for p, cnt in num_factorizations[num].items():\n            current_factors[p] += cnt\n    \n    # Check if already satisfied\n    satisfied = True\n    for p, req_cnt in req_factors.items():\n        if current_factors[p] < req_cnt:\n            satisfied = False\n            break\n    if satisfied:\n        return 0\n    \n    # Calculate deficit for each required prime\n    deficit = {}\n    for p, req_cnt in req_factors.items():\n        deficit[p] = max(0, req_cnt - current_factors[p])\n    \n    # For each number, calculate cost to improve\n    # Try increasing each number by at least 0 to 5 (enough for small examples)\n    improvements = []  # list of (cost, delta_factors_dict)\n    \n    for idx in range(len(a)):\n        num = a[idx]\n        for inc in range(6):  # Try incrementing up to 5 times\n            new_num = num + inc\n            old_factors = num_factorizations[num]\n            new_factors = num_factorizations[new_num]\n            \n            # Calculate improvement in factors\n            delta_factors = defaultdict(int)\n            for p in req_factors:\n                delta = new_factors.get(p, 0) - old_factors.get(p, 0)\n                if delta > 0:\n                    delta_factors[p] = delta\n            \n            if delta_factors:\n                improvements.append((inc, delta_factors))\n    \n    # Sort improvements by cost\n    improvements.sort()\n    \n    # Greedily apply improvements until deficit is met\n    ops = 0\n    for cost, delta_factors in improvements:\n        # Check if this helps reduce any deficit\n        useful = False\n        for p, delta in delta_factors.items():\n            if deficit[p] > 0:\n                useful = True\n                break\n        \n        if useful:\n            ops += cost\n            for p, delta in delta_factors.items():\n                deficit[p] = max(0, deficit[p] - delta)\n            \n            # Re-check if all deficits are met\n            all_met = True\n            for req_p, _ in req_factors.items():\n                if deficit[req_p] > 0:\n                    all_met = False\n                    break\n            if all_met:\n                return ops\n    \n    return ops\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx+1])\n        idx += 2\n        a = list(map(int, data[idx:idx+n]))\n        idx += n\n        \n        res = min_operations_to_divisible(a, k)\n        results.append(str(res))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1899_A", "solution": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n % 3 == 0:\n        print(\"Second\")\n    else:\n        print(\"First\")"}
{"task_id": "1899_B", "solution": "def solve():\n    import sys\n    import math\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Function to find all divisors of n\n        def get_divisors(num):\n            divs = set()\n            for i in range(1, int(math.sqrt(num)) + 1):\n                if num % i == 0:\n                    divs.add(i)\n                    if i != num // i:\n                        divs.add(num // i)\n            return sorted(divs)\n        \n        divisors = get_divisors(n)\n        max_diff = 0\n        \n        # Iterate through all divisors except n itself (since that would result in only one truck)\n        for k in divisors:\n            if k == n:\n                continue\n            num_trucks = n // k\n            sums = []\n            for i in range(num_trucks):\n                s = sum(a[i*k:(i+1)*k])\n                sums.append(s)\n            diff = max(sums) - min(sums)\n            if diff > max_diff:\n                max_diff = diff\n                \n        results.append(str(max_diff))\n    \n    print('\\n'.join(results))\n\nsolve()"}
{"task_id": "1899_C", "solution": "def kadane(arr):\n    max_ending_here = max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        if n == 1:\n            results.append(str(a[0]))\n            continue\n            \n        max_sum = float('-inf')\n        start = 0\n        \n        for end in range(1, n):\n            # Check if current element and previous element have same parity\n            if a[end] % 2 == a[end-1] % 2:\n                # Apply Kadane's algorithm on the segment from start to end-1\n                current_max = kadane(a[start:end])\n                max_sum = max(max_sum, current_max)\n                start = end  # Start new segment\n        \n        # Don't forget the last segment\n        current_max = kadane(a[start:])\n        max_sum = max(max_sum, current_max)\n        \n        results.append(str(max_sum))\n    \n    print(\"\\n\".join(results))\n\nsolve()"}
{"task_id": "1899_D", "solution": "from collections import Counter\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        freq = Counter(a)\n        total = 0\n        \n        # Count pairs with same value\n        for count in freq.values():\n            if count >= 2:\n                total += count * (count - 1) // 2\n        \n        # Count pairs where one is 1 and other is 2\n        count_1 = freq.get(1, 0)\n        count_2 = freq.get(2, 0)\n        total += count_1 * count_2\n        \n        results.append(str(total))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "2727", "solution": "class Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        count = 0\n        for detail in details:\n            # Extract the age substring (characters at index 11 and 12)\n            age_str = detail[11:13]\n            # Convert to integer\n            age = int(age_str)\n            # Check if the person is strictly more than 60 years old\n            if age > 60:\n                count += 1\n        return count"}
{"task_id": "2728", "solution": "class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        # Step 1: Sort each row in descending order\n        for row in nums:\n            row.sort(reverse=True)\n        \n        # Step 2: Initialize score\n        score = 0\n        \n        # Step 3: Iterate through each column index\n        for col_idx in range(len(nums[0])):\n            # Step 4: Find the maximum element in this column across all rows\n            max_in_column = 0\n            for row_idx in range(len(nums)):\n                max_in_column = max(max_in_column, nums[row_idx][col_idx])\n            \n            # Step 5: Add the maximum to the score\n            score += max_in_column\n        \n        # Step 6: Return the final score\n        return score"}
{"task_id": "2730", "solution": "class Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        \n        # Precompute prefix ORs\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] | nums[i]\n        \n        # Precompute suffix ORs\n        suffix = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            suffix[i] = suffix[i + 1] | nums[i]\n        \n        max_or = 0\n        # Try applying all k operations to each element\n        for i in range(n):\n            # Apply all k operations to nums[i]\n            modified_num = nums[i] << k\n            # Calculate the OR with prefix and suffix\n            current_or = prefix[i] | modified_num | suffix[i + 1]\n            max_or = max(max_or, current_or)\n        \n        return max_or"}
{"task_id": "2754", "solution": "from typing import List\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_product = float('-inf')\n        \n        # Iterate through all non-empty subsets using bitmask\n        for mask in range(1, 1 << n):\n            product = 1\n            for i in range(n):\n                if mask & (1 << i):\n                    product *= nums[i]\n            max_product = max(max_product, product)\n        \n        return max_product"}
{"task_id": "2755", "solution": "class Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        # Convert dictionary to a set for O(1) average time complexity lookups\n        word_set = set(dictionary)\n        n = len(s)\n        \n        # dp[i] will store the minimum number of extra characters in the first i characters of s\n        dp = [float('inf')] * (n + 1)\n        \n        # Base case: no characters mean no extra characters\n        dp[0] = 0\n        \n        # Fill the dp array\n        for i in range(1, n + 1):\n            # Initially assume the ith character is extra\n            dp[i] = dp[i - 1] + 1\n            \n            # Check all possible substrings ending at position i\n            for j in range(i):\n                if s[j:i] in word_set:\n                    dp[i] = min(dp[i], dp[j])\n        \n        return dp[n]"}
{"task_id": "2756", "solution": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        # Initialize the two smallest prices to infinity\n        first_min = float('inf')\n        second_min = float('inf')\n        \n        # Find the two smallest prices in one pass\n        for price in prices:\n            if price < first_min:\n                second_min = first_min\n                first_min = price\n            elif price < second_min:\n                second_min = price\n        \n        # Calculate the minimum cost to buy two chocolates\n        min_cost = first_min + second_min\n        \n        # Check if we can afford the two chocolates\n        if min_cost <= money:\n            return money - min_cost\n        else:\n            return money"}
{"task_id": "2757", "solution": "class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Helper function to subtract 1 from a numeric string\n        def subtract_one(s):\n            # Convert to list for easier manipulation\n            digits = list(s)\n            i = len(digits) - 1\n            # Borrow logic for subtraction\n            while i >= 0 and digits[i] == '0':\n                digits[i] = '9'\n                i -= 1\n            if i >= 0:\n                digits[i] = str(int(digits[i]) - 1)\n            # Remove leading zeros\n            result = ''.join(digits).lstrip('0')\n            return result if result else \"0\"\n        \n        # Digit DP function to count valid numbers from 0 to s\n        def count_up_to(s):\n            n = len(s)\n            memo = {}\n            \n            def dp(pos, tight, started, digit_sum):\n                # Base case\n                if pos == n:\n                    if started and min_sum <= digit_sum <= max_sum:\n                        return 1\n                    return 0\n                \n                if (pos, tight, started, digit_sum) in memo:\n                    return memo[(pos, tight, started, digit_sum)]\n                \n                # Determine the limit for current digit\n                limit = int(s[pos]) if tight else 9\n                result = 0\n                \n                # Try all possible digits at current position\n                for digit in range(0, limit + 1):\n                    new_tight = tight and (digit == limit)\n                    new_started = started or (digit > 0)\n                    new_digit_sum = digit_sum + digit if new_started else 0\n                    \n                    # Optimization: early pruning if digit_sum exceeds max_sum\n                    if new_started and new_digit_sum > max_sum:\n                        break\n                    \n                    result = (result + dp(pos + 1, new_tight, new_started, new_digit_sum)) % MOD\n                \n                memo[(pos, tight, started, digit_sum)] = result\n                return result\n            \n            return dp(0, True, False, 0)\n        \n        # Calculate count for [0, num2] - [0, num1-1]\n        count_num2 = count_up_to(num2)\n        count_num1_minus_1 = count_up_to(subtract_one(num1))\n        \n        return (count_num2 - count_num1_minus_1) % MOD"}
{"task_id": "2777", "solution": "class Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        \n        # Step 1: Compute prefix distinct counts\n        prefix_distinct = [0] * n\n        seen_prefix = set()\n        for i in range(n):\n            seen_prefix.add(nums[i])\n            prefix_distinct[i] = len(seen_prefix)\n        \n        # Step 2: Compute suffix distinct counts\n        suffix_distinct = [0] * (n + 1)  # Extra space to handle i+1 safely\n        seen_suffix = set()\n        for i in range(n - 1, -1, -1):\n            seen_suffix.add(nums[i])\n            suffix_distinct[i] = len(seen_suffix)\n        \n        # Step 3: Calculate the result array\n        diff = []\n        for i in range(n):\n            # suffix starts from index i+1\n            prefix_count = prefix_distinct[i]\n            suffix_count = suffix_distinct[i + 1]\n            diff.append(prefix_count - suffix_count)\n        \n        return diff"}
{"task_id": "2779", "solution": "class Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the array with all 0s (uncolored)\n        nums = [0] * n\n        # Keep track of the count of adjacent elements with same color\n        adjacent_count = 0\n        # Result array to store the count after each query\n        result = []\n        \n        for index, color in queries:\n            # Get the previous color at this index\n            prev_color = nums[index]\n            \n            # If the previous color was not 0, we might need to decrease the count\n            if prev_color != 0:\n                # Check left neighbor\n                if index > 0 and nums[index - 1] == prev_color:\n                    adjacent_count -= 1\n                # Check right neighbor\n                if index < n - 1 and nums[index + 1] == prev_color:\n                    adjacent_count -= 1\n            \n            # Update the color at the index\n            nums[index] = color\n            \n            # If the new color is not 0, we might need to increase the count\n            if color != 0:\n                # Check left neighbor\n                if index > 0 and nums[index - 1] == color:\n                    adjacent_count += 1\n                # Check right neighbor\n                if index < n - 1 and nums[index + 1] == color:\n                    adjacent_count += 1\n            \n            # Add current count to result\n            result.append(adjacent_count)\n        \n        return result"}
{"task_id": "2784", "solution": "class Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        ans = 0\n        sum_min_nonempty = 0\n        \n        for num in nums:\n            # Add contribution of subsets where current element is max\n            # Contribution = num^3 (for singleton set) + num^2 * sum of mins of all previous subsets\n            ans = (ans + pow(num, 3, MOD) + (pow(num, 2, MOD) * sum_min_nonempty) % MOD) % MOD\n            \n            # Update sum_min_nonempty for next iteration\n            # It's sum of mins of all subsets of elements processed so far\n            sum_min_nonempty = (2 * sum_min_nonempty + num) % MOD\n            \n        return ans"}
{"task_id": "2785", "solution": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        if nums[0] == 1 and nums[-1] == n:\n            return 0\n            \n        # Find positions of 1 and n\n        pos_1 = nums.index(1)\n        pos_n = nums.index(n)\n        \n        # Calculate the number of swaps needed\n        # pos_1 swaps to move 1 to the front\n        # (n - 1 - pos_n) swaps to move n to the end\n        # Subtract 1 if 1 comes after n originally (they will cross paths)\n        return pos_1 + (n - 1 - pos_n) - (1 if pos_1 > pos_n else 0)"}
{"task_id": "2786", "solution": "class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        if n <= 2:\n            return n\n        \n        left = 0\n        max_len = 0\n        pair_count = 0  # Count of consecutive same digit pairs in current window\n\n        for right in range(1, n):\n            # Check if we have a new consecutive pair\n            if s[right] == s[right - 1]:\n                pair_count += 1\n            \n            # Shrink window while we have more than one pair\n            while pair_count > 1:\n                # If the leftmost part of the window forms a pair, decrease count\n                if s[left] == s[left + 1]:\n                    pair_count -= 1\n                left += 1\n            \n            # Update maximum length at each valid window position\n            max_len = max(max_len, right - left + 1)\n        \n        return max_len"}
{"task_id": "2791", "solution": "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        # Set to keep track of friends who have received the ball\n        visited = set()\n        \n        # Start at friend 1 (using 0-based indexing)\n        current_friend = 0\n        turn = 1\n        \n        # Continue until someone receives the ball for the second time\n        while current_friend not in visited:\n            visited.add(current_friend)\n            # Calculate next position: move turn*k steps clockwise\n            current_friend = (current_friend + turn * k) % n\n            turn += 1\n        \n        # Find all friends who never received the ball\n        losers = []\n        for i in range(n):\n            if i not in visited:\n                losers.append(i + 1)  # Convert back to 1-based indexing\n        \n        return losers"}
{"task_id": "2792", "solution": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        xor_result = 0\n        for value in derived:\n            xor_result ^= value\n        return xor_result == 0"}
{"task_id": "2800", "solution": "class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            # Check if the current character and the top of the stack form \"AB\" or \"CD\"\n            if stack and ((stack[-1] == 'A' and char == 'B') or (stack[-1] == 'C' and char == 'D')):\n                stack.pop()  # Remove the matching pair\n            else:\n                stack.append(char)  # Push current character\n        return len(stack)"}
{"task_id": "2802", "solution": "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def can_partition(s, target):\n            # Base case: if string is empty, check if target is also zero\n            if not s:\n                return target == 0\n            \n            # Try all possible splits of the string\n            for i in range(1, len(s) + 1):\n                # Take prefix of length i\n                prefix = s[:i]\n                # Convert to integer\n                prefix_val = int(prefix)\n                \n                # If this value exceeds target, no point in proceeding further\n                # (only valid for positive targets)\n                if prefix_val > target and target >= 0:\n                    break\n                \n                # Recursively check if the rest can be partitioned\n                if can_partition(s[i:], target - prefix_val):\n                    return True\n            \n            return False\n        \n        result = 0\n        for i in range(1, n + 1):\n            square = i * i\n            square_str = str(square)\n            \n            if can_partition(square_str, i):\n                result += square\n                \n        return result"}
{"task_id": "2808", "solution": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        # dp[j] represents the minimum cost to get at least j units of (time + 1)\n        # We only need to track up to n, since anything above n is sufficient\n        INF = float('inf')\n        dp = [INF] * (n + 1)\n        dp[0] = 0\n        \n        # For each wall, we decide whether to assign it to the paid painter\n        for i in range(n):\n            # Traverse backwards to prevent using updated values in same iteration\n            for j in range(n, -1, -1):\n                # If we include this wall, we gain (time[i] + 1) towards our target\n                # So we look at dp[max(0, j - (time[i] + 1))] \n                prev_j = max(0, j - (time[i] + 1))\n                dp[j] = min(dp[j], dp[prev_j] + cost[i])\n        \n        # The answer is the minimum cost to reach at least n units\n        return dp[n]"}
{"task_id": "2810", "solution": "class Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        # min_costs[i] stores the minimum cost to collect chocolate of type i\n        min_costs = list(nums)\n        result = sum(nums)  # initial cost with 0 rotations\n        \n        # Try rotating k times, k from 1 to n-1\n        for k in range(1, n):\n            # Update min_costs with new possible lower costs after k rotations\n            for i in range(n):\n                rotated_index = (i + k) % n\n                min_costs[i] = min(min_costs[i], nums[rotated_index])\n            \n            # Calculate total cost: collection costs + rotation costs\n            rotation_cost = k * x\n            collection_cost = sum(min_costs)\n            total_cost = collection_cost + rotation_cost\n            \n            result = min(result, total_cost)\n        \n        return result"}
{"task_id": "2811", "solution": "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        # Numbers we can safely take from 1 to k//2\n        first_part_count = min(n, k // 2)\n        # Sum of 1, 2, ..., first_part_count\n        first_part_sum = first_part_count * (first_part_count + 1) // 2\n        \n        if first_part_count == n:\n            return first_part_sum\n            \n        # Remaining numbers we need to take\n        remaining = n - first_part_count\n        \n        # We take numbers starting from k to avoid conflicts\n        # These are k, k+1, k+2, ..., k + remaining - 1\n        # Sum = remaining * k + (remaining - 1) * remaining // 2\n        second_part_sum = remaining * k + (remaining - 1) * remaining // 2\n        \n        return first_part_sum + second_part_sum"}
{"task_id": "2812", "solution": "class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        # The maximum achievable x is num + 2*t\n        # This is because we can decrease x by 1 and increase num by 1 in each operation\n        # So if we start with x = num + 2*t, after t operations:\n        # x will be (num + 2*t) - t = num + t\n        # num will be num + t\n        # Hence they'll be equal and we've used exactly t operations\n        return num + 2 * t"}
{"task_id": "2816", "solution": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        # Convert string to list for easy modification\n        chars = list(s)\n        left = 0\n        right = len(s) - 1\n        \n        # Process pairs from both ends moving towards center\n        while left < right:\n            # If characters don't match, replace both with the smaller one\n            if chars[left] != chars[right]:\n                smaller_char = min(chars[left], chars[right])\n                chars[left] = smaller_char\n                chars[right] = smaller_char\n            # Move pointers inward\n            left += 1\n            right -= 1\n            \n        # Convert back to string and return\n        return ''.join(chars)"}
{"task_id": "2817", "solution": "class Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        \n        # Iterate through each adjacent pair\n        for i in range(n - 1):\n            # If there's a transition between different characters\n            if s[i] != s[i + 1]:\n                # Add the minimum cost to resolve this transition\n                cost += min(i + 1, n - (i + 1))\n                \n        return cost"}
{"task_id": "2819", "solution": "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        # Start from the end and find where the trailing zeros end\n        i = len(num) - 1\n        while i >= 0 and num[i] == '0':\n            i -= 1\n        \n        # Return substring from start to where trailing zeros begin\n        return num[:i+1]"}
{"task_id": "2824", "solution": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Step 1: Compute 2*n and 3*n\n        double_n = 2 * n\n        triple_n = 3 * n\n        \n        # Step 2: Concatenate n, 2*n, and 3*n into one string\n        concatenated = str(n) + str(double_n) + str(triple_n)\n        \n        # Step 3: Check if the concatenated string meets the criteria\n        # It must have exactly 9 digits and contain each digit from 1-9 exactly once\n        if len(concatenated) != 9:\n            return False\n            \n        # Convert to set to check uniqueness and content\n        digit_set = set(concatenated)\n        \n        # Must not contain '0' and must contain exactly the digits 1-9\n        return digit_set == set('123456789')"}
{"task_id": "2825", "solution": "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        # The minimized string length is simply the number of unique characters\n        # because each character that appears more than once can be reduced to\n        # a single instance, but characters appearing only once cannot be removed.\n        return len(set(s))"}
{"task_id": "2827", "solution": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n == 1:\n            return True\n\n        # If any element is 1 and there's more than one element, it's impossible\n        if 1 in nums:\n            return False\n\n        # Sieve to compute smallest prime factor (SPF)\n        max_val = max(nums)\n        spf = list(range(max_val + 1))  # smallest prime factor\n        \n        i = 2\n        while i * i <= max_val:\n            if spf[i] == i:  # i is a prime\n                for j in range(i * i, max_val + 1, i):\n                    if spf[j] == j:\n                        spf[j] = i\n            i += 1\n\n        # Union-Find data structure\n        parent = list(range(n))\n        size = [1] * n\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])  # Path compression\n            return parent[x]\n\n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x != root_y:\n                # Union by size\n                if size[root_x] < size[root_y]:\n                    root_x, root_y = root_y, root_x\n                parent[root_y] = root_x\n                size[root_x] += size[root_y]\n\n        # Map each prime factor to the first index it was seen at\n        prime_to_index = {}\n\n        # Process each number\n        for idx, num in enumerate(nums):\n            temp = num\n            while temp > 1:\n                p = spf[temp]\n                if p in prime_to_index:\n                    union(idx, prime_to_index[p])\n                else:\n                    prime_to_index[p] = idx\n                # Remove all occurrences of p from temp\n                while temp % p == 0:\n                    temp //= p\n\n        # Check if all indices are connected to index 0\n        root_0 = find(0)\n        for i in range(1, n):\n            if find(i) != root_0:\n                return False\n        return True"}
{"task_id": "2828", "solution": "class Solution:\n    def smallestString(self, s: str) -> str:\n        # Convert string to list for easier manipulation\n        s_list = list(s)\n        n = len(s_list)\n        \n        # Find the first non-'a' character\n        start = 0\n        while start < n and s_list[start] == 'a':\n            start += 1\n        \n        # If all characters are 'a', we must perform operation\n        # Change the last 'a' to 'z'\n        if start == n:\n            s_list[-1] = 'z'\n            return ''.join(s_list)\n        \n        # Otherwise, apply operation from first non-'a' until we hit an 'a' or end\n        for i in range(start, n):\n            if s_list[i] == 'a':\n                break\n            # Replace with previous character\n            s_list[i] = chr(ord(s_list[i]) - 1)\n        \n        return ''.join(s_list)"}
{"task_id": "2831", "solution": "import math\nfrom typing import List\n\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        def first_digit(n):\n            while n >= 10:\n                n //= 10\n            return n\n        \n        def last_digit(n):\n            return n % 10\n        \n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                first_d = first_digit(nums[i])\n                last_d = last_digit(nums[j])\n                if math.gcd(first_d, last_d) == 1:\n                    count += 1\n                    \n        return count"}
{"task_id": "2832", "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        # Step 1: Group indices by value\n        indices = defaultdict(list)\n        for i, x in enumerate(nums):\n            indices[x].append(i)\n        \n        max_len = 0\n        \n        # Step 2: For each group, apply sliding window\n        for vals in indices.values():\n            left = 0\n            for right in range(len(vals)):\n                # Calculate number of non-target elements between vals[left] and vals[right]\n                # That is: (vals[right] - vals[left] + 1) - (right - left + 1)\n                # Simplifies to: vals[right] - vals[left] - (right - left)\n                while vals[right] - vals[left] - (right - left) > k:\n                    left += 1\n                \n                max_len = max(max_len, right - left + 1)\n        \n        return max_len"}
{"task_id": "2833", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Step 1: Sort logs by time\n        logs.sort(key=lambda log: log[1])\n        \n        # Step 2: Prepare sorted queries with their original indices\n        indexed_queries = sorted((q, i) for i, q in enumerate(queries))\n        \n        # Initialize result array\n        result = [0] * len(queries)\n        \n        # Sliding window variables\n        left = 0\n        right = 0\n        server_count = defaultdict(int)  # Tracks count of requests per server in current window\n        \n        # Step 3: Process each query in sorted order\n        for query_time, original_index in indexed_queries:\n            start_time = query_time - x\n            end_time = query_time\n            \n            # Expand window to include all logs with time <= end_time\n            while right < len(logs) and logs[right][1] <= end_time:\n                server_id = logs[right][0]\n                server_count[server_id] += 1\n                right += 1\n            \n            # Contract window to exclude all logs with time < start_time\n            while left < len(logs) and logs[left][1] < start_time:\n                server_id = logs[left][0]\n                server_count[server_id] -= 1\n                if server_count[server_id] == 0:\n                    del server_count[server_id]\n                left += 1\n                \n            # Count inactive servers\n            inactive_servers = n - len(server_count)\n            result[original_index] = inactive_servers\n            \n        return result"}
{"task_id": "2834", "solution": "class Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        # Step 1: Initialize the set of occupied positions\n        occupied = set(nums)\n        \n        # Step 2: Process each move\n        for frm, to in zip(moveFrom, moveTo):\n            # Move all marbles from 'frm' to 'to'\n            if frm in occupied:\n                occupied.remove(frm)\n                occupied.add(to)\n        \n        # Step 3: Return the sorted list of occupied positions\n        return sorted(list(occupied))"}
{"task_id": "2837", "solution": "class Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        import math\n\n        # Helper to count number of 1-bits in binary representation\n        def popcount(x):\n            return bin(x).count('1')\n\n        # Iterate through possible number of operations k\n        for k in range(1, 101):  # Arbitrarily chosen upper limit based on constraints\n            target = num1 - k * num2\n            \n            # Necessary conditions\n            if target < 0:\n                continue\n            if target < k:\n                continue\n            if popcount(target) > k:\n                continue\n            \n            # All conditions satisfied\n            return k\n        \n        return -1"}
{"task_id": "2839", "solution": "from typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        # Step 1: Combine and sort pairs (a, b) by 'a' descending\n        pairs = sorted(zip(nums1, nums2), reverse=True)\n        \n        # Step 2: Sort queries by x descending, keeping track of original indices\n        indexed_queries = sorted([(x, y, i) for i, (x, y) in enumerate(queries)], reverse=True)\n        \n        # Result array to populate\n        res = [-1] * len(queries)\n        \n        # Monotonic stack: list of (b, max_sum_for_b_and_above)\n        # Maintained so that b is increasing and max_sum is decreasing\n        stack = []\n        \n        # Pointer to traverse sorted pairs\n        j = 0\n        \n        # Step 3: Process each query in sorted order\n        for x, y, idx in indexed_queries:\n            # Add all pairs with a >= x to the stack\n            while j < len(pairs) and pairs[j][0] >= x:\n                a, b = pairs[j]\n                # Remove elements from stack that are dominated by current sum\n                while stack and stack[-1][1] <= a + b:\n                    stack.pop()\n                # Only add if b is strictly greater than last in stack to maintain order\n                if not stack or b > stack[-1][0]:\n                    stack.append((b, a + b))\n                j += 1\n            \n            # Binary search for first b >= y\n            pos = bisect.bisect_left(stack, (y, float('-inf')))\n            if pos < len(stack):\n                res[idx] = stack[pos][1]\n                \n        return res"}
{"task_id": "2844", "solution": "from typing import List\n\nclass Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += nums[i - 1] * nums[i - 1]\n        return total"}
{"task_id": "2845", "solution": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        # Step 1: Sort the array\n        nums.sort()\n        \n        # Step 2: Initialize the minimum difference to a large number\n        min_diff = float('inf')\n        \n        # Step 3: Iterate through the sorted array and find the minimum difference\n        # between consecutive elements\n        for i in range(len(nums) - 1):\n            diff = abs(nums[i] - nums[i+1])\n            if diff < min_diff:\n                min_diff = diff\n        \n        # Step 4: Return the minimum difference found\n        return min_diff"}
{"task_id": "2847", "solution": "class Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        seen = set()\n        pairs = 0\n        \n        for word in words:\n            reversed_word = word[::-1]\n            if reversed_word in seen:\n                # Found a pair\n                pairs += 1\n                seen.remove(reversed_word)\n            else:\n                seen.add(word)\n                \n        return pairs"}
{"task_id": "2848", "solution": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Precompute which pairs satisfy the divisibility condition\n        compatible = [[False]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j and (nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0):\n                    compatible[i][j] = True\n        \n        # dp[mask][last] = number of special permutations using elements in mask, ending with element at index 'last'\n        dp = [[0]*n for _ in range(1 << n)]\n        \n        # Base case: single elements\n        for i in range(n):\n            dp[1 << i][i] = 1\n            \n        # Fill DP table\n        for mask in range(1 << n):\n            for last in range(n):\n                # If this state is not reachable, skip\n                if not (mask & (1 << last)):\n                    continue\n                    \n                # Try extending with each unused element\n                for next_idx in range(n):\n                    # If next_idx is already used or not compatible with last\n                    if (mask & (1 << next_idx)) or not compatible[last][next_idx]:\n                        continue\n                        \n                    new_mask = mask | (1 << next_idx)\n                    dp[new_mask][next_idx] = (dp[new_mask][next_idx] + dp[mask][last]) % MOD\n        \n        # Sum all permutations that use all elements\n        result = 0\n        full_mask = (1 << n) - 1\n        for i in range(n):\n            result = (result + dp[full_mask][i]) % MOD\n            \n        return result"}
{"task_id": "2849", "solution": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        \n        # For each starting index i\n        for i in range(n):\n            seen = set()\n            imbalance = 0\n            \n            # Expand subarray ending at j\n            for j in range(i, n):\n                x = nums[j]\n                \n                # If x is already in the subarray, no change\n                if x in seen:\n                    total += imbalance\n                    continue\n                \n                # Add x to the set\n                seen.add(x)\n                \n                # Determine neighbors\n                has_prev = (x - 1) in seen\n                has_next = (x + 1) in seen\n                \n                # Update imbalance based on neighbors\n                if not has_prev and not has_next:\n                    # Creates a new isolated component\n                    if len(seen) > 1:  # Only if there were previous elements\n                        imbalance += 1\n                elif has_prev and has_next:\n                    # Bridges two components => reduces gap count\n                    imbalance -= 1\n                \n                total += imbalance\n        \n        return total"}
{"task_id": "2850", "solution": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # Number of \"AA\" and \"BB\" we can pair up\n        paired = min(x, y)\n        # If x != y, we can add one more from the larger group\n        extra = 1 if x != y else 0\n        # Total number of strings we can use\n        total_strings = 2 * paired + extra + z\n        # Each string is 2 characters long\n        return total_strings * 2"}
{"task_id": "2854", "solution": "class Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        # dp[first_char][last_char] = minimal length for string starting with first_char and ending with last_char\n        # We'll use ord(char) - ord('a') as indices (0-25)\n        \n        # Initialize with the first word\n        dp = {}\n        first_word = words[0]\n        dp[(first_word[0], first_word[-1])] = len(first_word)\n        \n        # Process each subsequent word\n        for i in range(1, len(words)):\n            word = words[i]\n            new_dp = {}\n            \n            # For each existing state (first_char, last_char) with minimal length\n            for (first_char, last_char), length in dp.items():\n                # Option 1: Append current word to existing string (existing + word)\n                # Check if last_char of existing string matches first_char of word\n                if last_char == word[0]:\n                    # Overlap occurs, save 1 character\n                    new_length = length + len(word) - 1\n                else:\n                    # No overlap\n                    new_length = length + len(word)\n                \n                # New string will have first_char of existing string and last_char of word\n                new_state = (first_char, word[-1])\n                if new_state not in new_dp or new_dp[new_state] > new_length:\n                    new_dp[new_state] = new_length\n                \n                # Option 2: Prepend current word to existing string (word + existing)\n                # Check if last_char of word matches first_char of existing string\n                if word[-1] == first_char:\n                    # Overlap occurs, save 1 character\n                    new_length = length + len(word) - 1\n                else:\n                    # No overlap\n                    new_length = length + len(word)\n                \n                # New string will have first_char of word and last_char of existing string\n                new_state = (word[0], last_char)\n                if new_state not in new_dp or new_dp[new_state] > new_length:\n                    new_dp[new_state] = new_length\n            \n            # Update dp for next iteration\n            dp = new_dp\n        \n        # Return the minimum length among all possible final states\n        return min(dp.values())"}
{"task_id": "2855", "solution": "class Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        # dp[i] stores the maximum number of jumps to reach index i\n        dp = [-1] * n\n        dp[0] = 0  # Starting position requires 0 jumps\n        \n        # Process each index\n        for i in range(n):\n            # Skip if current index is not reachable\n            if dp[i] == -1:\n                continue\n            \n            # Try jumping to all subsequent indices\n            for j in range(i + 1, n):\n                # Check if the jump is valid based on the problem condition\n                diff = nums[j] - nums[i]\n                if -target <= diff <= target:\n                    # Update dp[j] if taking this path gives more jumps\n                    dp[j] = max(dp[j], dp[i] + 1)\n        \n        return dp[n - 1]"}
{"task_id": "2856", "solution": "class Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        # Step 1: Find the total number of distinct elements in the array\n        total_distinct = len(set(nums))\n        \n        # If there's only one distinct element, all subarrays are complete\n        if total_distinct == 1:\n            n = len(nums)\n            return n * (n + 1) // 2\n        \n        # Step 2: Use sliding window approach\n        count = 0\n        left = 0\n        freq_map = {}\n        \n        # Step 3: Expand the window with right pointer\n        for right in range(len(nums)):\n            # Add current element to frequency map\n            freq_map[nums[right]] = freq_map.get(nums[right], 0) + 1\n            \n            # Step 4: When we have a complete window, count valid subarrays\n            while len(freq_map) == total_distinct:\n                # All subarrays from current left to right, extending to end of array are valid\n                count += len(nums) - right\n                \n                # Shrink window from left\n                freq_map[nums[left]] -= 1\n                if freq_map[nums[left]] == 0:\n                    del freq_map[nums[left]]\n                left += 1\n                \n        return count"}
{"task_id": "2857", "solution": "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        distance = 0\n        \n        # While we can consume 5 liters from mainTank\n        while mainTank >= 5:\n            # Use 5 liters of fuel\n            mainTank -= 5\n            distance += 50  # 5 liters * 10 km/liter\n            \n            # If additional tank has fuel, transfer 1 liter\n            if additionalTank > 0:\n                mainTank += 1\n                additionalTank -= 1\n        \n        # Use remaining fuel in main tank\n        distance += mainTank * 10\n        \n        return distance"}
{"task_id": "2866", "solution": "class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        max_len = 0\n        n = len(nums)\n        i = 0\n        \n        while i < n:\n            # Check if nums[i] can be a valid starting point\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                # Start extending the subarray\n                current_len = 1\n                j = i + 1\n                \n                # Extend while conditions are met\n                while j < n and nums[j] <= threshold and nums[j] % 2 != nums[j-1] % 2:\n                    current_len += 1\n                    j += 1\n                \n                # Update maximum length found\n                max_len = max(max_len, current_len)\n                \n                # Move i to j since we've already processed up to j-1\n                i = j\n            else:\n                i += 1\n        \n        return max_len"}
{"task_id": "2867", "solution": "class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Find all positions of 1s\n        ones_positions = []\n        for i, num in enumerate(nums):\n            if num == 1:\n                ones_positions.append(i)\n        \n        # If there are no 1s, we can't form any good subarrays\n        if not ones_positions:\n            return 0\n        \n        # If there's only one 1, there's exactly one way to split\n        if len(ones_positions) == 1:\n            return 1\n        \n        # Calculate the number of ways to split\n        result = 1\n        for i in range(1, len(ones_positions)):\n            # Number of zeros between consecutive 1s\n            zeros_between = ones_positions[i] - ones_positions[i-1] - 1\n            # Number of ways to split between these two 1s\n            ways = zeros_between + 1\n            result = (result * ways) % MOD\n        \n        return result"}
{"task_id": "2868", "solution": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        left = 0\n        result = 0\n        \n        # Deques to maintain max and min in current window\n        # Each deque stores indices, not values\n        max_deque = deque()  # Decreasing order of values (max at front)\n        min_deque = deque()  # Increasing order of values (min at front)\n        \n        for right in range(n):\n            # Add current element to deques\n            # Remove elements from back while they violate the ordering\n            while max_deque and nums[max_deque[-1]] <= nums[right]:\n                max_deque.pop()\n            max_deque.append(right)\n            \n            while min_deque and nums[min_deque[-1]] >= nums[right]:\n                min_deque.pop()\n            min_deque.append(right)\n            \n            # Shrink window from left while max - min > 2\n            while nums[max_deque[0]] - nums[min_deque[0]] > 2:\n                # Remove indices that are out of the window\n                if max_deque[0] == left:\n                    max_deque.popleft()\n                if min_deque[0] == left:\n                    min_deque.popleft()\n                left += 1\n            \n            # All subarrays ending at 'right' and starting from 'left' to 'right' are valid\n            result += right - left + 1\n        \n        return result"}
{"task_id": "2869", "solution": "class Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        if n == 1:\n            return 1\n            \n        # dp1: length of longest non-decreasing subarray ending here if we pick nums1[i]\n        # dp2: length of longest non-decreasing subarray ending here if we pick nums2[i]\n        dp1, dp2 = 1, 1\n        max_len = 1\n        \n        for i in range(1, n):\n            # Calculate new dp values for current index\n            new_dp1 = 1  # At least the element itself\n            new_dp2 = 1  # At least the element itself\n            \n            # If we pick nums1[i], see what we can extend from previous choices\n            if nums1[i] >= nums1[i-1]:\n                new_dp1 = max(new_dp1, dp1 + 1)\n            if nums1[i] >= nums2[i-1]:\n                new_dp1 = max(new_dp1, dp2 + 1)\n                \n            # If we pick nums2[i], see what we can extend from previous choices\n            if nums2[i] >= nums1[i-1]:\n                new_dp2 = max(new_dp2, dp1 + 1)\n            if nums2[i] >= nums2[i-1]:\n                new_dp2 = max(new_dp2, dp2 + 1)\n            \n            # Update dp values for next iteration\n            dp1, dp2 = new_dp1, new_dp2\n            \n            # Update global maximum\n            max_len = max(max_len, dp1, dp2)\n            \n        return max_len"}
{"task_id": "2870", "solution": "class Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        max_len = -1\n        n = len(nums)\n        \n        i = 0\n        while i < n - 1:\n            # Check if we can start an alternating subarray here\n            if nums[i+1] == nums[i] + 1:\n                length = 2  # We have at least two elements [nums[i], nums[i+1]]\n                expected_diff = -1  # Next difference should be -1\n                j = i + 2\n                \n                # Extend the subarray as long as the pattern holds\n                while j < n and nums[j] - nums[j-1] == expected_diff:\n                    length += 1\n                    # Alternate the expected difference\n                    expected_diff = -expected_diff\n                    j += 1\n                \n                # Update the maximum length found\n                max_len = max(max_len, length)\n                \n                # Move i to j-1 to continue checking (optimization)\n                i = j - 1\n            else:\n                i += 1\n        \n        return max_len"}
{"task_id": "2872", "solution": "class Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        # Start from the last element as the initial current sum\n        current_sum = nums[-1]\n        max_value = current_sum\n        \n        # Traverse from second-last element to the first\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] <= current_sum:\n                # Merge nums[i] into the current sum\n                current_sum += nums[i]\n            else:\n                # Can't merge; start a new potential sum\n                current_sum = nums[i]\n            \n            # Update the maximum value seen so far\n            max_value = max(max_value, current_sum)\n        \n        return max_value"}
{"task_id": "2873", "solution": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        # Edge case: if n < 4, no prime pairs possible since minimum is 2+2=4\n        if n < 4:\n            return []\n        \n        # Sieve of Eratosthenes to find all primes up to n\n        is_prime = [True] * (n + 1)\n        is_prime[0] = is_prime[1] = False  # 0 and 1 are not primes\n        \n        for i in range(2, int(n**0.5) + 1):\n            if is_prime[i]:\n                for j in range(i * i, n + 1, i):\n                    is_prime[j] = False\n        \n        result = []\n        # Only check up to n//2 to ensure x <= y\n        for x in range(2, n // 2 + 1):\n            if is_prime[x]:\n                y = n - x\n                if is_prime[y]:\n                    result.append([x, y])\n        \n        return result"}
{"task_id": "2876", "solution": "class Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        # Initialize a counter for employees who met the target\n        count = 0\n        \n        # Iterate through each employee's hours\n        for hour in hours:\n            # If the employee worked at least the target hours, increment the counter\n            if hour >= target:\n                count += 1\n                \n        # Return the total count of employees who met the target\n        return count"}
{"task_id": "2877", "solution": "class Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        # Helper function to merge two strings with maximum overlap\n        def merge(s1, s2):\n            # If s2 is already a substring of s1, no need to add anything\n            if s2 in s1:\n                return s1\n            # Try to find maximum overlap where suffix of s1 matches prefix of s2\n            for i in range(len(s1)):\n                if s1[i:] == s2[:len(s1)-i]:\n                    return s1 + s2[len(s1)-i:]\n            # If no overlap, just concatenate\n            return s1 + s2\n        \n        # All permutations of the three strings\n        permutations = [\n            [a, b, c],\n            [a, c, b],\n            [b, a, c],\n            [b, c, a],\n            [c, a, b],\n            [c, b, a]\n        ]\n        \n        result = None\n        \n        # Try each permutation\n        for perm in permutations:\n            # Merge first two strings\n            merged = merge(perm[0], perm[1])\n            # Merge result with third string\n            merged = merge(merged, perm[2])\n            \n            # Update result if this is better\n            if result is None:\n                result = merged\n            elif len(merged) < len(result):\n                result = merged\n            elif len(merged) == len(result) and merged < result:\n                result = merged\n                \n        return result"}
{"task_id": "2878", "solution": "class Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        # Difference array to track operations\n        diff = [0] * (n + 1)\n        current_operations = 0\n        \n        for i in range(n):\n            # Update current_operations with diff[i]\n            current_operations += diff[i]\n            \n            # If current_operations exceeds nums[i], it's invalid\n            if current_operations > nums[i]:\n                return False\n            \n            # If current_operations is less than nums[i], we need to start\n            # (nums[i] - current_operations) new operations at index i\n            need = nums[i] - current_operations\n            if need > 0:\n                # Check if we can start a subarray of size k from index i\n                if i + k > n:\n                    return False\n                # Apply the operations via difference array\n                diff[i] += need\n                diff[i + k] -= need\n                # Update current_operations\n                current_operations += need\n        \n        return True"}
{"task_id": "2879", "solution": "class Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        \n        # Precompute cost for every substring to become semi-palindrome\n        cost = [[float('inf')] * n for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(i, n):\n                length = j - i + 1\n                if length == 1:\n                    cost[i][j] = 0  # Single character is not a semi-palindrome, but we'll handle this in DP\n                    continue\n                    \n                # Try all possible divisors d\n                for d in range(1, length):\n                    if length % d != 0:\n                        continue\n                        \n                    changes = 0\n                    # For each group (starting at offset 0 to d-1)\n                    for start in range(d):\n                        # Collect characters in this group\n                        group = []\n                        for idx in range(i + start, j + 1, d):\n                            group.append(s[idx])\n                        \n                        # Count changes to make this group palindrome\n                        left, right = 0, len(group) - 1\n                        while left < right:\n                            if group[left] != group[right]:\n                                changes += 1\n                            left += 1\n                            right -= 1\n                    \n                    cost[i][j] = min(cost[i][j], changes)\n        \n        # DP to find minimum cost to partition into k substrings\n        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                # Try all possible starting points for the j-th substring\n                for prev in range(j - 1, i):\n                    if dp[prev][j - 1] != float('inf'):\n                        dp[i][j] = min(dp[i][j], dp[prev][j - 1] + cost[prev][i - 1])\n        \n        return dp[n][k]"}
{"task_id": "2881", "solution": "class Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            # Split the word by the separator and filter out empty strings\n            parts = [part for part in word.split(separator) if part]\n            result.extend(parts)\n        return result"}
{"task_id": "2882", "solution": "class Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Generate all possible i^x values where i^x <= n\n        powers = []\n        i = 1\n        while True:\n            val = i ** x\n            if val > n:\n                break\n            powers.append(val)\n            i += 1\n        \n        # dp[i] will store the number of ways to form sum i\n        dp = [0] * (n + 1)\n        dp[0] = 1  # One way to make sum 0 (use no numbers)\n        \n        # For each power, update the dp array\n        for p in powers:\n            # Traverse backwards to prevent using the same number multiple times in one combination\n            for j in range(n, p - 1, -1):\n                dp[j] = (dp[j] + dp[j - p]) % MOD\n        \n        return dp[n]"}
{"task_id": "2883", "solution": "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        # Precompute all powers of 5 up to the max possible value for a 15-bit binary number\n        powers_of_5 = set()\n        power = 1\n        # 2^15 = 32768, so we go beyond that to be safe\n        while power < (1 << 15):\n            powers_of_5.add(bin(power)[2:])  # Remove '0b' prefix\n            power *= 5\n        \n        n = len(s)\n        # dp[i] represents the minimum number of beautiful substrings to partition s[:i]\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0  # Base case: 0 substrings needed for empty string\n        \n        # Fill DP table\n        for i in range(1, n + 1):\n            for j in range(i):\n                substring = s[j:i]\n                # Check if substring is beautiful\n                if substring in powers_of_5:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        # Return result\n        return dp[n] if dp[n] != float('inf') else -1"}
{"task_id": "2884", "solution": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        # Convert forbidden list to a set for O(1) average lookup\n        forbidden_set = set(forbidden)\n        \n        n = len(word)\n        left = 0\n        max_len = 0\n        \n        # Sliding window approach\n        for right in range(n):\n            # Check substrings ending at 'right' and starting from 'start_check' to 'right'\n            # We only need to check up to 10 characters back since max forbidden length is 10\n            start_check = max(left, right - 9)\n            \n            # Check all substrings ending at 'right' with length 1 to 10\n            for i in range(start_check, right + 1):\n                substring = word[i:right + 1]\n                if substring in forbidden_set:\n                    # Move left pointer to position after the start of forbidden substring\n                    left = i + 1\n                    \n            # Update maximum length of valid substring\n            max_len = max(max_len, right - left + 1)\n            \n        return max_len"}
{"task_id": "2886", "solution": "class Solution:\n    def finalString(self, s: str) -> str:\n        result = \"\"\n        for char in s:\n            if char == 'i':\n                result = result[::-1]\n            else:\n                result += char\n        return result"}
{"task_id": "2887", "solution": "class Solution:\n    def sortVowels(self, s: str) -> str:\n        # Define vowels set for quick lookup\n        vowels_set = set('aeiouAEIOU')\n        \n        # Extract all vowels from the string\n        vowels = []\n        for char in s:\n            if char in vowels_set:\n                vowels.append(char)\n        \n        # Sort vowels by their ASCII values\n        vowels.sort()\n        \n        # Reconstruct the string\n        result = []\n        vowel_index = 0\n        \n        for char in s:\n            if char in vowels_set:\n                # Place the next sorted vowel\n                result.append(vowels[vowel_index])\n                vowel_index += 1\n            else:\n                # Keep consonants in their original places\n                result.append(char)\n        \n        return ''.join(result)"}
{"task_id": "2888", "solution": "class Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        n = len(nums)\n        \n        # Step 1: Find the dominant element\n        count = Counter(nums)\n        dominant = None\n        max_freq = 0\n        for num, freq in count.items():\n            if freq * 2 > n:\n                dominant = num\n                max_freq = freq\n                break\n        \n        # Step 2: Precompute prefix counts of the dominant element\n        prefix_count = [0] * n\n        if nums[0] == dominant:\n            prefix_count[0] = 1\n        for i in range(1, n):\n            prefix_count[i] = prefix_count[i-1] + (1 if nums[i] == dominant else 0)\n        \n        # Step 3: Iterate through possible split points\n        for i in range(n - 1):\n            left_len = i + 1\n            right_len = n - i - 1\n            \n            left_freq = prefix_count[i]\n            right_freq = max_freq - left_freq\n            \n            if left_freq * 2 > left_len and right_freq * 2 > right_len:\n                return i\n        \n        # Step 4: No valid split found\n        return -1"}
{"task_id": "2891", "solution": "class Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        # Sort the array to enable sliding window technique\n        nums.sort()\n        \n        left = 0\n        max_beauty = 0\n        \n        # Use two pointers to find the maximum window size\n        for right in range(len(nums)):\n            # If the window is invalid, shrink it from the left\n            while nums[right] - nums[left] > 2 * k:\n                left += 1\n            \n            # Update the maximum window size\n            max_beauty = max(max_beauty, right - left + 1)\n        \n        return max_beauty"}
{"task_id": "2892", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        # Step 1: Determine the candidate n\n        n = max(nums)\n        \n        # Step 2: Check if the length matches base[n]\n        if len(nums) != n + 1:\n            return False\n            \n        # Step 3: Count the frequency of each element\n        count = Counter(nums)\n        \n        # Step 4: Verify frequencies\n        # All numbers from 1 to n-1 must appear exactly once\n        for i in range(1, n):\n            if count[i] != 1:\n                return False\n                \n        # The number n must appear exactly twice\n        if count[n] != 2:\n            return False\n            \n        # If all checks pass, it's a good array\n        return True"}
{"task_id": "2893", "solution": "class Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        # Initialize based on the parity of the first element\n        if nums[0] % 2 == 0:\n            # First element is even\n            even_max = nums[0]\n            odd_max = float('-inf')\n        else:\n            # First element is odd\n            odd_max = nums[0]\n            even_max = float('-inf')\n        \n        # Iterate over the rest of the array\n        for i in range(1, len(nums)):\n            num = nums[i]\n            if num % 2 == 0:\n                # Current number is even\n                new_even = max(even_max, odd_max - x) + num\n                even_max = new_even\n            else:\n                # Current number is odd\n                new_odd = max(odd_max, even_max - x) + num\n                odd_max = new_odd\n        \n        # Return the best possible score\n        return max(even_max, odd_max)"}
{"task_id": "2902", "solution": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        # Helper function to get the maximum digit in a number\n        def max_digit(n):\n            return max(int(digit) for digit in str(n))\n        \n        # Dictionary to store lists of numbers grouped by their max digit\n        groups = {}\n        \n        # Group numbers by their maximum digit\n        for num in nums:\n            md = max_digit(num)\n            if md not in groups:\n                groups[md] = []\n            groups[md].append(num)\n        \n        max_sum = -1\n        \n        # For each group, find the maximum sum of a pair\n        for group in groups.values():\n            if len(group) >= 2:\n                # Sort in descending order to get the two largest elements\n                group.sort(reverse=True)\n                current_sum = group[0] + group[1]\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum"}
{"task_id": "2915", "solution": "class Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        # Step 1: Convert the array to binary form based on condition\n        # We don't actually need to create a new array; we can work directly with counts\n        \n        # Step 2: Use prefix sum approach with modular arithmetic\n        from collections import defaultdict\n        \n        # Dictionary to store frequency of (prefix_sum % modulo)\n        mod_count = defaultdict(int)\n        mod_count[0] = 1  # Base case: empty prefix has sum 0\n        \n        prefix_sum = 0\n        result = 0\n        \n        for num in nums:\n            # Increment prefix_sum if current element meets the condition\n            if num % modulo == k:\n                prefix_sum += 1\n                \n            # Current prefix sum modulo\n            current_mod = prefix_sum % modulo\n            \n            # We want to find previous prefix sums such that:\n            # (current_prefix - prev_prefix) % modulo == k\n            # Which means: prev_prefix % modulo == (current_mod - k) % modulo\n            target_mod = (current_mod - k) % modulo\n            \n            # Add the count of such previous prefix sums to our result\n            result += mod_count[target_mod]\n            \n            # Record the current prefix sum modulo\n            mod_count[current_mod] += 1\n            \n        return result"}
{"task_id": "2916", "solution": "class Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        # If the array has 1 or 2 elements, it's always possible to split\n        if len(nums) <= 2:\n            return True\n        \n        # Check if there exists at least one adjacent pair with sum >= m\n        for i in range(len(nums) - 1):\n            if nums[i] + nums[i+1] >= m:\n                return True\n        \n        # If no such pair exists, it's impossible to split properly\n        return False"}
{"task_id": "2917", "solution": "class Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        n = len(nums)\n        # Loop through each possible pair (i, j) with i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] < target:\n                    count += 1\n        return count"}
{"task_id": "2919", "solution": "from typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        # Sort the usage limits in ascending order\n        usageLimits.sort()\n        \n        total_usage = 0\n        groups = 0\n        \n        # Iterate through each limit\n        for limit in usageLimits:\n            # Add current limit to total available usage\n            total_usage += limit\n            \n            # Check if we can form one more group\n            # The cost of forming (groups+1) groups is sum(1 to groups+1) = (groups+1)*(groups+2)//2\n            needed = (groups + 1) * (groups + 2) // 2\n            \n            if total_usage >= needed:\n                groups += 1\n                \n        return groups"}
{"task_id": "2920", "solution": "class Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        import math\n\n        # Step 1: Group indices by their values\n        value_indices = defaultdict(list)\n        n = len(nums)\n        for i in range(n):\n            value_indices[nums[i]].append(i)\n\n        min_time = float('inf')\n\n        # Step 2: For each unique value, calculate the max time to spread across the array\n        for val, indices in value_indices.items():\n            if len(indices) == n:\n                # All elements are already this value\n                return 0\n            \n            max_gap = 0\n            \n            # Calculate gaps between consecutive indices (considering circular array)\n            for i in range(len(indices)):\n                curr_idx = indices[i]\n                next_idx = indices[(i + 1) % len(indices)]\n                \n                # Calculate the gap size between current and next occurrence\n                if next_idx > curr_idx:\n                    gap = next_idx - curr_idx - 1\n                else:  # Wrap around case\n                    gap = (n - 1 - curr_idx) + next_idx\n                \n                max_gap = max(max_gap, gap)\n            \n            # Time needed is ceil(gap / 2) which equals (gap + 1) // 2\n            time_needed = (max_gap + 1) // 2\n            min_time = min(min_time, time_needed)\n        \n        return min_time"}
{"task_id": "2921", "solution": "class Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        \n        def minus_one(num_str):\n            # Convert string to list for easier manipulation\n            num_list = list(num_str)\n            i = len(num_list) - 1\n            # Borrow logic for subtraction\n            while i >= 0 and num_list[i] == '0':\n                num_list[i] = '9'\n                i -= 1\n            if i >= 0:\n                num_list[i] = str(int(num_list[i]) - 1)\n            # Remove leading zeros\n            result = ''.join(num_list).lstrip('0')\n            return result if result else \"0\"\n        \n        def count_stepping(limit):\n            n = len(limit)\n            # Memoization dictionary\n            memo = {}\n            \n            def dp(pos, prev_digit, tight, started):\n                # Base case\n                if pos == n:\n                    return 1 if started else 0\n                \n                if (pos, prev_digit, tight, started) in memo:\n                    return memo[(pos, prev_digit, tight, started)]\n                \n                # Determine the upper limit for current digit\n                upper = int(limit[pos]) if tight else 9\n                result = 0\n                \n                # Try placing each possible digit\n                for digit in range(0, upper + 1):\n                    # Handle leading zeros\n                    if not started and digit == 0:\n                        result = (result + dp(pos + 1, -1, tight and (digit == upper), False)) % MOD\n                        continue\n                    \n                    # Check stepping condition\n                    if started and abs(digit - prev_digit) != 1:\n                        continue\n                    \n                    # Make transition\n                    new_tight = tight and (digit == upper)\n                    result = (result + dp(pos + 1, digit, new_tight, True)) % MOD\n                \n                memo[(pos, prev_digit, tight, started)] = result\n                return result\n            \n            return dp(0, -1, True, False)\n        \n        # Count stepping numbers <= high\n        count_high = count_stepping(high)\n        \n        # Count stepping numbers <= (low - 1)\n        low_minus_one = minus_one(low)\n        count_low_minus_one = count_stepping(low_minus_one) if low_minus_one != \"0\" else 0\n        \n        # Return the difference\n        return (count_high - count_low_minus_one) % MOD"}
{"task_id": "2952", "solution": "from typing import List\n\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        \n        # Create pairs of (nums2[i], nums1[i]) and sort by nums2[i]\n        pairs = [(nums2[i], nums1[i]) for i in range(n)]\n        pairs.sort()\n        \n        # dp[t] represents the maximum reduction achievable with t operations\n        dp = [0] * (n + 1)\n        \n        # Process each item in sorted order of nums2 values\n        for i in range(n):\n            v2, v1 = pairs[i]\n            # Update DP from back to front to avoid using updated values in same iteration\n            for t in range(i + 1, 0, -1):\n                dp[t] = max(dp[t], dp[t - 1] + v1 + t * v2)\n        \n        # Calculate initial sums\n        sum1 = sum(nums1)\n        sum2 = sum(nums2)\n        \n        # Check for each possible time t\n        for t in range(n + 1):\n            # Total sum after t seconds without any resets would be:\n            # sum1 + t * sum2\n            # But we can save dp[t] through optimal resets\n            total = sum1 + t * sum2 - dp[t]\n            if total <= x:\n                return t\n                \n        return -1"}
{"task_id": "2953", "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        # Dictionary to store frequency of each coordinate seen so far\n        freq_map = defaultdict(int)\n        count = 0\n        \n        # Process each coordinate\n        for x1, y1 in coordinates:\n            # Try all possible splits of k into a and b where a + b = k\n            for a in range(k + 1):\n                b = k - a\n                # Calculate what x2 and y2 would need to be for the distance to be k\n                x2 = x1 ^ a\n                y2 = y1 ^ b\n                # Add the number of times this (x2, y2) has been seen before\n                count += freq_map[(x2, y2)]\n            \n            # Record the current point in the frequency map\n            freq_map[(x1, y1)] += 1\n            \n        return count"}
{"task_id": "2954", "solution": "class Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        from collections import defaultdict\n        \n        # Initialize variables\n        n = len(nums)\n        if n < k:\n            return 0\n            \n        # Frequency map to track elements in current window\n        freq_map = defaultdict(int)\n        distinct_count = 0\n        current_sum = 0\n        max_sum = 0\n        \n        # Process first window of size k\n        for i in range(k):\n            elem = nums[i]\n            current_sum += elem\n            if freq_map[elem] == 0:\n                distinct_count += 1\n            freq_map[elem] += 1\n            \n        # Check if first window satisfies the condition\n        if distinct_count >= m:\n            max_sum = current_sum\n            \n        # Slide the window through rest of the array\n        for i in range(k, n):\n            # Remove leftmost element of previous window\n            left_elem = nums[i - k]\n            current_sum -= left_elem\n            freq_map[left_elem] -= 1\n            if freq_map[left_elem] == 0:\n                distinct_count -= 1\n                \n            # Add rightmost element of current window\n            right_elem = nums[i]\n            current_sum += right_elem\n            if freq_map[right_elem] == 0:\n                distinct_count += 1\n            freq_map[right_elem] += 1\n            \n            # Update max_sum if current window satisfies condition\n            if distinct_count >= m:\n                max_sum = max(max_sum, current_sum)\n                \n        return max_sum"}
{"task_id": "2955", "solution": "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        # Get the remainder when divided by 10\n        remainder = purchaseAmount % 10\n        \n        # If remainder is less than 5, round down\n        if remainder < 5:\n            rounded_amount = purchaseAmount - remainder\n        # Otherwise, round up (this handles both > 5 and == 5 cases)\n        else:\n            rounded_amount = purchaseAmount + (10 - remainder)\n            \n        # Return the account balance after deducting the rounded amount\n        return 100 - rounded_amount"}
{"task_id": "2977", "solution": "class Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        # If lengths don't match, it can't be an acronym\n        if len(words) != len(s):\n            return False\n            \n        # Check each character of s against the first letter of corresponding word\n        for i in range(len(words)):\n            if words[i][0] != s[i]:\n                return False\n                \n        return True"}
{"task_id": "2979", "solution": "from typing import List\nimport bisect\n\nclass Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        # Sort offers by their end positions\n        offers.sort(key=lambda x: x[1])\n        m = len(offers)\n        \n        # Extract end times for binary search\n        ends = [offer[1] for offer in offers]\n        \n        # dp[i] will store the maximum profit using the first i offers (1-based indexing)\n        dp = [0] * (m + 1)\n        \n        for i in range(1, m + 1):\n            start, end, gold = offers[i - 1]\n            \n            # Find the rightmost offer whose end < current start\n            # bisect.bisect_left returns insertion point for (start - 1) in ends list\n            # which gives us the index of the latest non-overlapping offer\n            j = bisect.bisect_left(ends, start)\n            \n            # Update DP state\n            dp[i] = max(dp[i - 1], dp[j] + gold)\n        \n        return dp[m]"}
{"task_id": "2998", "solution": "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        count = 0\n        for num in range(low, high + 1):\n            s = str(num)\n            n = len(s)\n            # Skip if number of digits is odd\n            if n % 2 != 0:\n                continue\n            # Split into two halves\n            mid = n // 2\n            first_half = s[:mid]\n            second_half = s[mid:]\n            # Calculate sum of digits in each half\n            sum_first = sum(int(digit) for digit in first_half)\n            sum_second = sum(int(digit) for digit in second_half)\n            # Check if sums are equal\n            if sum_first == sum_second:\n                count += 1\n        return count"}
{"task_id": "2999", "solution": "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        # Check if characters at positions {0,2} can be made equal\n        s1_even = sorted([s1[0], s1[2]])\n        s2_even = sorted([s2[0], s2[2]])\n        \n        # Check if characters at positions {1,3} can be made equal\n        s1_odd = sorted([s1[1], s1[3]])\n        s2_odd = sorted([s2[1], s2[3]])\n        \n        # Return True if both groups match\n        return s1_even == s2_even and s1_odd == s2_odd"}
{"task_id": "3000", "solution": "from sortedcontainers import SortedList\nfrom typing import List\nimport math\n\nclass Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        # Use a SortedList to maintain elements that are at least x indices before current\n        sorted_list = SortedList()\n        min_diff = math.inf\n        \n        # Start from index x since we need at least x distance\n        for i in range(x, len(nums)):\n            # Add the element that is now valid (at least x positions before i)\n            sorted_list.add(nums[i - x])\n            \n            # Current element to compare against\n            curr = nums[i]\n            \n            # Find the position where curr would be inserted to keep list sorted\n            pos = sorted_list.bisect_left(curr)\n            \n            # Check neighbors around the insertion point for minimum difference\n            if pos < len(sorted_list):\n                min_diff = min(min_diff, abs(curr - sorted_list[pos]))\n            if pos > 0:\n                min_diff = min(min_diff, abs(curr - sorted_list[pos - 1]))\n                \n        return min_diff"}
{"task_id": "3017", "solution": "class Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        from functools import lru_cache\n\n        def count(limit):\n            s = str(limit)\n            n = len(s)\n\n            @lru_cache(None)\n            def dp(pos, tight, diff, mod, started):\n                # Base case: reached end of digit string\n                if pos == n:\n                    # Beautiful condition: diff=0 (even==odd), mod=0 (divisible by k), and started=True\n                    return int(diff == 0 and mod == 0 and started)\n                \n                max_digit = int(s[pos]) if tight else 9\n                res = 0\n\n                for digit in range(0, max_digit + 1):\n                    new_tight = tight and (digit == max_digit)\n                    new_started = started or (digit > 0)\n\n                    # Skip leading zeros in diff/mod calculation\n                    if not started and digit == 0:\n                        res += dp(pos + 1, new_tight, diff, mod, False)\n                    else:\n                        # Calculate new difference and modulus\n                        d = 1 if digit % 2 == 0 else -1\n                        new_diff = diff + d\n                        new_mod = (mod * 10 + digit) % k\n                        \n                        # Prune impossible paths early\n                        if -10 <= new_diff <= 10:\n                            res += dp(pos + 1, new_tight, new_diff, new_mod, True)\n                return res\n            \n            return dp(0, True, 0, 0, False)\n        \n        return count(high) - count(low - 1)"}
{"task_id": "3018", "solution": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        i = j = 0\n        n, m = len(str1), len(str2)\n        \n        while i < n and j < m:\n            # Check if str1[i] can match str2[j] either directly or after one cyclic increment\n            if (str1[i] == str2[j] or \n                (ord(str1[i]) - ord('a') + 1) % 26 == ord(str2[j]) - ord('a')):\n                j += 1\n            i += 1\n            \n        # If we've matched all characters in str2, return True\n        return j == m"}
{"task_id": "3019", "solution": "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        count_L = moves.count('L')\n        count_R = moves.count('R')\n        count_U = moves.count('_')\n        \n        # The maximum distance is the absolute difference between L and R counts\n        # plus all underscores contributing to that direction\n        return abs(count_L - count_R) + count_U"}
{"task_id": "3024", "solution": "class Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n\n        # Step 1: Count how many rotations of s are equal to t\n        # We use the Z-algorithm on t + '#' + s + s to count occurrences of t in s+s\n        # But we must exclude the case where we take the whole string (l=n)\n        combined = t + '#' + s + s\n        z = self.z_array(combined)\n        f = 0\n        for i in range(len(t) + 1, len(combined) - len(t)):\n            if z[i] == len(t):\n                f += 1\n        \n        # Now adjust f to exclude the invalid full rotation\n        # The last possible occurrence corresponds to taking l=0 (no rotation),\n        # which is invalid iff s != t initially\n        # But actually, we're looking in s+s, so we need to be more precise.\n        # In s+s, t occurs at positions where s[i:] + s[:i] == t\n        # These are positions from 0 to n-1 in the s part of s+s\n        # But in our z-array search over t + '#' + s + s,\n        # matches occur at positions i > len(t) + 1 such that z[i] == len(t)\n        # Those correspond to positions in s+s where t occurs\n        # Specifically, if t occurs at position p in s+s, then p >= len(t)+1\n        # And the actual shift is p - (len(t)+1)\n        # We want 0 <= shift < n, and shift != n (since l < n => shift > 0)\n        # Wait, let's re-examine the setup.\n        # When we do s+s, the rotation by i means taking s[i:] + s[:i]\n        # This appears at position i in s+s\n        # So we look for t in s+s, at positions 0 through n-1 (but not including n because that would be the full string again)\n        # Actually, better approach: build s+s and check each substring directly against t\n        # Or use KMP/Z as done above but limit the range correctly\n        \n        # Let's redo the count properly\n        # Build s+s and look for t in it at positions 0 to n-1 inclusive\n        # Use the precomputed z array\n        # Positions in combined = t + '#' + s + s\n        # Length of t + '#' is len(t) + 1\n        # So s+s starts at index len(t) + 1\n        # We look for matches in s part of s+s, i.e., from index len(t)+1 to len(t)+1+n-1\n        f = 0\n        start_s_in_combined = len(t) + 1\n        for i in range(start_s_in_combined, start_s_in_combined + n):\n            if i < len(z) and z[i] == len(t):\n                pos_in_s = i - start_s_in_combined\n                if pos_in_s < n:  # Only consider rotations within bounds\n                    f += 1\n\n        # Initial state\n        a0 = 1 if s == t else 0\n        b0 = 1 - a0\n\n        # Transition matrix\n        # [a']   [f-1    f  ] [a]\n        # [b'] = [n-f  n-1-f] [b]\n        mat = [\n            [(f - 1) % MOD, f % MOD],\n            [(n - f) % MOD, (n - 1 - f) % MOD]\n        ]\n\n        # Apply matrix exponentiation\n        result_mat = self.matrix_power(mat, k, MOD)\n        final_a = (result_mat[0][0] * a0 + result_mat[0][1] * b0) % MOD\n        return final_a\n\n    def z_array(self, s):\n        n = len(s)\n        z = [0] * n\n        l, r = 0, 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def matrix_multiply(self, A, B, mod):\n        return [\n            [(A[0][0]*B[0][0] + A[0][1]*B[1][0]) % mod, (A[0][0]*B[0][1] + A[0][1]*B[1][1]) % mod],\n            [(A[1][0]*B[0][0] + A[1][1]*B[1][0]) % mod, (A[1][0]*B[0][1] + A[1][1]*B[1][1]) % mod]\n        ]\n\n    def matrix_power(self, mat, exp, mod):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        base = [row[:] for row in mat]  # Copy of mat\n        while exp > 0:\n            if exp % 2 == 1:\n                result = self.matrix_multiply(result, base, mod)\n            base = self.matrix_multiply(base, base, mod)\n            exp //= 2\n        return result"}
{"task_id": "3025", "solution": "class Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        # Check if it's even possible\n        if sum(nums) < target:\n            return -1\n        \n        # Count frequencies of each power of 2 (since all nums are powers of 2)\n        # max power is 2^30 according to constraints, so we need indices 0..30\n        count = [0] * 32\n        for num in nums:\n            power = 0\n            temp = num\n            while temp > 1:\n                temp //= 2\n                power += 1\n            count[power] += 1\n            \n        operations = 0\n        i = 0\n        \n        # Process each bit of target from least significant to most\n        while target > 0:\n            # If current bit is set in target, we need 2^i\n            if target & 1:\n                # If we have a 2^i, use it\n                if count[i] > 0:\n                    count[i] -= 1\n                else:\n                    # Need to find a larger power and split it down to 2^i\n                    j = i + 1\n                    while j < 32 and count[j] == 0:\n                        j += 1\n                    \n                    # If no larger power exists, impossible\n                    if j == 32:\n                        return -1\n                    \n                    # Split 2^j down to 2^i, counting operations\n                    count[j] -= 1\n                    operations += j - i\n                    # Add all intermediate powers we created during splitting\n                    for k in range(i, j):\n                        count[k] += 1\n                        \n            # Carry over excess counts to next level (two 2^i can be combined to one 2^(i+1))\n            if i < 31:\n                count[i + 1] += count[i] // 2\n                \n            # Move to next bit\n            target >>= 1\n            i += 1\n            \n        return operations"}
{"task_id": "3031", "solution": "class Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        MOD = 12345\n        n, m = len(grid), len(grid[0])\n        \n        # Initialize result matrix\n        p = [[1]*m for _ in range(n)]\n        \n        # First pass: compute prefix products\n        prefix = 1\n        for i in range(n):\n            for j in range(m):\n                p[i][j] = prefix % MOD\n                prefix = (prefix * grid[i][j]) % MOD\n        \n        # Second pass: compute suffix products and combine with prefix\n        suffix = 1\n        for i in range(n-1, -1, -1):\n            for j in range(m-1, -1, -1):\n                p[i][j] = (p[i][j] * suffix) % MOD\n                suffix = (suffix * grid[i][j]) % MOD\n                \n        return p"}
{"task_id": "3032", "solution": "class Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n = len(receiver)\n        # Determine the number of bits needed for k\n        max_bit = k.bit_length()\n        \n        # Precompute next and sum tables for binary lifting\n        # next[i][j] = player id after 2^j passes starting from player i\n        # sum[i][j] = sum of player ids during 2^j passes starting from player i\n        next_table = [[0]*max_bit for _ in range(n)]\n        sum_table = [[0]*max_bit for _ in range(n)]\n        \n        # Base case: 2^0 = 1 pass\n        for i in range(n):\n            next_table[i][0] = receiver[i]\n            sum_table[i][0] = i + receiver[i]\n        \n        # Fill the tables for 2^j passes\n        for j in range(1, max_bit):\n            for i in range(n):\n                mid = next_table[i][j-1]\n                next_table[i][j] = next_table[mid][j-1]\n                sum_table[i][j] = sum_table[i][j-1] + (sum_table[mid][j-1] - mid)\n        \n        # Calculate f(x) for each starting player x\n        max_value = 0\n        for x in range(n):\n            current_pos = x\n            total_sum = x  # Include the starting player's ID\n            remaining_k = k\n            \n            # Decompose k into powers of 2 and accumulate sum\n            for j in range(max_bit):\n                if remaining_k & (1 << j):\n                    total_sum += (sum_table[current_pos][j] - current_pos)\n                    current_pos = next_table[current_pos][j]\n            \n            max_value = max(max_value, total_sum)\n        \n        return max_value"}
{"task_id": "3033", "solution": "class Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        # Find all mismatched positions\n        mismatches = []\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                mismatches.append(i)\n        \n        # If there's an odd number of mismatches, it's impossible\n        if len(mismatches) % 2 != 0:\n            return -1\n        \n        # If no mismatches, nothing to do\n        if not mismatches:\n            return 0\n            \n        # Dynamic Programming\n        # even: min cost when all previous mismatches are paired\n        # odd: min cost when one mismatch is left unpaired\n        even = 0\n        odd = float('inf')\n        \n        for i in range(1, len(mismatches)):\n            new_even = min(even, odd + x)  # Either already even or close the odd with cost x\n            new_odd = min(odd, even + (mismatches[i] - mismatches[i-1]))  # Either keep being odd or leave current unpaired\n            even, odd = new_even, new_odd\n        \n        return even"}
{"task_id": "3034", "solution": "class Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        # Step 1: Sort the intervals based on their starting points\n        nums.sort()\n        \n        # Step 2: Initialize the list to hold merged intervals\n        merged = []\n        \n        # Step 3: Iterate through the sorted intervals and merge overlapping ones\n        for start, end in nums:\n            # If merged is empty or current interval does not overlap with the last one in merged\n            if not merged or merged[-1][1] < start:\n                merged.append([start, end])\n            else:\n                # Overlapping or adjacent, so we merge by updating the end of the last interval\n                merged[-1][1] = max(merged[-1][1], end)\n        \n        # Step 4: Count total integer points in merged intervals\n        count = 0\n        for start, end in merged:\n            count += end - start + 1\n            \n        return count"}
{"task_id": "3044", "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        collected = set()\n        operations = 0\n        \n        # Traverse from the end of the array\n        for i in range(len(nums) - 1, -1, -1):\n            operations += 1\n            # If current element is in the target range and not yet collected\n            if 1 <= nums[i] <= k and nums[i] not in collected:\n                collected.add(nums[i])\n                \n            # Early exit condition: if we've collected all required elements\n            if len(collected) == k:\n                return operations\n        \n        # As per problem statement, it's guaranteed we can collect 1..k\n        # So this line should never be reached\n        return operations"}
{"task_id": "3045", "solution": "class Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        # Count how many times nums[i] > nums[i+1]\n        breaks = []\n        for i in range(n):\n            if nums[i] > nums[(i + 1) % n]:\n                breaks.append(i)\n        \n        # If more than one break, not a valid rotation\n        if len(breaks) > 1:\n            return -1\n        \n        # If no breaks, already sorted\n        if len(breaks) == 0:\n            return 0\n        \n        # Exactly one break\n        break_index = breaks[0]\n        # Number of right shifts needed is n - (break_index + 1)\n        shifts = n - (break_index + 1)\n        \n        # Verify that rotating gives a sorted array\n        # Rotate the array by 'shifts' right shifts and check if sorted\n        rotated = [nums[(i - shifts) % n] for i in range(n)]\n        for i in range(1, n):\n            if rotated[i] < rotated[i - 1]:\n                return -1\n        \n        return shifts"}
{"task_id": "3046", "solution": "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        n = len(num)\n        # To check divisibility by 25, last two digits must be 00, 25, 50, or 75\n        \n        found_zero = False\n        found_five = False\n        \n        # Traverse from right to left\n        for i in range(n - 1, -1, -1):\n            d = num[i]\n            \n            # Check for possible endings based on current digit\n            if d == '0':\n                if found_zero:   # Found \"00\"\n                    return n - i - 2\n                found_zero = True\n                \n            elif d == '5':\n                if found_zero:   # Found \"50\"\n                    return n - i - 2\n                found_five = True\n                \n            elif d == '2' and found_five:   # Found \"25\"\n                return n - i - 2\n                \n            elif d == '7' and found_five:   # Found \"75\"\n                return n - i - 2\n\n        # If no valid pair was found, see if we can reduce to \"0\"\n        # That means we delete all digits except one '0'\n        if found_zero:\n            return n - 1  # All digits except the zero\n            \n        # Otherwise, delete all digits to result in 0\n        return n"}
{"task_id": "3047", "solution": "class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Helper function to compute square-free part of a number\n        def square_free_part(x):\n            sqf = 1\n            i = 2\n            while i * i <= x:\n                cnt = 0\n                while x % i == 0:\n                    x //= i\n                    cnt += 1\n                # Only include odd powers in square-free part\n                if cnt % 2 == 1:\n                    sqf *= i\n                i += 1\n            # If x is still > 1, then it's a prime factor with power 1\n            if x > 1:\n                sqf *= x\n            return sqf\n        \n        # Group indices by their square-free parts\n        groups = defaultdict(int)\n        n = len(nums)\n        \n        for i in range(1, n + 1):\n            sf = square_free_part(i)\n            groups[sf] += nums[i - 1]  # nums is 0-indexed, so use i-1\n        \n        # Return the maximum sum among all groups\n        return max(groups.values())"}
{"task_id": "3055", "solution": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        # Count the number of '1's in the string\n        count_ones = s.count('1')\n        # Calculate the number of '0's\n        count_zeros = len(s) - count_ones\n        \n        # We need one '1' at the end to make the number odd\n        # So we place (count_ones - 1) '1's at the beginning\n        # Then all the '0's in the middle\n        # And finally the last '1' at the end\n        return '1' * (count_ones - 1) + '0' * count_zeros + '1'"}
{"task_id": "3080", "solution": "class Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        # Step 1: Compute the AND of the entire array\n        total_and = nums[0]\n        for num in nums[1:]:\n            total_and &= num\n        \n        # If the total AND is not zero, we can't do better than one subarray\n        if total_and != 0:\n            return 1\n        \n        # Otherwise, greedily split into max number of subarrays with AND = 0\n        count = 0\n        current_and = -1  # All bits set in two's complement (acts like 0xFFFFFFFF...)\n        \n        for num in nums:\n            current_and &= num\n            if current_and == 0:\n                count += 1\n                current_and = -1  # Reset for next subarray\n        \n        return count"}
{"task_id": "3081", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        # Count frequency of each element\n        freq_map = Counter(nums)\n        \n        # Find the maximum frequency\n        max_freq = max(freq_map.values())\n        \n        # Total number of elements\n        n = len(nums)\n        \n        # Calculate minimum possible length\n        # If max_freq <= n // 2, we can potentially pair all elements\n        # Otherwise, the excess elements (2 * max_freq - n) will remain\n        return max(0, 2 * max_freq - n)"}
{"task_id": "3091", "solution": "class Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Step 1: Count frequencies and handle zeros\n        from collections import Counter\n        freq = Counter(nums)\n        zero_count = freq.pop(0, 0)  # Remove zeros and get their count\n        \n        # If r is negative, there are no valid subsets\n        if r < 0:\n            return 0\n            \n        # Limit r to the maximum possible sum to avoid unnecessary computation\n        max_sum = sum(num * count for num, count in freq.items())\n        r = min(r, max_sum)\n        \n        # Step 2: Initialize DP array\n        dp = [0] * (r + 1)\n        dp[0] = 1  # One way to make sum 0 (empty set)\n        \n        # Step 3: Process each unique number and its frequency\n        for num, count in freq.items():\n            # Optimization: if num is greater than r, skip it\n            if num > r:\n                continue\n                \n            # Create a copy of the current dp array for updates\n            new_dp = dp[:]\n            \n            # Group the counts using the binary representation trick\n            # We decompose 'count' into powers of two plus a remainder\n            k = 1\n            while k < count:\n                # For each power of two, we add that many copies of num\n                amount = k * num\n                if amount <= r:\n                    for i in range(r, amount - 1, -1):\n                        new_dp[i] = (new_dp[i] + dp[i - amount]) % MOD\n                count -= k\n                k <<= 1\n            \n            # Handle the remaining count\n            amount = count * num\n            if amount <= r:\n                for i in range(r, amount - 1, -1):\n                    new_dp[i] = (new_dp[i] + dp[i - amount]) % MOD\n                    \n            dp = new_dp\n        \n        # Step 4: Calculate result for range [l, r]\n        result = 0\n        for i in range(l, r + 1):\n            result = (result + dp[i]) % MOD\n            \n        # Multiply by (zero_count + 1) since each subset can include 0 to zero_count zeros\n        result = (result * (zero_count + 1)) % MOD\n        \n        return result"}
{"task_id": "3093", "solution": "class Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        total_sum = 0\n        for i in range(len(nums)):\n            # Count set bits using bin().count('1')\n            if bin(i).count('1') == k:\n                total_sum += nums[i]\n        return total_sum"}
{"task_id": "3094", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        # Step 1: Count frequency of each element\n        freq_map = Counter(nums)\n        \n        operations = 0\n        \n        # Step 2: Process each frequency\n        for freq in freq_map.values():\n            # If any element occurs only once, it's impossible to remove\n            if freq == 1:\n                return -1\n            \n            # Calculate minimum operations for this frequency\n            # Using the formula (freq + 2) // 3\n            operations += (freq + 2) // 3\n            \n        return operations"}
{"task_id": "3104", "solution": "class Solution:\n    def countWays(self, nums: List[int]) -> int:\n        # Sort the array to make it easier to check the conditions\n        nums.sort()\n        n = len(nums)\n        count = 0\n        \n        # Case 1: Select 0 students\n        # All students must satisfy 0 < nums[i], i.e., all nums[i] > 0\n        if all(num > 0 for num in nums):\n            count += 1\n            \n        # Case 2: Select k students where 1 <= k <= n-1\n        # For selecting k students:\n        # - Max of selected (nums[k-1]) must be < k\n        # - Min of unselected (nums[k]) must be > k\n        for k in range(1, n):\n            if nums[k-1] < k < nums[k]:\n                count += 1\n                \n        # Case 3: Select all students (k = n)\n        # All students must satisfy n > nums[i], i.e., all nums[i] < n\n        if all(num < n for num in nums):\n            count += 1\n            \n        return count"}
{"task_id": "3106", "solution": "class Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        # dp[i] represents the maximum length of subsequence that sums to i\n        dp = [-float('inf')] * (target + 1)\n        dp[0] = 0  # Base case: sum of 0 with length 0\n        \n        for num in nums:\n            # Traverse backwards to prevent reusing the same element multiple times in one subsequence\n            for s in range(target, num - 1, -1):\n                if dp[s - num] != -float('inf'):\n                    dp[s] = max(dp[s], dp[s - num] + 1)\n        \n        return dp[target] if dp[target] != -float('inf') else -1"}
{"task_id": "3114", "solution": "class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        \n        # Calculate left[i]: max sum of non-decreasing sequence ending at i\n        left = [0] * n\n        stack = []  # monotonic increasing stack storing indices\n        \n        for i in range(n):\n            # Maintain increasing order in stack based on maxHeights\n            while stack and maxHeights[stack[-1]] > maxHeights[i]:\n                stack.pop()\n            \n            if not stack:\n                # All elements before i can be set to maxHeights[i]\n                left[i] = (i + 1) * maxHeights[i]\n            else:\n                # Previous smaller or equal element determines prefix sum\n                prev_index = stack[-1]\n                left[i] = left[prev_index] + (i - prev_index) * maxHeights[i]\n            \n            stack.append(i)\n\n        # Calculate right[i]: max sum of non-increasing sequence starting at i\n        right = [0] * n\n        stack = []  # reset stack for right pass\n        \n        for i in range(n - 1, -1, -1):\n            # Maintain decreasing order in stack based on maxHeights\n            while stack and maxHeights[stack[-1]] > maxHeights[i]:\n                stack.pop()\n                \n            if not stack:\n                # All elements after i can be set to maxHeights[i]\n                right[i] = (n - i) * maxHeights[i]\n            else:\n                # Next smaller or equal element determines suffix sum\n                next_index = stack[-1]\n                right[i] = right[next_index] + (next_index - i) * maxHeights[i]\n                \n            stack.append(i)\n        \n        # Find maximum total sum considering each index as peak\n        max_sum = 0\n        for i in range(n):\n            total = left[i] + right[i] - maxHeights[i]\n            max_sum = max(max_sum, total)\n        \n        return max_sum"}
{"task_id": "3141", "solution": "from typing import List\n\nclass Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        n = len(nums)\n\n        # Number of full cycles and remainder\n        full_cycles = target // total\n        reduced_target = target % total\n\n        # If nothing remains after removing full cycles\n        if reduced_target == 0:\n            return full_cycles * n\n\n        # Build extended array to allow wrap-around subarrays\n        extended = nums + nums  # up to 2*n elements\n\n        # Map prefix sum to earliest index where it occurs\n        prefix_map = {0: -1}\n        min_len = float('inf')\n        current_sum = 0\n\n        for i in range(len(extended)):\n            current_sum += extended[i]\n\n            # Check if there's a previous prefix such that subarray sum == reduced_target\n            if current_sum - reduced_target in prefix_map:\n                length = i - prefix_map[current_sum - reduced_target]\n                min_len = min(min_len, length)\n\n            # Store first occurrence of each prefix sum\n            if current_sum not in prefix_map:\n                prefix_map[current_sum] = i\n\n        # If no valid subarray found\n        if min_len == float('inf'):\n            return -1\n\n        # Return total length including full cycles\n        return full_cycles * n + min_len"}
{"task_id": "3150", "solution": "class Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        min_len = float('inf')\n        result = \"\"\n        \n        # Sliding window: [left, right]\n        left = 0\n        count_ones = 0\n        \n        for right in range(n):\n            if s[right] == '1':\n                count_ones += 1\n            \n            # Shrink the window as long as we have exactly k ones\n            while count_ones == k:\n                current_length = right - left + 1\n                current_substring = s[left:right+1]\n                \n                # Update the result if we found a shorter length\n                if current_length < min_len:\n                    min_len = current_length\n                    result = current_substring\n                # If same length, update to lexicographically smaller one\n                elif current_length == min_len:\n                    if current_substring < result:\n                        result = current_substring\n                \n                # Try to shrink from the left\n                if s[left] == '1':\n                    count_ones -= 1\n                left += 1\n        \n        return result if min_len != float('inf') else \"\""}
{"task_id": "3151", "solution": "from typing import List\n\nclass Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        # Sort processors by availability time (ascending)\n        processorTime.sort()\n        # Sort tasks by duration (descending)\n        tasks.sort(reverse=True)\n        \n        max_finish_time = 0\n        \n        # For each processor, assign the next 4 longest tasks\n        for i, start_time in enumerate(processorTime):\n            # Get the 4 tasks for this processor (starting from index i*4)\n            # The longest of these 4 determines the finish time for this processor\n            chunk_start = i * 4\n            # Since tasks are sorted descending, the first of the 4 is the longest\n            longest_task_in_chunk = tasks[chunk_start]\n            finish_time = start_time + longest_task_in_chunk\n            max_finish_time = max(max_finish_time, finish_time)\n        \n        return max_finish_time"}
{"task_id": "3153", "solution": "class Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        # Count frequency of each bit position (0 to 30)\n        bit_count = [0] * 32\n        \n        for num in nums:\n            for i in range(32):\n                if num & (1 << i):\n                    bit_count[i] += 1\n        \n        result = 0\n        \n        # Construct k largest numbers possible\n        for _ in range(k):\n            candidate = 0\n            # Greedily build the largest number by using available bits\n            for i in range(31, -1, -1):  # Start from highest bit\n                if bit_count[i] > 0:\n                    candidate |= (1 << i)\n                    bit_count[i] -= 1\n            result = (result + (candidate * candidate)) % MOD\n            \n        return result"}
{"task_id": "3154", "solution": "class Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        max_value = 0\n        n = len(nums)\n        \n        # Iterate through all possible triplets (i, j, k) with i < j < k\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    # Calculate the triplet value\n                    value = (nums[i] - nums[j]) * nums[k]\n                    # Update max_value if current value is greater\n                    max_value = max(max_value, value)\n        \n        return max_value"}
{"task_id": "3163", "solution": "class Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        total_sum = 0\n        \n        # Iterate over all possible starting points of subarrays\n        for i in range(n):\n            distinct_elements = set()\n            \n            # Extend the subarray from starting point i to all possible ending points j\n            for j in range(i, n):\n                # Add the current element to the set of distinct elements\n                distinct_elements.add(nums[j])\n                \n                # Calculate the number of distinct elements in the current subarray\n                distinct_count = len(distinct_elements)\n                \n                # Add the square of the distinct count to the total sum\n                total_sum += distinct_count * distinct_count\n        \n        return total_sum"}
{"task_id": "3164", "solution": "class Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        nums = []  # Stores integers in order of appearance\n        result = []\n        k = 0  # Count of consecutive 'prev' strings\n        \n        for word in words:\n            if word.isdigit():\n                # It's a positive integer\n                nums.append(int(word))\n                k = 0  # Reset consecutive 'prev' counter\n            else:\n                # It's \"prev\"\n                k += 1\n                if k <= len(nums):\n                    # Get the k-th most recent integer (1-indexed from the end)\n                    result.append(nums[-k])\n                else:\n                    # Not enough integers visited\n                    result.append(-1)\n        \n        return result"}
{"task_id": "3166", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        # Step 1: Get frequency of each unique element\n        freq = list(Counter(nums).values())\n        \n        # Helper function to check if a frequency 'f' can be split into groups of size x and x+1\n        def is_valid_split(f, x):\n            # Try all possible counts of (x+1)-sized groups\n            max_large_groups = f // (x + 1)\n            for num_large in range(max_large_groups + 1):\n                remainder = f - num_large * (x + 1)\n                if remainder >= 0 and remainder % x == 0:\n                    return True\n            return False\n        \n        # Helper function to compute minimum number of groups needed for a frequency 'f'\n        def num_groups_for_freq(f, x):\n            # To minimize groups, maximize use of (x+1) groups\n            max_large_groups = f // (x + 1)\n            for num_large in range(max_large_groups, -1, -1):\n                remainder = f - num_large * (x + 1)\n                if remainder >= 0 and remainder % x == 0:\n                    num_small = remainder // x\n                    return num_large + num_small\n            return float('inf')  # Not possible to split\n        \n        # Find maximum possible group base size\n        max_freq = max(freq)\n        \n        # Binary search for the maximum feasible x\n        left, right = 1, max_freq\n        best_x = 1\n        \n        # Check validity from highest to lowest to get maximum feasible x\n        for x in range(max_freq, 0, -1):\n            valid = True\n            for f in freq:\n                if not is_valid_split(f, x):\n                    valid = False\n                    break\n            if valid:\n                best_x = x\n                break\n        \n        # Now compute total groups needed with best_x\n        total_groups = 0\n        for f in freq:\n            total_groups += num_groups_for_freq(f, best_x)\n            \n        return total_groups"}
{"task_id": "3171", "solution": "from typing import List\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        # Calculate sum and count of zeros for nums1\n        sum1 = sum(nums1)\n        zeros1 = nums1.count(0)\n        \n        # Calculate sum and count of zeros for nums2\n        sum2 = sum(nums2)\n        zeros2 = nums2.count(0)\n        \n        # Calculate minimum possible sums (replacing each 0 with 1)\n        min_sum1 = sum1 + zeros1\n        min_sum2 = sum2 + zeros2\n        \n        # Check if it's impossible to make sums equal\n        # If one array has no zeros but its sum is less than the other's minimum possible sum\n        if zeros1 == 0 and sum1 < min_sum2:\n            return -1\n        if zeros2 == 0 and sum2 < min_sum1:\n            return -1\n            \n        # Return the maximum of the two minimum possible sums\n        return max(min_sum1, min_sum2)"}
{"task_id": "3172", "solution": "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        # Step 1: Calculate the total sum from 1 to n\n        total = n * (n + 1) // 2\n        \n        # Step 2: Calculate num2 (sum of multiples of m up to n)\n        # Count of multiples of m in [1, n]\n        k = n // m\n        # Sum of first k natural numbers is k*(k+1)/2\n        # So sum of multiples is m * k*(k+1)/2\n        num2 = m * k * (k + 1) // 2\n        \n        # Step 3: Use derived formula\n        # num1 - num2 = (total - num2) - num2 = total - 2*num2\n        return total - 2 * num2"}
{"task_id": "3174", "solution": "class Solution:\n    def minChanges(self, s: str) -> int:\n        changes = 0\n        # Iterate through the string in steps of 2\n        for i in range(0, len(s), 2):\n            # If the two characters in the pair are different, we need one change\n            if s[i] != s[i + 1]:\n                changes += 1\n        return changes"}
{"task_id": "3176", "solution": "class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return -1\n        \n        # Precompute left_min array\n        left_min = [float('inf')] * n\n        min_so_far = float('inf')\n        for j in range(1, n):  # j is the peak index, so check elements before it\n            min_so_far = min(min_so_far, nums[j-1])\n            if min_so_far < nums[j]:\n                left_min[j] = min_so_far\n                \n        # Precompute right_min array\n        right_min = [float('inf')] * n\n        min_so_far = float('inf')\n        for j in range(n-2, -1, -1):  # j is the peak index, so check elements after it\n            min_so_far = min(min_so_far, nums[j+1])\n            if min_so_far < nums[j]:\n                right_min[j] = min_so_far\n                \n        # Find the minimum sum mountain triplet\n        min_sum = float('inf')\n        for j in range(1, n-1):\n            if left_min[j] != float('inf') and right_min[j] != float('inf'):\n                current_sum = left_min[j] + nums[j] + right_min[j]\n                min_sum = min(min_sum, current_sum)\n                \n        return min_sum if min_sum != float('inf') else -1"}
{"task_id": "3183", "solution": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        result = 0\n        # Check for each bit position from 0 to 30 (since nums[i] < 2^31)\n        for i in range(31):\n            # Count how many numbers have the ith bit set\n            count = 0\n            for num in nums:\n                if (num >> i) & 1:\n                    count += 1\n            # If at least k numbers have this bit set, set this bit in result\n            if count >= k:\n                result |= (1 << i)\n        return result"}
{"task_id": "3184", "solution": "from typing import List\nimport bisect\n\nclass FenwickTreeMax:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [-float('inf')] * (n + 1)\n    \n    def update(self, idx, val):\n        # idx is 1-based\n        while idx <= self.n:\n            self.tree[idx] = max(self.tree[idx], val)\n            idx += idx & (-idx)\n    \n    def query(self, idx):\n        # idx is 1-based\n        res = -float('inf')\n        while idx > 0:\n            res = max(res, self.tree[idx])\n            idx -= idx & (-idx)\n        return res\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        b = [nums[i] - i for i in range(n)]\n        \n        # Coordinate compression\n        sorted_b = sorted(set(b))\n        b_index = {val: i+1 for i, val in enumerate(sorted_b)}  # 1-based indexing for Fenwick Tree\n        \n        ft = FenwickTreeMax(len(b_index))\n        max_sum = -float('inf')\n        \n        for i in range(n):\n            comp_idx = b_index[b[i]]\n            # Get max sum ending at some j where b[j] <= b[i]\n            prev_max = ft.query(comp_idx)\n            curr_sum = nums[i]\n            if prev_max != -float('inf'):\n                curr_sum = max(curr_sum, prev_max + nums[i])\n            \n            ft.update(comp_idx, curr_sum)\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}
{"task_id": "3188", "solution": "class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        max_strength = -1\n        champion = -1\n        \n        for i in range(len(grid)):\n            strength = sum(grid[i])\n            if strength > max_strength:\n                max_strength = strength\n                champion = i\n                \n        return champion"}
{"task_id": "3190", "solution": "from typing import List\n\nclass Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        \n        # Helper function to calculate minimum swaps for given max1 and max2\n        def count_swaps(max1, max2):\n            swaps = 0\n            for i in range(n - 1):\n                a, b = nums1[i], nums2[i]\n                \n                # If both fit in their respective arrays without swapping\n                if a <= max1 and b <= max2:\n                    continue\n                # If swapping makes them fit\n                elif b <= max1 and a <= max2:\n                    swaps += 1\n                # If neither works, impossible\n                else:\n                    return -1\n            return swaps\n        \n        # Case 1: Do not swap the last elements\n        max1 = nums1[-1]\n        max2 = nums2[-1]\n        res1 = count_swaps(max1, max2)\n        \n        # Case 2: Swap the last elements\n        max1 = nums2[-1]\n        max2 = nums1[-1]\n        res2 = count_swaps(max1, max2)\n        if res2 != -1:\n            res2 += 1  # Add 1 for the initial swap at the last index\n            \n        # Determine the answer based on results from both cases\n        if res1 == -1 and res2 == -1:\n            return -1\n        elif res1 == -1:\n            return res2\n        elif res2 == -1:\n            return res1\n        else:\n            return min(res1, res2)"}
{"task_id": "3192", "solution": "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Work with copies to modify\n        val_a = a\n        val_b = b\n        \n        # Iterate from the highest bit (n-1) down to 0\n        for i in range(n-1, -1, -1):\n            bit_mask = 1 << i\n            \n            # Current values without flipping this bit\n            curr_prod = val_a * val_b\n            \n            # Values if we flip this bit (i.e., set x[i] = 1)\n            new_a = val_a ^ bit_mask\n            new_b = val_b ^ bit_mask\n            new_prod = new_a * new_b\n            \n            # If flipping improves the product, do it\n            if new_prod > curr_prod:\n                val_a = new_a\n                val_b = new_b\n                \n        return (val_a * val_b) % MOD"}
{"task_id": "3193", "solution": "class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        max_xor = 0\n        n = len(nums)\n        \n        # Iterate through all pairs (including same indices)\n        for i in range(n):\n            for j in range(n):\n                x = nums[i]\n                y = nums[j]\n                \n                # Check if the pair forms a strong pair\n                if abs(x - y) <= min(x, y):\n                    # Update the maximum XOR value\n                    max_xor = max(max_xor, x ^ y)\n        \n        return max_xor"}
{"task_id": "3194", "solution": "class Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        result = []\n        for index, word in enumerate(words):\n            if x in word:\n                result.append(index)\n        return result"}
{"task_id": "3195", "solution": "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        steps = 0\n        zero_count = 0\n        \n        for char in s:\n            if char == '0':\n                zero_count += 1\n            else:  # char == '1'\n                steps += zero_count\n                \n        return steps"}
{"task_id": "3196", "solution": "from typing import List\n\nclass Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        # Prefix sums for efficient range sum queries\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i+1] = prefix[i] + nums[i]\n        \n        def get_cost(l, r):\n            # Returns the minimal cost to make all elements in nums[l..r] equal\n            if l >= r:\n                return 0\n            mid = (l + r) // 2\n            # Cost to bring left part up to nums[mid]\n            left_cost = (mid - l + 1) * nums[mid] - (prefix[mid + 1] - prefix[l])\n            # Cost to bring right part down to nums[mid]\n            right_cost = (prefix[r + 1] - prefix[mid]) - (r - mid + 1) * nums[mid]\n            return left_cost + right_cost\n        \n        left = 0\n        max_freq = 1\n        for right in range(n):\n            # Shrink window until cost <= k\n            while get_cost(left, right) > k:\n                left += 1\n            max_freq = max(max_freq, right - left + 1)\n        return max_freq"}
{"task_id": "3199", "solution": "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        count = 0\n        # Iterate through all possible values for the first child\n        for a in range(min(n, limit) + 1):\n            remaining = n - a\n            # For each 'a', find valid distributions for b and c such that b + c = remaining\n            # Both b and c must be between 0 and limit\n            # This means: max(0, remaining - limit) <= b <= min(limit, remaining)\n            lower_bound = max(0, remaining - limit)\n            upper_bound = min(limit, remaining)\n            \n            if lower_bound <= upper_bound:\n                # Add the count of valid values for b (which implicitly determines c)\n                count += upper_bound - lower_bound + 1\n                \n        return count"}
{"task_id": "3200", "solution": "class Solution:\n    def stringCount(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Function to compute (base^exp) % mod efficiently\n        def power(base, exp, mod):\n            result = 1\n            base %= mod\n            while exp > 0:\n                if exp & 1:\n                    result = (result * base) % mod\n                base = (base * base) % mod\n                exp >>= 1\n            return result\n\n        # Total number of strings of length n\n        total = power(26, n, MOD)\n        \n        # Strings with 0 'l'\n        no_l = power(25, n, MOD)\n        \n        # Strings with 0 or 1 'e'\n        # Case 1: 0 'e's -> all positions filled with other 25 chars\n        # Case 2: 1 'e' -> choose 1 position for 'e' (n choices), rest filled with 25 chars\n        no_more_than_one_e = (power(25, n, MOD) + (n * power(25, n-1, MOD)) % MOD) % MOD\n        \n        # Strings with 0 't'\n        no_t = power(25, n, MOD)\n        \n        # Intersection calculations\n        # No 'l' and (0 or 1 'e')\n        no_l_and_no_more_than_one_e = (power(24, n, MOD) + (n * power(24, n-1, MOD)) % MOD) % MOD\n        \n        # No 'l' and no 't'\n        no_l_and_no_t = power(24, n, MOD)\n        \n        # No 't' and (0 or 1 'e')\n        no_t_and_no_more_than_one_e = (power(24, n, MOD) + (n * power(24, n-1, MOD)) % MOD) % MOD\n        \n        # No 'l', no 't', and (0 or 1 'e')\n        none_l_t_and_limit_e = (power(23, n, MOD) + (n * power(23, n-1, MOD)) % MOD) % MOD\n        \n        # Apply inclusion-exclusion principle\n        result = (total - no_l - no_more_than_one_e - no_t +\n                  no_l_and_no_more_than_one_e + no_l_and_no_t + no_t_and_no_more_than_one_e -\n                  none_l_t_and_limit_e) % MOD\n        \n        # Ensure result is positive\n        return (result + MOD) % MOD"}
{"task_id": "3203", "solution": "class Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        from typing import List\n        \n        n = len(s)\n        half = n // 2\n        # Split into left and right halves\n        left_str = s[:half]\n        right_str = s[half:]\n        rev_right = right_str[::-1]\n\n        # Precompute prefix sums of character counts for both sides\n        def get_prefix_count(st):\n            m = len(st)\n            prefix = [[0]*26 for _ in range(m + 1)]\n            for i in range(m):\n                ch_index = ord(st[i]) - ord('a')\n                for j in range(26):\n                    prefix[i+1][j] = prefix[i][j]\n                prefix[i+1][ch_index] += 1\n            return prefix\n\n        left_prefix = get_prefix_count(left_str)\n        right_prefix = get_prefix_count(rev_right)\n\n        # Get count of characters in s[l..r] inclusive\n        def getCount(prefix, l, r):\n            if l > r:\n                return [0]*26\n            res = [0]*26\n            for i in range(26):\n                res[i] = prefix[r+1][i] - prefix[l][i]\n            return res\n\n        # Precompute mismatches\n        mismatch = [0] * half\n        for i in range(half):\n            if left_str[i] != rev_right[i]:\n                mismatch[i] = 1\n\n        # Prefix sum of mismatches\n        prefix_mismatch = [0] * (half + 1)\n        for i in range(half):\n            prefix_mismatch[i+1] = prefix_mismatch[i] + mismatch[i]\n\n        # Helper to check if there's any mismatch in [l, r]\n        def hasMismatch(l, r):\n            if l > r:\n                return False\n            return (prefix_mismatch[r+1] - prefix_mismatch[l]) > 0\n\n        # Check if two count arrays are equal\n        def equalCount(cnt1, cnt2):\n            return cnt1 == cnt2\n\n        # Subtract cnt2 from cnt1 element-wise\n        def subtractCount(cnt1, cnt2):\n            res = []\n            for i in range(26):\n                diff = cnt1[i] - cnt2[i]\n                if diff < 0:\n                    return None\n                res.append(diff)\n            return res\n\n        result = []\n\n        for a, b, c, d in queries:\n            # Convert right indices to left mirrored space\n            c_mirror = n - 1 - d\n            d_mirror = n - 1 - c\n\n            # Clamp mirrored indices to valid left half range\n            c_m = max(c_mirror, 0)\n            d_m = min(d_mirror, half - 1)\n\n            # Now working with [a,b] and [c_m, d_m] in left half [0, half-1]\n            # Sort intervals for consistent processing\n            seg1 = (a, b)\n            seg2 = (c_m, d_m)\n            if seg1[0] > seg2[0]:\n                seg1, seg2 = seg2, seg1\n\n            l1, r1 = seg1\n            l2, r2 = seg2\n\n            # If completely separate\n            if r1 < l2:\n                # Check gap between r1 and l2\n                gap_left = hasMismatch(r1+1, l2-1)\n                # Check before first and after second\n                before_first = hasMismatch(0, l1-1)\n                after_second = hasMismatch(r2+1, half-1)\n                # Each segment must cover its own mismatch area\n                cnt_l1_r1 = getCount(left_prefix, l1, r1)\n                needed_l1_r1 = getCount(right_prefix, l1, r1)\n                cnt_l2_r2 = getCount(left_prefix, l2, r2)\n                needed_l2_r2 = getCount(right_prefix, l2, r2)\n                ok = (\n                    not gap_left and\n                    not before_first and\n                    not after_second and\n                    equalCount(cnt_l1_r1, needed_l1_r1) and\n                    equalCount(cnt_l2_r2, needed_l2_r2)\n                )\n                result.append(ok)\n                continue\n\n            # If one is contained in another\n            if r2 <= r1:\n                # seg2 is inside seg1\n                # Check outside seg1\n                before = hasMismatch(0, l1-1)\n                after = hasMismatch(r1+1, half-1)\n                # Check content of seg1 matches what's needed\n                cnt_l1_r1 = getCount(left_prefix, l1, r1)\n                needed_l1_r1 = getCount(right_prefix, l1, r1)\n                ok = (\n                    not before and\n                    not after and\n                    equalCount(cnt_l1_r1, needed_l1_r1)\n                )\n                result.append(ok)\n                continue\n\n            # Overlapping case\n            # Union of [l1,r1] and [l2,r2] is [l1,r2]\n            union_start = l1\n            union_end = r2\n\n            # Before union\n            before_union = hasMismatch(0, union_start - 1)\n            # After union\n            after_union = hasMismatch(union_end + 1, half - 1)\n\n            # Total available in union from left\n            total_avail = getCount(left_prefix, union_start, union_end)\n            # Total needed in union from right\n            total_needed = getCount(right_prefix, union_start, union_end)\n\n            if before_union or after_union or not equalCount(total_avail, total_needed):\n                result.append(False)\n                continue\n\n            # Now check internal consistency\n            # Left-only part: [l1, max(l2-1, r1)]\n            left_only_start = l1\n            left_only_end = min(r1, l2 - 1)\n            if left_only_end >= left_only_start:\n                avail_left_only = getCount(left_prefix, left_only_start, left_only_end)\n                needed_here = getCount(right_prefix, left_only_start, left_only_end)\n                if not equalCount(avail_left_only, needed_here):\n                    result.append(False)\n                    continue\n\n            # Right-only part: [max(r1+1,l2), r2]\n            right_only_start = max(r1 + 1, l2)\n            right_only_end = r2\n            if right_only_end >= right_only_start:\n                avail_right_only = getCount(left_prefix, right_only_start, right_only_end)\n                needed_here = getCount(right_prefix, right_only_start, right_only_end)\n                if not equalCount(avail_right_only, needed_here):\n                    result.append(False)\n                    continue\n\n            # Middle shared part: [max(l2, r1+1), min(r2, l2-1)]  actually empty due to ordering\n            # But better safe than sorry\n            mid_start = max(l2, r1 + 1)\n            mid_end = min(r2, l2 - 1)\n            if mid_end >= mid_start:\n                # Should never happen since l2 <= r1 would mean containment handled earlier\n                pass\n\n            result.append(True)\n\n        return result"}
{"task_id": "3206", "solution": "class Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Convert both lists to sets for O(1) lookup\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # Count how many elements in nums1 appear in nums2\n        count1 = sum(1 for num in nums1 if num in set2)\n        \n        # Count how many elements in nums2 appear in nums1\n        count2 = sum(1 for num in nums2 if num in set1)\n        \n        return [count1, count2]"}
{"task_id": "3207", "solution": "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        # Find the length of the longest common prefix\n        i = 0\n        min_len = min(len(s1), len(s2), len(s3))\n        \n        while i < min_len and s1[i] == s2[i] == s3[i]:\n            i += 1\n            \n        # If there's no common prefix, return -1\n        if i == 0:\n            return -1\n        \n        # Calculate total operations needed to truncate all strings to length i\n        return (len(s1) - i) + (len(s2) - i) + (len(s3) - i)"}
{"task_id": "3209", "solution": "class Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        # dp[i] represents the minimum coins to acquire first i fruits (1-indexed)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):  # for each target fruit count (1-based)\n            # Option 1: Buy the i-th fruit directly\n            dp[i] = min(dp[i], dp[i - 1] + prices[i - 1])\n            \n            # Option 2: Try all previous fruits j (1-indexed) that can cover current fruit i\n            for j in range(1, i + 1):  # j is 1-indexed\n                if 2 * j >= i:\n                    dp[i] = min(dp[i], dp[j - 1] + prices[j - 1])\n        \n        return dp[n]"}
{"task_id": "3210", "solution": "class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        # Create a set of vowels for fast lookup\n        vowels_set = {'a', 'e', 'i', 'o', 'u'}\n        \n        # Precompute prefix sums for vowels\n        prefix_vowels = [0] * (n + 1)\n        for i in range(n):\n            prefix_vowels[i + 1] = prefix_vowels[i] + (1 if s[i] in vowels_set else 0)\n        \n        count = 0\n        \n        # Check all possible substrings\n        for i in range(n):\n            for j in range(i, n):\n                # Length of substring\n                length = j - i + 1\n                \n                # Number of vowels in substring s[i:j+1]\n                vowels = prefix_vowels[j + 1] - prefix_vowels[i]\n                \n                # Number of consonants\n                consonants = length - vowels\n                \n                # Check if it's a beautiful substring\n                if vowels == consonants and (vowels * consonants) % k == 0:\n                    count += 1\n                    \n        return count"}
{"task_id": "3211", "solution": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        # Precompute prefix sums\n        n = len(nums)\n        prefix_sums = [0] * (n + 1)\n        for i in range(n):\n            prefix_sums[i+1] = prefix_sums[i] + nums[i]\n\n        # dp_deque stores tuples (last_element_value, max_length_ending_with_this_value)\n        # It maintains candidates in increasing order of last_element_value\n        dp_deque = deque()\n        dp_deque.append((0, 0))  # Base case: empty prefix has value 0 and length 0\n        \n        max_length = 0\n        \n        for i in range(1, n + 1):  # Process each index (1-based indexing for prefix sum)\n            # Remove outdated entries from front of deque\n            while len(dp_deque) > 1 and dp_deque[1][0] <= prefix_sums[i]:\n                dp_deque.popleft()\n\n            # Current best length is derived from the front of deque\n            prev_last_val, prev_length = dp_deque[0]\n            \n            # Compute the sum of subarray ending at i and starting after the previous segment\n            curr_sum = prefix_sums[i] - prev_last_val\n            \n            # Update max_length\n            max_length = prev_length + 1\n\n            # Maintain deque invariants: remove elements from back that are worse than current\n            while dp_deque and dp_deque[-1][0] >= curr_sum:\n                dp_deque.pop()\n                \n            dp_deque.append((curr_sum, max_length))\n            \n        return max_length"}
{"task_id": "3212", "solution": "class Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        # Step 1: Record the last occurrence of each element\n        last_occurrence = {}\n        for i, num in enumerate(nums):\n            last_occurrence[num] = i\n        \n        # Step 2: Count the number of minimal required blocks\n        blocks = 0\n        max_last = -1\n        \n        for i, num in enumerate(nums):\n            # Update the furthest last occurrence of any element encountered so far\n            max_last = max(max_last, last_occurrence[num])\n            \n            # If current index reaches the furthest last occurrence,\n            # we've completed a minimal block\n            if i == max_last:\n                blocks += 1\n                \n        # Step 3: Calculate 2^(blocks - 1) mod (10^9 + 7)\n        MOD = 10**9 + 7\n        return pow(2, blocks - 1, MOD)"}
{"task_id": "3213", "solution": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        # Step 1: Find the maximum element in the array\n        max_val = max(nums)\n        \n        n = len(nums)\n        count = 0  # To store the result\n        max_count = 0  # Count of max_val in current window\n        \n        left = 0  # Left pointer of the sliding window\n        \n        # Step 2: Use sliding window technique\n        for right in range(n):\n            # Expand window by including nums[right]\n            if nums[right] == max_val:\n                max_count += 1\n            \n            # Shrink window from the left until max_count < k\n            while max_count >= k:\n                # All subarrays from left to right, right+1, ..., n-1 are valid\n                # That is, (n - right) subarrays ending at positions >= right\n                count += n - right\n                \n                # Move left pointer and update max_count\n                if nums[left] == max_val:\n                    max_count -= 1\n                left += 1\n        \n        return count"}
{"task_id": "3219", "solution": "class Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        # Step 1: Pair each number with its original index\n        indexed_nums = [(nums[i], i) for i in range(len(nums))]\n        \n        # Step 2: Sort the pairs by value\n        indexed_nums.sort()\n\n        # Step 3: Group elements that can be swapped (difference <= limit)\n        groups = []\n        current_group = [indexed_nums[0]]\n        \n        for i in range(1, len(indexed_nums)):\n            # Check if the current element can be grouped with previous ones\n            if indexed_nums[i][0] - current_group[-1][0] <= limit:\n                current_group.append(indexed_nums[i])\n            else:\n                # Save the completed group and start a new one\n                groups.append(current_group)\n                current_group = [indexed_nums[i]]\n        \n        # Add the last group\n        groups.append(current_group)\n\n        # Step 4: For each group, sort indices and assign sorted values to those positions\n        result = [0] * len(nums)\n        for group in groups:\n            # Extract indices and sort them\n            indices = sorted([idx for val, idx in group])\n            # Extract values and sort them\n            values = sorted([val for val, idx in group])\n            \n            # Assign sorted values to sorted indices\n            for i, idx in enumerate(indices):\n                result[idx] = values[i]\n\n        return result"}
{"task_id": "3220", "solution": "class Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        tested_devices = 0\n        decrement_count = 0\n        \n        for battery in batteryPercentages:\n            # Effective battery is current battery minus all previous decrements\n            if battery - decrement_count > 0:\n                tested_devices += 1\n                decrement_count += 1\n                \n        return tested_devices"}
{"task_id": "3221", "solution": "class Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        peaks = []\n        # Iterate through valid indices (excluding first and last)\n        for i in range(1, len(mountain) - 1):\n            # Check if current element is strictly greater than both neighbors\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n                peaks.append(i)\n        return peaks"}
{"task_id": "3223", "solution": "class Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        # Helper function to split word into valid segments\n        def get_segments(s):\n            segments = []\n            start = 0\n            for i in range(1, len(s)):\n                # Check if adjacent characters satisfy the difference constraint\n                if abs(ord(s[i]) - ord(s[i-1])) > 2:\n                    segments.append(s[start:i])\n                    start = i\n            segments.append(s[start:])\n            return segments\n        \n        # Helper function to count valid substrings in a segment\n        def count_in_segment(segment):\n            count = 0\n            n = len(segment)\n            \n            # Try all possible numbers of unique characters (1 to 26)\n            for unique_chars in range(1, 27):\n                window_size = unique_chars * k\n                if window_size > n:\n                    break\n                    \n                # Sliding window approach\n                freq = {}\n                # Initialize the first window\n                for i in range(window_size):\n                    char = segment[i]\n                    freq[char] = freq.get(char, 0) + 1\n                \n                # Check if the first window is valid\n                valid_chars = sum(1 for c, f in freq.items() if f == k)\n                if valid_chars == unique_chars:\n                    count += 1\n                \n                # Slide the window\n                for i in range(window_size, n):\n                    # Remove the leftmost character\n                    left_char = segment[i - window_size]\n                    freq[left_char] -= 1\n                    if freq[left_char] == 0:\n                        del freq[left_char]\n                    \n                    # Add the new rightmost character\n                    right_char = segment[i]\n                    freq[right_char] = freq.get(right_char, 0) + 1\n                    \n                    # Check if current window is valid\n                    valid_chars = sum(1 for c, f in freq.items() if f == k)\n                    if valid_chars == unique_chars:\n                        count += 1\n                        \n            return count\n        \n        # Get all valid segments\n        segments = get_segments(word)\n        \n        # Count complete substrings in each segment\n        total_count = 0\n        for segment in segments:\n            if len(segment) >= k:  # Only consider segments long enough\n                total_count += count_in_segment(segment)\n                \n        return total_count"}
{"task_id": "3224", "solution": "class Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Precompute factorials and inverse factorials\n        max_n = n\n        fact = [1] * (max_n + 1)\n        for i in range(1, max_n + 1):\n            fact[i] = (fact[i-1] * i) % MOD\n            \n        def modinv(x):\n            return pow(x, MOD - 2, MOD)\n        \n        inv_fact = [1] * (max_n + 1)\n        inv_fact[max_n] = modinv(fact[max_n])\n        for i in range(max_n - 1, -1, -1):\n            inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n            \n        def comb(n, k):\n            if k > n or k < 0:\n                return 0\n            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n-k] % MOD\n        \n        # Identify segments\n        segments = []\n        prev = -1\n        for pos in sick:\n            if pos - prev > 1:\n                segments.append(pos - prev - 1)\n            prev = pos\n        if n - 1 - prev > 0:\n            segments.append(n - 1 - prev)\n            \n        # Calculate ways for each segment\n        ways = []\n        sizes = []\n        \n        # First segment: left edge\n        if sick[0] > 0:\n            ways.append(1)\n            sizes.append(sick[0])\n            \n        # Middle segments\n        for i in range(len(sick) - 1):\n            length = sick[i+1] - sick[i] - 1\n            if length > 0:\n                ways.append(pow(2, length - 1, MOD))\n                sizes.append(length)\n                \n        # Last segment: right edge\n        if sick[-1] < n - 1:\n            ways.append(1)\n            sizes.append(n - 1 - sick[-1])\n            \n        # If there are no segments, return 1\n        if not sizes:\n            return 1\n            \n        # Multiply all ways together\n        total_ways = 1\n        for w in ways:\n            total_ways = (total_ways * w) % MOD\n            \n        # Multiply by multinomial coefficient\n        total_uninfected = sum(sizes)\n        denom = 1\n        for s in sizes:\n            denom = (denom * inv_fact[s]) % MOD\n        multinomial = (fact[total_uninfected] * denom) % MOD\n        \n        result = (total_ways * multinomial) % MOD\n        return result"}
{"task_id": "3225", "solution": "class Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        # Dictionary to store the frequency of elements in the current window\n        freq = {}\n        left = 0\n        max_length = 0\n        \n        # Right pointer expands the window\n        for right in range(len(nums)):\n            # Add the current element to the window\n            freq[nums[right]] = freq.get(nums[right], 0) + 1\n            \n            # Shrink the window from the left until all frequencies are <= k\n            while freq[nums[right]] > k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n            \n            # Update the maximum length of good subarray\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"}
{"task_id": "3226", "solution": "class Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        # Step 1: Sort the array to simulate the removal of minimum elements in order\n        nums.sort()\n        \n        # Step 2: Initialize the result array\n        arr = []\n        \n        # Step 3: Process pairs of elements according to game rules\n        for i in range(0, len(nums), 2):\n            # Bob's element (next smallest) comes first\n            bob_pick = nums[i + 1]\n            # Alice's element (smallest) comes second\n            alice_pick = nums[i]\n            \n            # Append in the order: Bob first, then Alice\n            arr.append(bob_pick)\n            arr.append(alice_pick)\n        \n        return arr"}
{"task_id": "3227", "solution": "class Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        total_numbers = n * n\n        expected_sum = total_numbers * (total_numbers + 1) // 2\n        \n        seen = set()\n        actual_sum = 0\n        duplicate = -1\n        \n        # Flatten the grid and process each element\n        for row in grid:\n            for num in row:\n                if num in seen:\n                    duplicate = num\n                else:\n                    seen.add(num)\n                    actual_sum += num\n        \n        # Calculate missing number using sum difference\n        missing = expected_sum - actual_sum\n        \n        return [duplicate, missing]"}
{"task_id": "3228", "solution": "class Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        half = n // 2\n        \n        # Convert to sets to find unique elements\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # Find exclusive and common elements\n        only1 = set1 - set2\n        only2 = set2 - set1\n        common = set1 & set2\n        \n        # Take as many unique elements as possible from each array, up to half\n        take_only1 = min(len(only1), half)\n        take_only2 = min(len(only2), half)\n        \n        # Calculate how many slots are left for common elements\n        taken_so_far = take_only1 + take_only2\n        remaining_slots = n - taken_so_far\n        \n        # We can take at most len(common) elements, but also limited by remaining slots\n        # Also, we can't take more than 'half' from each array\n        # So, the actual number of common elements we can add is constrained\n        max_common_from_nums1 = half - take_only1\n        max_common_from_nums2 = half - take_only2\n        max_possible_common = min(len(common), max_common_from_nums1 + max_common_from_nums2)\n        take_common = min(max_possible_common, remaining_slots)\n        \n        return take_only1 + take_only2 + take_common"}
{"task_id": "3229", "solution": "class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # Helper function to check if a number is a palindrome\n        def is_palindrome(x):\n            s = str(x)\n            return s == s[::-1]\n        \n        # Helper function to calculate cost of converting all elements to 'target'\n        def calc_cost(target):\n            return sum(abs(num - target) for num in nums)\n        \n        # Sort the array to get the median\n        nums.sort()\n        n = len(nums)\n        median = nums[n // 2]\n        \n        # Find the largest palindrome <= median\n        left_pal = median\n        while left_pal >= 0 and not is_palindrome(left_pal):\n            left_pal -= 1\n        \n        # Find the smallest palindrome >= median\n        right_pal = median\n        while right_pal < 10**9 and not is_palindrome(right_pal):\n            right_pal += 1\n            \n        # Return the minimum cost between the two options\n        return min(calc_cost(left_pal), calc_cost(right_pal))"}
{"task_id": "3230", "solution": "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        def are_almost_equal(a: str, b: str) -> bool:\n            return a == b or abs(ord(a) - ord(b)) == 1\n        \n        operations = 0\n        i = 0\n        n = len(word)\n        \n        while i < n - 1:\n            if are_almost_equal(word[i], word[i + 1]):\n                operations += 1\n                i += 2  # Skip the next character as we consider it \"fixed\"\n            else:\n                i += 1\n                \n        return operations"}
{"task_id": "3231", "solution": "class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        coins.sort()\n        miss = 1  # The smallest sum we cannot form yet\n        added = 0  # Number of coins added\n        i = 0  # Index for iterating through sorted coins\n        \n        while miss <= target:\n            if i < len(coins) and coins[i] <= miss:\n                # Use this coin to extend the range of obtainable sums\n                miss += coins[i]\n                i += 1\n            else:\n                # Need to add a coin of value 'miss'\n                miss += miss\n                added += 1\n                \n        return added"}
{"task_id": "3233", "solution": "class Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        if k == 26:\n            return 1\n        \n        # Step 1: Generate original partitions\n        n = len(s)\n        partitions = []  # list of (start, end, char_set)\n        i = 0\n        while i < n:\n            charset = set()\n            j = i\n            while j < n:\n                charset.add(s[j])\n                if len(charset) > k:\n                    break\n                j += 1\n            # The valid prefix ends at j-1\n            partitions.append((i, j-1, frozenset(charset)))\n            i = j\n\n        num_original = len(partitions)\n\n        # Step 2: Build prefix and suffix arrays\n        prefix_partitions = [0] * n\n        for idx, (start, end, _) in enumerate(partitions):\n            for i in range(start, end + 1):\n                prefix_partitions[i] = idx + 1\n\n        suffix_partitions = [0] * n\n        for idx in range(len(partitions)):\n            rev_idx = len(partitions) - 1 - idx\n            start, end, _ = partitions[rev_idx]\n            for i in range(start, end + 1):\n                suffix_partitions[i] = len(partitions) - rev_idx\n\n        # Map index to its partition id\n        index_to_partition = {}\n        for p_id, (start, end, _) in enumerate(partitions):\n            for i in range(start, end + 1):\n                index_to_partition[i] = p_id\n\n        max_res = num_original\n\n        # Helper to count distinct chars in substring with optional replacement\n        def get_distinct_with_change(l, r, change_pos, new_char):\n            charset = set()\n            for i in range(l, r + 1):\n                c = s[i]\n                if i == change_pos:\n                    c = new_char\n                charset.add(c)\n            return len(charset)\n\n        # Step 3: Try changing each character\n        for i in range(n):\n            p_id = index_to_partition[i]\n            start, end, orig_charset = partitions[p_id]\n\n            # If original partition already uses less than k chars,\n            # no benefit from changing a char inside it\n            if len(orig_charset) < k:\n                continue\n\n            # Otherwise, try changing s[i] to different chars\n            for ch in 'abcdefghijklmnopqrstuvwxyz':\n                if ch == s[i]:\n                    continue\n                \n                # Check if changing s[i] to ch splits the partition\n                # That means first part [start..split] has <=k chars,\n                # and second part [split+1..end] also has <=k chars\n\n                # Try all possible split points between start and end\n                # But optimize: find earliest point where adding s[i]->ch causes overflow\n                cs_left = set()\n                split_point = -1\n                for pos in range(start, end + 1):\n                    c = s[pos]\n                    if pos == i:\n                        c = ch\n                    cs_left.add(c)\n                    if len(cs_left) > k:\n                        split_point = pos - 1\n                        break\n                else:\n                    # No split needed; still valid single partition\n                    continue\n\n                # Now verify right side [split_point + 1 .. end] is also valid\n                cs_right = set()\n                valid_right = True\n                for pos in range(split_point + 1, end + 1):\n                    c = s[pos]\n                    if pos == i:\n                        c = ch\n                    cs_right.add(c)\n                    if len(cs_right) > k:\n                        valid_right = False\n                        break\n\n                if not valid_right:\n                    continue\n\n                # Calculate new total partitions\n                left_count = 1 if start <= split_point else 0\n                right_count = 1 if split_point + 1 <= end else 0\n                total_addition = left_count + right_count - 1  # replaces 1 partition with 2\n\n                before_partitions = prefix_partitions[start - 1] if start > 0 else 0\n                after_partitions = suffix_partitions[end + 1] if end + 1 < n else 0\n\n                total = before_partitions + total_addition + after_partitions\n                max_res = max(max_res, total)\n\n        return max_res"}
{"task_id": "3234", "solution": "from typing import List\n\nclass Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        good_indices = []\n        \n        for i, (a, b, c, m) in enumerate(variables):\n            # Step 1: Compute (a^b % 10)\n            intermediate = pow(a, b, 10)\n            \n            # Step 2: Compute (intermediate^c) % m\n            result = pow(intermediate, c, m)\n            \n            # Step 3: Check if result matches target\n            if result == target:\n                good_indices.append(i)\n                \n        return good_indices"}
{"task_id": "3235", "solution": "from typing import List\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        # Number of lowercase English letters\n        NUM_CHARS = 26\n        \n        # Initialize distance matrix with infinity\n        INF = float('inf')\n        dist = [[INF] * NUM_CHARS for _ in range(NUM_CHARS)]\n        \n        # Distance from a character to itself is 0\n        for i in range(NUM_CHARS):\n            dist[i][i] = 0\n            \n        # Populate initial costs from the input arrays\n        for i in range(len(original)):\n            orig_index = ord(original[i]) - ord('a')\n            chng_index = ord(changed[i]) - ord('a')\n            # Keep the minimum cost for each edge\n            dist[orig_index][chng_index] = min(dist[orig_index][chng_index], cost[i])\n            \n        # Floyd-Warshall Algorithm to compute all-pairs shortest paths\n        for k in range(NUM_CHARS):\n            for i in range(NUM_CHARS):\n                for j in range(NUM_CHARS):\n                    if dist[i][k] + dist[k][j] < dist[i][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n                        \n        # Calculate the total minimum cost to convert source to target\n        total_cost = 0\n        for i in range(len(source)):\n            s_char = source[i]\n            t_char = target[i]\n            \n            if s_char == t_char:\n                continue\n                \n            s_index = ord(s_char) - ord('a')\n            t_index = ord(t_char) - ord('a')\n            \n            # If no path exists, conversion is impossible\n            if dist[s_index][t_index] == INF:\n                return -1\n                \n            total_cost += dist[s_index][t_index]\n            \n        return total_cost"}
{"task_id": "3236", "solution": "class Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        # Step 1: Find the longest sequential prefix\n        i = 1\n        while i < len(nums) and nums[i] == nums[i - 1] + 1:\n            i += 1\n        \n        # Step 2: Calculate the sum of the longest sequential prefix\n        prefix_sum = sum(nums[:i])\n        \n        # Step 3: Convert list to set for fast lookup\n        num_set = set(nums)\n        \n        # Step 4: Find the smallest missing integer >= prefix_sum\n        candidate = prefix_sum\n        while candidate in num_set:\n            candidate += 1\n            \n        return candidate"}
{"task_id": "3239", "solution": "from collections import deque\n\nclass Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        # If x is less than or equal to y, only increments are needed\n        if x <= y:\n            return y - x\n        \n        # BFS initialization\n        queue = deque([(x, 0)])  # (current_value, operations_count)\n        visited = {x}\n        \n        while queue:\n            curr, ops = queue.popleft()\n            \n            # If we've reached the target\n            if curr == y:\n                return ops\n            \n            # Generate next states based on allowed operations\n            next_states = []\n            \n            # Divide by 11 if divisible\n            if curr % 11 == 0:\n                next_states.append(curr // 11)\n                \n            # Divide by 5 if divisible\n            if curr % 5 == 0:\n                next_states.append(curr // 5)\n                \n            # Decrement by 1\n            next_states.append(curr - 1)\n            \n            # Increment by 1\n            next_states.append(curr + 1)\n            \n            # Process all valid next states\n            for next_val in next_states:\n                # Only process if not visited and within reasonable bounds\n                # We don't want to go too far below 1 or too far above a reasonable upper limit\n                if next_val not in visited and next_val >= 1 and next_val <= 2 * max(x, y):\n                    visited.add(next_val)\n                    queue.append((next_val, ops + 1))\n        \n        # This line should never be reached given the constraints\n        return -1"}
{"task_id": "3240", "solution": "class Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        def count_bits(num, pos):\n            # Count how many numbers from 1 to num have bit set at position pos (1-indexed)\n            if pos > num.bit_length():\n                return 0\n            \n            cycle_len = 1 << pos  # 2^pos\n            half_cycle = cycle_len >> 1  # 2^(pos-1)\n            \n            # How many complete cycles\n            complete_cycles = (num + 1) // cycle_len\n            remainder = (num + 1) % cycle_len\n            \n            # Each complete cycle contributes half_cycle set bits\n            count = complete_cycles * half_cycle\n            \n            # In the incomplete cycle, count how many positions >= half_cycle\n            if remainder > half_cycle:\n                count += remainder - half_cycle\n                \n            return count\n        \n        def price_sum(num):\n            # Sum of prices for all numbers from 1 to num\n            total = 0\n            # Check all positions that are multiples of x\n            # Position indices start at 1\n            pos = x\n            while pos <= num.bit_length():\n                total += count_bits(num, pos)\n                pos += x\n            return total\n        \n        # Binary search for the largest num such that price_sum(num) <= k\n        left, right = 1, 1 << 64  # Large enough upper bound\n        result = 0\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if price_sum(mid) <= k:\n                result = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return result"}
{"task_id": "3242", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        # Step 1: Count the frequency of each element\n        freq_count = Counter(nums)\n        \n        # Step 2: Find the maximum frequency\n        max_freq = max(freq_count.values())\n        \n        # Step 3: Count how many elements have the maximum frequency\n        num_elements_with_max_freq = sum(1 for freq in freq_count.values() if freq == max_freq)\n        \n        # Step 4: Calculate the total number of elements with maximum frequency\n        return max_freq * num_elements_with_max_freq"}
{"task_id": "3243", "solution": "class Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        def count_powerful(n_str: str) -> int:\n            # If n is shorter than s, impossible to have s as suffix\n            if len(n_str) < len(s):\n                return 0\n            \n            # Check if any digit exceeds limit, truncate if needed\n            truncated = False\n            for i, ch in enumerate(n_str):\n                if int(ch) > limit:\n                    # Truncate from this digit onward to max allowable digits\n                    n_str = n_str[:i] + str(limit) * (len(n_str) - i)\n                    truncated = True\n                    break\n            \n            # Now compare suffix\n            suffix_start_idx = len(n_str) - len(s)\n            prefix_part = n_str[:suffix_start_idx]\n            suffix_part = n_str[suffix_start_idx:]\n            \n            # Convert prefix part as base-(limit+1) number\n            def to_base_limit_number(digits: str) -> int:\n                res = 0\n                base = limit + 1\n                for ch in digits:\n                    res = res * base + int(ch)\n                return res\n            \n            count = to_base_limit_number(prefix_part) if prefix_part else 0\n            \n            # If suffix >= s, we can take exactly 'count' prefixes\n            # But if suffix < s, we must subtract 1 from prefix before converting\n            if suffix_part >= s:\n                count += 1\n            # else: already accounted for\n            \n            return count\n        \n        # Calculate count for finish and start-1\n        result = count_powerful(str(finish)) - count_powerful(str(start - 1))\n        return result"}
{"task_id": "3244", "solution": "class Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        # Find the minimum value in the array\n        min_val = min(nums)\n        \n        # Count how many times the minimum value appears\n        count_min = nums.count(min_val)\n        \n        # If the minimum value appears only once, we can reduce the array to size 1\n        if count_min == 1:\n            return 1\n        \n        # Check if there exists any element that does not divide evenly by min_val\n        # If such an element exists, we can generate a smaller value than min_val\n        for num in nums:\n            if num % min_val != 0:\n                return 1\n        \n        # If all elements are multiples of min_val, we can only pair up min_vals\n        # Each pair reduces to 0, so we need (count_min + 1) // 2 elements\n        return (count_min + 1) // 2"}
{"task_id": "3245", "solution": "class Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        # Step 1: Find all indices where pattern 'a' occurs\n        indices_a = []\n        len_a = len(a)\n        for i in range(len(s) - len_a + 1):\n            if s[i:i+len_a] == a:\n                indices_a.append(i)\n\n        # Step 2: Find all indices where pattern 'b' occurs\n        indices_b = []\n        len_b = len(b)\n        for i in range(len(s) - len_b + 1):\n            if s[i:i+len_b] == b:\n                indices_b.append(i)\n\n        # Step 3 & 4: For each index in indices_a, check if there exists a close enough index in indices_b\n        from bisect import bisect_left\n        result = []\n\n        for i in indices_a:\n            # Binary search for the insertion point of i in indices_b\n            pos = bisect_left(indices_b, i)\n            \n            # Check the closest candidates around the insertion point\n            # Check element at pos (if exists)\n            if pos < len(indices_b) and abs(indices_b[pos] - i) <= k:\n                result.append(i)\n            # Check element at pos-1 (if exists)\n            elif pos > 0 and abs(indices_b[pos-1] - i) <= k:\n                result.append(i)\n                \n        return result"}
{"task_id": "3246", "solution": "class Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        # Count how many even numbers are in the list\n        even_count = 0\n        for num in nums:\n            if num % 2 == 0:\n                even_count += 1\n                # Early exit if we already have at least two even numbers\n                if even_count >= 2:\n                    return True\n        return False"}
{"task_id": "3249", "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Step 1: Compute the XOR of all elements in the array\n        current_xor = 0\n        for num in nums:\n            current_xor ^= num\n        \n        # Step 2: Find the difference between current XOR and target k\n        diff = current_xor ^ k\n        \n        # Step 3: Count the number of set bits in diff\n        # This gives the minimum number of bit flips required\n        return bin(diff).count('1')"}
{"task_id": "3251", "solution": "from typing import List\n\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        max_diag_sq = 0\n        max_area = 0\n        \n        for length, width in dimensions:\n            diag_sq = length * length + width * width\n            area = length * width\n            \n            if diag_sq > max_diag_sq:\n                max_diag_sq = diag_sq\n                max_area = area\n            elif diag_sq == max_diag_sq:\n                max_area = max(max_area, area)\n                \n        return max_area"}
{"task_id": "3252", "solution": "from typing import List\n\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        \n        # Helper function to check if an array is strictly increasing\n        def is_strictly_increasing(arr):\n            for i in range(1, len(arr)):\n                if arr[i] <= arr[i-1]:\n                    return False\n            return True\n        \n        # Iterate through all possible subarrays\n        for i in range(n):\n            for j in range(i, n):\n                # Create the array after removing subarray from index i to j\n                left_part = nums[:i]\n                right_part = nums[j+1:]\n                remaining = left_part + right_part\n                \n                # Check if remaining array is strictly increasing\n                if is_strictly_increasing(remaining):\n                    count += 1\n                    \n        return count"}
{"task_id": "3261", "solution": "class Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        ans = 0\n        # We try to minimize the result by turning off bits from MSB to LSB\n        # Iterate over bits from 29 down to 0 (since nums[i] < 2^30)\n        for b in range(29, -1, -1):\n            # Tentatively try to make this bit 0 in the final answer\n            # So we construct a mask where all higher bits are decided,\n            # and this bit and lower ones are 0\n            mask = ans | ((1 << b) - 1)\n            # The target is to ensure that all final numbers after merging have\n            # (ans >> b) & 1 == 0 at bit b, so we test if we can clear this bit\n            \n            # To clear this bit, we need all final elements to have 0 at bit b\n            # That means during merging process, each merged group must end with\n            # a value where bit b is 0\n            \n            # Simulate grouping:\n            # Keep computing running ANDs until the result & (1<<b) becomes 0\n            # Then we finalize a group\n            groups = 0\n            current_and = (1 << 30) - 1  # Large enough initial value\n            \n            for x in nums:\n                current_and &= x\n                # If adding x makes the current group's AND have bit b as 0\n                # then we can finalize this group\n                if (current_and | mask) == mask:\n                    groups += 1\n                    current_and = (1 << 30) - 1  # Reset for next group\n            \n            # Number of operations needed is n - groups\n            ops_needed = n - groups\n            # If we can't do it within k operations, we must keep this bit in answer\n            if ops_needed > k:\n                ans |= (1 << b)\n            # Else we can make this bit 0, so we leave ans unchanged\n                \n        return ans"}
{"task_id": "3262", "solution": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        # Sort the array to allow greedy selection of smallest elements first\n        nums.sort()\n        n = len(nums)\n        \n        # Initialize prefix sum with the first two elements\n        prefix_sum = nums[0] + nums[1]\n        max_perimeter = -1\n        \n        # Start from the third element (index 2) to ensure at least 3 sides\n        for i in range(2, n):\n            # Check if the sum of all previous elements is greater than current element\n            if prefix_sum > nums[i]:\n                # Valid polygon can be formed; update maximum perimeter\n                max_perimeter = max(max_perimeter, prefix_sum + nums[i])\n            \n            # Add current element to prefix sum for next iteration\n            prefix_sum += nums[i]\n        \n        return max_perimeter"}
{"task_id": "3263", "solution": "class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # The cost of the first subarray is always the first element\n        first_cost = nums[0]\n        \n        # Get the remaining elements\n        remaining = nums[1:]\n        \n        # Sort the remaining elements to find the two smallest values\n        remaining.sort()\n        \n        # The minimum cost is the first element plus the two smallest from the rest\n        return first_cost + remaining[0] + remaining[1]"}
{"task_id": "3265", "solution": "class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        # Dictionary to store the minimum prefix sum for each value encountered\n        min_prefix_sums = {}\n        \n        # Running prefix sum\n        prefix_sum = 0\n        \n        # Result to track the maximum sum of a good subarray\n        max_sum = float('-inf')\n        \n        for num in nums:\n            # Add current number to prefix sum\n            prefix_sum += num\n            \n            # Check for possible good subarrays ending at current position\n            # Case 1: previous element could be (num - k)\n            if (num - k) in min_prefix_sums:\n                subarray_sum = prefix_sum - min_prefix_sums[num - k]\n                max_sum = max(max_sum, subarray_sum)\n            \n            # Case 2: previous element could be (num + k)\n            if (num + k) in min_prefix_sums:\n                subarray_sum = prefix_sum - min_prefix_sums[num + k]\n                max_sum = max(max_sum, subarray_sum)\n            \n            # Update the minimum prefix sum for this value\n            # We want the minimum prefix sum because we're subtracting it,\n            # and we want to maximize the difference (subarray sum)\n            if num in min_prefix_sums:\n                min_prefix_sums[num] = min(min_prefix_sums[num], prefix_sum - num)\n            else:\n                min_prefix_sums[num] = prefix_sum - num\n        \n        # Return 0 if no good subarray found, otherwise return max_sum\n        return max_sum if max_sum != float('-inf') else 0"}
{"task_id": "3267", "solution": "class Solution:\n    def maximumLength(self, s: str) -> int:\n        # Dictionary to store for each character, a dictionary of {length: count}\n        freq = {}\n        \n        i = 0\n        n = len(s)\n        \n        # Traverse the string to find all maximal consecutive segments\n        while i < n:\n            j = i\n            # Extend j to the end of current run of same characters\n            while j < n and s[j] == s[i]:\n                j += 1\n            length = j - i  # Length of the consecutive segment\n            \n            char = s[i]\n            if char not in freq:\n                freq[char] = {}\n            \n            # For a segment of length `length`, it contributes:\n            # (length - k + 1) substrings of length k, for k from 1 to length\n            for k in range(1, length + 1):\n                freq[char][k] = freq[char].get(k, 0) + (length - k + 1)\n            \n            i = j  # Move to next different character\n        \n        max_len = -1\n        \n        # Now check for each character and each length, if count >= 3\n        for char in freq:\n            for length in freq[char]:\n                if freq[char][length] >= 3:\n                    max_len = max(max_len, length)\n        \n        return max_len"}
{"task_id": "3269", "solution": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        m = len(pattern)\n        \n        # Iterate through all possible starting indices for subarrays of length m+1\n        for i in range(n - m):\n            match = True\n            # Check if the subarray starting at i matches the pattern\n            for k in range(m):\n                if pattern[k] == 1:\n                    if nums[i + k + 1] <= nums[i + k]:\n                        match = False\n                        break\n                elif pattern[k] == 0:\n                    if nums[i + k + 1] != nums[i + k]:\n                        match = False\n                        break\n                else:  # pattern[k] == -1\n                    if nums[i + k + 1] >= nums[i + k]:\n                        match = False\n                        break\n            if match:\n                count += 1\n                \n        return count"}
{"task_id": "3279", "solution": "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        # Count of odd numbers in [1, n] and [1, m]\n        odd_n = (n + 1) // 2\n        odd_m = (m + 1) // 2\n        \n        # Count of even numbers in [1, n] and [1, m]\n        even_n = n // 2\n        even_m = m // 2\n        \n        # Case 1: x is odd, y is even\n        case1 = odd_n * even_m\n        \n        # Case 2: x is even, y is odd\n        case2 = even_n * odd_m\n        \n        return case1 + case2"}
{"task_id": "3291", "solution": "class Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        def count_set_bits(x):\n            return bin(x).count('1')\n        \n        n = len(nums)\n        i = 0\n        \n        # Track the maximum value of the previous group\n        prev_max = float('-inf')\n        \n        while i < n:\n            current_bits = count_set_bits(nums[i])\n            group_min = nums[i]\n            group_max = nums[i]\n            \n            # Process the entire group with same set bits\n            while i < n and count_set_bits(nums[i]) == current_bits:\n                group_min = min(group_min, nums[i])\n                group_max = max(group_max, nums[i])\n                i += 1\n            \n            # Check if this group can come after the previous group\n            if group_min < prev_max:\n                return False\n            \n            # Update prev_max for next iteration\n            prev_max = group_max\n        \n        return True"}
{"task_id": "3292", "solution": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n = len(nums)\n        m = len(changeIndices)\n        \n        # Helper function to check if all indices can be marked by time 'mid'\n        def is_feasible(mid):\n            # Map each index to its last occurrence in changeIndices[0..mid-1]\n            last_occurrence = {}\n            for i in range(mid):\n                idx = changeIndices[i] - 1  # Convert to 0-based indexing\n                last_occurrence[idx] = i\n            \n            # If any index doesn't appear, it's impossible to mark it\n            if len(last_occurrence) < n:\n                return False\n\n            # Available operations to decrement nums\n            available_ops = 0\n            # Track whether we've processed the final marking opportunity for each index\n            marked = [False] * n\n\n            # Traverse from mid-1 backwards to 0\n            for t in reversed(range(mid)):\n                idx = changeIndices[t] - 1  # Convert to 0-based indexing\n                \n                # If this is the last chance to mark idx and we haven't used it yet\n                if last_occurrence[idx] == t and not marked[idx]:\n                    # Need to reduce nums[idx] to 0 before marking\n                    needed = nums[idx]\n                    if available_ops >= needed:\n                        available_ops -= needed\n                        marked[idx] = True\n                    else:\n                        return False\n                else:\n                    # Otherwise, we gain one operation we can use earlier\n                    available_ops += 1\n            \n            # All indices should be marked\n            return all(marked)\n        \n        # Binary search on the answer\n        left, right = 1, m\n        result = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if is_feasible(mid):\n                result = mid\n                right = mid - 1  # Try to find a smaller valid time\n            else:\n                left = mid + 1   # Need more time\n        \n        return result"}
{"task_id": "3297", "solution": "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        n = len(word)\n        # Try each step: after removing k*i characters\n        for i in range(1, n // k + 2):  # We might have to go one more time beyond exact divisions\n            start_index = i * k\n            if start_index >= n:\n                # All characters removed; we can reconstruct the whole string\n                return i\n            \n            # Remaining suffix\n            remaining_suffix = word[start_index:]\n            \n            # Check if this suffix is a prefix of the original word\n            if word.startswith(remaining_suffix):\n                return i\n        \n        # In worst case, it takes ceil(n / k) steps\n        return (n + k - 1) // k"}
{"task_id": "3298", "solution": "class Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        # Sort the array to process numbers in ascending order\n        nums.sort()\n        \n        # Dictionary to store dp[value] = max length of consecutive sequence ending at 'value'\n        dp = {}\n        max_len = 0\n        \n        # Iterate through each number in the sorted array\n        for x in nums:\n            # Update dp[x+1] using dp[x]\n            # This corresponds to incrementing current element x to x+1\n            dp[x + 1] = max(dp.get(x + 1, 0), dp.get(x, 0) + 1)\n            \n            # Update dp[x] using dp[x-1]\n            # This corresponds to keeping current element x as is\n            dp[x] = max(dp.get(x, 0), dp.get(x - 1, 0) + 1)\n            \n            # Update the maximum length found so far\n            max_len = max(max_len, dp[x], dp[x + 1])\n        \n        return max_len"}
{"task_id": "3299", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        # Count the frequency of each number\n        freq = Counter(nums)\n        max_length = 1  # At least one element can always form a valid sequence\n        \n        # Handle each unique number in the list\n        for num in freq:\n            if num == 1:\n                # Special case for 1 since 1^2 = 1\n                # We can take all 1's if count is odd, otherwise count-1\n                count_ones = freq[num]\n                if count_ones % 2 == 1:\n                    max_length = max(max_length, count_ones)\n                else:\n                    max_length = max(max_length, count_ones - 1)\n            else:\n                # For other numbers, try to build the longest possible sequence\n                current = num\n                length = 0\n                \n                # While we have at least 2 occurrences of current number\n                # we can use them as a pair on both sides of the sequence\n                while freq[current] >= 2:\n                    length += 2  # Add pair to sequence\n                    current = current * current  # Move to next in sequence (square)\n                \n                # Check if we can place the final element as the peak\n                if freq[current] >= 1:\n                    length += 1  # Add the peak element\n                else:\n                    # If we couldn't find the peak, we added an extra pair\n                    # So we need to subtract one element from the last pair\n                    length -= 1\n                \n                max_length = max(max_length, length)\n        \n        return max_length"}
{"task_id": "3308", "solution": "class Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        # Count frequency of each character\n        freq = {}\n        for char in s:\n            freq[char] = freq.get(char, 0) + 1\n        \n        # Find maximum frequency\n        max_freq = max(freq.values())\n        \n        # Find characters with maximum frequency and their last positions\n        last_pos = {}\n        for i, char in enumerate(s):\n            if freq[char] == max_freq:\n                last_pos[char] = i\n        \n        # Sort characters by their last positions\n        sorted_chars = sorted(last_pos.keys(), key=lambda x: last_pos[x])\n        \n        return ''.join(sorted_chars)"}
{"task_id": "3309", "solution": "class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        count = 0\n        n = len(words)\n        for i in range(n):\n            for j in range(i + 1, n):\n                word1 = words[i]\n                word2 = words[j]\n                if word2.startswith(word1) and word2.endswith(word1):\n                    count += 1\n        return count"}
{"task_id": "3311", "solution": "class Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        position = 0\n        count = 0\n        \n        for num in nums:\n            position += num\n            if position == 0:\n                count += 1\n                \n        return count"}
{"task_id": "3312", "solution": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        # Initialize the counter for key changes\n        changes = 0\n        \n        # Iterate through the string starting from the second character\n        for i in range(1, len(s)):\n            # Compare current character with previous character (case-insensitive)\n            if s[i].lower() != s[i-1].lower():\n                changes += 1\n                \n        return changes"}
{"task_id": "3317", "solution": "class Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        # Step 1: Count all characters\n        from collections import Counter\n        char_count = Counter()\n        for word in words:\n            char_count.update(word)\n        \n        # Step 2: Calculate total number of pairs we can form\n        total_pairs = sum(count // 2 for count in char_count.values())\n        \n        # Step 3: Sort word lengths to apply greedy strategy\n        word_lengths = sorted(len(word) for word in words)\n        \n        # Step 4: Try to form as many palindromes as possible\n        palindrome_count = 0\n        for length in word_lengths:\n            required_pairs = length // 2\n            if required_pairs <= total_pairs:\n                total_pairs -= required_pairs\n                palindrome_count += 1\n            else:\n                break  # Not enough pairs left to form current word as palindrome\n        \n        return palindrome_count"}
{"task_id": "3320", "solution": "class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        # At least one operation is always possible since len(nums) >= 2\n        target_sum = nums[0] + nums[1]\n        operations = 0\n        i = 0\n        \n        # Process consecutive pairs from the start\n        while i + 1 < len(nums):\n            current_sum = nums[i] + nums[i + 1]\n            if current_sum == target_sum:\n                operations += 1\n                i += 2  # Move to next pair\n            else:\n                break  # Stop when sum doesn't match\n                \n        return operations"}
{"task_id": "3324", "solution": "class Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        # Count frequency of each element\n        freq = {}\n        for num in nums:\n            freq[num] = freq.get(num, 0) + 1\n        \n        # Check if any element appears more than 2 times\n        for count in freq.values():\n            if count > 2:\n                return False\n        \n        return True"}
{"task_id": "3329", "solution": "class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        # Step 1: Generate all prefixes of numbers in arr1 and store in a set\n        prefixes_arr1 = set()\n        for num in arr1:\n            s = str(num)\n            for i in range(1, len(s) + 1):\n                prefixes_arr1.add(s[:i])\n        \n        # Step 2: Check prefixes of numbers in arr2 against the set\n        max_length = 0\n        for num in arr2:\n            s = str(num)\n            # Check all prefixes of the current number from longest to shortest\n            for i in range(len(s), 0, -1):\n                if s[:i] in prefixes_arr1:\n                    max_length = max(max_length, i)\n                    break  # No need to check shorter prefixes once we found the longest match\n        \n        return max_length"}
{"task_id": "3331", "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Count how many elements are less than k\n        count = 0\n        for num in nums:\n            if num < k:\n                count += 1\n        return count"}
{"task_id": "3347", "solution": "class Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        # Step 1: Initialize two arrays\n        arr1 = []\n        arr2 = []\n        \n        # Step 2: First two operations\n        arr1.append(nums[0])\n        arr2.append(nums[1])\n        \n        # Step 3: Distribute remaining elements\n        for i in range(2, len(nums)):\n            # Compare last elements of both arrays\n            if arr1[-1] > arr2[-1]:\n                arr1.append(nums[i])\n            else:\n                arr2.append(nums[i])\n        \n        # Step 4: Concatenate the two arrays\n        return arr1 + arr2"}
{"task_id": "abc301_a", "solution": "# Read input\nN = int(input())\nS = input().strip()\n\n# Count total wins\nt_wins = S.count('T')\na_wins = S.count('A')\n\n# If one has more wins, they are the overall winner\nif t_wins > a_wins:\n    print('T')\nelif a_wins > t_wins:\n    print('A')\nelse:\n    # They have equal wins; find who reached this number first\n    t_count = 0\n    a_count = 0\n    target = t_wins  # Since they're equal, either works\n    \n    for char in S:\n        if char == 'T':\n            t_count += 1\n        else:\n            a_count += 1\n            \n        # Check if either reached the target first\n        if t_count == target:\n            print('T')\n            break\n        elif a_count == target:\n            print('A')\n            break"}
{"task_id": "abc301_b", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    changed = True\n    while changed:\n        changed = False\n        # Scan from left to right to find the first pair with |diff| != 1\n        for i in range(len(A) - 1):\n            diff = abs(A[i] - A[i+1])\n            if diff != 1:\n                # Found the first bad pair\n                changed = True\n                if A[i] < A[i+1]:\n                    # Insert A[i]+1, A[i]+2, ..., A[i+1]-1\n                    to_insert = list(range(A[i] + 1, A[i+1]))\n                else:\n                    # Insert A[i]-1, A[i]-2, ..., A[i+1]+1\n                    to_insert = list(range(A[i] - 1, A[i+1], -1))\n                \n                # Insert the new elements after position i\n                A = A[:i+1] + to_insert + A[i+1:]\n                break  # Restart the search from the beginning\n    \n    print(' '.join(map(str, A)))\n\nsolve()"}
{"task_id": "abc301_c", "solution": "from collections import Counter\n\ndef main():\n    S = input().strip()\n    T = input().strip()\n    \n    # Count frequencies\n    cnt_s = Counter(S)\n    cnt_t = Counter(T)\n    \n    # Set of valid characters that @ can be replaced with\n    valid_replacements = set('atcoder')\n    \n    # Calculate the number of replacements needed in each direction\n    need_s_to_t = 0  # How many @ in S need to be replaced to cover excess in T\n    need_t_to_s = 0  # How many @ in T need to be replaced to cover excess in S\n    \n    # Check all lowercase letters\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        freq_s = cnt_s.get(c, 0)\n        freq_t = cnt_t.get(c, 0)\n        \n        if c not in valid_replacements:\n            # This character cannot be produced from @\n            if freq_s != freq_t:\n                print(\"No\")\n                return\n        else:\n            if freq_s > freq_t:\n                # S has more of this char than T; T needs to produce the difference using @\n                need_t_to_s += freq_s - freq_t\n            elif freq_t > freq_s:\n                # T has more of this char than S; S needs to produce the difference using @\n                need_s_to_t += freq_t - freq_s\n                \n    # Now check if there are enough @ symbols to satisfy the needs\n    at_s = cnt_s.get('@', 0)\n    at_t = cnt_t.get('@', 0)\n    \n    if at_s >= need_s_to_t and at_t >= need_t_to_s:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc301_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    S = data[0]\n    N = int(data[1])\n    \n    res = []\n    n = len(S)\n    \n    for i in range(n):\n        if S[i] != '?':\n            res.append(S[i])\n            continue\n        \n        # Try placing '1' at this position\n        temp_res = res + ['1']\n        # Fill remaining '?' with '0'\n        temp_str = ''.join(temp_res) + '0' * (n - len(temp_res))\n        val = int(temp_str, 2)\n        \n        if val <= N:\n            res.append('1')\n        else:\n            res.append('0')\n    \n    final_bin_str = ''.join(res)\n    final_val = int(final_bin_str, 2)\n    \n    if final_val <= N:\n        print(final_val)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc301_e", "solution": "import collections\n\ndef main():\n    import sys\n    from collections import deque\n    input = sys.stdin.read\n    data = input().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    T = int(data[2])\n    \n    grid = []\n    for i in range(H):\n        grid.append(data[3 + i])\n        \n    # Find positions\n    pos = {}\n    candy_positions = []\n    for i in range(H):\n        for j in range(W):\n            c = grid[i][j]\n            if c == 'S':\n                pos['S'] = (i, j)\n            elif c == 'G':\n                pos['G'] = (i, j)\n            elif c == 'o':\n                candy_positions.append((i, j))\n                \n    start = pos['S']\n    goal = pos['G']\n    C = len(candy_positions)\n    \n    # Precompute distances using BFS from a source point\n    def bfs_distances(src):\n        dist = [[-1]*W for _ in range(H)]\n        dist[src[0]][src[1]] = 0\n        q = deque()\n        q.append(src)\n        directions = [(-1,0),(1,0),(0,-1),(0,1)]\n        while q:\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x+dx, y+dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '#' and dist[nx][ny] == -1:\n                    dist[nx][ny] = dist[x][y] + 1\n                    q.append((nx, ny))\n        return dist\n    \n    # Check if goal is reachable within T moves from start\n    dist_from_start = bfs_distances(start)\n    if dist_from_start[goal[0]][goal[1]] == -1 or dist_from_start[goal[0]][goal[1]] > T:\n        print(-1)\n        return\n    \n    # If no candies, just check if direct path is within T\n    if C == 0:\n        if dist_from_start[goal[0]][goal[1]] <= T:\n            print(0)\n        else:\n            print(-1)\n        return\n        \n    # Build list of key points: start, goal, candies\n    key_points = [start] + candy_positions + [goal]\n    K = len(key_points)\n    \n    # Compute distance matrix between all key points\n    dist_matrix = [[-1]*K for _ in range(K)]\n    full_dists = []\n    for i in range(K):\n        d = bfs_distances(key_points[i])\n        full_dists.append(d)\n        for j in range(K):\n            x, y = key_points[j]\n            dist_matrix[i][j] = d[x][y]\n            \n    # Now perform bitmask DP\n    # dp[mask][i] = minimum cost to visit nodes in mask and end at node i (0-based index for key_points)\n    # Node indices: 0=start, 1..C=candies, C+1=goal\n    INF = float('inf')\n    dp = [[INF]*(K) for _ in range(1 << K)]\n    dp[1][0] = 0  # Start at node 0 (start point), mask = 1 (only start visited)\n    \n    # Iterate over all masks\n    for mask in range(1 << K):\n        for u in range(K):\n            if not (mask & (1<<u)):\n                continue\n            if dp[mask][u] == INF:\n                continue\n            current_cost = dp[mask][u]\n            # Try to go to next unvisited node v\n            for v in range(K):\n                if mask & (1<<v):\n                    continue\n                if dist_matrix[u][v] == -1:\n                    continue\n                new_mask = mask | (1<<v)\n                new_cost = current_cost + dist_matrix[u][v]\n                if new_cost < dp[new_mask][v]:\n                    dp[new_mask][v] = new_cost\n                    \n    # Now check for each number of candies from max down to 0\n    # Goal is node K-1\n    goal_index = K - 1\n    max_candies = -1\n    # Iterate from largest subset to smallest\n    for mask in range((1 << K)-1, -1, -1):\n        # Count how many candies are included in this mask\n        # Candies are indices 1 to C\n        candy_count = 0\n        for i in range(1, C+1):\n            if mask & (1<<i):\n                candy_count += 1\n        # Check if goal is in this mask\n        if not (mask & (1<<goal_index)):\n            continue\n        # Check if start is in this mask\n        if not (mask & (1<<0)):\n            continue\n        # Check if this path is feasible\n        if dp[mask][goal_index] <= T:\n            max_candies = max(max_candies, candy_count)\n            \n    print(max_candies)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc301_f", "solution": "import sys\nsys.setrecursionlimit(1 << 25)\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    S = input().strip()\n    N = len(S)\n    \n    # Precompute transitions\n    # states: 0,1,2,3,4\n    # 4 is bad\n    trans = [[[] for _ in range(2)] for __ in range(5)]\n    # char_type: 0 = uppercase, 1 = lowercase\n    \n    def get_next_states(cur_state, char_type):\n        res = []\n        if cur_state == 0:\n            if char_type == 0:  # uppercase\n                res.append(1)\n            else:\n                res.append(0)\n        elif cur_state == 1:\n            if char_type == 0:  # uppercase\n                res.append(1)  # different uppercase resets to 1\n                res.append(2)  # same uppercase moves to 2\n            else:\n                res.append(0)\n        elif cur_state == 2:\n            if char_type == 0:  # uppercase\n                res.append(1)\n            else:\n                res.append(3)\n        elif cur_state == 3:\n            if char_type == 0:  # uppercase\n                res.append(4)  # bad!\n            else:\n                res.append(0)\n        elif cur_state == 4:\n            res.append(4)\n        return res\n\n    # Build transition table\n    for s in range(5):\n        for t in range(2):\n            trans[s][t] = get_next_states(s, t)\n\n    # Memoization for DP\n    memo = {}\n\n    def dp(pos, state):\n        if state == 4:\n            return 0\n        if pos == N:\n            return 1\n        if (pos, state) in memo:\n            return memo[(pos, state)]\n        \n        ans = 0\n        c = S[pos]\n        if c == '?':\n            # Try all 52 possibilities\n            # 26 uppercase\n            for ns in trans[state][0]:\n                ans = (ans + dp(pos+1, ns)) % MOD\n            # 26 lowercase\n            for ns in trans[state][1]:\n                ans = (ans + dp(pos+1, ns)) % MOD\n        else:\n            char_type = 0 if c.isupper() else 1\n            for ns in trans[state][char_type]:\n                ans = (ans + dp(pos+1, ns)) % MOD\n        \n        memo[(pos, state)] = ans\n        return ans\n\n    result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc302_a", "solution": "# Read input\nA, B = map(int, input().split())\n\n# Calculate the minimum number of attacks using ceiling division\n# ceil(A/B) = (A + B - 1) // B for positive integers\nattacks = (A + B - 1) // B\n\n# Print the result\nprint(attacks)"}
{"task_id": "abc302_b", "solution": "# Read input\nH, W = map(int, input().split())\ngrid = [input() for _ in range(H)]\n\n# Define the target word and the 8 directions (row_delta, col_delta)\ntarget_word = \"snuke\"\ndirections = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),           (0, 1),\n    (1, -1),  (1, 0),  (1, 1)\n]\n\n# Function to check if coordinates are within bounds\ndef in_bounds(r, c):\n    return 0 <= r < H and 0 <= c < W\n\n# Search for the sequence\nfound = False\nfor r in range(H):\n    for c in range(W):\n        # Only start search if current cell is 's'\n        if grid[r][c] == 's':\n            # Try all 8 directions\n            for dr, dc in directions:\n                # Check if we can form the entire word in this direction\n                match = True\n                positions = []\n                \n                for i, char in enumerate(target_word):\n                    nr, nc = r + i * dr, c + i * dc\n                    if not in_bounds(nr, nc) or grid[nr][nc] != char:\n                        match = False\n                        break\n                    positions.append((nr + 1, nc + 1))  # Convert to 1-indexed\n                \n                if match:\n                    # Print the result and exit\n                    for pos in positions:\n                        print(pos[0], pos[1])\n                    found = True\n                    break\n            \n            if found:\n                break\n    if found:\n        break"}
{"task_id": "abc302_c", "solution": "from itertools import permutations\nimport sys\n\ndef diff_by_one(s1, s2):\n    \"\"\"Check if two strings differ by exactly one character.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    diff_count = 0\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            diff_count += 1\n            if diff_count > 1:\n                return False\n    return diff_count == 1\n\ndef can_form_sequence(strings):\n    \"\"\"Check if strings can be rearranged to satisfy the condition.\"\"\"\n    # Try all permutations\n    for perm in permutations(strings):\n        valid = True\n        for i in range(len(perm) - 1):\n            if not diff_by_one(perm[i], perm[i+1]):\n                valid = False\n                break\n        if valid:\n            return True\n    return False\n\n# Read input\nline = input().split()\nN, M = int(line[0]), int(line[1])\nstrings = []\nfor _ in range(N):\n    strings.append(input().strip())\n\n# Solve and output\nif can_form_sequence(strings):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc302_d", "solution": "import bisect\n\n# Read input\nN, M, D = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n# Sort both arrays\nA.sort()\nB.sort()\n\nmax_sum = -1\n\n# For each element in A, find the best matching element in B\nfor a in A:\n    # We want to find b in B such that |a - b| <= D\n    # This means: -D <= a - b <= D\n    # Rearranging: a - D <= b <= a + D\n    \n    # Find the leftmost position where b >= a - D\n    left_idx = bisect.bisect_left(B, a - D)\n    \n    # Find the rightmost position where b <= a + D\n    right_idx = bisect.bisect_right(B, a + D)\n    \n    # If there are elements in this range\n    if left_idx < right_idx:\n        # The best choice is the largest b in this range to maximize sum\n        best_b = B[right_idx - 1]\n        current_sum = a + best_b\n        max_sum = max(max_sum, current_sum)\n\nprint(max_sum)"}
{"task_id": "abc302_e", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    Q = int(data[idx])\n    idx += 1\n    \n    # adj[u] is a set of neighbors of u\n    adj = [set() for _ in range(N + 1)]\n    # degree[i] is the degree of vertex i\n    degree = [0] * (N + 1)\n    # Count of isolated vertices (degree == 0)\n    isolated_count = N\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[idx])\n        idx += 1\n        \n        if query_type == 1:\n            u = int(data[idx])\n            idx += 1\n            v = int(data[idx])\n            idx += 1\n            \n            # Add edge u-v\n            adj[u].add(v)\n            adj[v].add(u)\n            \n            # Update degrees and isolated count\n            if degree[u] == 0:\n                isolated_count -= 1\n            degree[u] += 1\n            \n            if degree[v] == 0:\n                isolated_count -= 1\n            degree[v] += 1\n                \n        else:  # query_type == 2\n            v = int(data[idx])\n            idx += 1\n            \n            # Remove all edges connected to v\n            # First, update isolated count for v if needed\n            if degree[v] == 0:\n                pass  # already isolated\n            else:\n                isolated_count += 1  # v will become isolated\n            \n            # For each neighbor of v, remove the edge and update their degree\n            for neighbor in list(adj[v]):\n                adj[neighbor].remove(v)\n                degree[neighbor] -= 1\n                if degree[neighbor] == 0:\n                    isolated_count += 1\n            \n            # Clear v's adjacency list and reset its degree\n            adj[v].clear()\n            degree[v] = 0\n        \n        results.append(isolated_count)\n    \n    # Output results\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc302_f", "solution": "import sys\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    sets = []\n    element_to_sets = defaultdict(list)\n    \n    for i in range(N):\n        A = int(data[idx])\n        idx += 1\n        current_set = []\n        for _ in range(A):\n            elem = int(data[idx])\n            idx += 1\n            current_set.append(elem)\n            element_to_sets[elem].append(i)\n        sets.append(current_set)\n    \n    # Initialize Union-Find for N sets\n    uf = UnionFind(N)\n    \n    # For each element, union all sets containing that element\n    for elem, set_list in element_to_sets.items():\n        for i in range(1, len(set_list)):\n            uf.union(set_list[0], set_list[i])\n    \n    # Find which sets contain 1 and M\n    sets_with_1 = element_to_sets.get(1, [])\n    sets_with_M = element_to_sets.get(M, [])\n    \n    if not sets_with_1 or not sets_with_M:\n        print(-1)\n        return\n    \n    # Get the root of components containing 1 and M\n    root_1 = uf.find(sets_with_1[0])\n    root_M = uf.find(sets_with_M[0])\n    \n    # Check if 1 and M are in the same component\n    if root_1 != root_M:\n        print(-1)\n        return\n    \n    # Count how many sets are in the component containing both 1 and M\n    component_size = 0\n    for i in range(N):\n        if uf.find(i) == root_1:\n            component_size += 1\n    \n    # Minimum operations is component_size - 1\n    print(component_size - 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc303_a", "solution": "# Read input\nN = int(input())\nS = input().strip()\nT = input().strip()\n\n# Function to check if two characters are similar\ndef are_similar(c1, c2):\n    if c1 == c2:\n        return True\n    if (c1 == '1' and c2 == 'l') or (c1 == 'l' and c2 == '1'):\n        return True\n    if (c1 == '0' and c2 == 'o') or (c1 == 'o' and c2 == '0'):\n        return True\n    return False\n\n# Check similarity for each position\nis_similar = True\nfor i in range(N):\n    if not are_similar(S[i], T[i]):\n        is_similar = False\n        break\n\n# Output result\nif is_similar:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc303_b", "solution": "# Read input\nN, M = map(int, input().split())\nphotos = []\nfor _ in range(M):\n    photo = list(map(int, input().split()))\n    photos.append(photo)\n\n# Set to store all pairs that are adjacent in at least one photo\nadjacent_pairs = set()\n\n# Process each photo to find adjacent pairs\nfor photo in photos:\n    for i in range(N - 1):\n        # Get the pair and create an unordered representation (sorted tuple)\n        a, b = photo[i], photo[i + 1]\n        pair = (min(a, b), max(a, b))\n        adjacent_pairs.add(pair)\n\n# Calculate total possible pairs\ntotal_pairs = N * (N - 1) // 2\n\n# The pairs that may be in a bad mood are those NOT in adjacent_pairs\nbad_mood_pairs = total_pairs - len(adjacent_pairs)\n\n# Output the result\nprint(bad_mood_pairs)"}
{"task_id": "abc303_c", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    H = int(data[idx]); idx += 1\n    K = int(data[idx]); idx += 1\n    S = data[idx]; idx += 1\n    \n    items = set()\n    for _ in range(M):\n        x = int(data[idx]); idx += 1\n        y = int(data[idx]); idx += 1\n        items.add((x, y))\n    \n    # Directions mapping\n    directions = {\n        'R': (1, 0),\n        'L': (-1, 0),\n        'U': (0, 1),\n        'D': (0, -1)\n    }\n    \n    x, y = 0, 0\n    health = H\n    \n    for move in S:\n        dx, dy = directions[move]\n        x += dx\n        y += dy\n        health -= 1\n        \n        if health < 0:\n            print(\"No\")\n            return\n            \n        # Check for item consumption\n        if (x, y) in items and health < K:\n            health = K\n            items.remove((x, y))  # Item is consumed and removed\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc303_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    X = int(data[0])\n    Y = int(data[1])\n    Z = int(data[2])\n    S = data[3]\n    \n    n = len(S)\n    \n    # dp[i][0] = min cost to type first i chars with caps lock OFF\n    # dp[i][1] = min cost to type first i chars with caps lock ON\n    \n    # Use rolling variables to save space\n    prev_off = 0      # dp[i-1][0]\n    prev_on = Z       # dp[i-1][1], initially we can turn ON caps lock for Z\n    \n    for char in S:\n        curr_off = float('inf')\n        curr_on = float('inf')\n        \n        if char == 'a':\n            # To get 'a' with caps lock OFF: use 'a' key (X)\n            # To get 'a' with caps lock ON: use 'a'+Shift (Y)\n            \n            # Coming from OFF state\n            curr_off = min(curr_off, prev_off + X)\n            curr_on = min(curr_on, prev_off + Z + Y)\n            \n            # Coming from ON state\n            curr_off = min(curr_off, prev_on + Z + X)\n            curr_on = min(curr_on, prev_on + Y)\n        else:  # char == 'A'\n            # To get 'A' with caps lock OFF: use 'a'+Shift (Y)\n            # To get 'A' with caps lock ON: use 'a' key (X)\n            \n            # Coming from OFF state\n            curr_off = min(curr_off, prev_off + Y)\n            curr_on = min(curr_on, prev_off + Z + X)\n            \n            # Coming from ON state\n            curr_off = min(curr_off, prev_on + Z + Y)\n            curr_on = min(curr_on, prev_on + X)\n            \n        prev_off = curr_off\n        prev_on = curr_on\n        \n    print(min(prev_off, prev_on))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc303_e", "solution": "import sys\nsys.setrecursionlimit(1 << 25)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n\n    # Build adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Compute degrees\n    degree = [0] * (N + 1)\n    for u in range(1, N + 1):\n        degree[u] = len(adj[u])\n    \n    # Find star centers and their levels\n    star_levels = []\n    for u in range(1, N + 1):\n        if degree[u] >= 2:\n            leaf_neighbors = 0\n            for neighbor in adj[u]:\n                if degree[neighbor] == 1:\n                    leaf_neighbors += 1\n            if leaf_neighbors == 1:\n                star_levels.append(degree[u])\n    \n    # Sort and print result\n    star_levels.sort()\n    print(' '.join(map(str, star_levels)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc304_a", "solution": "# Read the number of people\nN = int(input())\n\n# Lists to store names and ages\nnames = []\nages = []\n\n# Read each person's name and age\nfor _ in range(N):\n    line = input().split()\n    name = line[0]\n    age = int(line[1])\n    names.append(name)\n    ages.append(age)\n\n# Find the index of the youngest person\nmin_age = min(ages)\nstart_index = ages.index(min_age)\n\n# Print names starting from the youngest person's position, going clockwise\nfor i in range(N):\n    current_index = (start_index + i) % N\n    print(names[current_index])"}
{"task_id": "abc304_b", "solution": "# Read input\nN = int(input())\n\n# Determine the approximation based on rules\nif N <= 999:\n    result = N\nelif N <= 9999:\n    # Truncate 1 digit (ones place)\n    result = (N // 10) * 10\nelif N <= 99999:\n    # Truncate 2 digits (tens & ones)\n    result = (N // 100) * 100\nelif N <= 999999:\n    # Truncate 3 digits (hundreds & below)\n    result = (N // 1000) * 1000\nelif N <= 9999999:\n    # Truncate 4 digits (thousands & below)\n    result = (N // 10000) * 10000\nelif N <= 99999999:\n    # Truncate 5 digits (ten-thousands & below)\n    result = (N // 100000) * 100000\nelse:\n    # N is between 100000000 and 999999999 inclusive\n    # Truncate 6 digits (hundred-thousands & below)\n    result = (N // 1000000) * 1000000\n\n# Output the result\nprint(result)"}
{"task_id": "abc304_c", "solution": "import math\nfrom collections import deque\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n# Read input\nN, D = map(int, input().split())\npeople = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    people.append((x, y))\n\n# Track infection status (0-indexed)\ninfected = [False] * N\ninfected[0] = True  # Person 1 (index 0) is initially infected\n\n# Use BFS to spread the infection\nqueue = deque([0])  # Start with person 1 (index 0)\n\nwhile queue:\n    current_person = queue.popleft()\n    current_position = people[current_person]\n    \n    # Check all other people\n    for i in range(N):\n        if not infected[i]:  # If person i is not yet infected\n            # Calculate distance to current infected person\n            distance = euclidean_distance(current_position, people[i])\n            \n            # If within infection range\n            if distance <= D:\n                infected[i] = True\n                queue.append(i)\n\n# Output results\nfor i in range(N):\n    if infected[i]:\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"task_id": "abc304_d", "solution": "import bisect\nfrom collections import defaultdict\n\n# Read input\nW, H = map(int, input().split())\nN = int(input())\nstrawberries = []\nfor _ in range(N):\n    p, q = map(int, input().split())\n    strawberries.append((p, q))\n\nA = int(input())\na_cuts = list(map(int, input().split()))\n\nB = int(input())\nb_cuts = list(map(int, input().split()))\n\n# Prepare the boundaries for x and y intervals\n# Add 0 at beginning and W at end for vertical boundaries\nx_boundaries = [0] + a_cuts + [W]\n# Add 0 at beginning and H at end for horizontal boundaries\ny_boundaries = [0] + b_cuts + [H]\n\n# Dictionary to store count of strawberries in each cell\ncell_count = defaultdict(int)\n\n# Process each strawberry\nfor p, q in strawberries:\n    # Find which x-segment the strawberry is in\n    x_idx = bisect.bisect_right(x_boundaries, p) - 1\n    # Find which y-segment the strawberry is in\n    y_idx = bisect.bisect_right(y_boundaries, q) - 1\n    \n    # Increment the count for this cell\n    cell_count[(x_idx, y_idx)] += 1\n\n# Total number of cells\ntotal_cells = (A + 1) * (B + 1)\n\n# Get all the counts of strawberries in occupied cells\ncounts = list(cell_count.values())\n\n# If we have fewer occupied cells than total cells, there's at least one empty cell\nif len(counts) < total_cells:\n    min_strawberries = 0\nelse:\n    min_strawberries = min(counts)\n\nmax_strawberries = max(counts) if counts else 0\n\nprint(min_strawberries, max_strawberries)"}
{"task_id": "abc304_e", "solution": "import sys\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        # Union by rank\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    # Initialize Union-Find\n    uf = UnionFind(N + 1)  # Vertices are 1-indexed\n    \n    # Process edges\n    for _ in range(M):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        uf.union(u, v)\n    \n    # Read K\n    K = int(data[idx])\n    idx += 1\n    \n    # Process forbidden pairs\n    forbidden_components = defaultdict(int)\n    for _ in range(K):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        cx = uf.find(x)\n        cy = uf.find(y)\n        # Store unordered pair\n        if cx > cy:\n            cx, cy = cy, cx\n        forbidden_components[(cx, cy)] += 1\n    \n    # Read Q\n    Q = int(data[idx])\n    idx += 1\n    \n    # Process queries\n    results = []\n    for _ in range(Q):\n        p = int(data[idx])\n        idx += 1\n        q = int(data[idx])\n        idx += 1\n        cp = uf.find(p)\n        cq = uf.find(q)\n        # Check unordered pair\n        if cp > cq:\n            cp, cq = cq, cp\n        if (cp, cq) in forbidden_components:\n            results.append(\"No\")\n        else:\n            results.append(\"Yes\")\n    \n    # Output results\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc305_a", "solution": "# Read input\nN = int(input())\n\n# Compute the nearest water station\n# Water stations are at multiples of 5: 0, 5, 10, ..., 100\n\n# Get the largest multiple of 5 <= N\nlower_station = (N // 5) * 5\n\n# Get the smallest multiple of 5 >= N\nupper_station = lower_station + 5\n\n# Clamp upper station to maximum allowed value (100)\nif upper_station > 100:\n    upper_station = 100\n\n# Calculate distances\ndistance_to_lower = N - lower_station\ndistance_to_upper = upper_station - N\n\n# Choose the nearest station\nif distance_to_lower < distance_to_upper:\n    result = lower_station\nelif distance_to_upper < distance_to_lower:\n    result = upper_station\nelse:\n    # As per problem statement, nearest station is unique, so this case won't occur\n    # But just in case, we pick one (e.g., the lower one)\n    result = lower_station\n\nprint(result)"}
{"task_id": "abc305_b", "solution": "# Read input\np, q = input().split()\n\n# Precomputed cumulative distances from point A\ncumulative_distances = {\n    'A': 0,\n    'B': 3,\n    'C': 4,\n    'D': 8,\n    'E': 9,\n    'F': 14,\n    'G': 23\n}\n\n# Calculate the distance between p and q\ndistance = abs(cumulative_distances[p] - cumulative_distances[q])\n\n# Output the result\nprint(distance)"}
{"task_id": "abc305_c", "solution": "# Read input\nH, W = map(int, input().split())\ngrid = [input() for _ in range(H)]\n\n# Find the bounding box of all '#' characters\nmin_row, max_row = H, -1\nmin_col, max_col = W, -1\n\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j] == '#':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\n# Now search within the bounding box for the '.' which indicates the eaten cookie\nfor i in range(min_row, max_row + 1):\n    for j in range(min_col, max_col + 1):\n        if grid[i][j] == '.':\n            # Found the position of the eaten cookie\n            # Output in 1-indexed format\n            print(i + 1, j + 1)"}
{"task_id": "abc305_d", "solution": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    A = list(map(int, data[idx:idx+N]))\n    idx += N\n    Q = int(data[idx])\n    idx += 1\n    \n    # Precompute the breakpoints and prefix sleep sums\n    breakpoints = []\n    prefix_sleep = []\n    sleep_so_far = 0\n    \n    # Process A[1] through A[N-1]\n    for i in range(1, N):\n        if i % 2 == 0:  # Even index (1-based sleep end)\n            sleep_so_far += A[i] - A[i-1]\n        breakpoints.append(A[i])\n        prefix_sleep.append(sleep_so_far)\n    \n    # Function to compute SleepUpTo(x)\n    def sleep_up_to(x):\n        if x <= 0:\n            return 0\n        # Find rightmost breakpoint <= x\n        pos = bisect.bisect_right(breakpoints, x) - 1\n        if pos < 0:\n            return 0\n        base_sleep = prefix_sleep[pos]\n        # Check if there's additional partial sleep from breakpoints[pos] to x\n        # This happens if the next interval (after pos) is a sleep interval\n        # Which means pos+1 corresponds to an odd index in original A (1-based)\n        if pos + 1 < len(breakpoints):\n            next_index_in_A = pos + 2  # Because breakpoints start from A[1]\n            if next_index_in_A % 2 == 1:  # Next interval starts sleep\n                # Person is sleeping from breakpoints[pos] to x\n                base_sleep += x - breakpoints[pos]\n        elif pos + 1 == len(breakpoints):\n            # x is beyond all breakpoints, so no more sleep\n            pass\n        else:\n            # x is beyond all, no extra sleep\n            pass\n            \n        # Actually, let's rethink this logic more clearly\n        \n        # Simpler way:\n        # After processing up to breakpoints[pos], we have 'base_sleep'\n        # Now see if there's additional sleep from breakpoints[pos] to x\n        # That depends on whether we're currently in a sleep interval\n        \n        # Index in original A array corresponding to breakpoints[pos] is pos + 1\n        # If that index is even, it means we just ended a sleep period\n        # If that index is odd, it means we just started a sleep period and are still sleeping\n        \n        index_in_A = pos + 1  # Since breakpoints start at A[1]\n        \n        if index_in_A % 2 == 1:  # Started sleep, still sleeping until next breakpoint\n            base_sleep += x - breakpoints[pos]\n            \n        return base_sleep\n    \n    results = []\n    for _ in range(Q):\n        l = int(data[idx])\n        idx += 1\n        r = int(data[idx])\n        idx += 1\n        res = sleep_up_to(r) - sleep_up_to(l)\n        results.append(str(res))\n        \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc305_e", "solution": "from collections import deque, defaultdict\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    K = int(data[idx]); idx += 1\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Read guards info\n    guards = []\n    for _ in range(K):\n        p = int(data[idx]); idx += 1\n        h = int(data[idx]); idx += 1\n        guards.append((p, h))\n    \n    # Multi-source BFS\n    # Queue elements: (vertex, distance_from_source, max_distance_allowed)\n    queue = deque()\n    # Distance array: dist[v] = minimum distance to any guard\n    dist = [-1] * (N + 1)\n    \n    # Initialize queue with all guards\n    for p, h in guards:\n        queue.append((p, 0, h))\n        dist[p] = 0\n    \n    guarded_vertices = set()\n    \n    while queue:\n        u, d, max_d = queue.popleft()\n        guarded_vertices.add(u)\n        \n        # If we've reached maximum allowed distance, don't explore further\n        if d >= max_d:\n            continue\n            \n        # Explore neighbors\n        for v in adj[u]:\n            # If not visited yet, or can be reached with shorter distance\n            if dist[v] == -1 or dist[v] > d + 1:\n                dist[v] = d + 1\n                # Find which guard this path originated from\n                queue.append((v, d + 1, max_d))\n    \n    # Convert to sorted list\n    result = sorted(list(guarded_vertices))\n    \n    # Output\n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_a", "solution": "# Read the input\nN = int(input())\nS = input()\n\n# Create the result string by duplicating each character\nresult = \"\"\nfor char in S:\n    result += char * 2\n\n# Print the result\nprint(result)"}
{"task_id": "abc306_b", "solution": "# Read the input line and split into individual bits\nbits = list(map(int, input().split()))\n\n# Calculate the decimal value from the binary representation\n# A_0 is the least significant bit (2^0), so we process from index 0 upwards\nresult = 0\nfor i in range(64):\n    if bits[i] == 1:\n        result += (1 << i)  # Using bit shifting for efficiency (equivalent to 2**i)\n\nprint(result)"}
{"task_id": "abc306_c", "solution": "# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# We'll use a dictionary to count occurrences and track the middle index\ncount = [0] * (N + 1)  # count[i] will store how many times number i has appeared\nf_values = [0] * (N + 1)  # f_values[i] will store the middle occurrence index of number i\n\n# Traverse the sequence to find f(i) for each number i\nfor idx in range(3 * N):\n    num = A[idx]\n    count[num] += 1\n    if count[num] == 2:  # This is the middle (second) occurrence\n        f_values[num] = idx + 1  # Convert to 1-based indexing\n\n# Create a list of (f_value, number) pairs and sort by f_value\npairs = [(f_values[i], i) for i in range(1, N + 1)]\npairs.sort()\n\n# Extract the numbers in the sorted order\nresult = [str(pair[1]) for pair in pairs]\n\n# Print the result\nprint(' '.join(result))"}
{"task_id": "abc306_d", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    courses = []\n    index = 1\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index+1])\n        courses.append((x, y))\n        index += 2\n    \n    # dp states: best_tastiness when finishing at healthy(0) or upset(1) stomach\n    # Initialize: start with healthy stomach and 0 tastiness\n    best_healthy = 0\n    best_upset = float('-inf')\n    \n    for i in range(N):\n        x, y = courses[i]\n        new_healthy = float('-inf')\n        new_upset = float('-inf')\n        \n        # From healthy state\n        if best_healthy != float('-inf'):\n            # Option 1: Skip\n            new_healthy = max(new_healthy, best_healthy)\n            \n            # Option 2: Eat\n            if x == 0:  # Antidote\n                # Healthy + Antidote -> Healthy\n                new_healthy = max(new_healthy, best_healthy + y)\n            else:  # Poison\n                # Healthy + Poison -> Upset\n                new_upset = max(new_upset, best_healthy + y)\n        \n        # From upset state\n        if best_upset != float('-inf'):\n            # Option 1: Skip\n            new_upset = max(new_upset, best_upset)\n            \n            # Option 2: Eat\n            if x == 0:  # Antidote\n                # Upset + Antidote -> Healthy\n                new_healthy = max(new_healthy, best_upset + y)\n            # If x == 1 (poison), then Upset + Poison -> Death (invalid)\n        \n        best_healthy = new_healthy\n        best_upset = new_upset\n    \n    # Answer is the maximum of both states (as long as it's not -inf)\n    result = max(best_healthy, best_upset) if max(best_healthy, best_upset) != float('-inf') else 0\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_e", "solution": "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    Q = int(data[2])\n    \n    # Initialize the array A with all zeros\n    A = [0] * (N + 1)  # 1-indexed\n    \n    # Initialize a SortedList to maintain the values\n    sl = SortedList()\n    \n    # Add initial N zeros to the sorted list\n    for _ in range(N):\n        sl.add(0)\n    \n    idx = 3\n    results = []\n    \n    for _ in range(Q):\n        X = int(data[idx])\n        Y = int(data[idx+1])\n        idx += 2\n        \n        # Remove the old value from the sorted list\n        old_val = A[X]\n        sl.remove(old_val)\n        \n        # Update the array\n        A[X] = Y\n        \n        # Add the new value to the sorted list\n        sl.add(Y)\n        \n        # Calculate the sum of the top K elements\n        # These are the last K elements in the sorted list\n        top_k_sum = sum(sl[-K:])\n        results.append(str(top_k_sum))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc307_a", "solution": "# Read number of weeks\nN = int(input())\n\n# Read all step counts\nsteps = list(map(int, input().split()))\n\n# Calculate and store the total steps for each week\nweekly_totals = []\nfor i in range(N):\n    # Extract the steps for the i-th week (7 days)\n    week_steps = steps[7 * i : 7 * (i + 1)]\n    # Compute the sum for the week\n    total = sum(week_steps)\n    weekly_totals.append(total)\n\n# Print the result separated by spaces\nprint(' '.join(map(str, weekly_totals)))"}
{"task_id": "abc307_b", "solution": "def is_palindrome_concat(s1, s2):\n    # Simulate concatenation of s1 + s2 and check if it's a palindrome\n    len1 = len(s1)\n    len2 = len(s2)\n    total_len = len1 + len2\n    \n    # Check if the concatenated string is a palindrome\n    for i in range(total_len // 2):\n        # Get character from left side\n        if i < len1:\n            left_char = s1[i]\n        else:\n            left_char = s2[i - len1]\n            \n        # Get character from right side\n        right_pos = total_len - 1 - i\n        if right_pos < len1:\n            right_char = s1[right_pos]\n        else:\n            right_char = s2[right_pos - len1]\n            \n        if left_char != right_char:\n            return False\n            \n    return True\n\n# Read input\nn = int(input())\nstrings = []\nfor _ in range(n):\n    strings.append(input().strip())\n\n# Check all pairs (i, j) where i != j\nfound = False\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            if is_palindrome_concat(strings[i], strings[j]):\n                found = True\n                break\n    if found:\n        break\n\n# Output result\nif found:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc307_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    \n    # Read Sheet A\n    H_A = int(data[idx])\n    W_A = int(data[idx+1])\n    idx += 2\n    A = data[idx:idx+H_A]\n    idx += H_A\n    \n    # Read Sheet B\n    H_B = int(data[idx])\n    W_B = int(data[idx+1])\n    idx += 2\n    B = data[idx:idx+H_B]\n    idx += H_B\n    \n    # Read Sheet X\n    H_X = int(data[idx])\n    W_X = int(data[idx+1])\n    idx += 2\n    X = data[idx:idx+H_X]\n    idx += H_X\n\n    # Get all black squares in A and B with their relative coordinates\n    def get_black_coords(sheet, h, w):\n        coords = set()\n        for i in range(h):\n            for j in range(w):\n                if sheet[i][j] == '#':\n                    coords.add((i, j))\n        return coords\n\n    black_A = get_black_coords(A, H_A, W_A)\n    black_B = get_black_coords(B, H_B, W_B)\n\n    # Try all relative positions of B with respect to A within a reasonable range\n    # Since max dimension is 10, and we might offset up to ~10 in either direction,\n    # trying -20 to +20 should be safe.\n    OFFSET_RANGE = 30\n    for di in range(-OFFSET_RANGE, OFFSET_RANGE + 1):\n        for dj in range(-OFFSET_RANGE, OFFSET_RANGE + 1):\n            # Position B at (di, dj) relative to A's (0,0)\n            black_combined = set()\n            black_combined.update(black_A)\n            for (bi, bj) in black_B:\n                black_combined.add((bi + di, bj + dj))\n            \n            if not black_combined:\n                continue\n            \n            # Determine bounding box of combined black squares\n            min_i = min(pos[0] for pos in black_combined)\n            max_i = max(pos[0] for pos in black_combined)\n            min_j = min(pos[1] for pos in black_combined)\n            max_j = max(pos[1] for pos in black_combined)\n\n            # Now try placing the H_X x W_X window such that it covers all black squares\n            # The window's top-left can range so that the window covers the bounding box\n            for wi in range(min_i - H_X + 1, max_i + 1):\n                for wj in range(min_j - W_X + 1, max_j + 1):\n                    # Window is [wi, wi+H_X) x [wj, wj+W_X)\n                    # Check if all black squares are inside this window\n                    valid_window = True\n                    for (ci, cj) in black_combined:\n                        if not (wi <= ci < wi + H_X and wj <= cj < wj + W_X):\n                            valid_window = False\n                            break\n                    if not valid_window:\n                        continue\n                    \n                    # Now build the pattern in the window and compare with X\n                    pattern = set()\n                    for (ci, cj) in black_combined:\n                        pattern.add((ci - wi, cj - wj))\n                    \n                    # Compare with X\n                    match = True\n                    for i in range(H_X):\n                        for j in range(W_X):\n                            is_black = (i, j) in pattern\n                            expected_char = X[i][j]\n                            actual_char = '#' if is_black else '.'\n                            if actual_char != expected_char:\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if match:\n                        print(\"Yes\")\n                        return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc307_d", "solution": "n = int(input())\ns = input().strip()\n\nstack = []\n\nfor char in s:\n    stack.append(char)\n    \n    # While the last character is ')', try to find a matching '('\n    while len(stack) >= 2 and stack[-1] == ')':\n        # Look for the matching '(' backwards\n        # We need to ensure there are no '(' or ')' between them\n        found = False\n        for i in range(len(stack) - 2, -1, -1):  # Start from second last element\n            if stack[i] == '(':\n                # Check if everything between i and end is free of parentheses\n                valid = True\n                for j in range(i + 1, len(stack) - 1):\n                    if stack[j] in '()':\n                        valid = False\n                        break\n                if valid:\n                    # Remove the substring from i to end (inclusive)\n                    stack = stack[:i]\n                    found = True\n                    break\n                else:\n                    # Not a valid segment, continue looking\n                    continue\n            elif stack[i] == ')':\n                # Found a ')' before '(' - invalidates current segment\n                break\n        \n        if not found:\n            # No valid matching found, stop trying\n            break\n\nprint(''.join(stack))"}
{"task_id": "abc307_e", "solution": "def mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = result * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return result\n\ndef main():\n    MOD = 998244353\n    \n    # Read input\n    N, M = map(int, input().split())\n    \n    # Special cases\n    if N == 1:\n        print(M % MOD)\n        return\n    \n    if M == 1 and N >= 2:\n        print(0)\n        return\n    \n    # Calculate (M-1)^N mod MOD\n    base = M - 1\n    power_n = mod_pow(base, N, MOD)\n    \n    # Calculate (-1)^N * (M-1)\n    if N % 2 == 0:\n        correction = base % MOD\n    else:\n        correction = (-base) % MOD\n    \n    # Final result\n    result = (power_n + correction) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc308_a", "solution": "# Read input\nnumbers = list(map(int, input().split()))\n\n# Check all three conditions\nis_non_decreasing = all(numbers[i] <= numbers[i+1] for i in range(7))\nis_in_range = all(100 <= num <= 675 for num in numbers)\nis_multiple_of_25 = all(num % 25 == 0 for num in numbers)\n\n# Print result\nif is_non_decreasing and is_in_range and is_multiple_of_25:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc308_b", "solution": "# Read input\nN, M = map(int, input().split())\nC = input().split()  # Plate colors\nD = input().split()  # Special colors\nP = list(map(int, input().split()))  # Prices [P0, P1, ..., PM]\n\n# Create a mapping from special colors to their prices\n# D[i-1] maps to P[i] for i=1 to M (since P0 is the default price)\ncolor_to_price = {}\nfor i in range(M):\n    color_to_price[D[i]] = P[i + 1]\n\n# Calculate total price\ntotal = 0\nfor color in C:\n    if color in color_to_price:\n        total += color_to_price[color]\n    else:\n        total += P[0]  # Default price\n\n# Output the result\nprint(total)"}
{"task_id": "abc308_c", "solution": "import sys\nfrom functools import cmp_to_key\n\ndef compare(person1, person2):\n    # person1 = (index1, a1, b1)\n    # person2 = (index2, a2, b2)\n    i1, a1, b1 = person1\n    i2, a2, b2 = person2\n    \n    # Compare a1/b1 vs a2/b2\n    # Cross multiply: a1*b2 vs a2*b1\n    left = a1 * b2\n    right = a2 * b1\n    \n    if left > right:\n        return -1  # person1 comes first (higher success rate)\n    elif left < right:\n        return 1   # person2 comes first (higher success rate)\n    else:\n        # Tie in success rate, compare by index\n        if i1 < i2:\n            return -1  # person1 comes first (lower index)\n        elif i1 > i2:\n            return 1   # person2 comes first (lower index)\n        else:\n            return 0\n\n# Read input\nN = int(sys.stdin.readline())\npeople = []\n\nfor i in range(N):\n    a, b = map(int, sys.stdin.readline().split())\n    people.append((i+1, a, b))\n\n# Sort using custom comparator\npeople.sort(key=cmp_to_key(compare))\n\n# Output result\nresult = [str(person[0]) for person in people]\nprint(' '.join(result))"}
{"task_id": "abc308_d", "solution": "from collections import deque\n\ndef solve():\n    # Read input\n    H, W = map(int, input().split())\n    grid = []\n    for _ in range(H):\n        grid.append(input().strip())\n    \n    # Define the target sequence and its length\n    snuke = \"snuke\"\n    seq_len = len(snuke)\n    \n    # Starting position (0-indexed)\n    start_row, start_col = 0, 0\n    end_row, end_col = H - 1, W - 1\n    \n    # Check if starting cell has the correct character\n    if grid[start_row][start_col] != snuke[0]:\n        print(\"No\")\n        return\n    \n    # BFS setup\n    # State: (row, col, expected_char_index)\n    queue = deque([(start_row, start_col, 0)])  # Start with 's' (index 0)\n    visited = [[[False] * seq_len for _ in range(W)] for _ in range(H)]\n    visited[start_row][start_col][0] = True\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        row, col, char_idx = queue.popleft()\n        \n        # If we reached the destination\n        if row == end_row and col == end_col:\n            print(\"Yes\")\n            return\n        \n        # Next expected character index\n        next_char_idx = (char_idx + 1) % seq_len\n        \n        # Explore neighbors\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            # Check bounds\n            if 0 <= new_row < H and 0 <= new_col < W:\n                # Check if the cell has the expected character\n                if grid[new_row][new_col] == snuke[next_char_idx]:\n                    # Check if this state has been visited\n                    if not visited[new_row][new_col][next_char_idx]:\n                        visited[new_row][new_col][next_char_idx] = True\n                        queue.append((new_row, new_col, next_char_idx))\n    \n    print(\"No\")\n\n# Run the solution\nsolve()"}
{"task_id": "abc308_e", "solution": "def mex(a, b, c):\n    s = {a, b, c}\n    for i in range(4):\n        if i not in s:\n            return i\n    return 3\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = data[N+1]\n    \n    # Precompute prefix counts for M positions\n    # m_count[v][i] = number of M positions before index i with A[value] = v\n    m_count = [[0] * (N + 1) for _ in range(3)]\n    \n    for i in range(N):\n        for v in range(3):\n            m_count[v][i+1] = m_count[v][i]\n        if S[i] == 'M':\n            m_count[A[i]][i+1] += 1\n    \n    # Precompute suffix counts for X positions\n    # x_count[v][i] = number of X positions after index i (inclusive) with A[value] = v\n    x_count = [[0] * (N + 1) for _ in range(3)]\n    \n    for i in range(N-1, -1, -1):\n        for v in range(3):\n            x_count[v][i] = x_count[v][i+1]\n        if S[i] == 'X':\n            x_count[A[i]][i] += 1\n    \n    result = 0\n    \n    # For each E position, calculate contribution\n    for j in range(N):\n        if S[j] == 'E':\n            e_val = A[j]\n            # Get counts of each value in M positions before j\n            m_vals = [m_count[v][j] for v in range(3)]\n            # Get counts of each value in X positions after j\n            x_vals = [x_count[v][j+1] for v in range(3)]\n            \n            # Calculate contribution for all combinations\n            for m_val in range(3):\n                for x_val in range(3):\n                    count = m_vals[m_val] * x_vals[x_val]\n                    if count > 0:\n                        current_mex = mex(m_val, e_val, x_val)\n                        result += count * current_mex\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc308_f", "solution": "import bisect\n\ndef main():\n    # Read input\n    N, M = map(int, input().split())\n    P = list(map(int, input().split()))\n    L = list(map(int, input().split()))\n    D = list(map(int, input().split()))\n    \n    # Create list of items (price, index) and sort by price\n    items = [(P[i], i) for i in range(N)]\n    items.sort()\n    \n    # Extract sorted prices for binary search\n    sorted_prices = [item[0] for item in items]\n    \n    # Create list of coupons (discount, threshold, index) and sort by discount descending\n    coupons = [(D[i], L[i], i) for i in range(M)]\n    coupons.sort(reverse=True)\n    \n    # Track which items have been assigned coupons\n    assigned = [False] * N\n    \n    total_cost = 0\n    \n    # Process each coupon in order of decreasing discount value\n    for discount, threshold, coupon_idx in coupons:\n        # Binary search for the first item with price >= threshold\n        pos = bisect.bisect_left(sorted_prices, threshold)\n        \n        # Find the first unassigned item from position pos onwards\n        for i in range(pos, N):\n            price, item_idx = items[i]\n            if not assigned[item_idx]:\n                # Apply coupon to this item\n                total_cost += price - discount\n                assigned[item_idx] = True\n                break\n    \n    # Add prices of all unassigned items\n    for i in range(N):\n        if not assigned[i]:\n            total_cost += P[i]\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_a", "solution": "# Read input\nA, B = map(int, input().split())\n\n# Calculate positions for both numbers\n# For a 3x3 grid with numbers 1-9 arranged as:\n# 1 2 3\n# 4 5 6\n# 7 8 9\nrow_A = (A - 1) // 3\ncol_A = (A - 1) % 3\n\nrow_B = (B - 1) // 3\ncol_B = (B - 1) % 3\n\n# Check if they are adjacent horizontally\n# This means they must be in the same row and columns differ by 1\nif row_A == row_B and abs(col_A - col_B) == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc309_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    grid = []\n    for i in range(1, N+1):\n        row = list(data[i])\n        grid.append([int(x) for x in row])\n    \n    # If N == 1, no shifting needed, but constraint says N >= 2\n    if N == 1:\n        print(grid[0][0])\n        return\n    \n    # Collect values from outer ring in clockwise order\n    values = []\n    # Top row: left to right\n    for j in range(N):\n        values.append(grid[0][j])\n    \n    # Right column: top to bottom (excluding top-right corner)\n    for i in range(1, N):\n        values.append(grid[i][N-1])\n        \n    # Bottom row: right to left (excluding bottom-right corner)\n    for j in range(N-2, -1, -1):\n        values.append(grid[N-1][j])\n        \n    # Left column: bottom to top (excluding bottom-left and top-left corners)\n    for i in range(N-2, 0, -1):\n        values.append(grid[i][0])\n    \n    # Perform clockwise shift by moving last element to front\n    if len(values) > 0:\n        shifted_values = [values[-1]] + values[:-1]\n    else:\n        shifted_values = values\n    \n    # Place back the shifted values\n    idx = 0\n    \n    # Top row: left to right\n    for j in range(N):\n        grid[0][j] = shifted_values[idx]\n        idx += 1\n        \n    # Right column: top to bottom (excluding top-right corner)\n    for i in range(1, N):\n        grid[i][N-1] = shifted_values[idx]\n        idx += 1\n        \n    # Bottom row: right to left (excluding bottom-right corner)\n    for j in range(N-2, -1, -1):\n        grid[N-1][j] = shifted_values[idx]\n        idx += 1\n        \n    # Left column: bottom to top (excluding bottom-left and top-left corners)\n    for i in range(N-2, 0, -1):\n        grid[i][0] = shifted_values[idx]\n        idx += 1\n    \n    # Print the result\n    for row in grid:\n        print(''.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_c", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    # Read medicine data\n    medicines = []\n    idx = 2\n    total_pills_day1 = 0\n    \n    events = defaultdict(int)  # day -> reduction in pills\n    \n    for _ in range(N):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        total_pills_day1 += b\n        # Medicine stops after day a, so reduction starts at day a+1\n        events[a + 1] += b\n    \n    # If already satisfied on day 1\n    if total_pills_day1 <= K:\n        print(1)\n        return\n    \n    # Convert events to sorted list of (day, reduction)\n    sorted_events = sorted(events.items())\n    \n    current_total = total_pills_day1\n    for day, reduction in sorted_events:\n        current_total -= reduction\n        if current_total <= K:\n            print(day)\n            return\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_d", "solution": "from collections import deque, defaultdict\nimport sys\n\ndef bfs_distances(graph, start, vertices):\n    \"\"\"BFS to compute distances from start to all vertices in the component\"\"\"\n    distances = {v: -1 for v in vertices}\n    distances[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:  # Not visited\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n    \n    return distances\n\ndef main():\n    # Read input\n    line = input().split()\n    N1, N2, M = int(line[0]), int(line[1]), int(line[2])\n    \n    # Build adjacency list representation of the graph\n    graph = defaultdict(list)\n    \n    for _ in range(M):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Create vertex sets for each component\n    component1 = set(range(1, N1 + 1))\n    component2 = set(range(N1 + 1, N1 + N2 + 1))\n    \n    # BFS from vertex 1 in component 1\n    distances1 = bfs_distances(graph, 1, component1)\n    \n    # BFS from vertex (N1+N2) in component 2\n    distances2 = bfs_distances(graph, N1 + N2, component2)\n    \n    # Find maximum distances in each component\n    max_dist1 = max(distances1.values())\n    max_dist2 = max(distances2.values())\n    \n    # The answer is the sum of max distances plus 1 for the added edge\n    result = max_dist1 + 1 + max_dist2\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_e", "solution": "import sys\nfrom collections import deque\nsys.setrecursionlimit(1 << 25)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    # Parents array (1-indexed)\n    parents = [0] * (N + 1)\n    for i in range(2, N + 1):\n        parents[i] = int(data[idx])\n        idx += 1\n        \n    # Build children list\n    children = [[] for _ in range(N + 1)]\n    for i in range(2, N + 1):\n        p = parents[i]\n        children[p].append(i)\n        \n    # Insurance policies\n    insurances = []\n    for _ in range(M):\n        x = int(data[idx])\n        idx += 1\n        y = int(data[idx])\n        idx += 1\n        insurances.append((x, y))\n        \n    # Calculate depth of each node using BFS\n    depth = [0] * (N + 1)\n    queue = deque([1])\n    depth[1] = 0\n    while queue:\n        u = queue.popleft()\n        for v in children[u]:\n            depth[v] = depth[u] + 1\n            queue.append(v)\n            \n    # max_coverage_depth[u] = max(y_i) among all insurances (x_i, y_i) where x_i == u\n    max_coverage_depth = [0] * (N + 1)\n    for x, y in insurances:\n        max_coverage_depth[x] = max(max_coverage_depth[x], y)\n        \n    # Propagate coverage down the tree and count covered nodes\n    count = 0\n    # Stack elements: (node, effective_coverage_from_ancestor_insurance)\n    stack = [(1, -1)]  # Start with node 1, no initial coverage\n    \n    while stack:\n        u, effective_from_parent = stack.pop()\n        # Effective coverage at node u is max of:\n        # 1. What we inherit from parent (effective_from_parent - 1)\n        # 2. Direct insurance at u (max_coverage_depth[u])\n        effective = max((effective_from_parent - 1) if effective_from_parent != -1 else -1, \n                        max_coverage_depth[u])\n        \n        # If effective coverage >= 0, then this node is covered\n        if effective >= 0:\n            count += 1\n            \n        # Push children to stack with updated effective coverage\n        for v in children[u]:\n            stack.append((v, effective))\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_a", "solution": "# Read input\nN, P, Q = map(int, input().split())\nD = list(map(int, input().split()))\n\n# Find the minimum dish price\nmin_dish_price = min(D)\n\n# Calculate the two possible costs\ncost_without_coupon = P\ncost_with_coupon = Q + min_dish_price\n\n# Print the minimum of the two\nprint(min(cost_without_coupon, cost_with_coupon))"}
{"task_id": "abc310_b", "solution": "def main():\n    # Read N and M\n    N, M = map(int, input().split())\n    \n    # Store product information\n    products = []\n    \n    # Read product data\n    for _ in range(N):\n        line = list(map(int, input().split()))\n        price = line[0]\n        count = line[1]\n        functions = set(line[2:2+count])  # Store as set for efficient operations\n        products.append((price, functions))\n    \n    # Check all pairs of products\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n                \n            price_i, functions_i = products[i]\n            price_j, functions_j = products[j]\n            \n            # Check if j is strictly superior to i\n            # Condition 1: Price of i >= Price of j\n            if price_i < price_j:\n                continue\n            \n            # Condition 2: All functions of i are present in j\n            # In other words, functions_i is a subset of functions_j\n            if not functions_i.issubset(functions_j):\n                continue\n            \n            # Condition 3: Either P_i > P_j OR j has more functions than i\n            if price_i > price_j or len(functions_j) > len(functions_i):\n                print(\"Yes\")\n                return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_c", "solution": "# Read the number of sticks\nn = int(input())\n\n# Set to store unique canonical forms\nunique_sticks = set()\n\n# Process each stick\nfor _ in range(n):\n    s = input().strip()\n    # Compute the canonical form as the lexicographically smaller between s and its reverse\n    reversed_s = s[::-1]\n    canonical_form = min(s, reversed_s)\n    unique_sticks.add(canonical_form)\n\n# Output the number of unique sticks\nprint(len(unique_sticks))"}
{"task_id": "abc310_d", "solution": "from itertools import product\n\ndef main():\n    # Read input\n    N, T, M = map(int, input().split())\n    \n    # Read incompatible pairs\n    incompatible = []\n    for _ in range(M):\n        a, b = map(int, input().split())\n        incompatible.append((a-1, b-1))  # Convert to 0-indexed\n    \n    # If T > N, impossible to have exactly T non-empty teams\n    if T > N:\n        print(0)\n        return\n    \n    count = 0\n    \n    # Try all possible assignments of players to teams (0 to T-1)\n    # Each assignment is represented as a tuple of team numbers\n    for assignment in product(range(T), repeat=N):\n        # Check if all T teams are used (no team is empty)\n        if len(set(assignment)) < T:\n            continue\n            \n        # Check if any incompatible pair is assigned to the same team\n        valid = True\n        for a, b in incompatible:\n            if assignment[a] == assignment[b]:\n                valid = False\n                break\n                \n        if valid:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_e", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    \n    # Convert string to list of integers\n    A = [int(c) for c in S]\n    \n    # Initialize counters\n    count_0 = 0  # Number of f(i,j-1) = 0\n    count_1 = 0  # Number of f(i,j-1) = 1\n    total_sum = 0\n    \n    for j in range(N):\n        if A[j] == 0:\n            # f(i,j) = f(i,j-1) NAND 0 = 1 for all i <= j\n            # Add contribution to sum\n            total_sum += count_0 + count_1  # All previous f(i,j-1) become 1\n            \n            # Update counts\n            # f(j,j) = A[j] = 0, so we have one more 0\n            # All f(i,j) for i < j are 1, f(j,j) = 0\n            new_count_0 = 1  # Just f(j,j)\n            new_count_1 = count_0 + count_1  # All previous become 1\n            count_0, count_1 = new_count_0, new_count_1\n        else:  # A[j] == 1\n            # f(i,j) = f(i,j-1) NAND 1\n            # If f(i,j-1) = 0, then f(i,j) = 1\n            # If f(i,j-1) = 1, then f(i,j) = 0\n            # f(j,j) = A[j] = 1\n            \n            # Add contribution to sum\n            total_sum += count_0 * 1 + count_1 * 0 + 1  # Last +1 for f(j,j) = 1\n            \n            # Update counts\n            # Those that were 0 become 1, those that were 1 become 0\n            # Plus f(j,j) = 1\n            new_count_0 = count_1  # Those that were 1 now become 0\n            new_count_1 = count_0 + 1  # Those that were 0 now become 1, plus f(j,j) = 1\n            count_0, count_1 = new_count_0, new_count_1\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_f", "solution": "def modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    MOD = 998244353\n    \n    # Read input\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # dp[s] will store the number of ways to get subset sum s\n    # Indexes from 0 to 10 (since we're looking for sum = 10)\n    dp = [0] * 11\n    dp[0] = 1  # One way to make sum 0 (select nothing)\n    \n    # Process each die\n    for i in range(N):\n        # Create a new DP array for this step\n        ndp = [0] * 11\n        \n        # For each possible sum so far\n        for s in range(11):\n            if dp[s] == 0:\n                continue\n                \n            # For each possible value this die can show (1 to A[i])\n            # But we only care about contributing to sums <= 10\n            max_val = min(A[i], 10 - s)\n            if max_val <= 0:\n                continue\n                \n            # Add dp[s] to ndp[s+1], ndp[s+2], ..., ndp[s+max_val]\n            # This is equivalent to: for v in 1..max_val: ndp[s+v] += dp[s]\n            for v in range(1, max_val + 1):\n                ndp[s + v] = (ndp[s + v] + dp[s]) % MOD\n            \n            # Also account for not using this die in our subset\n            # In that case, just carry forward the count\n            ndp[s] = (ndp[s] + dp[s]) % MOD\n            \n        dp = ndp\n    \n    # Calculate total possible outcomes\n    total = 1\n    for a in A:\n        total = (total * a) % MOD\n    \n    # Get the number of favorable outcomes (where subset sum = 10)\n    favorable = dp[10]\n    \n    # Calculate probability as (favorable / total) mod MOD\n    result = (favorable * modinv(total, MOD)) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc311_a", "solution": "# Read input\nN = int(input())\nS = input().strip()\n\n# Set to keep track of seen characters\nseen = set()\n\n# Iterate over the string\nfor i in range(N):\n    # Add current character to the set\n    seen.add(S[i])\n    \n    # Check if we have seen all three characters\n    if len(seen) == 3:\n        # Return the number of characters checked (1-indexed)\n        print(i + 1)\n        break"}
{"task_id": "abc311_b", "solution": "# Read input\nN, D = map(int, input().split())\nschedules = []\nfor _ in range(N):\n    schedules.append(input().strip())\n\n# Create an array to track if all people are free on each day\nall_free = [True] * D\n\n# Check each day to see if all people are free\nfor day in range(D):\n    for person in range(N):\n        if schedules[person][day] == 'x':\n            all_free[day] = False\n            break  # No need to check other people for this day\n\n# Find the maximum consecutive sequence of days where all are free\nmax_consecutive = 0\ncurrent_streak = 0\n\nfor day in range(D):\n    if all_free[day]:\n        current_streak += 1\n        max_consecutive = max(max_consecutive, current_streak)\n    else:\n        current_streak = 0\n\nprint(max_consecutive)"}
{"task_id": "abc311_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = [0] * (N + 1)  # 1-indexed\n    for i in range(1, N + 1):\n        A[i] = int(data[i])\n    \n    # Start traversal from node 1\n    visited = {}\n    path = []\n    current = 1\n    index = 0\n    \n    while True:\n        if current in visited:\n            # Found a cycle\n            cycle_start_index = visited[current]\n            cycle_length = index - cycle_start_index\n            cycle_nodes = path[cycle_start_index:]\n            print(cycle_length)\n            print(' '.join(map(str, cycle_nodes)))\n            return\n        \n        visited[current] = index\n        path.append(current)\n        current = A[current]\n        index += 1\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc311_d", "solution": "from collections import deque\n\ndef main():\n    # Read input\n    N, M = map(int, input().split())\n    grid = [input() for _ in range(N)]\n    \n    # Starting position (0-indexed)\n    start = (1, 1)\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Set to store all ice squares that can be touched\n    touched = set()\n    \n    # Set to store positions where player has stopped\n    visited = set()\n    \n    # Queue for BFS\n    queue = deque([start])\n    touched.add(start)\n    visited.add(start)\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        # Try all 4 directions\n        for dx, dy in directions:\n            # Start sliding from current position\n            nx, ny = x, y\n            \n            # Keep moving in this direction while next cell is ice\n            while True:\n                # Check next cell\n                next_x, next_y = nx + dx, ny + dy\n                \n                # If next cell is out of bounds or rock, stop\n                if (next_x < 0 or next_x >= N or \n                    next_y < 0 or next_y >= M or \n                    grid[next_x][next_y] == '#'):\n                    break\n                \n                # Move to next cell (it's ice)\n                nx, ny = next_x, next_y\n                touched.add((nx, ny))\n            \n            # After sliding, (nx, ny) is where player stops\n            # If this stopping position hasn't been visited, add to queue\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n    \n    print(len(touched))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc311_e", "solution": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    H = int(data[0])\n    W = int(data[1])\n    N = int(data[2])\n    \n    # Initialize the hole grid\n    is_hole = [[False] * (W + 1) for _ in range(H + 1)]\n    \n    idx = 3\n    for _ in range(N):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        is_hole[a][b] = True\n        idx += 2\n    \n    # DP table: dp[i][j] = max square size with top-left at (i,j)\n    dp = [[0] * (W + 2) for _ in range(H + 2)]\n    \n    res = 0\n    \n    # Fill DP from bottom-right to top-left\n    for i in range(H, 0, -1):\n        for j in range(W, 0, -1):\n            if is_hole[i][j]:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1]) + 1\n                res += dp[i][j]\n                \n    print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_a", "solution": "# Read input\nS = input().strip()\n\n# Define the set of valid strings\nvalid_strings = {\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"}\n\n# Check if S is in the valid strings and print result\nif S in valid_strings:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc312_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    grid = data[2:2+N]\n    \n    # Precompute the pattern for a valid Tak Code (9x9)\n    # '#' means must be black, '.' means must be white, '?' means don't care\n    pattern = [['?' for _ in range(9)] for _ in range(9)]\n    \n    # Top-left 3x3 must be black\n    for i in range(3):\n        for j in range(3):\n            pattern[i][j] = '#'\n            \n    # Bottom-right 3x3 must be black\n    for i in range(6, 9):\n        for j in range(6, 9):\n            pattern[i][j] = '#'\n            \n    # Adjacent cells to top-left 3x3 must be white\n    # This includes positions: (0-2,3), (3,0-2), (3,3)\n    for i in range(3):  # rows 0-2\n        pattern[i][3] = '.'\n    for j in range(3):  # cols 0-2\n        pattern[3][j] = '.'\n    pattern[3][3] = '.'  # diagonal\n    \n    # Adjacent cells to bottom-right 3x3 must be white\n    # This includes positions: (5,6-8), (6-8,5), (5,5)\n    for i in range(6, 9):  # rows 6-8\n        pattern[i][5] = '.'\n    for j in range(6, 9):  # cols 6-8\n        pattern[5][j] = '.'\n    pattern[5][5] = '.'  # diagonal\n    \n    results = []\n    \n    # Check all possible 9x9 regions\n    for i in range(N - 8):\n        for j in range(M - 8):\n            match = True\n            for di in range(9):\n                for dj in range(9):\n                    if pattern[di][dj] == '?':\n                        continue\n                    if grid[i + di][j + dj] != pattern[di][dj]:\n                        match = False\n                        break\n                if not match:\n                    break\n            if match:\n                results.append((i + 1, j + 1))  # Convert to 1-indexed\n                \n    # Output results\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_c", "solution": "import bisect\n\n# Read input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n# Sort the arrays for binary search\nA.sort()\nB.sort()\n\n# Define the check function for binary search\ndef is_valid(X):\n    # Count sellers who can sell at price X or less\n    sellers = bisect.bisect_right(A, X)\n    # Count buyers who can buy at price X or more\n    buyers = M - bisect.bisect_left(B, X)\n    return sellers >= buyers\n\n# Binary search on the answer\nlow = min(A)  # At least the cheapest seller's price\nhigh = 10**9  # As per constraints\nanswer = high\n\nwhile low <= high:\n    mid = (low + high) // 2\n    if is_valid(mid):\n        answer = mid\n        high = mid - 1\n    else:\n        low = mid + 1\n\nprint(answer)"}
{"task_id": "abc312_d", "solution": "def solve():\n    MOD = 998244353\n    s = input().strip()\n    n = len(s)\n    \n    # dp[i][j] = number of ways to fill first i chars with balance j\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(n + 1):\n            if dp[i][j] == 0:\n                continue\n                \n            char = s[i]\n            \n            if char == '(':\n                # Only can place '('\n                if j + 1 <= n:\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n            elif char == ')':\n                # Only can place ')'\n                if j - 1 >= 0:\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % MOD\n            else:  # char == '?'\n                # Can place either '(' or ')'\n                if j + 1 <= n:\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n                if j - 1 >= 0:\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % MOD\n    \n    print(dp[n][0])\n\nsolve()"}
{"task_id": "abc312_e", "solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    cuboids = []\n    for _ in range(N):\n        x1 = int(data[idx])\n        y1 = int(data[idx+1])\n        z1 = int(data[idx+2])\n        x2 = int(data[idx+3])\n        y2 = int(data[idx+4])\n        z2 = int(data[idx+5])\n        idx += 6\n        cuboids.append((x1, y1, z1, x2, y2, z2))\n    return N, cuboids\n\ndef has_overlap_2d(a_min, a_max, b_min, b_max):\n    \"\"\"Check if two intervals [a_min, a_max] and [b_min, b_max] overlap with positive length.\"\"\"\n    return max(a_min, b_min) < min(a_max, b_max)\n\ndef main():\n    N, cuboids = read_input()\n    \n    # Initialize adjacency counter for each cuboid\n    adj_count = [0] * N\n    \n    # Group cuboids by face positions\n    # Each entry maps a coordinate to list of (index, opposite_face_coords)\n    x_left = defaultdict(list)   # x = x1\n    x_right = defaultdict(list)  # x = x2\n    y_bottom = defaultdict(list) # y = y1\n    y_top = defaultdict(list)    # y = y2\n    z_back = defaultdict(list)   # z = z1\n    z_front = defaultdict(list)  # z = z2\n    \n    for i in range(N):\n        x1, y1, z1, x2, y2, z2 = cuboids[i]\n        x_left[x1].append((i, y1, y2, z1, z2))\n        x_right[x2].append((i, y1, y2, z1, z2))\n        y_bottom[y1].append((i, x1, x2, z1, z2))\n        y_top[y2].append((i, x1, x2, z1, z2))\n        z_back[z1].append((i, x1, x2, y1, y2))\n        z_front[z2].append((i, x1, x2, y1, y2))\n    \n    # Check for shared faces between cuboids\n    def check_groups(groups_dict, proj_func):\n        \"\"\"\n        groups_dict: dictionary mapping coord to list of (idx, p1, p2, q1, q2)\n        proj_func: function to extract projection ranges from item tuple\n        \"\"\"\n        for coord, items in groups_dict.items():\n            # Compare all pairs in the same group\n            for i in range(len(items)):\n                idx_a, p1_a, p2_a, q1_a, q2_a = items[i]\n                for j in range(i+1, len(items)):\n                    idx_b, p1_b, p2_b, q1_b, q2_b = items[j]\n                    # Check if projections overlap in both dimensions\n                    if has_overlap_2d(p1_a, p2_a, p1_b, p2_b) and has_overlap_2d(q1_a, q2_a, q1_b, q2_b):\n                        adj_count[idx_a] += 1\n                        adj_count[idx_b] += 1\n    \n    # Process each type of face\n    check_groups(x_left, lambda t: (t[1], t[2]))     # Project on YZ-plane\n    check_groups(x_right, lambda t: (t[1], t[2]))    # Project on YZ-plane\n    check_groups(y_bottom, lambda t: (t[1], t[2]))   # Project on XZ-plane\n    check_groups(y_top, lambda t: (t[1], t[2]))      # Project on XZ-plane\n    check_groups(z_back, lambda t: (t[1], t[2]))     # Project on XY-plane\n    check_groups(z_front, lambda t: (t[1], t[2]))    # Project on XY-plane\n    \n    # Output results\n    for count in adj_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_f", "solution": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    idx = 2\n    pull_tab_cans = []   # T=0\n    regular_cans = []    # T=1\n    can_openers = []     # T=2\n    \n    for i in range(N):\n        t = int(data[idx])\n        x = int(data[idx+1])\n        idx += 2\n        if t == 0:\n            pull_tab_cans.append(x)\n        elif t == 1:\n            regular_cans.append(x)\n        else:\n            can_openers.append(x)\n    \n    # Sort in descending order\n    pull_tab_cans.sort(reverse=True)\n    regular_cans.sort(reverse=True)\n    can_openers.sort(reverse=True)\n    \n    # Compute prefix sums for fast range sum queries\n    def compute_prefix(arr):\n        prefix = [0]\n        for val in arr:\n            prefix.append(prefix[-1] + val)\n        return prefix\n    \n    prefix_pull = compute_prefix(pull_tab_cans)\n    prefix_reg = compute_prefix(regular_cans)\n    \n    max_happiness = 0\n    \n    # Try taking k can openers, where k ranges from 0 to min(M, len(can_openers))\n    for k in range(min(M, len(can_openers)) + 1):\n        if k > len(can_openers):\n            break\n        # Total capacity from top k can openers\n        total_capacity = sum(can_openers[:k])\n        \n        # Remaining slots after taking k can openers\n        remaining_slots = M - k\n        \n        if remaining_slots < 0:\n            continue\n            \n        # Now distribute remaining_slots between pull-tab cans and regular cans\n        # Let p be number of pull-tab cans taken, r be number of regular cans taken\n        # p + r <= remaining_slots\n        # Maximize: sum of top p pull-tab cans + sum of top r regular cans (r <= total_capacity)\n        \n        # Greedy: first take as many pull-tab cans as possible, then fill rest with best regular cans\n        max_for_this_k = 0\n        # Iterate through possible number of pull-tab cans to take (p)\n        for p in range(min(remaining_slots, len(pull_tab_cans)) + 1):\n            r_slots = remaining_slots - p\n            r_taken = min(r_slots, len(regular_cans), total_capacity)\n            happiness = prefix_pull[p] + prefix_reg[r_taken]\n            if happiness > max_for_this_k:\n                max_for_this_k = happiness\n                \n        if max_for_this_k > max_happiness:\n            max_happiness = max_for_this_k\n            \n    print(max_happiness)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc313_a", "solution": "# Read input\nn = int(input())\nscores = list(map(int, input().split()))\n\n# Person 1's current score\np1 = scores[0]\n\n# If there's only one person, person 1 is already the strongest\nif n == 1:\n    print(0)\nelse:\n    # Find the maximum score among all other people (persons 2 through N)\n    max_others = max(scores[1:])\n    \n    # Calculate minimum points needed\n    # We need p1 + x > max_others\n    # So x > max_others - p1\n    # Minimum integer x satisfying this is max(0, max_others - p1 + 1)\n    x = max(0, max_others - p1 + 1)\n    \n    print(x)"}
{"task_id": "abc313_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Initialize adjacency matrix for transitive closure\n    # reachable[i][j] will be True if person i+1 is stronger than person j+1\n    reachable = [[False]*N for _ in range(N)]\n    \n    idx = 2\n    for _ in range(M):\n        a = int(data[idx]) - 1  # Convert to 0-indexed\n        b = int(data[idx+1]) - 1\n        reachable[a][b] = True\n        idx += 2\n    \n    # Floyd-Warshall to compute transitive closure\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if reachable[i][k] and reachable[k][j]:\n                    reachable[i][j] = True\n    \n    # For each person, count how many people they can beat (directly or indirectly)\n    can_beat_count = [sum(row) for row in reachable]\n    \n    # Find candidates who can beat N-1 people (potential strongest)\n    candidates = []\n    for i in range(N):\n        if can_beat_count[i] == N - 1:\n            candidates.append(i)\n    \n    # If not exactly one candidate, we cannot determine uniquely\n    if len(candidates) != 1:\n        print(-1)\n        return\n    \n    candidate = candidates[0]\n    \n    # Check if anyone can beat this candidate\n    # If someone can beat the candidate, then the candidate isn't truly the strongest\n    for i in range(N):\n        if reachable[i][candidate]:\n            print(-1)\n            return\n    \n    # If we reach here, the candidate is uniquely the strongest\n    print(candidate + 1)  # Convert back to 1-indexed\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc313_c", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\n\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Calculate total sum\ntotal = sum(A)\n\n# Calculate target values\nlow = total // N\nhigh = low + 1\n\n# Number of elements that should be equal to 'low'\nk = N - (total % N)\n\n# Sort the array\nA.sort()\n\n# Calculate the number of operations\n# We need to decrease elements in the first k positions to 'low'\n# and increase elements in the last (N-k) positions to 'high'\n\n# Excess that needs to be moved out from first k elements\nexcess = sum(max(0, A[i] - low) for i in range(k))\n\n# Deficit that needs to be filled in last (N-k) elements\ndeficit = sum(max(0, high - A[i]) for i in range(k, N))\n\n# By conservation of total value, excess == deficit\n# So we can return either one as the answer\nprint(excess)"}
{"task_id": "abc314_a", "solution": "# Read the input\nN = int(input())\n\n# The value of pi to 100 decimal places\npi_str = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\n# Truncate to N decimal places\n# The integer part and decimal point are 2 characters (\"3.\")\n# So we take the first 2 + N characters\nresult = pi_str[:2 + N]\n\n# Print the result\nprint(result)"}
{"task_id": "abc314_b", "solution": "# Read number of people\nN = int(input())\n\n# Store bets for each person\nbets = []\n\n# Read bets for each person\nfor i in range(N):\n    C = int(input())\n    A = list(map(int, input().split()))\n    bets.append(A)\n\n# Read the outcome\nX = int(input())\n\n# Find people who bet on X and count their bets\npeople_who_bet_on_X = []\nmin_bets = float('inf')\n\n# Check each person\nfor i in range(N):\n    if X in bets[i]:\n        num_bets = len(bets[i])\n        people_who_bet_on_X.append((i + 1, num_bets))  # Store (person_number, bet_count)\n        if num_bets < min_bets:\n            min_bets = num_bets\n\n# If no one bet on X\nif not people_who_bet_on_X:\n    print(0)\nelse:\n    # Find all people with minimum number of bets\n    result = []\n    for person, num_bets in people_who_bet_on_X:\n        if num_bets == min_bets:\n            result.append(person)\n    \n    # Sort in ascending order (already should be, but good practice)\n    result.sort()\n    \n    # Output\n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n    else:\n        print()"}
{"task_id": "abc314_c", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    S = list(data[2])\n    C = list(map(int, data[3:3+N]))\n    \n    # Create lists to hold positions and characters for each color (1-indexed)\n    positions = [[] for _ in range(M + 1)]\n    chars = [[] for _ in range(M + 1)]\n    \n    # Group positions and characters by color\n    for i in range(N):\n        color = C[i]\n        positions[color].append(i)\n        chars[color].append(S[i])\n    \n    # Process each color in order\n    for color in range(1, M + 1):\n        if not positions[color]:\n            continue\n            \n        # Perform right circular shift on chars[color]\n        # The last character moves to the front\n        if len(chars[color]) > 1:\n            shifted_chars = [chars[color][-1]] + chars[color][:-1]\n        else:\n            shifted_chars = chars[color]\n            \n        # Put the shifted characters back into their positions\n        for idx, pos in enumerate(positions[color]):\n            S[pos] = shifted_chars[idx]\n    \n    print(''.join(S))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc314_d", "solution": "N = int(input())\nS = input().strip()\nQ = int(input())\n\n# Store modifications: (time, new_char) for each position (1-indexed)\nmodifications = [None] * (N + 1)  # modifications[i] = (time, char)\n\n# Track last case conversion operation\nlast_case_op = None  # 2 for lowercase, 3 for uppercase\nlast_case_time = 0\n\ndef apply_case_conversion(char, op_type):\n    if op_type == 2:  # to lowercase\n        return char.lower()\n    elif op_type == 3:  # to uppercase\n        return char.upper()\n    return char\n\n# Process operations\nfor time in range(1, Q + 1):\n    t, x, c = input().split()\n    t = int(t)\n    x = int(x)\n    \n    if t == 1:\n        modifications[x] = (time, c)\n    elif t == 2:  # all to lowercase\n        last_case_op = 2\n        last_case_time = time\n    elif t == 3:  # all to uppercase\n        last_case_op = 3\n        last_case_time = time\n\n# Build result\nresult = []\nfor i in range(1, N + 1):\n    # Determine current character value\n    if modifications[i] is not None:\n        mod_time, mod_char = modifications[i]\n        current_char = mod_char\n        # Apply case conversion if it happened after this modification\n        if last_case_op is not None and last_case_time > mod_time:\n            current_char = apply_case_conversion(current_char, last_case_op)\n    else:\n        # Character was never modified, start with original\n        current_char = S[i-1]\n        # Apply case conversion if there was one\n        if last_case_op is not None:\n            current_char = apply_case_conversion(current_char, last_case_op)\n    \n    result.append(current_char)\n\nprint(''.join(result))"}
{"task_id": "abc314_e", "solution": "def solve():\n    # Read input\n    N, M = map(int, input().split())\n    wheels = []\n    for _ in range(N):\n        line = list(map(int, input().split()))\n        C = line[0]\n        P = line[1]\n        S = line[2:]\n        wheels.append((C, P, S))\n    \n    # Initialize DP table\n    # dp[s] = expected minimum cost to get at least M points when currently having s points\n    dp = [0.0] * (M + 100)  # Extra space to avoid boundary issues\n    \n    # Base case: if we already have >= M points, cost is 0\n    for i in range(M, len(dp)):\n        dp[i] = 0.0\n    \n    # Value iteration until convergence\n    epsilon = 1e-12\n    iteration = 0\n    max_iterations = 100000\n    \n    while iteration < max_iterations:\n        max_diff = 0.0\n        new_dp = dp[:]\n        \n        for s in range(M):\n            min_expected_cost = float('inf')\n            \n            # Try each wheel\n            for C, P, S in wheels:\n                expected_cost = C  # Cost to play this wheel\n                expected_future_cost = 0.0\n                \n                # Calculate expected future cost\n                for points in S:\n                    expected_future_cost += dp[s + points]\n                \n                expected_cost += expected_future_cost / P\n                min_expected_cost = min(min_expected_cost, expected_cost)\n            \n            new_dp[s] = min_expected_cost\n            max_diff = max(max_diff, abs(dp[s] - new_dp[s]))\n        \n        dp = new_dp\n        iteration += 1\n        \n        if max_diff < epsilon:\n            break\n    \n    print(dp[0])\n\nsolve()"}
{"task_id": "abc314_f", "solution": "import sys\n\ndef modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.exp_wins = [0] * n  # accumulated expected wins for each player\n        # Keep track of which players are in each component\n        self.members = [[i] for i in range(n)]\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        \n        # Merge smaller tree into larger tree\n        if self.size[px] < self.size[py]:\n            px, py = py, px\n        \n        self.parent[py] = px\n        self.size[px] += self.size[py]\n        # Move all members from py to px\n        self.members[px].extend(self.members[py])\n        self.members[py] = []\n    \n    def get_team_info(self, x):\n        root = self.find(x)\n        return root, self.size[root]\n    \n    def get_team_members(self, x):\n        root = self.find(x)\n        return self.members[root]\n\ndef main():\n    MOD = 998244353\n    \n    N = int(sys.stdin.readline())\n    matches = []\n    for _ in range(N - 1):\n        p, q = map(int, sys.stdin.readline().split())\n        matches.append((p - 1, q - 1))  # Convert to 0-indexed\n    \n    uf = UnionFind(N)\n    \n    # Process each match\n    for p, q in matches:\n        # Get team information\n        team_p_root, size_p = uf.get_team_info(p)\n        team_q_root, size_q = uf.get_team_info(q)\n        \n        # Calculate win probabilities\n        total_size = size_p + size_q\n        prob_p_wins = (size_p * modinv(total_size, MOD)) % MOD\n        prob_q_wins = (size_q * modinv(total_size, MOD)) % MOD\n        \n        # Update expected wins for all players in each team\n        for player in uf.get_team_members(p):\n            uf.exp_wins[player] = (uf.exp_wins[player] + prob_p_wins) % MOD\n            \n        for player in uf.get_team_members(q):\n            uf.exp_wins[player] = (uf.exp_wins[player] + prob_q_wins) % MOD\n        \n        # Merge the teams\n        uf.union(p, q)\n    \n    # Output results\n    result = []\n    for i in range(N):\n        result.append(str(uf.exp_wins[i]))\n    \n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_a", "solution": "# Read input\nS = input().strip()\n\n# Define vowels\nvowels = {'a', 'e', 'i', 'o', 'u'}\n\n# Build result string by excluding vowels\nresult = \"\"\nfor char in S:\n    if char not in vowels:\n        result += char\n\n# Print the result\nprint(result)"}
{"task_id": "abc315_b", "solution": "# Read input\nM = int(input())\nD = list(map(int, input().split()))\n\n# Calculate total number of days in the year\ntotal_days = sum(D)\n\n# Find the middle day (1-based index)\nmiddle_index = (total_days + 1) // 2\n\n# Find which month and day the middle day falls on\ncumulative_days = 0\nfor i in range(M):\n    # If the middle day is within this month\n    if cumulative_days + D[i] >= middle_index:\n        # Calculate which day in this month\n        day_in_month = middle_index - cumulative_days\n        # Month numbers are 1-indexed\n        month_number = i + 1\n        print(month_number, day_in_month)\n        break\n    # Add current month's days to cumulative count\n    cumulative_days += D[i]"}
{"task_id": "abc315_c", "solution": "import sys\nfrom collections import defaultdict\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    fs = []\n    index = 1\n    for _ in range(N):\n        f = int(data[index])\n        s = int(data[index+1])\n        fs.append((f, s))\n        index += 2\n    \n    # Group by flavor, keeping only top 2 deliciousness values per flavor\n    flavor_map = defaultdict(list)\n    for f, s in fs:\n        flavor_map[f].append(s)\n    \n    # For each flavor, sort in descending order and keep top 2\n    for f in flavor_map:\n        flavor_map[f].sort(reverse=True)\n        if len(flavor_map[f]) > 2:\n            flavor_map[f] = flavor_map[f][:2]\n    \n    max_satisfaction = 0\n    \n    # Case 1: Same flavor\n    same_flavor_max = 0\n    for lst in flavor_map.values():\n        if len(lst) >= 2:\n            s = lst[0]\n            t = lst[1]\n            satisfaction = s + t // 2\n            if satisfaction > same_flavor_max:\n                same_flavor_max = satisfaction\n    max_satisfaction = max(max_satisfaction, same_flavor_max)\n    \n    # Case 2: Different flavors\n    # Get all (flavor, deliciousness) pairs, sorted by deliciousness descending\n    all_cups = []\n    for f, lst in flavor_map.items():\n        for s in lst:\n            all_cups.append((s, f))\n    all_cups.sort(reverse=True)\n    \n    if len(all_cups) >= 2:\n        # Try pairing the highest with the best from a different flavor\n        first_s, first_f = all_cups[0]\n        best_diff_flavor = 0\n        for i in range(1, len(all_cups)):\n            s, f = all_cups[i]\n            if f != first_f:\n                best_diff_flavor = s\n                break\n        if best_diff_flavor > 0:\n            diff_flavor_satisfaction = first_s + best_diff_flavor\n            max_satisfaction = max(max_satisfaction, diff_flavor_satisfaction)\n    \n    print(max_satisfaction)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    \n    grid = data[2:2+H]\n    \n    # Convert to list of lists for easier handling\n    cookies = [list(row) for row in grid]\n    \n    # Keep track of which cookies have been removed\n    removed = [[False]*W for _ in range(H)]\n    \n    changed = True\n    while changed:\n        changed = False\n        # Track which positions to remove in this iteration\n        to_remove = [[False]*W for _ in range(H)]\n        \n        # Check rows\n        for i in range(H):\n            # Collect non-removed cookies in this row\n            colors = []\n            positions = []\n            for j in range(W):\n                if not removed[i][j]:\n                    colors.append(cookies[i][j])\n                    positions.append((i, j))\n            \n            # If we have at least 2 cookies and they're all the same color\n            if len(colors) >= 2 and all(c == colors[0] for c in colors):\n                for (r, c) in positions:\n                    to_remove[r][c] = True\n        \n        # Check columns\n        for j in range(W):\n            # Collect non-removed cookies in this column\n            colors = []\n            positions = []\n            for i in range(H):\n                if not removed[i][j]:\n                    colors.append(cookies[i][j])\n                    positions.append((i, j))\n            \n            # If we have at least 2 cookies and they're all the same color\n            if len(colors) >= 2 and all(c == colors[0] for c in colors):\n                for (r, c) in positions:\n                    to_remove[r][c] = True\n        \n        # Apply removals\n        for i in range(H):\n            for j in range(W):\n                if to_remove[i][j] and not removed[i][j]:\n                    removed[i][j] = True\n                    changed = True\n    \n    # Count remaining cookies\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if not removed[i][j]:\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_e", "solution": "from collections import deque, defaultdict\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    \n    # adj[i] = list of prerequisites for book i (1-indexed)\n    adj = [[] for _ in range(N + 1)]\n    in_degree = [0] * (N + 1)\n    \n    # Store original prerequisites for building dependency set\n    prereqs = [[] for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        C = int(data[idx])\n        idx += 1\n        for _ in range(C):\n            p = int(data[idx])\n            idx += 1\n            prereqs[i].append(p)\n            adj[p].append(i)  # p is a prerequisite for i\n            in_degree[i] += 1\n            \n    # Step 1: Find all books that are needed to read book 1 (transitive closure)\n    # We do a BFS/DFS backwards from book 1 to find all dependencies\n    visited = [False] * (N + 1)\n    required = set()\n    queue = deque()\n    queue.append(1)\n    visited[1] = True\n    required.add(1)\n    \n    while queue:\n        u = queue.popleft()\n        for v in prereqs[u]:\n            if not visited[v]:\n                visited[v] = True\n                required.add(v)\n                queue.append(v)\n                \n    # Step 2: Build subgraph with only required books\n    # Create new in_degree and adjacency list for topological sort\n    new_in_degree = {book: 0 for book in required}\n    new_adj = {book: [] for book in required}\n    \n    for book in required:\n        for prereq in prereqs[book]:\n            if prereq in required:\n                new_adj[prereq].append(book)\n                new_in_degree[book] += 1\n                \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque()\n    result = []\n    \n    # Initialize queue with nodes having zero in-degree\n    for book in required:\n        if new_in_degree[book] == 0:\n            queue.append(book)\n            \n    while queue:\n        u = queue.popleft()\n        # Skip book 1 in the final output\n        if u != 1:\n            result.append(u)\n        for v in new_adj[u]:\n            new_in_degree[v] -= 1\n            if new_in_degree[v] == 0:\n                queue.append(v)\n                \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_f", "solution": "import math\n\ndef euclidean_distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n# Read input\nN = int(input())\ncheckpoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    checkpoints.append((x, y))\n\n# Initialize DP array\ndp = [float('inf')] * N\ndp[0] = 0  # Base case: starting at checkpoint 1 (index 0)\n\n# Fill DP array\nfor i in range(1, N):\n    for j in range(i):\n        # Calculate number of skipped checkpoints\n        skipped = i - j - 1\n        \n        # Calculate penalty\n        if skipped == 0:\n            penalty = 0\n        else:\n            penalty = 2 ** (skipped - 1)\n        \n        # Calculate distance\n        dist = euclidean_distance(checkpoints[j][0], checkpoints[j][1], \n                                  checkpoints[i][0], checkpoints[i][1])\n        \n        # Update DP state\n        dp[i] = min(dp[i], dp[j] + dist + penalty)\n\n# Output the result\nprint(dp[N-1])"}
{"task_id": "abc318_a", "solution": "# Read input\nN, M, P = map(int, input().split())\n\n# If the first full moon is after day N, there are no full moons in range\nif M > N:\n    print(0)\nelse:\n    # Calculate the number of full moons in the range [1, N]\n    # Formula: floor((N - M) / P) + 1\n    count = (N - M) // P + 1\n    print(count)"}
{"task_id": "abc318_b", "solution": "# Read input\nN = int(input())\nrectangles = []\nfor _ in range(N):\n    A, B, C, D = map(int, input().split())\n    rectangles.append((A, B, C, D))\n\n# Coordinate compression\nx_coords = set()\ny_coords = set()\n\nfor A, B, C, D in rectangles:\n    x_coords.add(A)\n    x_coords.add(B)\n    y_coords.add(C)\n    y_coords.add(D)\n\nx_coords = sorted(x_coords)\ny_coords = sorted(y_coords)\n\n# Calculate the total area covered by at least one rectangle\narea = 0\n\n# Iterate through adjacent pairs of x-coordinates\nfor i in range(len(x_coords) - 1):\n    x1 = x_coords[i]\n    x2 = x_coords[i + 1]\n    \n    # Iterate through adjacent pairs of y-coordinates\n    for j in range(len(y_coords) - 1):\n        y1 = y_coords[j]\n        y2 = y_coords[j + 1]\n        \n        # Check if this cell is covered by any rectangle\n        for A, B, C, D in rectangles:\n            if A <= x1 and x2 <= B and C <= y1 and y2 <= D:\n                # This cell is covered; add its area\n                area += (x2 - x1) * (y2 - y1)\n                break  # No need to check other rectangles for this cell\n\nprint(area)"}
{"task_id": "abc318_c", "solution": "import math\n\n# Read input\nN, D, P = map(int, input().split())\nF = list(map(int, input().split()))\n\n# Sort fares in descending order to prioritize using passes on expensive days\nF.sort(reverse=True)\n\n# Calculate prefix sums for efficient range sum calculation\nprefix_sum = [0] * (N + 1)\nfor i in range(N):\n    prefix_sum[i + 1] = prefix_sum[i] + F[i]\n\n# Try different numbers of batches and find the minimum cost\nmin_cost = float('inf')\nmax_batches = math.ceil(N / D)\n\nfor k in range(max_batches + 1):  # k is the number of batches\n    passes_used = k * D\n    \n    # Cost of buying k batches\n    pass_cost = k * P\n    \n    # Sum of regular fares for days not covered by passes\n    # We use passes on the first 'passes_used' days (most expensive ones)\n    # So we pay regular fare for days from index 'passes_used' to N-1\n    if passes_used >= N:\n        regular_fare_cost = 0\n    else:\n        regular_fare_cost = prefix_sum[N] - prefix_sum[passes_used]\n    \n    total_cost = pass_cost + regular_fare_cost\n    min_cost = min(min_cost, total_cost)\n\nprint(min_cost)"}
{"task_id": "abc318_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    idx = 1\n    \n    # Create adjacency matrix\n    D = [[0]*N for _ in range(N)]\n    \n    for i in range(N-1):\n        for j in range(i+1, N):\n            D[i][j] = int(data[idx])\n            D[j][i] = D[i][j]\n            idx += 1\n    \n    # DP with bitmasks\n    dp = [-float('inf')] * (1 << N)\n    dp[0] = 0\n    \n    # Iterate through all masks\n    for mask in range(1 << N):\n        if dp[mask] == -float('inf'):\n            continue\n            \n        # Try pairing every two unpaired vertices\n        for i in range(N):\n            if mask & (1 << i):\n                continue\n            for j in range(i+1, N):\n                if mask & (1 << j):\n                    continue\n                new_mask = mask | (1 << i) | (1 << j)\n                dp[new_mask] = max(dp[new_mask], dp[mask] + D[i][j])\n    \n    # Find maximum value among all dp states\n    result = max(dp)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc318_e", "solution": "from collections import defaultdict\n\n# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Create a mapping from value to list of indices (1-indexed)\nvalue_to_indices = defaultdict(list)\nfor i in range(N):\n    value_to_indices[A[i]].append(i + 1)  # Convert to 1-indexed\n\nresult = 0\n\n# For each value, process its indices\nfor value, indices in value_to_indices.items():\n    # For every pair of indices (i, k) where i < k\n    for i in range(len(indices)):\n        for j in range(i + 1, len(indices)):  # Using j as the second index in the pair\n            idx_i = indices[i]\n            idx_k = indices[j]\n            \n            # Number of elements between idx_i and idx_k\n            total_between = idx_k - idx_i - 1\n            \n            # Number of elements between idx_i and idx_k with the same value\n            same_value_between = j - i - 1\n            \n            # Number of valid j values\n            valid_j_count = total_between - same_value_between\n            result += valid_j_count\n\nprint(result)"}
{"task_id": "abc319_b", "solution": "# Read input\nN = int(input())\n\n# Initialize result list with '-'\nresult = ['-'] * (N + 1)\n\n# Check each j from 1 to 9\nfor j in range(1, 10):\n    if N % j == 0:  # j is a divisor of N\n        quotient = N // j\n        # For each multiple of quotient up to N\n        for i in range(0, N + 1, quotient):\n            # If this is the first valid j for this index, or if j is smaller than current value\n            if result[i] == '-' or int(result[i]) > j:\n                result[i] = str(j)\n\n# Convert list to string and print\nprint(''.join(result))"}
{"task_id": "abc319_c", "solution": "from itertools import permutations\n\ndef main():\n    # Read the grid\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Define the 8 lines (each line is a list of (i,j) positions)\n    lines = [\n        [(0,0), (0,1), (0,2)],  # Row 1\n        [(1,0), (1,1), (1,2)],  # Row 2\n        [(2,0), (2,1), (2,2)],  # Row 3\n        [(0,0), (1,0), (2,0)],  # Column 1\n        [(0,1), (1,1), (2,1)],  # Column 2\n        [(0,2), (1,2), (2,2)],  # Column 3\n        [(0,0), (1,1), (2,2)],  # Diagonal 1\n        [(0,2), (1,1), (2,0)]   # Diagonal 2\n    ]\n    \n    # Generate all permutations of positions (0,0) to (2,2)\n    positions = [(i, j) for i in range(3) for j in range(3)]\n    all_perms = list(permutations(positions))\n    \n    total_count = len(all_perms)\n    valid_count = 0\n    \n    # For each permutation, check if it causes disappointment\n    for perm in all_perms:\n        # Create a mapping from position to its index in the permutation\n        pos_to_index = {pos: idx for idx, pos in enumerate(perm)}\n        \n        valid = True\n        # Check each line\n        for line in lines:\n            # Get the indices in the permutation for each position in the line\n            indices = [pos_to_index[pos] for pos in line]\n            # Sort the positions based on their order in the permutation\n            sorted_positions = sorted(zip(indices, line))\n            first_pos = sorted_positions[0][1]\n            second_pos = sorted_positions[1][1]\n            third_pos = sorted_positions[2][1]\n            \n            val_first = grid[first_pos[0]][first_pos[1]]\n            val_second = grid[second_pos[0]][second_pos[1]]\n            val_third = grid[third_pos[0]][third_pos[1]]\n            \n            # Check if first two are equal and third is different\n            if val_first == val_second and val_first != val_third:\n                valid = False\n                break\n        \n        if valid:\n            valid_count += 1\n    \n    probability = valid_count / total_count\n    print(probability)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc319_d", "solution": "def can_fit_in_lines(words, max_lines, width):\n    lines_used = 1\n    current_line_width = 0\n    \n    for word_len in words:\n        # If a single word is longer than width, it's impossible\n        if word_len > width:\n            return False\n            \n        # If this is the first word on the line\n        if current_line_width == 0:\n            current_line_width = word_len\n        # If we can fit this word on the current line\n        elif current_line_width + 1 + word_len <= width:\n            current_line_width += 1 + word_len\n        # Otherwise, we need to start a new line\n        else:\n            lines_used += 1\n            current_line_width = word_len\n            \n        # If we've used more lines than allowed, return False\n        if lines_used > max_lines:\n            return False\n            \n    return True\n\ndef find_min_window_width(n, m, words):\n    # Lower bound: longest word (must fit at least one word)\n    low = max(words)\n    \n    # Upper bound: all words in one line\n    high = sum(words) + (n - 1)  # Sum of all words + spaces between them\n    \n    # Binary search for the minimum width\n    while low < high:\n        mid = (low + high) // 2\n        \n        if can_fit_in_lines(words, m, mid):\n            high = mid  # Try for a smaller width\n        else:\n            low = mid + 1  # Need a larger width\n            \n    return low\n\n# Read input\nn, m = map(int, input().split())\nwords = list(map(int, input().split()))\n\n# Find and print the answer\nresult = find_min_window_width(n, m, words)\nprint(result)"}
{"task_id": "abc319_e", "solution": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    X = int(data[idx])\n    idx += 1\n    Y = int(data[idx])\n    idx += 1\n    \n    P = [0] * (N - 1)\n    T = [0] * (N - 1)\n    \n    for i in range(N - 1):\n        P[i] = int(data[idx])\n        idx += 1\n        T[i] = int(data[idx])\n        idx += 1\n    \n    # Calculate LCM of all periods\n    G = reduce(lcm, P)\n    \n    # Precompute delays for one period\n    dp = [0] * G\n    \n    for t in range(G):\n        current_time = t + X  # Time when reaching first bus stop\n        extra_time = 0\n        \n        for i in range(N - 1):\n            # Wait for the next bus departure (multiple of P[i])\n            if current_time % P[i] == 0:\n                departure_time = current_time\n            else:\n                departure_time = ((current_time // P[i]) + 1) * P[i]\n            \n            wait_time = departure_time - current_time\n            extra_time += wait_time\n            \n            # Update current time after taking the bus\n            current_time = departure_time + T[i]\n        \n        dp[t] = extra_time\n    \n    Q = int(data[idx])\n    idx += 1\n    \n    results = []\n    for _ in range(Q):\n        q = int(data[idx])\n        idx += 1\n        \n        # Base journey time without delays\n        base_time = X + sum(T) + Y\n        \n        # Add the precomputed delay\n        delay = dp[q % G]\n        \n        # Total time is query time + base time + delay\n        total_time = q + base_time + delay\n        results.append(total_time)\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc320_a", "solution": "# Read input\nA, B = map(int, input().split())\n\n# Calculate A^B and B^A\nresult = A**B + B**A\n\n# Print the result\nprint(result)"}
{"task_id": "abc320_b", "solution": "def expand_around_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\ns = input().strip()\nn = len(s)\nmax_length = 1\n\nfor i in range(n):\n    # Odd length palindromes (centered at i)\n    len1 = expand_around_center(s, i, i)\n    \n    # Even length palindromes (centered between i and i+1)\n    len2 = expand_around_center(s, i, i + 1)\n    \n    # Update max_length\n    max_length = max(max_length, len1, len2)\n\nprint(max_length)"}
{"task_id": "abc320_c", "solution": "import sys\nfrom itertools import product\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    M = int(data[0])\n    S1 = data[1]\n    S2 = data[2]\n    S3 = data[3]\n\n    # Create mappings from each digit to the set of indices where it appears in each string\n    pos1 = {}\n    pos2 = {}\n    pos3 = {}\n\n    for i in range(M):\n        c1 = S1[i]\n        c2 = S2[i]\n        c3 = S3[i]\n        pos1.setdefault(c1, []).append(i)\n        pos2.setdefault(c2, []).append(i)\n        pos3.setdefault(c3, []).append(i)\n\n    min_time = float('inf')\n\n    # Check all digits from '0' to '9'\n    for d in '0123456789':\n        if d not in pos1 or d not in pos2 or d not in pos3:\n            continue  # This digit does not appear on all reels\n        \n        # Get positions where digit d occurs in each reel\n        p1 = pos1[d]\n        p2 = pos2[d]\n        p3 = pos3[d]\n\n        # Generate possible stop times for each reel up to a reasonable limit (e.g., 3*M)\n        # Stop time t gives index t%M => so for index i, valid t values are i, i+M, i+2M, ...\n        times1 = []\n        times2 = []\n        times3 = []\n\n        for idx in p1:\n            times1.extend([idx + k*M for k in range(3)])\n        for idx in p2:\n            times2.extend([idx + k*M for k in range(3)])\n        for idx in p3:\n            times3.extend([idx + k*M for k in range(3)])\n\n        # Sort for optimization\n        times1.sort()\n        times2.sort()\n        times3.sort()\n\n        # Now try all combinations of one element from each list\n        for t1 in times1:\n            for t2 in times2:\n                for t3 in times3:\n                    max_t = max(t1, t2, t3)\n                    if max_t < min_time:\n                        min_time = max_t\n\n    if min_time == float('inf'):\n        print(-1)\n    else:\n        print(min_time)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc320_d", "solution": "from collections import deque, defaultdict\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    # Adjacency list: adj[a] contains list of (b, dx, dy) meaning from a's perspective, b is at (dx, dy)\n    adj = defaultdict(list)\n    \n    for _ in range(M):\n        A = int(data[idx])\n        idx += 1\n        B = int(data[idx])\n        idx += 1\n        X = int(data[idx])\n        idx += 1\n        Y = int(data[idx])\n        idx += 1\n        adj[A].append((B, X, Y))\n        adj[B].append((A, -X, -Y))  # Reverse relationship\n        \n    # Coordinates array, initialized to None\n    coords = [None] * (N + 1)\n    coords[1] = (0, 0)\n    \n    # BFS queue\n    queue = deque()\n    queue.append(1)\n    \n    while queue:\n        u = queue.popleft()\n        ux, uy = coords[u]\n        \n        for v, dx, dy in adj[u]:\n            vx_new = ux + dx\n            vy_new = uy + dy\n            \n            if coords[v] is None:\n                coords[v] = (vx_new, vy_new)\n                queue.append(v)\n            else:\n                # Consistency check (problem says input is consistent, so we can skip)\n                # But we can verify if needed\n                pass\n    \n    # Output results\n    for i in range(1, N + 1):\n        if coords[i] is None:\n            print(\"undecidable\")\n        else:\n            print(coords[i][0], coords[i][1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc320_e", "solution": "import heapq\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Read events\n    events = []\n    idx = 2\n    for i in range(M):\n        T = int(data[idx])\n        W = int(data[idx+1])\n        S = int(data[idx+2])\n        idx += 3\n        # (time, type, weight, duration, person_id)\n        # type 0 = noodle arrival, type 1 = person returns\n        events.append((T, 0, W, S, -1))\n    \n    # Sort events by time\n    events.sort()\n    \n    # Result array to store noodles received by each person\n    noodles_received = [0] * (N + 1)  # 1-indexed\n    \n    # Min-heap to keep track of people currently in row (by index)\n    in_row = list(range(1, N + 1))\n    heapq.heapify(in_row)\n    \n    # List to store return events\n    return_events = []\n    \n    # Process events\n    for event in events:\n        T, type_event, W, S, _ = event\n        \n        # First, process all return events that happen at or before time T\n        while return_events and return_events[0][0] <= T:\n            return_time, person = heapq.heappop(return_events)\n            heapq.heappush(in_row, person)\n        \n        if type_event == 0:  # Noodle arrival\n            if in_row:  # Someone is in the row\n                person = heapq.heappop(in_row)\n                noodles_received[person] += W\n                # Schedule return\n                heapq.heappush(return_events, (T + S, person))\n    \n    # Handle remaining return events (not necessary for counting noodles, but good practice)\n    # These happen after all noodle events, so they don't affect the outcome\n    \n    # Output results\n    for i in range(1, N + 1):\n        print(noodles_received[i])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_a", "solution": "# Read input\nN = input().strip()\n\n# Check if digits are strictly decreasing\nis_321_like = True\n\nfor i in range(len(N) - 1):\n    if int(N[i]) <= int(N[i + 1]):\n        is_321_like = False\n        break\n\n# Output result\nif is_321_like:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc321_b", "solution": "def calculate_final_grade(scores):\n    sorted_scores = sorted(scores)\n    # Exclude the lowest and highest scores\n    return sum(sorted_scores[1:-1])\n\ndef min_score_needed(N, X, A):\n    # A is a list of N-1 scores\n    # We need to find the minimum score in [0, 100] for the Nth round\n    # such that the final grade is at least X\n    \n    # First check if it's even possible with a score of 100\n    scores_with_100 = A + [100]\n    max_possible_grade = calculate_final_grade(scores_with_100)\n    \n    if max_possible_grade < X:\n        return -1\n    \n    # Binary search for the minimum required score\n    left, right = 0, 100\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        scores = A + [mid]\n        grade = calculate_final_grade(scores)\n        \n        if grade >= X:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n            \n    return result\n\n# Read input\nline1 = input().split()\nN = int(line1[0])\nX = int(line1[1])\nA = list(map(int, input().split()))\n\n# Solve and print result\nprint(min_score_needed(N, X, A))"}
{"task_id": "abc321_c", "solution": "K = int(input())\n\n# Generate all 321-like numbers\nnumbers = []\n\n# Iterate through all non-empty subsets of {0,1,2,3,4,5,6,7,8,9}\n# Using bit manipulation from 1 to 2^10 - 1\nfor mask in range(1, 1 << 10):\n    # Determine which digits are in this subset\n    digits = []\n    for i in range(10):\n        if mask & (1 << i):\n            digits.append(str(i))\n    \n    # Sort digits in descending order to form the 321-like number\n    digits.sort(reverse=True)\n    \n    # Join to make the number string\n    num_str = ''.join(digits)\n    \n    # Convert to integer (this automatically handles filtering out \"0\")\n    num = int(num_str)\n    \n    # Only add positive numbers (this filters out \"0\")\n    if num > 0:\n        numbers.append(num)\n\n# Sort all generated 321-like numbers\nnumbers.sort()\n\n# Return the K-th smallest (1-indexed)\nprint(numbers[K-1])"}
{"task_id": "abc321_d", "solution": "import bisect\n\n# Read input\nN, M, P = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n# Sort B for binary search and prefix sums\nB.sort()\n\n# Precompute prefix sums of B\nprefix_B = [0] * (M + 1)\nfor i in range(M):\n    prefix_B[i + 1] = prefix_B[i] + B[i]\n\ntotal = 0\n\n# For each main dish price A_i\nfor a in A:\n    # Find number of B_j such that B_j <= P - A_i\n    # Using bisect_right to get the count\n    limit = P - a\n    k = bisect.bisect_right(B, limit)\n    \n    # Sum of (A_i + B_j) for B_j <= P - A_i\n    # = k * A_i + sum_{j=1}^{k} B_j\n    sum_valid_pairs = k * a + prefix_B[k]\n    \n    # Number of B_j such that B_j > P - A_i is (M - k)\n    # Each contributes P to the total\n    sum_capped_pairs = (M - k) * P\n    \n    total += sum_valid_pairs + sum_capped_pairs\n\nprint(total)"}
{"task_id": "abc321_e", "solution": "def get_ancestors_with_distances(x):\n    \"\"\"Get all ancestors of x with their distances from x\"\"\"\n    ancestors = []\n    current = x\n    distance = 0\n    while current > 1:\n        current = current // 2\n        distance += 1\n        ancestors.append((current, distance))\n    return ancestors\n\ndef count_nodes_in_subtree(root, max_n, max_depth):\n    \"\"\"Count nodes in subtree of root at exactly max_depth, respecting max_n limit\"\"\"\n    if max_depth == 0:\n        return 1 if root <= max_n else 0\n    \n    if root > max_n:\n        return 0\n    \n    # BFS-like counting in binary tree\n    count = 0\n    queue = [(root, 0)]  # (node, current_depth)\n    \n    while queue:\n        node, depth = queue.pop(0)\n        if depth == max_depth:\n            if node <= max_n:\n                count += 1\n        elif depth < max_depth:\n            if node > max_n:\n                continue\n            # Add children\n            left_child = 2 * node\n            right_child = 2 * node + 1\n            if left_child <= max_n:\n                queue.append((left_child, depth + 1))\n            if right_child <= max_n:\n                queue.append((right_child, depth + 1))\n    \n    return count\n\ndef count_descendants(node, max_n, depth):\n    \"\"\"Count descendants of node at exactly 'depth' levels down\"\"\"\n    if depth == 0:\n        return 1 if node <= max_n else 0\n        \n    if node > max_n:\n        return 0\n        \n    # Use mathematical formula for complete binary tree\n    # At depth d, node n has 2^d potential descendants (in unlimited tree)\n    # But we need to account for the limit max_n\n    \n    if depth == 0:\n        return 1 if node <= max_n else 0\n    \n    leftmost = node * (2 ** depth)\n    rightmost = leftmost + (2 ** depth) - 1\n    \n    if leftmost > max_n:\n        return 0\n    \n    if rightmost <= max_n:\n        return 2 ** depth\n    else:\n        # Partially filled level\n        return max(0, max_n - leftmost + 1)\n\ndef solve_case(n, x, k):\n    if k == 0:\n        return 1  # Only X itself\n    \n    total = 0\n    \n    # Case 1: Descendants of X at depth k\n    total += count_descendants(x, n, k)\n    \n    # Case 2: Go up some steps, then down a different branch\n    ancestors = get_ancestors_with_distances(x)\n    \n    for ancestor, up_steps in ancestors:\n        if up_steps > k:\n            continue\n            \n        down_steps = k - up_steps\n        if down_steps < 0:\n            continue\n            \n        # From ancestor, we want to go down_steps, but not into the branch containing X\n        # Count all descendants of ancestor at depth down_steps\n        all_descendants = count_descendants(ancestor, n, down_steps)\n        \n        # Subtract descendants that are in the subtree of X\n        # Find which child of ancestor leads to X\n        temp = x\n        for _ in range(up_steps - 1):\n            temp = temp // 2\n            \n        sibling_branch = None\n        if ancestor * 2 == temp:\n            sibling_branch = ancestor * 2 + 1\n        elif ancestor * 2 + 1 == temp:\n            sibling_branch = ancestor * 2\n            \n        # If we found a sibling branch, count its descendants\n        if sibling_branch is not None and down_steps > 0:\n            # We went up_steps to reach ancestor, now we go down_steps\n            # But one of those down steps is to the sibling branch\n            # So we want descendants of sibling_branch at depth (down_steps - 1)\n            sibling_descendants = count_descendants(sibling_branch, n, down_steps - 1)\n            total += sibling_descendants\n        elif down_steps == 0 and up_steps == k:\n            # Special case: we go exactly k steps up to ancestor\n            total += 1\n    \n    return total\n\ndef solve_case_optimized(n, x, k):\n    if k == 0:\n        return 1\n    \n    result = 0\n    \n    # Get path from x to root\n    path = []  # [(node, steps_from_x)]\n    curr = x\n    steps = 0\n    while curr >= 1:\n        path.append((curr, steps))\n        curr //= 2\n        steps += 1\n    \n    # For each node in the path\n    for i, (node, dist_from_x) in enumerate(path):\n        if dist_from_x > k:\n            continue\n            \n        remaining_steps = k - dist_from_x\n        \n        if i == 0:  # This is x itself\n            # Count descendants at depth remaining_steps\n            result += count_descendants_at_exact_depth(node, n, remaining_steps)\n        else:  # This is an ancestor\n            # Which child of this ancestor leads toward x?\n            prev_node_on_path = path[i-1][0]  # The previous node (closer to x)\n            \n            # Determine the other child\n            if node * 2 == prev_node_on_path:\n                other_child = node * 2 + 1\n            else:\n                other_child = node * 2\n                \n            # Count descendants of the other child at depth (remaining_steps - 1)\n            if remaining_steps > 0:\n                result += count_descendants_at_exact_depth(other_child, n, remaining_steps - 1)\n            elif remaining_steps == 0:\n                # We're at exactly distance k\n                result += 1\n                \n    return result\n\ndef count_descendants_at_exact_depth(root, max_n, depth):\n    \"\"\"Count nodes in subtree rooted at 'root' that are exactly at depth 'depth', limited by max_n\"\"\"\n    if depth < 0:\n        return 0\n    if root > max_n:\n        return 0\n    if depth == 0:\n        return 1 if root <= max_n else 0\n    \n    # Leftmost and rightmost nodes at that depth\n    leftmost = root << depth  # root * 2^depth\n    rightmost = leftmost + (1 << depth) - 1  # leftmost + 2^depth - 1\n    \n    if leftmost > max_n:\n        return 0\n    if rightmost <= max_n:\n        return 1 << depth  # 2^depth\n    \n    # Partial range\n    return max(0, max_n - leftmost + 1)\n\n# Read input and solve\nt = int(input())\nfor _ in range(t):\n    n, x, k = map(int, input().split())\n    print(solve_case_optimized(n, x, k))"}
{"task_id": "abc322_a", "solution": "# Read input\nN = int(input())\nS = input()\n\n# Search for the first occurrence of \"ABC\"\nfound = False\nfor i in range(N - 2):  # N-2 because we need at least 3 characters remaining\n    if S[i:i+3] == \"ABC\":\n        print(i + 1)  # Convert to 1-indexed position\n        found = True\n        break\n\n# If not found, print -1\nif not found:\n    print(-1)"}
{"task_id": "abc322_b", "solution": "# Read input\nN, M = map(int, input().split())\nS = input().strip()\nT = input().strip()\n\n# Check if S is a prefix of T\nis_prefix = T.startswith(S)\n\n# Check if S is a suffix of T\nis_suffix = T.endswith(S)\n\n# Determine and print the result based on conditions\nif is_prefix and is_suffix:\n    print(0)\nelif is_prefix:\n    print(1)\nelif is_suffix:\n    print(2)\nelse:\n    print(3)"}
{"task_id": "abc322_c", "solution": "import sys\n\ndef main():\n    import bisect\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Result array to hold answer for each day (1-based indexing simulated via 0-based)\n    result = [0] * N\n\n    # Pointer to the next firework day in A\n    firework_index = M - 1  # Start at last firework (guaranteed to be on day N)\n\n    # Process days from N down to 1\n    for day in range(N, 0, -1):\n        # Move firework_index back as long as previous fireworks are still >= current day\n        while firework_index > 0 and A[firework_index - 1] >= day:\n            firework_index -= 1\n        \n        # Now A[firework_index] is the earliest firework >= day\n        next_firework_day = A[firework_index]\n        result[day - 1] = next_firework_day - day\n\n    # Print all results\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc322_d", "solution": "def parse_polyomino(lines):\n    \"\"\"Convert 4x4 character grid to list of coordinates\"\"\"\n    coords = []\n    for r in range(4):\n        for c in range(4):\n            if lines[r][c] == '#':\n                coords.append((r, c))\n    return coords\n\ndef normalize(coords):\n    \"\"\"Normalize coordinates to start from (0,0)\"\"\"\n    if not coords:\n        return coords\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    return [(r - min_r, c - min_c) for r, c in coords]\n\ndef rotate_90(coords):\n    \"\"\"Rotate coordinates 90 degrees clockwise\"\"\"\n    return normalize([(c, -r) for r, c in coords])\n\ndef get_rotations(coords):\n    \"\"\"Get all 4 rotations of a polyomino\"\"\"\n    rotations = [normalize(coords)]\n    for _ in range(3):\n        rotations.append(rotate_90(rotations[-1]))\n    # Remove duplicates\n    unique_rotations = []\n    for rot in rotations:\n        if rot not in unique_rotations:\n            unique_rotations.append(rot)\n    return unique_rotations\n\ndef can_place(grid, coords, offset_r, offset_c):\n    \"\"\"Check if a polyomino can be placed at the given offset\"\"\"\n    for r, c in coords:\n        nr, nc = r + offset_r, c + offset_c\n        # Check bounds\n        if not (0 <= nr < 4 and 0 <= nc < 4):\n            return False\n        # Check if cell is already occupied\n        if grid[nr][nc]:\n            return False\n    return True\n\ndef place_polyomino(grid, coords, offset_r, offset_c, poly_id):\n    \"\"\"Place a polyomino on the grid\"\"\"\n    for r, c in coords:\n        nr, nc = r + offset_r, c + offset_c\n        grid[nr][nc] = poly_id\n\ndef remove_polyomino(grid, coords, offset_r, offset_c):\n    \"\"\"Remove a polyomino from the grid\"\"\"\n    for r, c in coords:\n        nr, nc = r + offset_r, c + offset_c\n        grid[nr][nc] = 0\n\ndef solve(grid, polyominos, index):\n    \"\"\"Recursive backtracking solver\"\"\"\n    if index == len(polyominos):\n        # Check if grid is completely filled\n        for r in range(4):\n            for c in range(4):\n                if grid[r][c] == 0:\n                    return False\n        return True\n    \n    polyomino_shapes = polyominos[index]\n    \n    # Try each rotation of the current polyomino\n    for shape in polyomino_shapes:\n        # Try placing at each position\n        for r in range(4):\n            for c in range(4):\n                if can_place(grid, shape, r, c):\n                    place_polyomino(grid, shape, r, c, index + 1)\n                    if solve(grid, polyominos, index + 1):\n                        return True\n                    remove_polyomino(grid, shape, r, c)\n    \n    return False\n\ndef main():\n    import sys\n    lines = []\n    for _ in range(12):\n        lines.append(sys.stdin.readline().strip())\n    \n    # Parse the three polyominoes\n    polyomino1 = parse_polyomino(lines[0:4])\n    polyomino2 = parse_polyomino(lines[4:8])\n    polyomino3 = parse_polyomino(lines[8:12])\n    \n    # Normalize each polyomino\n    polyomino1 = normalize(polyomino1)\n    polyomino2 = normalize(polyomino2)\n    polyomino3 = normalize(polyomino3)\n    \n    # Get all rotations for each polyomino\n    rotations1 = get_rotations(polyomino1)\n    rotations2 = get_rotations(polyomino2)\n    rotations3 = get_rotations(polyomino3)\n    \n    polyominos = [rotations1, rotations2, rotations3]\n    \n    # Initialize empty grid\n    grid = [[0 for _ in range(4)] for _ in range(4)]\n    \n    # Solve\n    if solve(grid, polyominos, 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc322_e", "solution": "import sys\nfrom collections import defaultdict\nimport math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    K = int(data[idx])\n    idx += 1\n    P = int(data[idx])\n    idx += 1\n    \n    plans = []\n    for i in range(N):\n        C = int(data[idx])\n        idx += 1\n        A = []\n        for j in range(K):\n            A.append(int(data[idx]))\n            idx += 1\n        plans.append((C, A))\n    \n    # dp[state_tuple] = minimum cost to reach that state\n    # state_tuple is a tuple of length K, each value 0 to P\n    dp = dict()\n    initial_state = tuple([0]*K)\n    dp[initial_state] = 0\n    \n    # For each plan, update the dp table\n    for i in range(N):\n        cost, effects = plans[i]\n        new_dp = dp.copy()\n        for state, cur_cost in dp.items():\n            # Compute new state\n            new_state_list = []\n            for j in range(K):\n                new_val = state[j] + effects[j]\n                if new_val > P:\n                    new_val = P\n                new_state_list.append(new_val)\n            new_state = tuple(new_state_list)\n            new_cost = cur_cost + cost\n            if new_state not in new_dp or new_dp[new_state] > new_cost:\n                new_dp[new_state] = new_cost\n        dp = new_dp\n    \n    # Find minimum cost among all states where all params >= P\n    min_cost = math.inf\n    for state, cost in dp.items():\n        if all(param >= P for param in state):\n            if cost < min_cost:\n                min_cost = cost\n                \n    if min_cost == math.inf:\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc323_a", "solution": "# Read input\nS = input().strip()\n\n# Define the 0-based indices corresponding to 1-based even positions (2, 4, ..., 16)\neven_positions = [1, 3, 5, 7, 9, 11, 13, 15]\n\n# Check if all characters at even positions are '0'\nall_zero = True\nfor pos in even_positions:\n    if S[pos] == '1':\n        all_zero = False\n        break\n\n# Output result\nif all_zero:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc323_b", "solution": "# Read the number of players\nN = int(input())\n\n# Read the result strings\nresults = []\nfor _ in range(N):\n    results.append(input().strip())\n\n# Calculate wins for each player\nplayers = []\nfor i in range(N):\n    wins = results[i].count('o')\n    players.append((wins, i + 1))  # (number of wins, player number)\n\n# Sort by wins (descending) and then by player number (ascending)\n# We use -wins to sort wins in descending order, and player number in ascending order\nplayers.sort(key=lambda x: (-x[0], x[1]))\n\n# Extract the player numbers in the sorted order\nranking = [str(player[1]) for player in players]\n\n# Print the result\nprint(' '.join(ranking))"}
{"task_id": "abc323_c", "solution": "# Read input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nS = []\nfor _ in range(N):\n    S.append(input().strip())\n\n# Calculate current scores for all players\ncurrent_scores = []\nfor i in range(N):\n    score = 0\n    for j in range(M):\n        if S[i][j] == 'o':\n            score += A[j]\n    score += (i + 1)  # Add bonus points (1-indexed)\n    current_scores.append(score)\n\n# For each player, calculate minimum problems to solve to beat all others\nresults = []\nfor i in range(N):\n    # Find the maximum score among all other players\n    max_other_score = 0\n    for j in range(N):\n        if i != j:\n            max_other_score = max(max_other_score, current_scores[j])\n    \n    # If already ahead of everyone\n    if current_scores[i] > max_other_score:\n        results.append(0)\n        continue\n    \n    # Get unsolved problems and their scores\n    unsolved_scores = []\n    for j in range(M):\n        if S[i][j] == 'x':\n            unsolved_scores.append(A[j])\n    \n    # Sort in descending order to pick highest value first\n    unsolved_scores.sort(reverse=True)\n    \n    # Keep adding problems until we exceed max_other_score\n    additional_score = 0\n    num_problems = 0\n    for score in unsolved_scores:\n        additional_score += score\n        num_problems += 1\n        if current_scores[i] + additional_score > max_other_score:\n            break\n    \n    results.append(num_problems)\n\n# Output results\nfor res in results:\n    print(res)"}
{"task_id": "abc323_d", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    idx = 1\n    \n    # Dictionary to hold for each base, a dictionary of exponent -> count\n    base_to_exp_count = defaultdict(lambda: defaultdict(int))\n    \n    for _ in range(N):\n        S = int(data[idx])\n        C = int(data[idx+1])\n        idx += 2\n        \n        # Factor out powers of 2 from S to get base and exponent\n        base = S\n        exp = 0\n        while base % 2 == 0:\n            base //= 2\n            exp += 1\n            \n        base_to_exp_count[base][exp] += C\n\n    total_slimes = 0\n    \n    # Process each base independently\n    for exp_count_map in base_to_exp_count.values():\n        # Get sorted list of exponents\n        exponents = sorted(exp_count_map.keys())\n        \n        carry = 0\n        for exp in exponents:\n            total = exp_count_map[exp] + carry\n            remainder = total % 2\n            carry = total // 2\n            total_slimes += remainder\n            \n        # Add any remaining carry (will contribute entirely as singles)\n        while carry > 0:\n            remainder = carry % 2\n            carry = carry // 2\n            total_slimes += remainder\n            \n    print(total_slimes)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc323_e", "solution": "def modinv(a, m=998244353):\n    return pow(a, m-2, m)\n\ndef main():\n    MOD = 998244353\n    \n    # Read input\n    N, X = map(int, input().split())\n    T = list(map(int, input().split()))\n    \n    # dp[t] represents the probability of starting a new song at time t\n    dp = [0] * (X + 1)\n    dp[0] = 1\n    \n    # Fill the dp array\n    for t in range(1, X + 1):\n        for i in range(N):\n            if t >= T[i]:\n                dp[t] = (dp[t] + dp[t - T[i]]) % MOD\n        dp[t] = (dp[t] * modinv(N)) % MOD\n    \n    # Calculate the probability that song 1 is playing at time X + 0.5\n    # This happens when song 1 starts at time s where s <= X < s + T[0]\n    # So s can be from max(0, X - T[0] + 1) to X\n    prob = 0\n    T1 = T[0]\n    for s in range(max(0, X - T1 + 1), X + 1):\n        # Probability of starting any song at time s and then picking song 1\n        prob = (prob + dp[s]) % MOD\n    \n    # Multiply by 1/N (probability of picking song 1)\n    result = (prob * modinv(N)) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_a", "solution": "# Read the number of elements\nN = int(input())\n\n# Read the list of integers\nA = list(map(int, input().split()))\n\n# Check if all elements are equal to the first element\nall_equal = True\nfor i in range(1, N):\n    if A[i] != A[0]:\n        all_equal = False\n        break\n\n# Print the result\nif all_equal:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc324_b", "solution": "# Read input\nN = int(input())\n\n# Keep dividing by 2 and 3 until we can't anymore\nwhile N % 2 == 0:\n    N //= 2\n\nwhile N % 3 == 0:\n    N //= 3\n\n# If we're left with 1, then N was of the form 2^x * 3^y\nif N == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc324_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Parse first line\n    first_line = data[0].split()\n    N = int(first_line[0])\n    T_prime = first_line[1]\n    \n    # Remaining lines are the N strings\n    S_list = data[1:N+1]\n    \n    len_T = len(T_prime)\n    results = []\n\n    for idx, S in enumerate(S_list, 1):  # 1-based indexing\n        len_S = len(S)\n        diff = len_T - len_S\n        \n        match = False\n        if diff == 0:\n            # Case 1: Equal or Substitution\n            count_diff = 0\n            for i in range(len_T):\n                if T_prime[i] != S[i]:\n                    count_diff += 1\n                    if count_diff > 1:\n                        break\n            if count_diff <= 1:\n                match = True\n                \n        elif diff == 1:\n            # Case 2: Deletion from T' gives S\n            i = j = 0\n            while i < len_T and j < len_S:\n                if T_prime[i] == S[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n            # After loop, either both reached end or one extra char in T'\n            if j == len_S:\n                match = True\n                \n        elif diff == -1:\n            # Case 3: Insertion into T' gives S => Deletion from S gives T'\n            i = j = 0\n            while i < len_T and j < len_S:\n                if T_prime[i] == S[j]:\n                    i += 1\n                    j += 1\n                else:\n                    j += 1\n            # After loop, either both reached end or one extra char in S\n            if i == len_T:\n                match = True\n        \n        if match:\n            results.append(idx)\n    \n    print(len(results))\n    if results:\n        print(' '.join(map(str, results)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_d", "solution": "from collections import Counter\nimport math\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    \n    # Count the frequency of digits in S\n    s_count = Counter(S)\n    \n    # Set to store unique square numbers that can be formed\n    valid_squares = set()\n    \n    # Determine the range of k such that k*k has at most N digits\n    # Minimum k is 0, maximum k is such that k*k < 10^N\n    max_square = 10 ** N\n    max_k = int(math.isqrt(max_square))\n    if max_k * max_k == max_square:\n        max_k -= 1  # We want k*k < 10^N\n    \n    # Iterate through all possible k values\n    k = 0\n    while k <= max_k:\n        square = k * k\n        square_str = str(square)\n        if len(square_str) > N:\n            break\n        # Pad with leading zeros to make length exactly N\n        padded_square_str = square_str.zfill(N)\n        # Count digit frequencies\n        square_count = Counter(padded_square_str)\n        # Check if digit counts match\n        if square_count == s_count:\n            valid_squares.add(square)\n        k += 1\n    \n    print(len(valid_squares))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_e", "solution": "import sys\nfrom collections import defaultdict\n\ndef compute_prefix_match(s, t):\n    \"\"\"Compute max prefix of t that is a subsequence of s.\"\"\"\n    i = 0\n    for ch in s:\n        if i < len(t) and ch == t[i]:\n            i += 1\n    return i\n\ndef compute_suffix_match(s, t):\n    \"\"\"Compute max suffix of t that is a subsequence of some suffix of s.\"\"\"\n    # Reverse both strings and reverse matching logic\n    rev_s = s[::-1]\n    rev_t = t[::-1]\n    i = 0\n    for ch in rev_s:\n        if i < len(rev_t) and ch == rev_t[i]:\n            i += 1\n    return i\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = data[1]\n    len_T = len(T)\n    \n    strings = data[2:2+N]\n    \n    prefix = [0]*N\n    suffix = [0]*N\n    \n    for idx, s in enumerate(strings):\n        prefix[idx] = compute_prefix_match(s, T)\n        suffix[idx] = compute_suffix_match(s, T)\n    \n    # Count frequencies of suffix values\n    suffix_count = [0] * (len_T + 1)\n    for val in suffix:\n        suffix_count[val] += 1\n        \n    # Build suffix sum array from right to left\n    suffix_sum = [0] * (len_T + 2)\n    for i in range(len_T, -1, -1):\n        suffix_sum[i] = suffix_sum[i+1] + suffix_count[i]\n        \n    res = 0\n    for i in range(N):\n        needed = len_T - prefix[i]\n        if needed <= 0:\n            res += N\n        else:\n            if needed <= len_T:\n                res += suffix_sum[needed]\n                \n    print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_f", "solution": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    M = int(data[idx+1])\n    idx += 2\n    \n    # Build adjacency list\n    graph = defaultdict(list)\n    edges = []\n    for _ in range(M):\n        u = int(data[idx]) - 1  # Convert to 0-indexed\n        v = int(data[idx+1]) - 1\n        b = int(data[idx+2])\n        c = int(data[idx+3])\n        idx += 4\n        graph[u].append((v, b, c))\n        edges.append((u, v, b, c))\n    \n    # Binary search on the answer\n    # We need to find the maximum r such that there exists a path with ratio >= r\n    # That is, sum(b_i) / sum(c_i) >= r => sum(b_i - r*c_i) >= 0\n    \n    def is_possible(r):\n        # For each edge, the weight becomes b - r*c\n        # We want to find the maximum weight path from 0 to N-1\n        # Since it's a DAG with u < v, we can use DP in order 0 to N-1\n        dp = [-float('inf')] * N\n        dp[0] = 0.0\n        for u in range(N):\n            if dp[u] == -float('inf'):\n                continue\n            for v, b, c in graph[u]:\n                w = b - r * c\n                if dp[u] + w > dp[v]:\n                    dp[v] = dp[u] + w\n        return dp[N-1] >= 0\n    \n    # Set precision for binary search\n    eps = 1e-12\n    low = 0.0\n    high = 1e9  # A large enough upper bound since b_i, c_i <= 1e4\n    \n    for _ in range(100):  # Enough iterations for the required precision\n        mid = (low + high) / 2\n        if is_possible(mid):\n            low = mid\n        else:\n            high = mid\n            \n    print(low)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_a", "solution": "# Read input from stdin\nline = input().strip()\n# Split the input into surname and first name\nparts = line.split()\nS = parts[0]  # surname\n# T = parts[1]  # first name (not needed for output)\n\n# Create the output string: surname + space + \"san\"\nresult = S + \" san\"\n\n# Print the result\nprint(result)"}
{"task_id": "abc325_b", "solution": "N = int(input())\nbases = []\nfor _ in range(N):\n    W, X = map(int, input().split())\n    bases.append((W, X))\n\nmax_employees = 0\n\n# Try every possible start time T in UTC from 0 to 23\nfor T in range(24):\n    total = 0\n    for W, X in bases:\n        # Calculate the local start time of the meeting at this base\n        local_start = (T + X) % 24\n        # Meeting lasts one hour, so ends at local_start + 1\n        # Employee can attend only if 9 <= local_start < local_start + 1 <= 18\n        # Which simplifies to 9 <= local_start <= 17\n        if 9 <= local_start <= 17:\n            total += W\n    if total > max_employees:\n        max_employees = total\n\nprint(max_employees)"}
{"task_id": "abc325_c", "solution": "from collections import deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    H, W = map(int, data[0].split())\n    grid = data[1:H+1]\n    \n    # Create a visited matrix\n    visited = [[False] * W for _ in range(H)]\n    \n    # Define 8 directions (horizontal, vertical, diagonal)\n    directions = [(-1,-1), (-1,0), (-1,1),\n                  (0,-1),           (0,1),\n                  (1,-1),  (1,0),  (1,1)]\n    \n    def bfs(start_row, start_col):\n        queue = deque()\n        queue.append((start_row, start_col))\n        visited[start_row][start_col] = True\n        \n        while queue:\n            row, col = queue.popleft()\n            \n            # Check all 8 neighbors\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n                \n                # Check bounds\n                if 0 <= nr < H and 0 <= nc < W:\n                    # Check if it's a sensor and not visited\n                    if grid[nr][nc] == '#' and not visited[nr][nc]:\n                        visited[nr][nc] = True\n                        queue.append((nr, nc))\n    \n    sensor_groups = 0\n    \n    # Iterate through each cell in the grid\n    for i in range(H):\n        for j in range(W):\n            # If we find an unvisited sensor, start a new group\n            if grid[i][j] == '#' and not visited[i][j]:\n                sensor_groups += 1\n                bfs(i, j)  # Mark all connected sensors as visited\n    \n    print(sensor_groups)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_d", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    intervals = []\n    \n    idx = 1\n    for i in range(N):\n        T = int(data[idx])\n        D = int(data[idx + 1])\n        idx += 2\n        intervals.append((T, T + D))  # [start, end]\n    \n    # Sort by end time, and for ties, by negative start time (longer intervals first)\n    intervals.sort(key=lambda x: (x[1], -x[0]))\n    \n    count = 0\n    last_print_time = -10**18  # A very small number to handle initial case\n    \n    for start, end in intervals:\n        # Earliest time we can print considering recharge time\n        earliest_possible = max(start, last_print_time + 1)\n        \n        # If we can print within this interval\n        if earliest_possible <= end:\n            count += 1\n            last_print_time = earliest_possible\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_e", "solution": "import heapq\nimport sys\n\ndef main():\n    # Read input\n    line1 = list(map(int, sys.stdin.readline().split()))\n    N, A, B, C = line1\n    D = []\n    for _ in range(N):\n        row = list(map(int, sys.stdin.readline().split()))\n        D.append(row)\n    \n    # Distance array: dist[i][mode] where mode=0 (car), mode=1 (train)\n    # Initialize with infinity\n    INF = float('inf')\n    dist = [[INF, INF] for _ in range(N)]\n    \n    # Priority queue for Dijkstra: (time, city_index, mode)\n    # mode: 0 = using company car, 1 = using train\n    pq = [(0, 0, 0)]  # Start at city 1 (index 0), using car, time 0\n    dist[0][0] = 0\n    \n    while pq:\n        current_time, u, mode = heapq.heappop(pq)\n        \n        # If we've found a better path already, skip\n        if current_time > dist[u][mode]:\n            continue\n            \n        # If we've reached the destination (city N, index N-1)\n        if u == N - 1:\n            print(current_time)\n            return\n            \n        # For each neighboring city\n        for v in range(N):\n            if u == v:\n                continue\n                \n            if mode == 0:  # Currently using company car\n                # Option 1: Continue using company car\n                car_time = current_time + D[u][v] * A\n                if car_time < dist[v][0]:\n                    dist[v][0] = car_time\n                    heapq.heappush(pq, (car_time, v, 0))\n                \n                # Option 2: Switch to train\n                train_time = current_time + D[u][v] * B + C\n                if train_time < dist[v][1]:\n                    dist[v][1] = train_time\n                    heapq.heappush(pq, (train_time, v, 1))\n            \n            else:  # mode == 1, currently using train\n                # Can only continue using train\n                train_time = current_time + D[u][v] * B + C\n                if train_time < dist[v][1]:\n                    dist[v][1] = train_time\n                    heapq.heappush(pq, (train_time, v, 1))\n    \n    # Find minimum time to reach city N (index N-1)\n    result = min(dist[N-1][0], dist[N-1][1])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_f", "solution": "import math\nfrom collections import defaultdict\n\ndef main():\n    # Read input\n    N = int(input())\n    D = list(map(int, input().split()))\n    L1, C1, K1 = map(int, input().split())\n    L2, C2, K2 = map(int, input().split())\n    \n    # Precompute valid combinations for each section\n    section_options = []\n    \n    for d in D:\n        options = []\n        # Try all possible numbers of type-1 sensors\n        max_type1 = min(K1, (d + L1 - 1) // L1)  # ceil(d / L1)\n        \n        for x in range(max_type1 + 1):\n            # Calculate minimum required type-2 sensors\n            remaining = max(0, d - x * L1)\n            y = (remaining + L2 - 1) // L2  # ceil(remaining / L2)\n            \n            # Check if we have enough type-2 sensors\n            if y <= K2:\n                cost = x * C1 + y * C2\n                options.append((x, y, cost))\n        \n        section_options.append(options)\n    \n    # Check if any section cannot be covered\n    for options in section_options:\n        if not options:\n            print(-1)\n            return\n    \n    # DP approach\n    # dp[j][k] = minimum cost to use exactly j type-1 and k type-2 sensors for processed sections\n    # Initialize with a large value\n    INF = float('inf')\n    dp = [[INF for _ in range(K2 + 1)] for _ in range(K1 + 1)]\n    dp[0][0] = 0\n    \n    # Process each section\n    for i in range(N):\n        new_dp = [[INF for _ in range(K2 + 1)] for _ in range(K1 + 1)]\n        \n        # For each current state\n        for j in range(K1 + 1):\n            for k in range(K2 + 1):\n                if dp[j][k] == INF:\n                    continue\n                    \n                # Try each option for the current section\n                for x, y, cost in section_options[i]:\n                    if j + x <= K1 and k + y <= K2:\n                        new_cost = dp[j][k] + cost\n                        if new_cost < new_dp[j + x][k + y]:\n                            new_dp[j + x][k + y] = new_cost\n        \n        dp = new_dp\n    \n    # Find the minimum cost among all valid states\n    result = INF\n    for j in range(K1 + 1):\n        for k in range(K2 + 1):\n            if dp[j][k] < result:\n                result = dp[j][k]\n    \n    if result == INF:\n        print(-1)\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc326_a", "solution": "# Read input\nX, Y = map(int, input().split())\n\n# Calculate the difference\ndiff = Y - X\n\n# Determine if stairs are used\nif (0 < diff <= 2) or (-3 <= diff < 0):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc326_b", "solution": "def is_326_like(num):\n    \"\"\"Check if a three-digit number is a 326-like number.\"\"\"\n    hundreds = num // 100\n    tens = (num // 10) % 10\n    ones = num % 10\n    return hundreds * tens == ones\n\ndef find_smallest_326_like(N):\n    \"\"\"Find the smallest 326-like number >= N.\"\"\"\n    current = N\n    while True:\n        if is_326_like(current):\n            return current\n        current += 1\n\n# Read input\nN = int(input())\n\n# Find and print the answer\nresult = find_smallest_326_like(N)\nprint(result)"}
{"task_id": "abc326_c", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Sort the gift positions\n    A.sort()\n    \n    # Sliding window approach\n    left = 0\n    max_gifts = 0\n    \n    for right in range(N):\n        # Shrink the window from the left until it's valid\n        while A[right] - A[left] >= M:\n            left += 1\n        \n        # Update the maximum number of gifts\n        max_gifts = max(max_gifts, right - left + 1)\n    \n    print(max_gifts)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc326_d", "solution": "import itertools\n\ndef solve():\n    N = int(input())\n    R = input().strip()\n    C = input().strip()\n    \n    # Generate all possible placements for a single row\n    # Each placement is a list of tuples (col_index, character)\n    def generate_row_placements(first_char):\n        placements = []\n        # Choose 3 distinct column positions\n        for cols in itertools.combinations(range(N), 3):\n            # The first character goes in the leftmost position\n            sorted_cols = sorted(cols)\n            first_col = sorted_cols[0]\n            \n            # Remaining two characters\n            remaining_chars = ['A', 'B', 'C']\n            remaining_chars.remove(first_char)\n            \n            # Permute the remaining characters in the remaining positions\n            for perm in itertools.permutations(remaining_chars):\n                placement = [(first_col, first_char)]\n                for i in range(2):\n                    placement.append((sorted_cols[i+1], perm[i]))\n                placements.append(placement)\n        return placements\n    \n    # Precompute all valid row placements\n    row_options = []\n    for i in range(N):\n        options = generate_row_placements(R[i])\n        row_options.append(options)\n    \n    # Try to find a valid combination using backtracking\n    grid = [['.' for _ in range(N)] for _ in range(N)]\n    col_first = [None] * N  # First character placed in each column\n    col_used = [set() for _ in range(N)]  # Characters already placed in each column\n    \n    def backtrack(row_idx):\n        if row_idx == N:\n            # Check if all columns have their required first character\n            for j in range(N):\n                if col_first[j] != C[j]:\n                    return False\n            return True\n        \n        # Try each valid placement for the current row\n        for placement in row_options[row_idx]:\n            # Check if this placement conflicts with column constraints\n            conflict = False\n            temp_first = []  # Temporary storage for changes to rollback\n            \n            # Check and apply column constraints\n            for col_idx, char in placement:\n                # If this column already has a character in this row, it's a conflict\n                if char in col_used[col_idx]:\n                    conflict = True\n                    break\n                    \n                # If this is the first time we're putting something in this column\n                if col_first[col_idx] is None:\n                    # This character becomes the first in the column\n                    # Check if it matches what C requires\n                    if C[col_idx] != char:\n                        conflict = True\n                        break\n                    temp_first.append(col_idx)\n                    col_first[col_idx] = char\n                \n                col_used[col_idx].add(char)\n            \n            if conflict:\n                # Rollback any changes made before detecting conflict\n                for col_idx, char in placement:\n                    if col_idx in temp_first:\n                        col_first[col_idx] = None\n                    col_used[col_idx].discard(char)\n                continue\n            \n            # Apply the placement to the grid\n            for col_idx, char in placement:\n                grid[row_idx][col_idx] = char\n            \n            # Recurse to the next row\n            if backtrack(row_idx + 1):\n                return True\n            \n            # Backtrack: undo changes\n            for col_idx, char in placement:\n                grid[row_idx][col_idx] = '.'\n                if col_idx in temp_first:\n                    col_first[col_idx] = None\n                col_used[col_idx].remove(char)\n        \n        return False\n    \n    if backtrack(0):\n        print(\"Yes\")\n        for row in grid:\n            print(''.join(row))\n    else:\n        print(\"No\")\n\nsolve()"}
{"task_id": "abc326_e", "solution": "MOD = 998244353\n\ndef modinv(a):\n    return pow(a, MOD - 2, MOD)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # E[i] = expected salary starting with current max = i\n    # We compute E[i] for i from N down to 0\n    # Base case: E[N] = 0\n    \n    E = [0] * (N + 1)\n    \n    # Suffix sums for efficiency\n    # sum_A[i] = sum of A[j] for j from i to N-1\n    # sum_E[i] = sum of E[j] for j from i to N-1\n    \n    sum_A = [0] * (N + 1)\n    sum_E = [0] * (N + 1)\n    \n    # Fill suffix sums from right to left\n    for i in range(N - 1, -1, -1):\n        sum_A[i] = (sum_A[i + 1] + A[i]) % MOD\n        sum_E[i] = (sum_E[i + 1] + E[i + 1]) % MOD\n        \n        # Compute E[i] = (sum_A[i+1] + sum_E[i+1]) / N\n        numerator = (sum_A[i + 1] + sum_E[i + 1]) % MOD\n        E[i] = (numerator * modinv(N)) % MOD\n    \n    print(E[0])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc327_a", "solution": "# Read input\nN = int(input())\nS = input()\n\n# Flag to track if we found adjacent a and b\nfound = False\n\n# Check each adjacent pair\nfor i in range(N - 1):\n    # If current char is 'a' and next is 'b', or current is 'b' and next is 'a'\n    if (S[i] == 'a' and S[i + 1] == 'b') or (S[i] == 'b' and S[i + 1] == 'a'):\n        found = True\n        break\n\n# Print result\nif found:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc327_b", "solution": "# Read the input\nB = int(input().strip())\n\n# Iterate through possible values of A\n# Since A^A grows very fast, we don't need to check beyond ~60\nfound = False\nfor A in range(1, 61):\n    # Calculate A^A\n    power = A ** A\n    \n    # If we found a match, print A and exit\n    if power == B:\n        print(A)\n        found = True\n        break\n    # If A^A exceeds B, no need to check further since A^A is increasing\n    elif power > B:\n        break\n\n# If no A was found such that A^A = B\nif not found:\n    print(-1)"}
{"task_id": "abc327_c", "solution": "# Read the 9x9 grid\ngrid = []\nfor _ in range(9):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# Function to check if a list of 9 numbers contains 1-9 exactly once\ndef is_valid_unit(unit):\n    return sorted(unit) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Check all rows\ndef check_rows(grid):\n    for row in grid:\n        if not is_valid_unit(row):\n            return False\n    return True\n\n# Check all columns\ndef check_columns(grid):\n    for col_idx in range(9):\n        column = [grid[row_idx][col_idx] for row_idx in range(9)]\n        if not is_valid_unit(column):\n            return False\n    return True\n\n# Check all 3x3 subgrids\ndef check_subgrids(grid):\n    for box_row in range(3):\n        for box_col in range(3):\n            # Extract the 3x3 subgrid\n            subgrid = []\n            for i in range(3):\n                for j in range(3):\n                    subgrid.append(grid[box_row * 3 + i][box_col * 3 + j])\n            if not is_valid_unit(subgrid):\n                return False\n    return True\n\n# Check all three conditions\nif check_rows(grid) and check_columns(grid) and check_subgrids(grid):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc327_d", "solution": "import sys\nfrom collections import deque\n\ndef main():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        print(\"Yes\")\n        return\n    \n    A = list(map(int, data[2:2+M]))\n    B = list(map(int, data[2+M:2+2*M]))\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N+1)]\n    \n    for i in range(M):\n        a = A[i]\n        b = B[i]\n        if a == b:\n            print(\"No\")\n            return\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Color array: 0 = unvisited, 1 and -1 are the two colors\n    color = [0] * (N + 1)\n    \n    # Check if bipartite using BFS\n    def is_bipartite(start):\n        queue = deque()\n        queue.append(start)\n        color[start] = 1\n        \n        while queue:\n            u = queue.popleft()\n            current_color = color[u]\n            \n            for v in adj[u]:\n                if color[v] == 0:\n                    color[v] = -current_color\n                    queue.append(v)\n                elif color[v] == current_color:\n                    return False\n        return True\n    \n    # Process all components\n    for i in range(1, N+1):\n        if color[i] == 0 and adj[i]:  # Unvisited node with edges\n            if not is_bipartite(i):\n                print(\"No\")\n                return\n                \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc327_e", "solution": "import math\n\ndef main():\n    # Read input\n    N = int(input())\n    P = list(map(int, input().split()))\n\n    max_rating = float('-inf')\n\n    # Precompute powers of 0.9\n    pow09 = [1.0] * (N + 1)\n    for i in range(1, N + 1):\n        pow09[i] = pow09[i-1] * 0.9\n\n    # For each possible number of contests k from 1 to N\n    for k in range(1, N + 1):\n        # Initialize DP table\n        # dp[i][j] represents the maximum weighted sum by choosing j elements from first i elements\n        dp = [[float('-inf')] * (k + 1) for _ in range(N + 1)]\n        dp[0][0] = 0.0\n\n        # Fill DP table\n        for i in range(1, N + 1):\n            dp[i][0] = 0.0\n            for j in range(1, min(i, k) + 1):\n                # Weight for the j-th selected element among k total selected elements\n                weight = pow09[k - j]\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + weight * P[i-1])\n\n        # Calculate denominator (sum of weights)\n        weight_sum = sum(pow09[k - i] for i in range(1, k + 1))\n\n        # Calculate rating for this k\n        if weight_sum > 0:\n            weighted_avg = dp[N][k] / weight_sum\n            penalty = 1200.0 / math.sqrt(k)\n            rating = weighted_avg - penalty\n            max_rating = max(max_rating, rating)\n\n    print(max_rating)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc328_a", "solution": "# Read the first line to get N and X\nN, X = map(int, input().split())\n\n# Read the second line to get the list of scores\nscores = list(map(int, input().split()))\n\n# Calculate the total score for problems with score <= X\ntotal_score = sum(score for score in scores if score <= X)\n\n# Print the result\nprint(total_score)"}
{"task_id": "abc328_b", "solution": "# Read input\nN = int(input())\nD = list(map(int, input().split()))\n\n# Generate repdigit candidates for digits 1 through 9\nrepdigit_map = {}\nfor d in range(1, 10):\n    repdigits = []\n    # Add single digit number\n    repdigits.append(d)\n    # Add double digit number if applicable\n    dd = d * 10 + d\n    if dd <= 100:\n        repdigits.append(dd)\n    repdigit_map[d] = repdigits\n\ncount = 0\n\n# For each digit d from 1 to 9\nfor d in range(1, 10):\n    repdigits = repdigit_map[d]\n    # For each repdigit month formed by digit d\n    for month in repdigits:\n        # Check if this month is within the valid month range [1, N]\n        if 1 <= month <= N:\n            # For each repdigit day formed by the same digit d\n            for day in repdigits:\n                # Check if the day is within the valid day range for this month\n                if 1 <= day <= D[month - 1]:\n                    count += 1\n\nprint(count)"}
{"task_id": "abc328_c", "solution": "# Read input\nN, Q = map(int, input().split())\nS = input().strip()\n\n# Preprocessing: Create adjacency array\nadj = [0] * N\nfor i in range(N - 1):\n    if S[i] == S[i + 1]:\n        adj[i] = 1\n    else:\n        adj[i] = 0\n\n# Build prefix sum array\nprefix = [0] * (N + 1)\nfor i in range(N):\n    prefix[i + 1] = prefix[i] + adj[i]\n\n# Process queries\nfor _ in range(Q):\n    l, r = map(int, input().split())\n    # Convert to 0-based indexing\n    left = l - 1\n    right = r - 1\n    \n    # If substring length is 1, answer is 0\n    if left == right:\n        print(0)\n    else:\n        # Count adjacent pairs in range [left, right-1]\n        result = prefix[right] - prefix[left]\n        print(result)"}
{"task_id": "abc328_d", "solution": "def main():\n    S = input().strip()\n    stack = []\n    \n    for char in S:\n        stack.append(char)\n        # Check if the last three characters form \"ABC\"\n        if len(stack) >= 3 and stack[-3] == 'A' and stack[-2] == 'B' and stack[-1] == 'C':\n            # Remove the last three characters (the \"ABC\")\n            stack.pop()  # Remove 'C'\n            stack.pop()  # Remove 'B'\n            stack.pop()  # Remove 'A'\n    \n    # Convert the stack back to a string\n    result = ''.join(stack)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc328_e", "solution": "import sys\nfrom itertools import combinations\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False  # Cycle detected\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n    \n    def connected(self, n):\n        root = self.find(0)\n        return all(self.find(i) == root for i in range(n))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    K = int(data[idx]); idx += 1\n    \n    edges = []\n    for _ in range(M):\n        u = int(data[idx]) - 1; idx += 1\n        v = int(data[idx]) - 1; idx += 1\n        w = int(data[idx]); idx += 1\n        edges.append((w, u, v))\n    \n    min_cost = K  # Initialize to maximum possible cost before mod\n    # Try all combinations of N-1 edges\n    for combo in combinations(edges, N - 1):\n        uf = UnionFind(N)\n        total_weight = 0\n        valid = True\n        for w, u, v in combo:\n            if not uf.union(u, v):\n                valid = False\n                break\n            total_weight += w\n        if valid and uf.connected(N):\n            cost = total_weight % K\n            if cost < min_cost:\n                min_cost = cost\n                \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc329_a", "solution": "# Read input\nS = input().strip()\n\n# Separate each character with a space and print\nresult = ' '.join(S)\nprint(result)"}
{"task_id": "abc329_b", "solution": "# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum value\nmax_val = max(a)\n\n# Filter out all instances of the maximum value\nfiltered_vals = [x for x in a if x < max_val]\n\n# Find the maximum among the filtered values\nresult = max(filtered_vals)\n\n# Print the result\nprint(result)"}
{"task_id": "abc329_c", "solution": "# Read input\nN = int(input())\nS = input().strip()\n\n# Dictionary to store the maximum consecutive count for each character\nmax_consecutive = {}\n\ni = 0\nwhile i < N:\n    current_char = S[i]\n    count = 0\n    # Count consecutive occurrences of the same character\n    while i < N and S[i] == current_char:\n        count += 1\n        i += 1\n    \n    # Update the maximum consecutive count for this character\n    if current_char in max_consecutive:\n        max_consecutive[current_char] = max(max_consecutive[current_char], count)\n    else:\n        max_consecutive[current_char] = count\n\n# Sum up the maximum consecutive counts for all characters\nresult = sum(max_consecutive.values())\nprint(result)"}
{"task_id": "abc329_d", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    votes = list(map(int, data[2:]))\n    \n    # vote_count[i] represents the number of votes for candidate i\n    vote_count = [0] * (N + 1)\n    \n    # Initialize current winner and their vote count\n    current_winner = 0\n    max_votes = 0\n    \n    result = []\n    \n    for i in range(M):\n        candidate = votes[i]\n        vote_count[candidate] += 1\n        \n        # Check if we need to update the current winner\n        if (vote_count[candidate] > max_votes) or \\\n           (vote_count[candidate] == max_votes and candidate < current_winner):\n            current_winner = candidate\n            max_votes = vote_count[candidate]\n            \n        result.append(str(current_winner))\n        \n    print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc329_e", "solution": "from collections import deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    S = data[2]\n    T = data[3]\n    \n    # Initial state is S, target is all '#'\n    initial_state = list(S)\n    target = ['#'] * N\n    \n    # Convert to tuple for hashing\n    initial_tuple = tuple(initial_state)\n    target_tuple = tuple(target)\n    \n    if initial_tuple == target_tuple:\n        print(\"Yes\")\n        return\n\n    queue = deque()\n    visited = set()\n    \n    queue.append(initial_tuple)\n    visited.add(initial_tuple)\n    \n    while queue:\n        current = list(queue.popleft())\n        \n        # Try applying reverse operation: find T and replace with ###\n        for i in range(N - M + 1):\n            # Check if substring matches T\n            match = True\n            for j in range(M):\n                if current[i + j] != T[j]:\n                    match = False\n                    break\n            \n            if match:\n                # Create new state by replacing with '#'\n                new_state = current[:]\n                for j in range(M):\n                    new_state[i + j] = '#'\n                \n                new_tuple = tuple(new_state)\n                \n                if new_tuple == target_tuple:\n                    print(\"Yes\")\n                    return\n                \n                if new_tuple not in visited:\n                    visited.add(new_tuple)\n                    queue.append(new_tuple)\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc329_f", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    Q = int(data[idx+1])\n    idx += 2\n    \n    # Read initial colors\n    C = [0] * (N + 1)  # 1-indexed\n    for i in range(1, N + 1):\n        C[i] = int(data[idx])\n        idx += 1\n    \n    # Initialize boxes with their color sets\n    boxes = [set() for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        boxes[i].add(C[i])\n    \n    # Process queries\n    results = []\n    for _ in range(Q):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        idx += 2\n        \n        # Move all balls from box a to box b\n        boxes[b].update(boxes[a])\n        boxes[a].clear()\n        \n        # Record number of different colors in box b\n        results.append(str(len(boxes[b])))\n    \n    # Output results\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc330_a", "solution": "# Read the first line: N and L\nN, L = map(int, input().split())\n\n# Read the second line: scores of N people\nscores = list(map(int, input().split()))\n\n# Count how many people passed (score >= L)\ncount_passed = 0\nfor score in scores:\n    if score >= L:\n        count_passed += 1\n\n# Output the result\nprint(count_passed)"}
{"task_id": "abc330_b", "solution": "# Read input\nN, L, R = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute Xi for each Ai\nresult = []\nfor a in A:\n    x = max(L, min(R, a))\n    result.append(x)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"task_id": "abc330_c", "solution": "import math\n\ndef main():\n    D = int(input().strip())\n    \n    min_diff = D  # Initialize with worst case (when x=y=0)\n    \n    max_x = int(math.sqrt(D)) + 1\n    \n    for x in range(max_x + 1):\n        x_squared = x * x\n        \n        # Early termination if x^2 is already too large to improve result\n        if x_squared > D + min_diff:\n            break\n            \n        residual = D - x_squared\n        \n        if residual < 0:\n            # Best y is 0 when residual is negative\n            diff = abs(residual)\n            if diff < min_diff:\n                min_diff = diff\n        else:\n            # Find the best y by checking floor and ceiling of sqrt(residual)\n            s = int(math.sqrt(residual))\n            for y in [s, s+1]:\n                if y >= 0:  # y must be non-negative\n                    sum_squares = x_squared + y * y\n                    diff = abs(sum_squares - D)\n                    if diff < min_diff:\n                        min_diff = diff\n                        if min_diff == 0:\n                            print(0)\n                            return\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc330_d", "solution": "# Read input\nN = int(input())\ngrid = []\nfor _ in range(N):\n    grid.append(input().strip())\n\n# Precompute row and column counts of 'o'\nrow_count = [0] * N\ncol_count = [0] * N\n\nfor i in range(N):\n    for j in range(N):\n        if grid[i][j] == 'o':\n            row_count[i] += 1\n            col_count[j] += 1\n\n# Calculate the number of valid triples\nresult = 0\nfor i in range(N):\n    for j in range(N):\n        if grid[i][j] == 'o':\n            # For each 'o' at (i,j), count how many valid triples can be formed\n            # by pairing with another 'o' in the same row and another in the same column\n            # Exclude the current cell itself from both counts\n            result += (row_count[i] - 1) * (col_count[j] - 1)\n\nprint(result)"}
{"task_id": "abc330_e", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    A = list(map(int, data[2:2+N]))\n    \n    # We only care about values in [0, N] for mex\n    # count[v] = how many times value v appears in A, for v in [0, N]\n    count = [0] * (N + 2)  # index 0 to N+1 to avoid boundary issues\n    \n    for a in A:\n        if 0 <= a <= N:\n            count[a] += 1\n            \n    # Find initial mex\n    mex = 0\n    while mex <= N and count[mex] > 0:\n        mex += 1\n        \n    # Process queries\n    index = 2 + N\n    results = []\n    \n    for _ in range(Q):\n        i_k = int(data[index]) - 1  # Convert to 0-based\n        x_k = int(data[index + 1])\n        old_val = A[i_k]\n        \n        # Remove old value from count if it's in range\n        if 0 <= old_val <= N:\n            count[old_val] -= 1\n            if count[old_val] == 0 and old_val < mex:\n                mex = old_val\n                \n        # Update array\n        A[i_k] = x_k\n        \n        # Add new value to count if it's in range\n        if 0 <= x_k <= N:\n            count[x_k] += 1\n            \n        # Update mex\n        while mex <= N and count[mex] > 0:\n            mex += 1\n            \n        results.append(str(mex))\n        index += 2\n        \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc331_a", "solution": "# Read input\nM, D = map(int, input().split())\ny, m, d = map(int, input().split())\n\n# Increment the day\nd += 1\n\n# Check if we've exceeded the number of days in a month\nif d > D:\n    d = 1\n    m += 1\n    \n    # Check if we've exceeded the number of months in a year\n    if m > M:\n        m = 1\n        y += 1\n\n# Print the result\nprint(y, m, d)"}
{"task_id": "abc331_b", "solution": "import math\n\n# Read input\nN, S, M, L = map(int, input().split())\n\nmin_cost = float('inf')\n\n# Try all combinations of 6-packs (a) and 8-packs (b)\n# Upper bound is set to 20 since 20 * 6 = 120 > 100 (max N)\nfor a in range(20):  # number of 6-egg packs\n    for b in range(20):  # number of 8-egg packs\n        eggs_so_far = 6 * a + 8 * b\n        remaining_eggs = N - eggs_so_far\n        \n        if remaining_eggs <= 0:\n            # Already have enough eggs\n            c = 0\n        else:\n            # Need to buy at least ceil(remaining_eggs / 12) packs of 12\n            c = math.ceil(remaining_eggs / 12)\n        \n        total_cost = a * S + b * M + c * L\n        min_cost = min(min_cost, total_cost)\n\nprint(min_cost)"}
{"task_id": "abc331_c", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    # Read input\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # Create (value, index) pairs and sort by value in descending order\n    indexed_A = [(A[i], i) for i in range(N)]\n    indexed_A.sort(reverse=True)\n    \n    # Initialize result array\n    result = [0] * N\n    \n    # Process elements in groups of same values\n    i = 0\n    running_sum = 0\n    \n    while i < N:\n        # Find the end of current group (same value)\n        current_value = indexed_A[i][0]\n        j = i\n        \n        # Extend j to include all elements with the same value\n        while j < N and indexed_A[j][0] == current_value:\n            j += 1\n            \n        # For all elements in this group, their answer is the current running_sum\n        for k in range(i, j):\n            _, original_index = indexed_A[k]\n            result[original_index] = running_sum\n            \n        # Add all elements in this group to running_sum\n        for k in range(i, j):\n            value, _ = indexed_A[k]\n            running_sum += value\n            \n        # Move to next group\n        i = j\n    \n    # Print result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc331_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    # Read the pattern\n    P = []\n    index = 2\n    for i in range(N):\n        P.append(data[index])\n        index += 1\n    \n    # Build prefix sum array\n    # prefix[i][j] = number of black squares in rectangle from (0,0) to (i-1,j-1)\n    prefix = [[0] * (N + 1) for _ in range(N + 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            prefix[i+1][j+1] = (\n                prefix[i][j+1] + \n                prefix[i+1][j] - \n                prefix[i][j] + \n                (1 if P[i][j] == 'B' else 0)\n            )\n    \n    # Function to get count of black squares in a rectangle within one tile\n    def get_count(r1, c1, r2, c2):\n        return (\n            prefix[r2+1][c2+1] - \n            prefix[r1][c2+1] - \n            prefix[r2+1][c1] + \n            prefix[r1][c1]\n        )\n    \n    # Total black squares in one full tile\n    total_in_tile = prefix[N][N]\n    \n    results = []\n    \n    # Process queries\n    for _ in range(Q):\n        A = int(data[index])\n        B = int(data[index+1])\n        C = int(data[index+2])\n        D = int(data[index+3])\n        index += 4\n        \n        # Rectangle is from (A,B) to (C,D) inclusive\n        height = C - A + 1\n        width = D - B + 1\n        \n        # Number of complete tiles\n        full_tiles_vertical = height // N\n        full_tiles_horizontal = width // N\n        \n        # Remaining partial rows/columns\n        partial_rows = height % N\n        partial_cols = width % N\n        \n        # Count black squares\n        count = 0\n        \n        # Full tiles\n        count += full_tiles_vertical * full_tiles_horizontal * total_in_tile\n        \n        # Partial columns strip (top part if there are partial rows)\n        if partial_rows > 0:\n            count += full_tiles_horizontal * get_count(A % N, 0, (A + partial_rows - 1) % N, N - 1)\n        \n        # Partial rows strip (left part if there are partial cols)\n        if partial_cols > 0:\n            count += full_tiles_vertical * get_count(0, B % N, N - 1, (B + partial_cols - 1) % N)\n        \n        # Corner rectangle (partial rows and partial columns)\n        if partial_rows > 0 and partial_cols > 0:\n            count += get_count(A % N, B % N, (A + partial_rows - 1) % N, (B + partial_cols - 1) % N)\n        \n        results.append(str(count))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc331_e", "solution": "import heapq\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    M = int(data[idx+1])\n    L = int(data[idx+2])\n    idx += 3\n    \n    a = [0]*N\n    for i in range(N):\n        a[i] = int(data[idx])\n        idx += 1\n        \n    b = [0]*M\n    for i in range(M):\n        b[i] = int(data[idx])\n        idx += 1\n        \n    # Store forbidden pairs in a set for O(1) lookup\n    forbidden = set()\n    for _ in range(L):\n        c = int(data[idx]) - 1  # Convert to 0-based index\n        d = int(data[idx+1]) - 1\n        forbidden.add((c, d))\n        idx += 2\n    \n    # Create sorted indices based on values in descending order\n    # We want the most expensive items first\n    a_indices_sorted = sorted(range(N), key=lambda i: a[i], reverse=True)\n    b_indices_sorted = sorted(range(M), key=lambda i: b[i], reverse=True)\n    \n    # Max heap simulation using negative values\n    # Each entry: (-sum, a_index_in_sorted_list, b_index_in_sorted_list)\n    heap = []\n    visited = set()\n    \n    # Start with the maximum possible sum\n    heapq.heappush(heap, (-(a[a_indices_sorted[0]] + b[b_indices_sorted[0]]), 0, 0))\n    visited.add((0, 0))\n    \n    while heap:\n        neg_sum, i, j = heapq.heappop(heap)\n        current_sum = -neg_sum\n        actual_i = a_indices_sorted[i]\n        actual_j = b_indices_sorted[j]\n        \n        # Check if this combination is not forbidden\n        if (actual_i, actual_j) not in forbidden:\n            print(current_sum)\n            return\n            \n        # Generate neighbors: move to next smaller a or next smaller b\n        # Neighbor 1: decrease i (next largest a)\n        if i + 1 < N and (i+1, j) not in visited:\n            new_sum = a[a_indices_sorted[i+1]] + b[b_indices_sorted[j]]\n            heapq.heappush(heap, (-new_sum, i+1, j))\n            visited.add((i+1, j))\n            \n        # Neighbor 2: decrease j (next largest b)\n        if j + 1 < M and (i, j+1) not in visited:\n            new_sum = a[a_indices_sorted[i]] + b[b_indices_sorted[j+1]]\n            heapq.heappush(heap, (-new_sum, i, j+1))\n            visited.add((i, j+1))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc332_a", "solution": "# Read N, S, K\nN, S, K = map(int, input().split())\n\n# Initialize total product cost\ntotal_cost = 0\n\n# Read each product's price and quantity and accumulate total cost\nfor _ in range(N):\n    P, Q = map(int, input().split())\n    total_cost += P * Q\n\n# Determine if shipping fee is needed\nif total_cost < S:\n    total_cost += K\n\n# Output the final amount to pay\nprint(total_cost)"}
{"task_id": "abc332_b", "solution": "# Read input\nK, G, M = map(int, input().split())\n\n# Initialize glass and mug\nglass = 0\nmug = 0\n\n# Perform K operations\nfor _ in range(K):\n    if glass == G:\n        # Glass is full, empty it\n        glass = 0\n    elif mug == 0:\n        # Mug is empty, fill it\n        mug = M\n    else:\n        # Transfer water from mug to glass\n        # Transfer amount is minimum of:\n        # 1. How much water is in the mug\n        # 2. How much space is left in the glass\n        transfer_amount = min(mug, G - glass)\n        glass += transfer_amount\n        mug -= transfer_amount\n\n# Print final amounts\nprint(glass, mug)"}
{"task_id": "abc332_c", "solution": "N, M = map(int, input().split())\nS = input().strip()\n\n# Split the string into segments separated by '0'\nsegments = []\ncurrent_segment = \"\"\n\nfor char in S:\n    if char == '0':\n        if current_segment:\n            segments.append(current_segment)\n            current_segment = \"\"\n    else:\n        current_segment += char\n\n# Don't forget the last segment if it doesn't end with '0'\nif current_segment:\n    segments.append(current_segment)\n\nmax_logo_needed = 0\n\nfor segment in segments:\n    L = len(segment)  # Total days in this segment\n    c1 = segment.count('1')  # Days for meals\n    c2 = segment.count('2')  # Days for contests\n    \n    # We need to wear something on each day, so L shirts total\n    # We have M plain shirts available for this segment\n    # We can use min(c1, M) plain shirts for '1' days\n    # So we need L - min(c1, M) other shirts\n    # At least c2 of these must be logo shirts (for '2' days)\n    # So we need max(c2, L - min(c1, M)) logo shirts for this segment\n    logo_needed = max(c2, L - min(c1, M))\n    max_logo_needed = max(max_logo_needed, logo_needed)\n\nprint(max_logo_needed)"}
{"task_id": "abc332_d", "solution": "from itertools import permutations\n\ndef count_inversions(perm):\n    \"\"\"Count the number of inversions in a permutation (minimum adjacent swaps).\"\"\"\n    inv_count = 0\n    for i in range(len(perm)):\n        for j in range(i + 1, len(perm)):\n            if perm[i] > perm[j]:\n                inv_count += 1\n    return inv_count\n\ndef apply_permutation_grid(grid, row_perm, col_perm):\n    \"\"\"Apply row and column permutations to a grid.\"\"\"\n    # Apply row permutation\n    new_grid = [None] * len(grid)\n    for i in range(len(grid)):\n        new_grid[row_perm[i]] = grid[i][:]\n    \n    # Apply column permutation\n    final_grid = [[None] * len(new_grid[0]) for _ in range(len(new_grid))]\n    for j in range(len(new_grid[0])):\n        for i in range(len(new_grid)):\n            final_grid[i][col_perm[j]] = new_grid[i][j]\n            \n    return final_grid\n\ndef solve():\n    # Read input\n    H, W = map(int, input().split())\n    A = []\n    B = []\n    \n    for _ in range(H):\n        row = list(map(int, input().split()))\n        A.append(row)\n        \n    for _ in range(H):\n        row = list(map(int, input().split()))\n        B.append(row)\n    \n    # Generate all possible row and column permutations\n    row_indices = list(range(H))\n    col_indices = list(range(W))\n    \n    row_perms = list(permutations(row_indices))\n    col_perms = list(permutations(col_indices))\n    \n    min_operations = float('inf')\n    \n    # Try all combinations of row and column permutations\n    for r_perm in row_perms:\n        for c_perm in col_perms:\n            # Convert tuples to lists\n            r_perm_list = list(r_perm)\n            c_perm_list = list(c_perm)\n            \n            # Apply permutation to A\n            transformed_A = [[A[r_perm_list[i]][c_perm_list[j]] for j in range(W)] for i in range(H)]\n            \n            # Check if it matches B\n            if transformed_A == B:\n                # Count inversions (minimum adjacent swaps)\n                row_swaps = count_inversions(r_perm_list)\n                col_swaps = count_inversions(c_perm_list)\n                total_swaps = row_swaps + col_swaps\n                min_operations = min(min_operations, total_swaps)\n    \n    # Output result\n    if min_operations == float('inf'):\n        print(-1)\n    else:\n        print(min_operations)\n\n# Run the solution\nsolve()"}
{"task_id": "abc333_a", "solution": "# Read the input\nN = int(input())\n\n# Convert N to string and repeat it N times\nresult = str(N) * N\n\n# Print the result\nprint(result)"}
{"task_id": "abc333_b", "solution": "# Read input\nS1S2 = input().strip()\nT1T2 = input().strip()\n\n# Map vertices to indices\nvertex_to_index = {\n    'A': 0,\n    'B': 1,\n    'C': 2,\n    'D': 3,\n    'E': 4\n}\n\n# Function to calculate the minimum distance between two vertices in a pentagon\ndef min_distance(v1, v2):\n    idx1 = vertex_to_index[v1]\n    idx2 = vertex_to_index[v2]\n    diff = abs(idx1 - idx2)\n    return min(diff, 5 - diff)\n\n# Calculate distances for both pairs\ndist_S = min_distance(S1S2[0], S1S2[1])\ndist_T = min_distance(T1T2[0], T1T2[1])\n\n# Check if both distances are the same\nif dist_S == dist_T:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc333_c", "solution": "# Read input\nN = int(input())\n\n# Generate repunits with lengths from 1 to 20\nrepunits = []\nfor i in range(1, 21):\n    repunit = int('1' * i)\n    repunits.append(repunit)\n\n# Generate all possible sums of three repunits (with repetition)\nsums_set = set()\nfor i in range(len(repunits)):\n    for j in range(i, len(repunits)):\n        for k in range(j, len(repunits)):\n            s = repunits[i] + repunits[j] + repunits[k]\n            sums_set.add(s)\n\n# Convert to sorted list\nsums_list = sorted(sums_set)\n\n# Output the N-th smallest sum (1-indexed)\nprint(sums_list[N - 1])"}
{"task_id": "abc333_d", "solution": "import sys\nfrom collections import defaultdict\nimport heapq\n\ndef main():\n    N = int(sys.stdin.readline())\n    \n    # Build adjacency list\n    adj = defaultdict(list)\n    for _ in range(N - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Special case: if node 1 is already a leaf\n    if len(adj[1]) <= 1:\n        print(1)\n        return\n    \n    # DFS to compute dp values\n    # dp[u] = minimum operations to delete node u\n    dp = [0] * (N + 1)\n    visited = [False] * (N + 1)\n    \n    def dfs(u):\n        visited[u] = True\n        children = []\n        \n        # Get unvisited neighbors (children in rooted tree)\n        for v in adj[u]:\n            if not visited[v]:\n                dfs(v)\n                children.append(dp[v])\n        \n        if not children:  # Leaf node\n            if u == 1:\n                dp[u] = 1  # Node 1 is a leaf, delete it in 1 operation\n            else:\n                dp[u] = 1  # Other leaf nodes take 1 operation to delete\n        else:\n            # Sort children by their dp values\n            children.sort()\n            \n            if u == 1:\n                # For root node 1, we must delete ALL children, then delete 1\n                dp[u] = sum(children) + 1\n            else:\n                # For other nodes, we delete all but one child (keep cheapest to consume this node)\n                # We delete (len(children) - 1) children\n                if len(children) == 1:\n                    dp[u] = 1  # Delete the one child, then this node becomes leaf and gets deleted\n                else:\n                    dp[u] = sum(children[:-1]) + 1  # Sum of smallest (len-1) values + 1 for deleting this node\n    \n    dfs(1)\n    print(dp[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc333_e", "solution": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N = int(sys.stdin.readline())\n    events = []\n    potion_count = defaultdict(int)\n    monster_count = defaultdict(int)\n    \n    for i in range(N):\n        t, x = map(int, sys.stdin.readline().split())\n        events.append((t, x))\n        if t == 1:\n            potion_count[x] += 1\n        else:\n            monster_count[x] += 1\n    \n    # Check if it's possible at all\n    for monster_type, count in monster_count.items():\n        if potion_count[monster_type] < count:\n            print(-1)\n            return\n    \n    # Precompute future monster counts\n    future_monsters = [defaultdict(int) for _ in range(N + 1)]\n    for i in range(N - 1, -1, -1):\n        t, x = events[i]\n        future_monsters[i] = future_monsters[i + 1].copy()\n        if t == 2:\n            future_monsters[i][x] += 1\n    \n    def simulate(max_potions):\n        current_potions = defaultdict(int)\n        total_potions = 0\n        actions = []\n        \n        for i in range(N):\n            t, x = events[i]\n            if t == 1:  # Found a potion\n                # Decide whether to pick it up\n                # Pick it up if we still need it and have space\n                if future_monsters[i + 1][x] > current_potions[x] and total_potions < max_potions:\n                    actions.append(1)\n                    current_potions[x] += 1\n                    total_potions += 1\n                else:\n                    actions.append(0)\n            else:  # Encountered a monster\n                if current_potions[x] > 0:\n                    current_potions[x] -= 1\n                    total_potions -= 1\n                else:\n                    return False, []  # Cannot defeat monster\n        \n        return True, actions\n    \n    # Binary search on the answer\n    left, right = 0, N\n    result_k = -1\n    result_actions = []\n    \n    while left <= right:\n        mid = (left + right) // 2\n        success, actions = simulate(mid)\n        if success:\n            result_k = mid\n            result_actions = actions\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    if result_k == -1:\n        print(-1)\n    else:\n        print(result_k)\n        # Only print actions for potion-finding events\n        potion_actions = []\n        action_idx = 0\n        for t, x in events:\n            if t == 1:\n                potion_actions.append(str(result_actions[action_idx]))\n            if t == 1:\n                action_idx += 1\n        print(' '.join(potion_actions))\n\nsolve()"}
{"task_id": "abc334_a", "solution": "# Read the input\nB, G = map(int, input().split())\n\n# Compare and determine which item is more expensive\nif B > G:\n    print(\"Bat\")\nelse:\n    print(\"Glove\")"}
{"task_id": "abc334_b", "solution": "import sys\n\ndef floor_div(a, b):\n    \"\"\"Returns floor(a / b) for integer a and positive integer b.\"\"\"\n    return a // b\n\ndef ceil_div(a, b):\n    \"\"\"Returns ceil(a / b) for integer a and positive integer b.\"\"\"\n    if a >= 0:\n        return (a + b - 1) // b\n    else:\n        q = a // b\n        # If there's a remainder, we need to round towards zero (which means adding 1 for negative quotients)\n        # But actually, for negative numbers, // already floors (goes more negative)\n        # So if a // b gave us a value that's less than the actual quotient, we might need adjustment\n        # Wait, let's think clearly:\n        # For negative a, a // b gives floor division (towards negative infinity)\n        # But we want ceiling division (towards positive infinity)\n        # Example: ceil(-3 / 5) = 0,  ceil(-5 / 5) = -1\n        # With // : -3 // 5 = -1,  -5 // 5 = -1\n        # So for a < 0,  a // b could be equal to ceil(a/b) or one less.\n        # Specifically, when a is divisible by b, they are equal.\n        # When a is not divisible by b, a // b is one less than ceil(a/b)\n        if a % b == 0:\n            return q\n        else:\n            return q + 1\n\ndef main():\n    line = sys.stdin.readline().strip()\n    A, M, L, R = map(int, line.split())\n    \n    # Shift coordinates so that A becomes 0\n    dl = L - A\n    dr = R - A\n    \n    # Find the range of valid k values such that dl <= k*M <= dr\n    # This translates to ceil(dl/M) <= k <= floor(dr/M)\n    low_k = ceil_div(dl, M)\n    high_k = floor_div(dr, M)\n    \n    # Count of integers from low_k to high_k inclusive\n    count = max(0, high_k - low_k + 1)\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc334_c", "solution": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:2+K]))\n    \n    # Convert to a set for faster lookup\n    lost = set(A)\n    \n    # Generate list of available socks\n    socks = []\n    for i in range(1, N+1):\n        if i in lost:\n            socks.append(i)\n        else:\n            socks.append(i)\n            socks.append(i)\n    \n    # Greedily pair adjacent socks to minimize total weirdness\n    total_weirdness = 0\n    i = 0\n    while i < len(socks) - 1:\n        total_weirdness += abs(socks[i] - socks[i+1])\n        i += 2\n        \n    print(total_weirdness)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc334_d", "solution": "import sys\nfrom bisect import bisect_right\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    # Read the reindeer requirements\n    R = list(map(int, data[2:2+N]))\n    \n    # Sort the requirements in ascending order\n    R.sort()\n    \n    # Precompute prefix sums\n    prefix = [0] * (N + 1)\n    for i in range(N):\n        prefix[i + 1] = prefix[i] + R[i]\n    \n    # Process queries\n    queries = data[2+N:2+N+Q]\n    results = []\n    \n    for x_str in queries:\n        X = int(x_str)\n        # Binary search for the maximum number of sleighs\n        # Find the rightmost index where prefix[index] <= X\n        idx = bisect_right(prefix, X) - 1\n        results.append(str(idx))\n    \n    # Output all results\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc334_e", "solution": "import sys\nfrom collections import deque\n\ndef main():\n    MOD = 998244353\n    \n    def modinv(a):\n        return pow(a, MOD - 2, MOD)\n    \n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Step 1: Label connected components of green cells\n    component = [[-1]*W for _ in range(H)]\n    comp_count = 0\n    \n    def bfs(start_r, start_c, cid):\n        q = deque()\n        q.append((start_r, start_c))\n        component[start_r][start_c] = cid\n        while q:\n            r, c = q.popleft()\n            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == '#' and component[nr][nc] == -1:\n                    component[nr][nc] = cid\n                    q.append((nr, nc))\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#' and component[i][j] == -1:\n                bfs(i, j, comp_count)\n                comp_count += 1\n                \n    # Step 2: For each red cell, find adjacent green component IDs\n    red_cells = []\n    adj_components = []  # List of sets of component IDs\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                red_cells.append((i, j))\n                neighbors = set()\n                for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                        neighbors.add(component[ni][nj])\n                adj_components.append(neighbors)\n    \n    # Step 3: Calculate expected value\n    N = len(red_cells)\n    if N == 0:\n        # No red cells to change, but problem guarantees at least one\n        print(0)\n        return\n        \n    # Expected value = C - (sum of (k_i - 1)) / N\n    # where k_i is number of distinct adjacent components for red cell i\n    sum_decrease = 0\n    for comps in adj_components:\n        k = len(comps)\n        sum_decrease += k - 1\n    \n    # E = comp_count - sum_decrease / N\n    # In modular arithmetic: E = (comp_count * N - sum_decrease) / N\n    numerator = (comp_count * N - sum_decrease) % MOD\n    denominator = N % MOD\n    \n    result = (numerator * modinv(denominator)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc335_a", "solution": "# Read the input string\nS = input().strip()\n\n# Change the last character from '3' to '4'\n# Since S ends with \"2023\", the last character is '3'\nmodified_string = S[:-1] + '4'\n\n# Print the result\nprint(modified_string)"}
{"task_id": "abc335_b", "solution": "# Read input\nN = int(input())\n\n# Generate and print all triples (x, y, z) such that x + y + z <= N in lexicographical order\nfor x in range(N + 1):\n    for y in range(N - x + 1):\n        for z in range(N - x - y + 1):\n            print(x, y, z)"}
{"task_id": "abc335_c", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    # Initial head position\n    x, y = 1, 0\n    \n    # Path stores the sequence of head positions\n    path = [(x, y)]\n    time = 0  # Number of moves performed\n    \n    idx = 2  # Pointer to next unread token in data\n    results = []\n    \n    for _ in range(Q):\n        query_type = data[idx]\n        idx += 1\n        \n        if query_type == '1':\n            direction = data[idx]\n            idx += 1\n            \n            # Update head position based on direction\n            if direction == 'R':\n                x += 1\n            elif direction == 'L':\n                x -= 1\n            elif direction == 'U':\n                y += 1\n            elif direction == 'D':\n                y -= 1\n            \n            # Record new head position\n            path.append((x, y))\n            time += 1\n            \n        else:  # query_type == '2'\n            p = int(data[idx])\n            idx += 1\n            \n            # Determine how many steps back part p is from current head\n            steps_back = p - 1\n            \n            if time >= steps_back:\n                pos = path[time - steps_back]\n            else:\n                # Part hasn't started moving; it's at its initial position\n                pos = (p, 0)\n                \n            results.append(f\"{pos[0]} {pos[1]}\")\n    \n    # Output all results for type 2 queries\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc335_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    \n    # Initialize the grid with None\n    grid = [[None]*N for _ in range(N)]\n    center = N // 2\n    grid[center][center] = 'T'\n    \n    # Directions: right, down, left, up\n    dx = [0, 1, 0, -1]\n    dy = [1, 0, -1, 0]\n    \n    # We will generate a spiral path excluding the center\n    visited = [[False]*N for _ in range(N)]\n    visited[center][center] = True  # Mark center as visited to exclude it\n    \n    x, y = 0, 0\n    direction = 0  # Start moving right\n    path = []\n    \n    for _ in range(N*N - 1):  # We have N*N - 1 dragon parts\n        path.append((x, y))\n        visited[x][y] = True\n        \n        # Try to move in current direction\n        nx, ny = x + dx[direction], y + dy[direction]\n        \n        # Check if we need to turn (hit boundary or already visited or center)\n        if not (0 <= nx < N and 0 <= ny < N) or visited[nx][ny]:\n            direction = (direction + 1) % 4\n            nx, ny = x + dx[direction], y + dy[direction]\n            \n        x, y = nx, ny\n    \n    # Now assign numbers 1 to N*N-1 to the path\n    for index, (i, j) in enumerate(path):\n        grid[i][j] = str(index + 1)\n    \n    # Print the result\n    for row in grid:\n        print(' '.join(row))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc336_a", "solution": "# Read the input\nN = int(input())\n\n# Construct the Dragon String of level N\n# Format: L + (N times 'o') + n + g\ndragon_string = \"L\" + \"o\" * N + \"ng\"\n\n# Print the result\nprint(dragon_string)"}
{"task_id": "abc336_b", "solution": "# Read input\nN = int(input())\n\n# Count trailing zeros by counting how many times N can be divided by 2\ncount = 0\ntemp = N\n\nwhile temp % 2 == 0:\n    temp //= 2\n    count += 1\n\nprint(count)"}
{"task_id": "abc336_c", "solution": "def solve(N):\n    # Define the mapping from base-5 digits to even digits\n    mapping = ['0', '2', '4', '6', '8']\n    \n    # Adjust N to 0-based index\n    N -= 1\n    \n    # Handle the special case of N == 1 (0-indexed N == 0)\n    if N == 0:\n        return \"0\"\n    \n    # Convert N to base-5 representation\n    digits = []\n    while N > 0:\n        digits.append(N % 5)\n        N //= 5\n    \n    # Reverse to get most significant digit first\n    digits.reverse()\n    \n    # Map each base-5 digit to the corresponding even digit\n    result = ''.join(mapping[d] for d in digits)\n    \n    return result\n\n# Read input\nN = int(input())\n\n# Solve and print the answer\nprint(solve(N))"}
{"task_id": "abc336_d", "solution": "def can_form_pyramid(A, k):\n    n = len(A)\n    length = 2 * k - 1\n    \n    if length > n:\n        return False\n    \n    # Generate the pyramid pattern\n    pyramid = [0] * length\n    mid = k - 1\n    for i in range(length):\n        pyramid[i] = k - abs(i - mid)\n    \n    min_cost = float('inf')\n    \n    # Try all subarrays of length 'length'\n    for i in range(n - length + 1):\n        cost = 0\n        for j in range(length):\n            if A[i + j] < pyramid[j]:\n                cost = float('inf')\n                break\n            cost += A[i + j] - pyramid[j]\n        min_cost = min(min_cost, cost)\n    \n    return min_cost <= n - length\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Binary search on k\n    left, right = 1, max(A)\n    result = 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_form_pyramid(A, mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    print(result)\n\nsolve()"}
{"task_id": "abc337_a", "solution": "# Read the number of matches\nN = int(input())\n\n# Initialize total scores for both teams\ntakahashi_total = 0\naoki_total = 0\n\n# Loop through each match and accumulate scores\nfor _ in range(N):\n    x, y = map(int, input().split())\n    takahashi_total += x\n    aoki_total += y\n\n# Determine and print the winner\nif takahashi_total > aoki_total:\n    print(\"Takahashi\")\nelif aoki_total > takahashi_total:\n    print(\"Aoki\")\nelse:\n    print(\"Draw\")"}
{"task_id": "abc337_b", "solution": "# Read input\nS = input().strip()\n\n# We need to check if the string matches the pattern A*B*C*\n# That is: zero or more A's, followed by zero or more B's, followed by zero or more C's\n\ni = 0\nn = len(S)\n\n# Consume all A's\nwhile i < n and S[i] == 'A':\n    i += 1\n\n# Consume all B's\nwhile i < n and S[i] == 'B':\n    i += 1\n\n# Consume all C's\nwhile i < n and S[i] == 'C':\n    i += 1\n\n# If we've consumed the entire string, it's a valid Extended ABC string\nif i == n:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc337_c", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Who is behind whom? \n    # behind[x] = y means person y is directly behind person x\n    behind = [0] * (N + 1)  # 1-indexed\n    \n    start = -1\n    for i in range(N):\n        person = i + 1\n        front_person = A[i]\n        if front_person == -1:\n            start = person\n        else:\n            behind[front_person] = person\n            \n    # Now traverse from start\n    result = []\n    current = start\n    while current != 0:\n        result.append(current)\n        current = behind[current]\n        \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc337_d", "solution": "from collections import deque\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    K = int(data[2])\n    \n    grid = data[3:3+H]\n    \n    min_ops = float('inf')\n    found_valid = False\n    \n    # Check horizontal segments\n    for i in range(H):\n        row = grid[i]\n        # Sliding window of size K\n        count_dot = 0\n        has_x = False\n        # Initialize the first window [0, K-1]\n        for j in range(K):\n            if row[j] == 'x':\n                has_x = True\n            elif row[j] == '.':\n                count_dot += 1\n        \n        if not has_x:\n            found_valid = True\n            min_ops = min(min_ops, count_dot)\n        \n        # Slide the window\n        for j in range(K, W):\n            # Remove the leftmost character of previous window\n            if row[j - K] == '.':\n                count_dot -= 1\n            elif row[j - K] == 'x':\n                has_x = False  # might become false now\n            \n            # Add the new rightmost character\n            if row[j] == 'x':\n                has_x = True\n            elif row[j] == '.':\n                count_dot += 1\n            \n            if not has_x:\n                found_valid = True\n                min_ops = min(min_ops, count_dot)\n    \n    # Check vertical segments\n    for j in range(W):\n        # Sliding window of size K down the column j\n        count_dot = 0\n        has_x = False\n        # Initialize the first window [0, K-1]\n        for i in range(K):\n            ch = grid[i][j]\n            if ch == 'x':\n                has_x = True\n            elif ch == '.':\n                count_dot += 1\n        \n        if not has_x:\n            found_valid = True\n            min_ops = min(min_ops, count_dot)\n        \n        # Slide the window\n        for i in range(K, H):\n            # Remove the top character of previous window\n            ch_out = grid[i - K][j]\n            if ch_out == '.':\n                count_dot -= 1\n            elif ch_out == 'x':\n                has_x = False  # might become false now\n            \n            # Add the new bottom character\n            ch_in = grid[i][j]\n            if ch_in == 'x':\n                has_x = True\n            elif ch_in == '.':\n                count_dot += 1\n            \n            if not has_x:\n                found_valid = True\n                min_ops = min(min_ops, count_dot)\n    \n    if not found_valid:\n        print(-1)\n    else:\n        print(min_ops)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc337_e", "solution": "import math\n\n# Read input\nN = int(input())\n\n# Calculate minimum number of friends needed: M = ceil(log2(N))\nM = math.ceil(math.log2(N))\n\n# Print number of friends\nprint(M)\n\n# Distribute juices based on binary representation\n# Internal indexing: 0 to N-1; External labeling: 1 to N\nfor i in range(M):\n    # Collect all bottles (1-based labels) where the i-th bit (in 0-based index) is set\n    bottles_to_serve = []\n    for j in range(N):\n        if (j >> i) & 1:  # Check if the i-th bit of j is set\n            bottles_to_serve.append(j + 1)  # Convert to 1-based label\n    \n    # Print the list of bottles for this friend\n    print(len(bottles_to_serve), *bottles_to_serve)\n\n# Flush output to ensure communication with judge\nimport sys\nsys.stdout.flush()\n\n# Read results from judge\nS = input().strip()\n\n# Decode the spoiled bottle\nspoiled_index = 0\nfor i in range(M):\n    if S[i] == '1':\n        spoiled_index |= (1 << i)\n\n# Convert 0-based index to 1-based bottle number\nprint(spoiled_index + 1)"}
{"task_id": "abc338_a", "solution": "# Read input\nS = input().strip()\n\n# Check if first character is uppercase\nfirst_char_uppercase = S[0].isupper()\n\n# Check if all remaining characters are lowercase (if there are any)\nremaining_chars_lowercase = True\nif len(S) > 1:\n    remaining_chars_lowercase = all(c.islower() for c in S[1:])\n\n# If both conditions are satisfied, print \"Yes\", otherwise \"No\"\nif first_char_uppercase and remaining_chars_lowercase:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc338_b", "solution": "# Read input\nS = input().strip()\n\n# Count frequency of each character\nfreq = {}\nfor char in S:\n    freq[char] = freq.get(char, 0) + 1\n\n# Find the maximum frequency\nmax_freq = max(freq.values())\n\n# Find the lexicographically smallest character with maximum frequency\nfor char in 'abcdefghijklmnopqrstuvwxyz':\n    if char in freq and freq[char] == max_freq:\n        print(char)\n        break"}
{"task_id": "abc338_c", "solution": "import sys\nimport math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n    B = list(map(int, data[2*N+1:3*N+1]))\n    \n    # Calculate maximum possible servings of dish A\n    max_x = float('inf')\n    for i in range(N):\n        if A[i] > 0:\n            max_x = min(max_x, Q[i] // A[i])\n    \n    # If no constraint on A (all A[i] are 0), set a high upper bound\n    if max_x == float('inf'):\n        max_x = 10**6  # Or take max Q_i as upper bound\n    \n    max_servings = 0\n    \n    # Try all possible values of x (servings of dish A)\n    for x in range(max_x + 1):\n        # Check if this x is feasible\n        feasible = True\n        for i in range(N):\n            if A[i] * x > Q[i]:\n                feasible = False\n                break\n        \n        if not feasible:\n            continue\n            \n        # Calculate remaining ingredients after making x servings of dish A\n        remaining = [Q[i] - A[i] * x for i in range(N)]\n        \n        # Calculate maximum servings of dish B we can make with remaining ingredients\n        max_y = float('inf')\n        for i in range(N):\n            if B[i] > 0:\n                max_y = min(max_y, remaining[i] // B[i])\n        \n        # Handle case where all B[i] are 0 (but problem guarantees at least one B[i] >= 1)\n        if max_y == float('inf'):\n            max_y = 0\n            \n        # Update maximum total servings\n        max_servings = max(max_servings, x + max_y)\n        \n    print(max_servings)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc338_d", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    X = list(map(int, data[2:]))\n\n    # Difference array to track how much removing each edge increases tour length\n    diff = [0] * (N + 2)  # 1-based indexing, extra space to avoid boundary checks\n    \n    total_length = 0\n    \n    for i in range(M - 1):\n        u = X[i]\n        v = X[i + 1]\n        \n        if u == v:\n            continue\n            \n        # Normalize to u < v\n        if u > v:\n            u, v = v, u\n        \n        dist_direct = v - u\n        dist_wrap = N - dist_direct\n        short_dist = min(dist_direct, dist_wrap)\n        long_dist = max(dist_direct, dist_wrap)\n        \n        total_length += short_dist\n        extra = long_dist - short_dist\n        \n        # Determine which edges are in the shortest path\n        if short_dist == dist_direct:\n            # Short path is u -> u+1 -> ... -> v\n            # Edges: u to v-1\n            diff[u] += extra\n            diff[v] -= extra\n        else:\n            # Short path wraps around: v -> v+1 -> N -> 1 -> ... -> u\n            # Edges: 1 to u-1 and v to N\n            diff[1] += extra\n            diff[u] -= extra\n            diff[v] += extra\n            diff[N + 1] -= extra  # Will be ignored due to size limit\n    \n    # Convert difference array to actual increments\n    delta = [0] * (N + 1)\n    cur = 0\n    for i in range(1, N + 1):\n        cur += diff[i]\n        delta[i] = cur\n    \n    # Find minimum total tour length after removing one edge\n    min_tour_length = float('inf')\n    for i in range(1, N + 1):\n        new_length = total_length + delta[i]\n        if new_length < min_tour_length:\n            min_tour_length = new_length\n    \n    print(min_tour_length)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc338_e", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    chords = []\n    point_to_chord = {}\n    \n    idx = 1\n    for i in range(N):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        chords.append((a, b))\n        point_to_chord[a] = (i, 0)  # 0 for start\n        point_to_chord[b] = (i, 1)  # 1 for end\n    \n    # Create list of events: (point_number, is_end, chord_index)\n    events = []\n    for point in range(1, 2*N + 1):\n        chord_idx, is_end = point_to_chord[point]\n        events.append((point, is_end, chord_idx))\n    \n    # No need to sort since points are already in order from 1 to 2N\n    \n    stack = []\n    for point, is_end, chord_idx in events:\n        if not is_end:\n            # Start of a chord\n            stack.append(chord_idx)\n        else:\n            # End of a chord\n            if not stack or stack[-1] != chord_idx:\n                print(\"Yes\")\n                return\n            stack.pop()\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc338_f", "solution": "import sys\nimport math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    # Read edges\n    edges = []\n    for _ in range(M):\n        u = int(data[idx]) - 1  # Convert to 0-based indexing\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        w = int(data[idx])\n        idx += 1\n        edges.append((u, v, w))\n    \n    # Initialize distance matrix for Floyd-Warshall\n    INF = float('inf')\n    dist = [[INF]*N for _ in range(N)]\n    for i in range(N):\n        dist[i][i] = 0\n    for u, v, w in edges:\n        dist[u][v] = min(dist[u][v], w)\n    \n    # Floyd-Warshall algorithm to get all-pairs shortest paths\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i][k] < INF and dist[k][j] < INF:\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # Check if all nodes are mutually reachable (in terms of existence of paths)\n    # Actually, we just proceed with DP; unreachable pairs will remain INF\n    \n    # Bitmask DP\n    FULL_MASK = (1 << N) - 1\n    dp = [None] * (1 << N)\n    for i in range(1 << N):\n        dp[i] = [INF] * N\n    \n    # Base cases: starting at each node\n    for i in range(N):\n        dp[1 << i][i] = 0\n    \n    # Fill DP table\n    for mask in range(1 << N):\n        for u in range(N):\n            if not (mask & (1 << u)):\n                continue\n            if dp[mask][u] == INF:\n                continue\n            # Try to extend to a new node v\n            for v in range(N):\n                if mask & (1 << v):\n                    continue  # already visited\n                if dist[u][v] == INF:\n                    continue  # no path from u to v\n                new_mask = mask | (1 << v)\n                new_cost = dp[mask][u] + dist[u][v]\n                if new_cost < dp[new_mask][v]:\n                    dp[new_mask][v] = new_cost\n    \n    # Find the minimum cost to visit all nodes\n    result = INF\n    for u in range(N):\n        if dp[FULL_MASK][u] < result:\n            result = dp[FULL_MASK][u]\n    \n    if result == INF:\n        print(\"No\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc339_a", "solution": "# Read input\nS = input().strip()\n\n# Split from the right by '.' and take the last part\nresult = S.rsplit('.', 1)[-1]\n\n# Print the result\nprint(result)"}
{"task_id": "abc339_b", "solution": "# Read input\nH, W, N = map(int, input().split())\n\n# Initialize grid with all white cells ('.')\ngrid = [['.' for _ in range(W)] for _ in range(H)]\n\n# Starting position (0-indexed) and initial direction (up = 0)\nx, y = 0, 0\ndirection = 0  # 0: up, 1: right, 2: down, 3: left\n\n# Direction vectors for movement\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\n\n# Simulate N operations\nfor _ in range(N):\n    # Check current cell color and flip it\n    if grid[x][y] == '.':\n        # White cell: paint black, turn clockwise\n        grid[x][y] = '#'\n        direction = (direction + 1) % 4\n    else:\n        # Black cell: paint white, turn counter-clockwise\n        grid[x][y] = '.'\n        direction = (direction - 1) % 4\n    \n    # Move forward in the new direction with toroidal wrapping\n    x = (x + dx[direction]) % H\n    y = (y + dy[direction]) % W\n\n# Output the final grid\nfor row in grid:\n    print(''.join(row))"}
{"task_id": "abc339_c", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    # Calculate prefix sums and track the minimum prefix sum\n    prefix_sum = 0\n    min_prefix_sum = 0\n    \n    for a in A:\n        prefix_sum += a\n        if prefix_sum < min_prefix_sum:\n            min_prefix_sum = prefix_sum\n            \n    # Minimum initial passengers needed to keep count non-negative\n    initial_passengers = -min_prefix_sum\n    \n    # Final number of passengers\n    final_passengers = initial_passengers + prefix_sum\n    \n    print(final_passengers)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc339_d", "solution": "from collections import deque\n\ndef main():\n    N = int(input())\n    grid = [input() for _ in range(N)]\n    \n    # Find initial positions of players\n    players = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'P':\n                players.append((i, j))\n    \n    r1, c1 = players[0]\n    r2, c2 = players[1]\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS\n    queue = deque()\n    visited = set()\n    \n    # Initial state\n    queue.append((r1, c1, r2, c2, 0))\n    visited.add((r1, c1, r2, c2))\n    \n    while queue:\n        curr_r1, curr_c1, curr_r2, curr_c2, moves = queue.popleft()\n        \n        # Check if players are at the same position\n        if curr_r1 == curr_r2 and curr_c1 == curr_c2:\n            print(moves)\n            return\n        \n        # Try all 4 directions\n        for dr, dc in directions:\n            # Calculate new positions\n            new_r1, new_c1 = curr_r1 + dr, curr_c1 + dc\n            new_r2, new_c2 = curr_r2 + dr, curr_c2 + dc\n            \n            # Check if new positions are valid for player 1\n            if not (0 <= new_r1 < N and 0 <= new_c1 < N) or grid[new_r1][new_c1] == '#':\n                # Player 1 can't move, stays at current position\n                new_r1, new_c1 = curr_r1, curr_c1\n            \n            # Check if new positions are valid for player 2\n            if not (0 <= new_r2 < N and 0 <= new_c2 < N) or grid[new_r2][new_c2] == '#':\n                # Player 2 can't move, stays at current position\n                new_r2, new_c2 = curr_r2, curr_c2\n            \n            # Check if this state has been visited\n            state = (new_r1, new_c1, new_r2, new_c2)\n            if state not in visited:\n                visited.add(state)\n                queue.append((new_r1, new_c1, new_r2, new_c2, moves + 1))\n    \n    # If we exhaust all possibilities and don't find a solution\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc340_a", "solution": "# Read input\nA, B, D = map(int, input().split())\n\n# Generate the arithmetic sequence\nsequence = []\ncurrent = A\nwhile current <= B:\n    sequence.append(current)\n    current += D\n\n# Print the sequence separated by spaces\nprint(' '.join(map(str, sequence)))"}
{"task_id": "abc340_b", "solution": "# Read number of queries\nQ = int(input())\n\n# Initialize the sequence A as an empty list\nA = []\n\n# Process each query\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    \n    if query[0] == 1:\n        # Type 1 query: append x to the end of A\n        x = query[1]\n        A.append(x)\n    else:\n        # Type 2 query: find the k-th value from the end of A\n        k = query[1]\n        # The k-th value from the end is at index -k in Python\n        result = A[-k]\n        print(result)"}
{"task_id": "abc340_c", "solution": "import sys\nsys.setrecursionlimit(1000000)\n\nmemo = {}\n\ndef f(x):\n    if x < 2:\n        return 0\n    if x in memo:\n        return memo[x]\n    \n    cost = x + f(x // 2) + f((x + 1) // 2)\n    memo[x] = cost\n    return cost\n\nN = int(input())\nprint(f(N))"}
{"task_id": "abc340_d", "solution": "import heapq\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    \n    idx = 1\n    for i in range(N - 1):\n        A = int(data[idx])\n        B = int(data[idx + 1])\n        X = int(data[idx + 2])\n        edges.append((A, B, X))\n        idx += 3\n\n    # Build adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for i in range(N - 1):\n        A, B, X = edges[i]\n        adj[i + 1].append((i + 2, A))   # i+1 -> i+2 with cost A\n        adj[i + 1].append((X, B))       # i+1 -> X with cost B\n\n    # Dijkstra's algorithm\n    dist = [float('inf')] * (N + 1)\n    dist[1] = 0\n    pq = [(0, 1)]  # (distance, node)\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        if u == N:\n            break\n        for v, w in adj[u]:\n            alt = d + w\n            if alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(pq, (alt, v))\n\n    print(dist[N])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc340_e", "solution": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Read initial balls in each box\n    A = list(map(int, data[2:2+N]))\n    \n    # Read operation boxes\n    B = list(map(int, data[2+N:2+N+M]))\n    \n    # Initialize the number of balls in each box\n    X = A[:]\n    \n    # Difference array for efficient range updates\n    diff = [0] * N\n    \n    # Process each operation\n    for i in range(M):\n        b_i = B[i]\n        count = X[b_i]\n        \n        # No balls to move\n        if count == 0:\n            continue\n            \n        # Clear the source box\n        X[b_i] = 0\n        \n        # Calculate start position (first box to receive a ball)\n        start_pos = (b_i + 1) % N\n        \n        # Distribute 'count' balls starting from start_pos in a circular manner\n        # This is equivalent to adding 1 to indices: start_pos, start_pos+1, ..., start_pos+count-1 (mod N)\n        \n        # Case 1: No wrap-around\n        if start_pos + count <= N:\n            diff[start_pos] += 1\n            if start_pos + count < N:\n                diff[start_pos + count] -= 1\n        else:\n            # Wrap-around case: split into two ranges\n            # First part: from start_pos to N-1\n            diff[start_pos] += 1\n            # Second part: from 0 to (start_pos + count - 1) % N\n            end_wrapped = (start_pos + count - 1) % N\n            diff[0] += 1\n            if end_wrapped + 1 < N:\n                diff[end_wrapped + 1] -= 1\n    \n    # Apply prefix sum to get the actual increments\n    for i in range(1, N):\n        diff[i] += diff[i-1]\n    \n    # Add increments to the current ball counts\n    result = [X[i] + diff[i] for i in range(N)]\n    \n    # Output the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_a", "solution": "# Read input\nN = int(input())\n\n# Generate the alternating string\n# Pattern: repeat \"10\" N times, then add one more \"1\"\nresult = \"10\" * N + \"1\"\n\n# Print the result\nprint(result)"}
{"task_id": "abc341_b", "solution": "# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\nS = []\nT = []\nfor _ in range(N-1):\n    s, t = map(int, input().split())\n    S.append(s)\n    T.append(t)\n\n# Process from left to right\nfor i in range(N-1):\n    # Calculate number of exchanges possible\n    exchanges = A[i] // S[i]\n    # Perform exchanges\n    A[i] -= exchanges * S[i]\n    A[i+1] += exchanges * T[i]\n\n# Output the maximum amount of currency N\nprint(A[N-1])"}
{"task_id": "abc341_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    N = int(data[2])\n    T = data[3]\n    grid = data[4:4+H]\n    \n    # Convert grid to a 2D list of characters for easier access\n    grid_chars = [list(row) for row in grid]\n    \n    # Define direction mappings for forward and reverse movements\n    # Forward: L -> (0,-1), R -> (0,1), U -> (-1,0), D -> (1,0)\n    # Reverse: L <- R, R <- L, U <- D, D <- U\n    dir_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    rev_dir_map = {\n        'L': (0, 1),   # Reversing L means moving right\n        'R': (0, -1),  # Reversing R means moving left\n        'U': (1, 0),   # Reversing U means moving down\n        'D': (-1, 0)   # Reversing D means moving up\n    }\n    \n    count = 0\n    \n    # Iterate over all cells inside the perimeter (since perimeter is sea)\n    for i in range(1, H-1):\n        for j in range(1, W-1):\n            # Check if current cell is land\n            if grid_chars[i][j] == '#':\n                continue\n            \n            # Start simulation from this cell, going backwards through the path\n            curr_i, curr_j = i, j\n            valid = True\n            \n            # Traverse the movement string in reverse order\n            for k in range(N-1, -1, -1):\n                move = T[k]\n                di, dj = rev_dir_map[move]\n                curr_i += di\n                curr_j += dj\n                \n                # Check bounds and whether the cell is land\n                if not (0 <= curr_i < H and 0 <= curr_j < W):\n                    valid = False\n                    break\n                if grid_chars[curr_i][curr_j] == '#':\n                    valid = False\n                    break\n            \n            if valid:\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_d", "solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef count_divisible_by_exactly_one(x, n, m, lcm_nm):\n    # Count of numbers <= x divisible by n\n    count_n = x // n\n    # Count of numbers <= x divisible by m\n    count_m = x // m\n    # Count of numbers <= x divisible by both n and m (i.e., by lcm(n,m))\n    count_both = x // lcm_nm\n    \n    # Count of numbers divisible by exactly one of n or m\n    return count_n + count_m - 2 * count_both\n\n# Read input\nN, M, K = map(int, input().split())\n\n# Calculate LCM of N and M\nlcm_nm = lcm(N, M)\n\n# Binary search for the K-th smallest number divisible by exactly one of N or M\nlow = 1\nhigh = K * max(N, M)\n\nwhile low < high:\n    mid = (low + high) // 2\n    count = count_divisible_by_exactly_one(mid, N, M, lcm_nm)\n    \n    if count < K:\n        low = mid + 1\n    else:\n        high = mid\n\nprint(low)"}
{"task_id": "abc341_e", "solution": "class SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.tree = [0] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n        self._build(data, 0, 0, self.n - 1)\n\n    def _build(self, data, node, start, end):\n        if start == end:\n            self.tree[node] = data[start]\n        else:\n            mid = (start + end) // 2\n            self._build(data, 2*node+1, start, mid)\n            self._build(data, 2*node+2, mid+1, end)\n            self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n\n    def push(self, node, start, end):\n        if self.lazy[node]:\n            self.tree[node] = (end - start + 1) - self.tree[node]\n            if start != end:\n                self.lazy[2*node+1] ^= 1\n                self.lazy[2*node+2] ^= 1\n            self.lazy[node] = 0\n\n    def update_range(self, l, r, node, start, end):\n        self.push(node, start, end)\n        if start > r or end < l:\n            return\n        if start >= l and end <= r:\n            self.lazy[node] ^= 1\n            self.push(node, start, end)\n            return\n        mid = (start + end) // 2\n        self.update_range(l, r, 2*node+1, start, mid)\n        self.update_range(l, r, 2*node+2, mid+1, end)\n        self.push(2*node+1, start, mid)\n        self.push(2*node+2, mid+1, end)\n        self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n\n    def query_range(self, l, r, node, start, end):\n        if start > r or end < l:\n            return 0\n        self.push(node, start, end)\n        if start >= l and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        p1 = self.query_range(l, r, 2*node+1, start, mid)\n        p2 = self.query_range(l, r, 2*node+2, mid+1, end)\n        return p1 + p2\n\n    def update(self, l, r):\n        if l <= r:\n            self.update_range(l, r, 0, 0, self.n - 1)\n\n    def query(self, l, r):\n        if l > r:\n            return 0\n        return self.query_range(l, r, 0, 0, self.n - 1)\n\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    Q = int(data[1])\n    S = list(data[2])\n    \n    # Convert to list of integers\n    S = [int(c) for c in S]\n    \n    # Create bad array: bad[i] = 1 if S[i] == S[i+1]\n    bad = [0] * (N - 1)\n    for i in range(N - 1):\n        if S[i] == S[i+1]:\n            bad[i] = 1\n    \n    st = SegmentTree(bad)\n    results = []\n    idx = 3\n    for _ in range(Q):\n        t = int(data[idx])\n        L = int(data[idx+1])\n        R = int(data[idx+2])\n        idx += 3\n        \n        if t == 1:\n            # Flip S[L-1:R]\n            for i in range(L-1, R):\n                S[i] ^= 1\n            \n            # Update bad array\n            # bad[L-2] might have changed (if L > 1)\n            if L > 1:\n                new_val = 1 if S[L-2] == S[L-1] else 0\n                bad[L-2] = new_val\n                st.update(L-2, L-2)\n                \n            # bad[R-1] might have changed (if R < N)\n            if R < N:\n                new_val = 1 if S[R-1] == S[R] else 0\n                bad[R-1] = new_val\n                st.update(R-1, R-1)\n                \n            # Now flip the range [L-1, R-2] in bad array using segment tree\n            if L <= R - 1:\n                st.update(L-1, R-2)\n                \n        else:\n            # Check if S[L-1:R] is good\n            if L == R:\n                results.append(\"Yes\")\n            else:\n                cnt = st.query(L-1, R-2)\n                if cnt == 0:\n                    results.append(\"Yes\")\n                else:\n                    results.append(\"No\")\n                    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_f", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    # Read input\n    N, M = map(int, sys.stdin.readline().split())\n    \n    # Build adjacency list\n    adj = defaultdict(list)\n    for _ in range(M):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Read weights and initial pieces\n    W = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed\n    A = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed\n    \n    # Create list of (weight, vertex) and sort by decreasing weight\n    vertices = [(W[i], i) for i in range(1, N+1)]\n    vertices.sort(reverse=True)\n    \n    # f[i] represents max operations one piece on vertex i can generate\n    f = [0] * (N + 1)\n    \n    # Process vertices in decreasing order of weight\n    for weight, vertex in vertices:\n        # Collect neighbors with smaller weights and their properties\n        candidates = []\n        for neighbor in adj[vertex]:\n            if W[neighbor] < W[vertex]:  # Only consider neighbors with smaller weights\n                candidates.append((W[neighbor], f[neighbor]))\n        \n        # Knapsack DP to find maximum value with weight < W[vertex]\n        # Capacity is W[vertex] - 1 due to strict inequality\n        capacity = W[vertex] - 1\n        if capacity <= 0:\n            # Cannot place any pieces on neighbors\n            f[vertex] = 1\n            continue\n            \n        # Standard 0/1 knapsack\n        dp = [0] * (capacity + 1)\n        for item_weight, item_value in candidates:\n            # Only consider items that can fit\n            if item_weight > capacity:\n                continue\n            # Update DP table backwards to avoid using updated values\n            for w in range(capacity, item_weight - 1, -1):\n                dp[w] = max(dp[w], dp[w - item_weight] + item_value)\n        \n        # f[vertex] = 1 (for removing the piece) + best distribution to neighbors\n        f[vertex] = 1 + dp[capacity]\n    \n    # Calculate final answer\n    result = 0\n    for i in range(1, N+1):\n        result += A[i] * f[i]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc342_a", "solution": "# Read input\nS = input().strip()\n\n# Determine the majority character by checking first three characters\n# Since only one character is different, at least two of the first three must be the same\nif S[0] == S[1]:\n    # First two are the same, so this is the majority character\n    majority_char = S[0]\nelif S[0] == S[2]:\n    # First and third are the same, so this is the majority character\n    majority_char = S[0]\nelse:\n    # Second and third are the same, so this is the majority character\n    majority_char = S[1]\n\n# Find the position of the different character\nfor i in range(len(S)):\n    if S[i] != majority_char:\n        # Found the different character, return 1-indexed position\n        print(i + 1)\n        break"}
{"task_id": "abc342_b", "solution": "# Read number of people\nN = int(input())\n\n# Read the permutation of people in line\nP = list(map(int, input().split()))\n\n# Create a mapping from person ID to their position (1-indexed)\nposition_map = {}\nfor i in range(N):\n    position_map[P[i]] = i + 1\n\n# Read number of queries\nQ = int(input())\n\n# Process each query\nfor _ in range(Q):\n    A, B = map(int, input().split())\n    \n    # Get positions of both people\n    pos_A = position_map[A]\n    pos_B = position_map[B]\n    \n    # The person with the smaller position value is further to the front\n    if pos_A < pos_B:\n        print(A)\n    else:\n        print(B)"}
{"task_id": "abc342_c", "solution": "# Read inputs\nN = int(input())\nS = input().strip()\nQ = int(input())\n\n# Initialize mapping: mapping[i] represents what character 'a' + i should become\nmapping = list(range(26))  # 0 -> 'a', 1 -> 'b', ..., 25 -> 'z'\n\n# Process each operation\nfor _ in range(Q):\n    c, d = input().split()\n    c_idx = ord(c) - ord('a')\n    d_idx = ord(d) - ord('a')\n    \n    # Update mapping: every character that was mapped to c should now map to d\n    for i in range(26):\n        if mapping[i] == c_idx:\n            mapping[i] = d_idx\n\n# Apply the final mapping to the string S\nresult = []\nfor char in S:\n    char_idx = ord(char) - ord('a')\n    new_char_idx = mapping[char_idx]\n    result.append(chr(new_char_idx + ord('a')))\n\n# Print the result\nprint(''.join(result))"}
{"task_id": "abc342_d", "solution": "def sieve_square_free(max_val):\n    # Precompute the square-free part for each number up to max_val\n    sqf = [i for i in range(max_val + 1)]\n    i = 2\n    while i * i <= max_val:\n        sq = i * i\n        for j in range(sq, max_val + 1, sq):\n            # Remove all square factors\n            while sqf[j] % sq == 0:\n                sqf[j] //= sq\n        i += 1\n    return sqf\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    MAX_VAL = 200000\n    sqf = sieve_square_free(MAX_VAL)\n    \n    # Count zeros separately\n    zeros = A.count(0)\n    result = 0\n    \n    # Pairs involving at least one zero\n    if zeros > 0:\n        # All pairs (0, x) where x != 0\n        result += zeros * (N - zeros)\n        # All pairs (0, 0)\n        result += zeros * (zeros - 1) // 2\n    \n    # Count frequencies of square-free parts among non-zero elements\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for a in A:\n        if a != 0:\n            s = sqf[a]\n            freq[s] += 1\n    \n    # For each group, count internal pairs\n    for count in freq.values():\n        if count >= 2:\n            result += count * (count - 1) // 2\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc342_e", "solution": "import heapq\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    # Reversed graph: for each station, store trains that arrive at this station\n    # Format: incoming[dest] = [(l, d, k, c, origin), ...]\n    incoming = defaultdict(list)\n    \n    for _ in range(M):\n        l = int(data[idx])\n        idx += 1\n        d = int(data[idx])\n        idx += 1\n        k = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        A = int(data[idx])\n        idx += 1\n        B = int(data[idx])\n        idx += 1\n        incoming[B].append((l, d, k, c, A))\n    \n    # f[S] = latest time we can arrive at station N from station S\n    # Use 0-indexing internally, but problem uses 1-indexing\n    INF = 10**20\n    f = [-INF] * (N + 1)\n    f[N] = INF  # We can \"arrive\" at N at any arbitrarily large time\n    \n    # Priority queue: (-time, station) - we use negative because heapq is min-heap\n    # But we want to process larger times first\n    pq = [(-INF, N)]\n    \n    visited = [False] * (N + 1)\n    \n    while pq:\n        neg_time, u = heapq.heappop(pq)\n        time = -neg_time\n        \n        if visited[u]:\n            continue\n        visited[u] = True\n        \n        # For each train that arrives at station u\n        for l, d, k, c, origin in incoming[u]:\n            # We need to arrive at u by time 'time'\n            # So we must depart from origin by time (time - c)\n            latest_departure = time - c\n            \n            if latest_departure < l:\n                continue  # No valid train\n            \n            # Find the latest train we can take\n            # Trains depart at l, l+d, l+2d, ..., l+(k-1)d\n            # We want the largest l + i*d such that l + i*d <= latest_departure\n            # i <= (latest_departure - l) / d\n            i = min(k - 1, (latest_departure - l) // d)\n            if i < 0:\n                continue\n            \n            actual_departure = l + i * d\n            # This means we can arrive at 'origin' by time 'actual_departure'\n            if actual_departure > f[origin]:\n                f[origin] = actual_departure\n                heapq.heappush(pq, (-actual_departure, origin))\n    \n    # Output results for stations 1 to N-1\n    for i in range(1, N):\n        if f[i] == -INF:\n            print(\"Unreachable\")\n        else:\n            print(f[i])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc343_a", "solution": "# Read input\nA, B = map(int, input().split())\n\n# Calculate sum\nsum_AB = A + B\n\n# Find any number between 0-9 that is not equal to sum_AB\n# Simple approach: if sum is not 0, return 0; otherwise return 1\nif sum_AB != 0:\n    print(0)\nelse:\n    print(1)"}
{"task_id": "abc343_b", "solution": "# Read the number of vertices\nN = int(input())\n\n# Read the adjacency matrix\nadj_matrix = []\nfor i in range(N):\n    row = list(map(int, input().split()))\n    adj_matrix.append(row)\n\n# For each vertex, find and print its neighbors\nfor i in range(N):\n    neighbors = []\n    for j in range(N):\n        if adj_matrix[i][j] == 1:\n            neighbors.append(j + 1)  # Convert to 1-based indexing\n    # Print neighbors (if any)\n    if neighbors:\n        print(' '.join(map(str, neighbors)))\n    else:\n        print()  # Print empty line if no neighbors"}
{"task_id": "abc343_c", "solution": "import math\n\ndef is_palindrome(n):\n    s = str(n)\n    return s == s[::-1]\n\ndef integer_cube_root(n):\n    # Binary search for the integer cube root\n    low = 0\n    high = n\n    while low <= high:\n        mid = (low + high) // 2\n        cube = mid ** 3\n        if cube == n:\n            return mid\n        elif cube < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return high  # Largest integer whose cube is <= n\n\ndef solve(N):\n    # Start from the largest possible cube root\n    start = integer_cube_root(N)\n    \n    # Check cubes in descending order\n    for x in range(start, 0, -1):\n        cube = x ** 3\n        if cube <= N and is_palindrome(cube):\n            return cube\n    \n    return 1  # 1 is always a palindromic cube\n\n# Read input\nN = int(input().strip())\n\n# Solve and print result\nresult = solve(N)\nprint(result)"}
{"task_id": "abc343_d", "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = int(data[1])\n    \n    # Read updates\n    updates = []\n    index = 2\n    for _ in range(T):\n        A = int(data[index])\n        B = int(data[index+1])\n        updates.append((A, B))\n        index += 2\n    \n    # Initialize scores for all players (0-indexed for convenience)\n    scores = [0] * (N + 1)  # scores[i] is the score of player i\n    \n    # score_count[score] = how many players have this score\n    score_count = defaultdict(int)\n    score_count[0] = N  # Initially all N players have score 0\n    \n    results = []\n    \n    # Process each update\n    for A, B in updates:\n        old_score = scores[A]\n        new_score = old_score + B\n        scores[A] = new_score\n        \n        # Update the frequency map\n        score_count[old_score] -= 1\n        if score_count[old_score] == 0:\n            del score_count[old_score]\n            \n        score_count[new_score] += 1\n        \n        # Number of distinct scores is the number of keys in score_count\n        results.append(len(score_count))\n    \n    # Output results\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc343_e", "solution": "def intersect_1d(a1, l1, a2, l2):\n    \"\"\"Calculate intersection length of two intervals [a1, a1+l1] and [a2, a2+l2].\"\"\"\n    start = max(a1, a2)\n    end = min(a1 + l1, a2 + l2)\n    return max(0, end - start)\n\ndef compute_volumes(a1, b1, c1, a2, b2, c2, a3, b3, c3, s=7):\n    \"\"\"Compute V1, V2, V3 based on cube positions.\"\"\"\n    # Define cube boundaries\n    x_ranges = [(a1, a1+s), (a2, a2+s), (a3, a3+s)]\n    y_ranges = [(b1, b1+s), (b2, b2+s), (b3, b3+s)]\n    z_ranges = [(c1, c1+s), (c2, c2+s), (c3, c3+s)]\n\n    # Precompute all possible intersections\n    def range_len(r):\n        return max(0, r[1] - r[0])\n    \n    # Volume for subset of cubes\n    def vol_of_subset(indices):\n        xr = x_ranges[indices[0]]\n        yr = y_ranges[indices[0]]\n        zr = z_ranges[indices[0]]\n        for i in indices[1:]:\n            xr = (max(xr[0], x_ranges[i][0]), min(xr[1], x_ranges[i][1]))\n            yr = (max(yr[0], y_ranges[i][0]), min(yr[1], y_ranges[i][1]))\n            zr = (max(zr[0], z_ranges[i][0]), min(zr[1], z_ranges[i][1]))\n        if xr[0] >= xr[1] or yr[0] >= yr[1] or zr[0] >= zr[1]:\n            return 0\n        return (xr[1] - xr[0]) * (yr[1] - yr[0]) * (zr[1] - zr[0])\n\n    # Inclusion-exclusion to count coverage multiplicity\n    from itertools import combinations\n    \n    total_vol = 0\n    for i in range(1, 4):\n        sign = (-1)**(i+1)\n        for combo in combinations(range(3), i):\n            v = vol_of_subset(combo)\n            total_vol += sign * v\n            \n    # Now compute V1, V2, V3 using inclusion-exclusion principle\n    # Total volume covered = V1 + V2 + V3\n    # Contribution to weighted sum: V1*1 + V2*2 + V3*3 = total of individual cube volumes\n    # So we have system:\n    # V1 + V2 + V3 = total_vol\n    # V1 + 2*V2 + 3*V3 = 3*343 = 1029\n    \n    # But instead we compute directly via inclusion-exclusion:\n    # V3 = |C1  C2  C3|\n    # V2 = |C1  C2 \\setminus C3| + |C1  C3 \\setminus C2| + |C2  C3 \\setminus C1|\n    # V1 = |C1 only| + |C2 only| + |C3 only|\n\n    # Helper functions to compute specific overlaps\n    def get_only(i):\n        others = {0,1,2} - {i}\n        olist = list(others)\n        full = vol_of_subset([i])\n        inter_with_o1 = vol_of_subset([i, olist[0]])\n        inter_with_o2 = vol_of_subset([i, olist[1]])\n        inter_all_three = vol_of_subset([0,1,2])\n        return full - inter_with_o1 - inter_with_o2 + inter_all_three\n\n    def get_two_only(pair):\n        rest = 3 - pair[0] - pair[1]\n        both = vol_of_subset(pair)\n        all_three = vol_of_subset([0,1,2])\n        return both - all_three\n\n    V3 = vol_of_subset([0,1,2])\n    V2 = get_two_only([0,1]) + get_two_only([0,2]) + get_two_only([1,2])\n    V1 = get_only(0) + get_only(1) + get_only(2)\n    \n    return V1, V2, V3\n\ndef main():\n    import sys\n    line = sys.stdin.readline()\n    V1_t, V2_t, V3_t = map(int, line.split())\n    \n    # Brute-force search for valid configuration\n    limit = 20  # Reduced for speed; can increase up to 100 if needed\n    s = 7\n    found = False\n    result = None\n    \n    # Place first cube at origin\n    a1, b1, c1 = 0, 0, 0\n    \n    for da2 in range(-limit, limit+1):\n        for db2 in range(-limit, limit+1):\n            for dc2 in range(-limit, limit+1):\n                a2, b2, c2 = a1 + da2, b1 + db2, c1 + dc2\n                for da3 in range(-limit, limit+1):\n                    for db3 in range(-limit, limit+1):\n                        for dc3 in range(-limit, limit+1):\n                            a3, b3, c3 = a1 + da3, b1 + db3, c1 + dc3\n                            V1_c, V2_c, V3_c = compute_volumes(a1,b1,c1, a2,b2,c2, a3,b3,c3, s)\n                            if V1_c == V1_t and V2_c == V2_t and V3_c == V3_t:\n                                found = True\n                                result = (a1,b1,c1,a2,b2,c2,a3,b3,c3)\n                                break\n                        if found: break\n                    if found: break\n                if found: break\n            if found: break\n        if found: break\n                        \n    if found:\n        print(\"Yes\")\n        print(*result)\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
