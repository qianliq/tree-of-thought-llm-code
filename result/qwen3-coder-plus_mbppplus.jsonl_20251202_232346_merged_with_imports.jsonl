{"task_id": "Mbpp/2", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef similar_elements(list1, list2):\n    # Convert second list to set for O(1) lookup\n    set2 = set(list2)\n    \n    # Keep track of elements we've already added to avoid duplicates\n    seen = set()\n    \n    # Result list to maintain order\n    result = []\n    \n    # Iterate through first list to maintain order\n    for element in list1:\n        # If element is in second list and not already added\n        if element in set2 and element not in seen:\n            result.append(element)\n            seen.add(element)\n    \n    # Return as tuple\n    return tuple(result)"}
{"task_id": "Mbpp/3", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_not_prime(n):\n    # Numbers less than or equal to 1 are not prime\n    if n <= 1:\n        return True\n    \n    # 2 is prime, so it's not non-prime\n    if n == 2:\n        return False\n    \n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    \n    # Check for odd divisors from 3 up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 2\n    \n    # If no divisors found, n is prime, so it's not non-prime\n    return False"}
{"task_id": "Mbpp/4", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        nums: List of integers\n        n: Number of largest elements to return\n        \n    Returns:\n        List of n largest integers in descending order\n    \"\"\"\n    # Handle edge cases\n    if n <= 0:\n        return []\n    \n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    \n    # Use heapq.nlargest to efficiently find the n largest elements\n    return heapq.nlargest(n, nums)"}
{"task_id": "Mbpp/6", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef differ_At_One_Bit_Pos(num1, num2):\n    # XOR the two numbers to get a number with 1s at differing bit positions\n    xor_result = num1 ^ num2\n    \n    # Check if exactly one bit is set (i.e., xor_result is a power of 2)\n    # A number is a power of 2 if it's > 0 and (n & (n-1)) == 0\n    return xor_result > 0 and (xor_result & (xor_result - 1)) == 0"}
{"task_id": "Mbpp/7", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_char_long(text):\n    # Split the string into words\n    words = text.split()\n    \n    # Filter words that are at least 4 characters long\n    result = [word for word in words if len(word) >= 4]\n    \n    return result"}
{"task_id": "Mbpp/8", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef square_nums(nums):\n    \"\"\"\n    Returns a list containing the squares of all elements in the input list.\n    \n    Args:\n        nums: A list of numbers\n        \n    Returns:\n        A list of squares of the input numbers\n    \"\"\"\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Rotations(s):\n    # Handle edge case of empty string\n    if not s:\n        return 0\n    \n    # Concatenate the string with itself\n    doubled = s + s\n    \n    # Find the first occurrence of s in doubled string, starting from index 1\n    # This gives us the minimum number of rotations\n    return doubled.find(s, 1)"}
{"task_id": "Mbpp/11", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_Occ(string, char):\n    # Find the first occurrence\n    first_index = string.find(char)\n    \n    # If character not found, return original string\n    if first_index == -1:\n        return string\n    \n    # Find the last occurrence\n    last_index = string.rfind(char)\n    \n    # If both indices are same, it means there's only one occurrence\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove both first and last occurrence\n    # Take string before first occurrence + string between first and last + string after last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]"}
{"task_id": "Mbpp/12", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix: A list of lists representing a matrix\n        \n    Returns:\n        A new matrix with rows sorted by their sums in ascending order\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))"}
{"task_id": "Mbpp/14", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Volume(base_triangle, height_triangle, length_prism):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: The base of the triangular face\n        height_triangle: The height of the triangular face\n        length_prism: The length (height) of the prism\n    \n    Returns:\n        float: The volume of the triangular prism\n    \"\"\"\n    volume = 0.5 * base_triangle * height_triangle * length_prism\n    return volume"}
{"task_id": "Mbpp/16", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef text_lowercase_underscore(text):\n    # Pattern explanation:\n    # ^[a-z]+(_[a-z]+)*$\n    # ^ - start of string\n    # [a-z]+ - one or more lowercase letters\n    # (_[a-z]+)* - zero or more groups of underscore followed by lowercase letters\n    # $ - end of string\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/17", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef square_perimeter(side_length):\n    return 4 * side_length"}
{"task_id": "Mbpp/18", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_dirty_chars(str1, str2):\n    # Convert str2 to a set for O(1) lookup\n    chars_to_remove = set(str2)\n    \n    # Build result by including only characters not in chars_to_remove\n    result = []\n    for char in str1:\n        if char not in chars_to_remove:\n            result.append(char)\n    \n    return ''.join(result)"}
{"task_id": "Mbpp/19", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        bool: True if duplicates exist, False otherwise\n    \"\"\"\n    # Convert array to set to remove duplicates\n    # If lengths are different, duplicates exist\n    return len(arr) != len(set(arr))"}
{"task_id": "Mbpp/20", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_woodall(num):\n    \"\"\"\n    Check if a given number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        num: The number to check\n        \n    Returns:\n        bool: True if the number is a Woodall number, False otherwise\n    \"\"\"\n    if num < 1:\n        return False\n    \n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == num:\n            return True\n        elif woodall_number > num:\n            return False\n        n += 1"}
{"task_id": "Mbpp/56", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check(n):\n    # Helper function to reverse a number\n    def reverse_number(num):\n        return int(str(num)[::-1])\n    \n    # Get the reverse of the number\n    reversed_n = reverse_number(n)\n    \n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_n - 1"}
{"task_id": "Mbpp/57", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Max_Num(digits):\n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Convert each digit to string and concatenate them\n    max_num_str = ''.join(map(str, sorted_digits))\n    \n    # Convert the concatenated string back to integer\n    return int(max_num_str)"}
{"task_id": "Mbpp/58", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef opposite_Signs(x, y):\n    # Check if the product is negative, which means they have opposite signs\n    # This also handles the case where one or both are zero (product would be 0, not negative)\n    return x * y < 0"}
{"task_id": "Mbpp/59", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_octagonal(n):\n    \"\"\"\n    Calculate the nth octagonal number using the formula: O(n) = n(3n - 2)\n    \n    Args:\n        n (int): The position of the octagonal number to calculate\n        \n    Returns:\n        int: The nth octagonal number\n    \"\"\"\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/61", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_Substrings(s):\n    # Dictionary to store the frequency of prefix sums\n    prefix_sum_count = {0: 1}  # Initialize with 0 having count 1 (empty prefix)\n    \n    prefix_sum = 0\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Transform the digit: d -> d - 1\n        digit = int(char)\n        prefix_sum += digit - 1\n        \n        # If this prefix sum has been seen before, \n        # it means there are substrings ending at current position with sum = 0\n        if prefix_sum in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum]\n            prefix_sum_count[prefix_sum] += 1\n        else:\n            prefix_sum_count[prefix_sum] = 1\n    \n    return count"}
{"task_id": "Mbpp/62", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef smallest_num(lst):\n    # Handle edge case of empty list\n    if not lst:\n        raise ValueError(\"List is empty\")\n    \n    # Initialize smallest with first element\n    smallest = lst[0]\n    \n    # Iterate through the rest of the elements\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    \n    return smallest"}
{"task_id": "Mbpp/63", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_difference(pairs):\n    \"\"\"\n    Find the maximum absolute difference between elements in each pair.\n    \n    Args:\n        pairs: A list of tuples/lists, where each tuple/list contains two numbers\n        \n    Returns:\n        int: The maximum absolute difference between paired elements\n    \"\"\"\n    # Handle edge case of empty list\n    if not pairs:\n        return 0\n    \n    # Calculate absolute differences for each pair and find the maximum\n    max_diff = 0\n    for pair in pairs:\n        diff = abs(pair[0] - pair[1])\n        max_diff = max(max_diff, diff)\n    \n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef subject_marks(marks_list):\n    \"\"\"\n    Sort a list of tuples using the second value of each tuple.\n    \n    Args:\n        marks_list: A list of tuples where each tuple contains (subject_name, marks)\n        \n    Returns:\n        A list of tuples sorted by the marks in ascending order\n    \"\"\"\n    return sorted(marks_list, key=lambda x: x[1])"}
{"task_id": "Mbpp/65", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef recursive_list_sum(data):\n    total = 0\n    for element in data:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"}
{"task_id": "Mbpp/66", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef pos_count(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/67", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    # Initialize the Bell triangle\n    # We only need to keep track of the current and previous rows\n    prev_row = [1]  # This represents the 0th row\n    \n    for i in range(1, n + 1):\n        # Start the new row with the last element of the previous row\n        curr_row = [prev_row[-1]]\n        \n        # Fill in the rest of the row\n        for j in range(len(prev_row)):\n            curr_row.append(curr_row[j] + prev_row[j])\n        \n        # Update prev_row for the next iteration\n        prev_row = curr_row\n    \n    # The first element of the last row is the nth Bell number\n    return prev_row[0]"}
{"task_id": "Mbpp/68", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_Monotonic(nums):\n    if len(nums) <= 1:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            decreasing = False\n        elif nums[i] < nums[i-1]:\n            increasing = False\n    \n    return increasing or decreasing"}
{"task_id": "Mbpp/69", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_sublist(main_list, sub_list):\n    # Handle edge cases\n    if len(sub_list) == 0:\n        return True\n    \n    if len(main_list) == 0 or len(sub_list) > len(main_list):\n        return False\n    \n    # Check each possible starting position in main_list\n    for i in range(len(main_list) - len(sub_list) + 1):\n        # Check if sub_list matches starting at position i\n        match = True\n        for j in range(len(sub_list)):\n            if main_list[i + j] != sub_list[j]:\n                match = False\n                break\n        \n        if match:\n            return True\n    \n    return False"}
{"task_id": "Mbpp/70", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_equal(tuples_list):\n    # Handle edge cases: empty list or single tuple\n    if len(tuples_list) <= 1:\n        return True\n    \n    # Get the length of the first tuple as reference\n    reference_length = len(tuples_list[0])\n    \n    # Check if all other tuples have the same length\n    for tup in tuples_list[1:]:\n        if len(tup) != reference_length:\n            return False\n    \n    return True"}
{"task_id": "Mbpp/71", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef comb_sort(arr):\n    # Create a copy of the array to avoid modifying the original\n    arr_copy = arr[:]\n    n = len(arr_copy)\n    \n    # Initialize gap and shrink factor\n    gap = n\n    shrink_factor = 1.3\n    swapped = True\n    \n    # Continue while gap > 1 or swaps occurred in the last pass\n    while gap > 1 or swapped:\n        # Calculate new gap\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n        \n        # Reset swap flag for this pass\n        swapped = False\n        \n        # Compare all pairs with current gap\n        for i in range(n - gap):\n            if arr_copy[i] > arr_copy[i + gap]:\n                # Swap elements\n                arr_copy[i], arr_copy[i + gap] = arr_copy[i + gap], arr_copy[i]\n                swapped = True\n                \n    return arr_copy"}
{"task_id": "Mbpp/72", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef dif_Square(n):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    A number n can be represented as a difference of two squares if and only if \n    n is not of the form 4k + 2 (i.e., n % 4 != 2).\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if n can be represented as difference of two squares, False otherwise\n    \"\"\"\n    return n % 4 != 2"}
{"task_id": "Mbpp/74", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_samepatterns(strings, patterns):\n    # Check if lengths are equal\n    if len(strings) != len(patterns):\n        return False\n    \n    # Create two dictionaries for bidirectional mapping\n    pattern_to_string = {}\n    string_to_pattern = {}\n    \n    # Iterate through both arrays simultaneously\n    for i in range(len(strings)):\n        string = strings[i]\n        pattern = patterns[i]\n        \n        # Check if pattern already has a mapping\n        if pattern in pattern_to_string:\n            if pattern_to_string[pattern] != string:\n                return False\n        else:\n            pattern_to_string[pattern] = string\n            \n        # Check if string already has a mapping\n        if string in string_to_pattern:\n            if string_to_pattern[string] != pattern:\n                return False\n        else:\n            string_to_pattern[string] = pattern\n    \n    return True"}
{"task_id": "Mbpp/75", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples/lists which have all elements divisible by k.\n    \n    Args:\n        tuples_list: List of tuples or lists\n        k: Integer divisor\n    \n    Returns:\n        List of tuples/lists where all elements are divisible by k\n    \"\"\"\n    result = []\n    \n    for tup in tuples_list:\n        # Check if all elements in the tuple/list are divisible by k\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    \n    return result"}
{"task_id": "Mbpp/77", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_Diff(n):\n    # Convert number to string to access individual digits\n    str_n = str(n)\n    \n    # Calculate alternating sum\n    alternating_sum = 0\n    for i, digit in enumerate(str_n):\n        # Add if index is even, subtract if index is odd\n        if i % 2 == 0:\n            alternating_sum += int(digit)\n        else:\n            alternating_sum -= int(digit)\n    \n    # Check if alternating sum is divisible by 11\n    return alternating_sum % 11 == 0"}
{"task_id": "Mbpp/79", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef word_len(word):\n    \"\"\"\n    Check whether the length of the word is odd or not.\n    \n    Args:\n        word (str): The input word\n        \n    Returns:\n        bool: True if the length is odd, False if even\n    \"\"\"\n    return len(word) % 2 != 0"}
{"task_id": "Mbpp/80", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number using the formula:\n    T(n) = n(n+1)(n+2)/6\n    \n    Args:\n        n (int): The position of the tetrahedral number to calculate\n        \n    Returns:\n        float: The nth tetrahedral number\n    \"\"\"\n    return n * (n + 1) * (n + 2) / 6"}
{"task_id": "Mbpp/82", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    \n    Formula: V = (4/3) × π × r³\n    \n    Args:\n        radius (float): The radius of the sphere\n        \n    Returns:\n        float: The volume of the sphere\n    \"\"\"\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume"}
{"task_id": "Mbpp/84", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sequence(n):\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    \n    # Handle base cases\n    if n == 1 or n == 2:\n        return 1\n    \n    # Create array to store sequence values\n    # Index 0 won't be used, so we need n+1 elements\n    p = [0] * (n + 1)\n    p[1] = 1\n    p[2] = 1\n    \n    # Build up the sequence iteratively\n    for i in range(3, n + 1):\n        p[i] = p[p[i - 1]] + p[i - p[i - 1]]\n    \n    return p[n]"}
{"task_id": "Mbpp/85", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n    \n    Formula: Surface Area = 4 * π * r²\n    \n    Args:\n        radius (float): The radius of the sphere\n        \n    Returns:\n        float: The surface area of the sphere\n    \"\"\"\n    return 4 * math.pi * radius ** 2"}
{"task_id": "Mbpp/86", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n    \n    A centered hexagonal number represents a hexagon with a dot in the center\n    and all other dots surrounding the center dot in hexagonal layers.\n    \n    Formula: 3 * n * (n - 1) + 1\n    \n    Args:\n        n (int): The position of the centered hexagonal number to calculate (1-indexed)\n        \n    Returns:\n        int: The nth centered hexagonal number\n    \"\"\"\n    return 3 * n * (n - 1) + 1"}
{"task_id": "Mbpp/87", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merge three dictionaries into a single dictionary.\n    If there are duplicate keys, values from later dictionaries override earlier ones.\n    \n    Args:\n        dict1, dict2, dict3: Dictionaries to be merged\n        \n    Returns:\n        A new dictionary containing all key-value pairs from the three input dictionaries\n    \"\"\"\n    return {**dict1, **dict2, **dict3}"}
{"task_id": "Mbpp/88", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef freq_count(lst):\n    \"\"\"\n    Count the frequency of all elements in a list and return as a dictionary.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A dictionary where keys are elements from the list and values are their frequencies\n    \"\"\"\n    freq_dict = {}\n    \n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict"}
{"task_id": "Mbpp/89", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef closest_num(n):\n    return n - 1"}
{"task_id": "Mbpp/90", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of strings.\n    \n    Args:\n        words (list): A list of strings\n        \n    Returns:\n        int: The length of the longest word\n    \"\"\"\n    if not words:  # Handle empty list case\n        return 0\n    \n    # Find the maximum length among all words\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length"}
{"task_id": "Mbpp/91", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_substring(string_list, substring):\n    \"\"\"\n    Check if a substring is present in any string within a list of strings.\n    \n    Args:\n        string_list (list): List of string values to search in\n        substring (str): Substring to search for\n    \n    Returns:\n        bool: True if substring is found in any string, False otherwise\n    \"\"\"\n    for string in string_list:\n        if substring in string:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_undulating(n):\n    # Convert number to string for easy digit access\n    s = str(n)\n    \n    # Need at least 2 digits to have an alternating pattern\n    if len(s) < 2:\n        return False\n    \n    # Get the first two digits\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # If first two digits are the same, it's not undulating\n    if first_digit == second_digit:\n        return False\n    \n    # Check if all digits follow the alternating pattern\n    for i in range(len(s)):\n        if i % 2 == 0:  # Even positions (0, 2, 4, ...)\n            if s[i] != first_digit:\n                return False\n        else:  # Odd positions (1, 3, 5, ...)\n            if s[i] != second_digit:\n                return False\n    \n    return True"}
{"task_id": "Mbpp/93", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef power(a, b):\n    \"\"\"\n    Calculate the value of 'a' raised to the power 'b'.\n    \n    Args:\n        a (int/float): The base number\n        b (int/float): The exponent\n    \n    Returns:\n        int/float: The result of a^b\n    \"\"\"\n    return a ** b"}
{"task_id": "Mbpp/94", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef index_minimum(tuples_list):\n    # Find the tuple with the minimum second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]"}
{"task_id": "Mbpp/95", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Find_Min_Length(lists):\n    \"\"\"\n    Find the length of the smallest list in a list of lists.\n    \n    Args:\n        lists: A list containing sublists\n        \n    Returns:\n        int: The length of the shortest sublist\n    \"\"\"\n    return min(len(sublist) for sublist in lists)"}
{"task_id": "Mbpp/96", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer n.\n    \n    Args:\n        n (int): A positive integer\n        \n    Returns:\n        int: The number of divisors of n\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    count = 0\n    i = 1\n    \n    # Check divisors up to sqrt(n)\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                # Perfect square case - count the square root only once\n                count += 1\n            else:\n                # Count both i and n/i\n                count += 2\n        i += 1\n    \n    return count"}
{"task_id": "Mbpp/97", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef frequency_lists(lists):\n    # Flatten the list of lists into a single list\n    flattened = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each element\n    frequency_dict = {}\n    for item in flattened:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict"}
{"task_id": "Mbpp/98", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef multiply_num(numbers):\n    # Handle empty list case\n    if len(numbers) == 0:\n        return 0  # or we could raise an exception\n    \n    # Multiply all numbers in the list\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    # Divide by the length of the list\n    result = product / len(numbers)\n    \n    return result"}
{"task_id": "Mbpp/99", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    \n    binary_digits = []\n    while n > 0:\n        remainder = n % 2\n        binary_digits.append(str(remainder))\n        n = n // 2\n    \n    # Reverse the digits to get the correct binary representation\n    binary_digits.reverse()\n    return ''.join(binary_digits)"}
{"task_id": "Mbpp/100", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef next_smallest_palindrome(n):\n    n += 1  # Start checking from the next number\n    \n    s = str(n)\n    length = len(s)\n    \n    # Handle special case where all digits are 9\n    if all(c == '9' for c in s):\n        return n + 2  # Will be 10...01 format\n    \n    # Get the first half of the number\n    mid = length // 2\n    first_half = s[:mid] if length % 2 == 0 else s[:mid+1]\n    \n    # Create palindrome by mirroring first half\n    if length % 2 == 0:\n        palindrome = first_half + first_half[::-1]\n    else:\n        palindrome = first_half + first_half[-2::-1]\n    \n    # If this palindrome is greater than n, return it\n    if int(palindrome) >= n:\n        return int(palindrome)\n    \n    # Otherwise, increment the first half and mirror again\n    if length % 2 == 0:\n        incremented = str(int(first_half) + 1)\n        result = incremented + incremented[::-1]\n    else:\n        incremented = str(int(first_half) + 1)\n        result = incremented + incremented[-2::-1]\n    \n    return int(result)"}
{"task_id": "Mbpp/101", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n    \n    Args:\n        arr: List of elements\n        k: 1-based index position\n    \n    Returns:\n        The element at the kth position (1-based indexing)\n    \"\"\"\n    # Convert 1-based indexing to 0-based indexing\n    return arr[k - 1]"}
{"task_id": "Mbpp/102", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef snake_to_camel(snake_str):\n    # Split the string by underscores\n    words = snake_str.split('_')\n    \n    # Capitalize each word and join them together\n    camel_case = ''.join(word.capitalize() for word in words)\n    \n    return camel_case"}
{"task_id": "Mbpp/103", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef eulerian_num(n, m):\n    # Memoization dictionary to store computed values\n    memo = {}\n    \n    def eulerian_helper(n, m):\n        # Check if already computed\n        if (n, m) in memo:\n            return memo[(n, m)]\n        \n        # Base cases\n        if m < 0 or m >= n:\n            return 0\n        if n == 0:\n            return 1 if m == 0 else 0\n        if m == 0:\n            return 1\n        \n        # Recursive case using the formula:\n        # A(n, m) = (n - m) * A(n-1, m-1) + (m + 1) * A(n-1, m)\n        result = (n - m) * eulerian_helper(n - 1, m - 1) + (m + 1) * eulerian_helper(n - 1, m)\n        \n        # Store in memo before returning\n        memo[(n, m)] = result\n        return result\n    \n    return eulerian_helper(n, m)"}
{"task_id": "Mbpp/104", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sort_sublists(list_of_lists):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n    \n    Args:\n        list_of_lists: A list containing sublists of strings\n        \n    Returns:\n        A new list with each sublist sorted alphabetically\n    \"\"\"\n    # Create a new list to store sorted sublists\n    result = []\n    \n    # Iterate through each sublist\n    for sublist in list_of_lists:\n        # Sort the current sublist and add to result\n        sorted_sublist = sorted(sublist)\n        result.append(sorted_sublist)\n    \n    return result"}
{"task_id": "Mbpp/105", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count(lst):\n    return sum(lst)"}
{"task_id": "Mbpp/108", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    merged_list = list1 + list2 + list3\n    \n    # Sort the merged list in ascending order\n    sorted_list = sorted(merged_list)\n    \n    # Return the sorted list\n    return sorted_list"}
{"task_id": "Mbpp/109", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef odd_Equivalent(s, n):\n    count = 0\n    length = len(s)\n    \n    # For each rotation from 1 to n\n    for i in range(1, n + 1):\n        # After i rotations, the last digit is at index (i-1) % length\n        if s[(i - 1) % length] == '1':\n            count += 1\n    \n    return count"}
{"task_id": "Mbpp/111", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef common_in_nested_lists(nested_lists):\n    # Handle edge case of empty input\n    if not nested_lists:\n        return []\n    \n    # Start with the first list as a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Intersect with the current list (converted to set)\n        common_elements &= set(lst)\n        \n        # Early termination optimization: if no common elements left, break\n        if not common_elements:\n            break\n    \n    # Convert back to list and return\n    return list(common_elements)"}
{"task_id": "Mbpp/113", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_integer(s):\n    \"\"\"\n    Check if a string represents an integer.\n    \n    Args:\n        s (str): The string to check\n        \n    Returns:\n        bool: True if the string represents an integer, False otherwise\n    \"\"\"\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/116", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tuple_to_int(t):\n    # Convert each element to string and join them together\n    return int(''.join(str(x) for x in t))"}
{"task_id": "Mbpp/118", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef string_to_list(s):\n    return s.split()"}
{"task_id": "Mbpp/119", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef search(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if mid is even or odd and compare with its pair\n        if (mid % 2 == 0 and arr[mid] == arr[mid + 1]) or \\\n           (mid % 2 == 1 and arr[mid] == arr[mid - 1]):\n            # Pattern is maintained, single element is in the right half\n            left = mid + 1\n        else:\n            # Pattern is broken, single element is in the left half (including mid)\n            right = mid\n    \n    return arr[left]"}
{"task_id": "Mbpp/120", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_product_tuple(list_of_tuples):\n    # Initialize a variable to store the maximum product\n    max_product = float('-inf')\n    \n    # Iterate through each tuple/list in the input\n    for pair in list_of_tuples:\n        # Calculate the product of the two elements\n        product = pair[0] * pair[1]\n        # Take the absolute value of the product\n        abs_product = abs(product)\n        # Update the maximum product if current one is larger\n        if abs_product > max_product:\n            max_product = abs_product\n    \n    return max_product"}
{"task_id": "Mbpp/123", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef amicable_numbers_sum(n):\n    def sum_of_proper_divisors(num):\n        if num <= 1:\n            return 0\n        divisor_sum = 1  # 1 is always a proper divisor\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                divisor_sum += i\n                if i != num // i:  # Avoid adding the same divisor twice for perfect squares\n                    divisor_sum += num // i\n            i += 1\n        return divisor_sum\n    \n    total_sum = 0\n    for i in range(2, n + 1):  # Start from 2 since 1 cannot be part of an amicable pair\n        j = sum_of_proper_divisors(i)\n        # Check if i and j form an amicable pair\n        # j > i to avoid double counting, and j <= n to ensure both are within range\n        if j > i and j <= n and sum_of_proper_divisors(j) == i:\n            total_sum += i + j\n    \n    return total_sum"}
{"task_id": "Mbpp/125", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_length(s):\n    if not s:\n        return 0\n    \n    # Transform the problem: '0' -> +1, '1' -> -1\n    # Then find maximum subarray sum using Kadane's algorithm\n    max_ending_here = 0\n    max_so_far = float('-inf')\n    \n    for char in s:\n        # Convert character to value: '0' -> 1, '1' -> -1\n        value = 1 if char == '0' else -1\n        \n        # Kadane's algorithm\n        max_ending_here = max(value, max_ending_here + value)\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    # If maximum sum is negative, we can always choose empty substring with difference 0\n    return max(0, max_so_far)"}
{"task_id": "Mbpp/126", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum(a, b):\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    \n    divisors_a = get_divisors(a)\n    divisors_b = get_divisors(b)\n    \n    common_divisors = divisors_a.intersection(divisors_b)\n    \n    return float(sum(common_divisors))"}
{"task_id": "Mbpp/127", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef multiply_int(a, b):\n    \"\"\"\n    Multiply two integers and return the result.\n    \n    Args:\n        a (int): First integer\n        b (int): Second integer\n    \n    Returns:\n        int: Product of a and b\n    \"\"\"\n    return a * b"}
{"task_id": "Mbpp/128", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result"}
{"task_id": "Mbpp/129", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef magic_square_test(matrix):\n    # Check if matrix is empty\n    if not matrix or not matrix[0]:\n        return False\n    \n    n = len(matrix)\n    \n    # Check if matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row as reference\n    target_sum = sum(matrix[0])\n    \n    # Check all rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n    \n    # Check all columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    anti_diag_sum = sum(matrix[i][n-1-i] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True"}
{"task_id": "Mbpp/130", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    \n    # Count frequencies while maintaining order of first occurrence\n    freq_count = {}\n    for item in lst:\n        if item in freq_count:\n            freq_count[item] += 1\n        else:\n            freq_count[item] = 1\n    \n    # Find the maximum frequency\n    max_freq = max(freq_count.values())\n    \n    # Return the first element (in order of appearance) with maximum frequency\n    for item in lst:\n        if freq_count[item] == max_freq:\n            return item"}
{"task_id": "Mbpp/131", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef reverse_vowels(s):\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Move left pointer to next vowel\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        \n        # Move right pointer to previous vowel\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap vowels\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    \n    return ''.join(s_list)"}
{"task_id": "Mbpp/132", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tup_string(tup):\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of negative numbers in a given list.\n    \n    Args:\n        numbers: A list of numbers (integers or floats)\n        \n    Returns:\n        The sum of all negative numbers in the list\n    \"\"\"\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number using the formula H(n) = n * (2n - 1)\n    \n    Args:\n        n (int): The position of the hexagonal number to calculate\n        \n    Returns:\n        int: The nth hexagonal number\n    \"\"\"\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/137", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        float: Ratio of zeroes to non-zeroes, or 0.0 if no non-zeroes exist\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    \n    # Handle edge case where there are no non-zero elements\n    if non_zero_count == 0:\n        return 0.0\n    \n    return zero_count / non_zero_count"}
{"task_id": "Mbpp/138", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_Sum_Of_Powers_Of_Two(n):\n    # A number can be represented as sum of non-zero powers of 2 \n    # if and only if it is a positive even number\n    return n > 0 and n % 2 == 0"}
{"task_id": "Mbpp/139", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n    \n    Args:\n        radius (float): The radius of the circle\n        \n    Returns:\n        float: The circumference of the circle\n    \"\"\"\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_singly(list_of_lists):\n    result_set = set()\n    for sublist in list_of_lists:\n        for element in sublist:\n            result_set.add(element)\n    return result_set"}
{"task_id": "Mbpp/141", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef pancake_sort(arr):\n    def flip(sublist, k):\n        \"\"\"Helper function to reverse the first k elements of sublist\"\"\"\n        sublist[:k] = sublist[:k][::-1]\n    \n    # Work with a copy to avoid modifying the original array\n    n = len(arr)\n    result = arr[:]  # Create a copy of the array\n    \n    # Start from the end and work backwards\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_idx = 0\n        for i in range(1, curr_size):\n            if result[i] > result[max_idx]:\n                max_idx = i\n        \n        # If the maximum element is already at the end of the current size, continue\n        if max_idx == curr_size - 1:\n            continue\n            \n        # If max element is not at the beginning, move it there\n        if max_idx != 0:\n            flip(result, max_idx + 1)\n        \n        # Now move the maximum element to its correct position\n        flip(result, curr_size)\n    \n    return result"}
{"task_id": "Mbpp/142", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_samepair(list1, list2, list3):\n    count = 0\n    for a, b, c in zip(list1, list2, list3):\n        if a == b == c:\n            count += 1\n    return count"}
{"task_id": "Mbpp/145", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_Abs_Diff(arr):\n    # Handle edge cases\n    if len(arr) <= 1:\n        return 0\n    \n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Return the absolute difference (which is just max - min)\n    return max_val - min_val"}
{"task_id": "Mbpp/160", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_solution(a, b, n):\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        else:\n            gcd, x1, y1 = extended_gcd(b, a % b)\n            x = y1\n            y = x1 - (a // b) * y1\n            return gcd, x, y\n    \n    # Find gcd and coefficients for ax + by = gcd(a,b)\n    gcd, x0, y0 = extended_gcd(a, b)\n    \n    # Check if solution exists\n    if n % gcd != 0:\n        return None\n    \n    # Scale the solution\n    factor = n // gcd\n    x = x0 * factor\n    y = y0 * factor\n    \n    return (x, y)"}
{"task_id": "Mbpp/161", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_elements(list1, list2):\n    \"\"\"\n    Remove all elements from list1 that are present in list2.\n    \n    Args:\n        list1: The original list\n        list2: The list of elements to remove\n    \n    Returns:\n        A new list with elements from list1 that are not in list2\n    \"\"\"\n    # Convert list2 to a set for O(1) lookup time\n    remove_set = set(list2)\n    \n    # Use list comprehension to filter out elements present in remove_set\n    return [element for element in list1 if element not in remove_set]"}
{"task_id": "Mbpp/162", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_series(n):\n    if n <= 0:\n        return 0\n    \n    # Calculate number of terms in the series\n    num_terms = n // 2 + 1\n    \n    # Calculate the last term in the series\n    last_term = n - 2 * (n // 2)\n    \n    # Use arithmetic series formula: sum = num_terms * (first_term + last_term) / 2\n    return num_terms * (n + last_term) // 2"}
{"task_id": "Mbpp/165", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_char_position(s):\n    count = 0\n    s = s.lower()  # Convert to lowercase for case insensitivity\n    \n    for i in range(len(s)):\n        char = s[i]\n        # Calculate the position of the character in the alphabet (a=1, b=2, ...)\n        alphabet_position = ord(char) - ord('a') + 1\n        # String index is 0-based, so we add 1 to make it 1-based for comparison\n        string_position = i + 1\n        \n        if alphabet_position == string_position:\n            count += 1\n            \n    return count"}
{"task_id": "Mbpp/166", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_even_pair(arr):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Number of pairs that XOR to an even number\n    \"\"\"\n    # Count even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate pairs where both numbers have the same parity\n    # For n elements, number of pairs = n * (n-1) / 2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs"}
{"task_id": "Mbpp/167", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef next_power_of_2(n):\n    if n <= 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    # For n > 1, find the next power of 2\n    # bit_length() gives the number of bits needed to represent a number\n    # For (n-1), this gives us the correct exponent for the next power of 2\n    return 1 << (n - 1).bit_length()"}
{"task_id": "Mbpp/168", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef frequency(lst, num):\n    count = 0\n    for element in lst:\n        if element == num:\n            count += 1\n    return count"}
{"task_id": "Mbpp/170", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n        lst: List of numbers\n        start: Starting index (inclusive)\n        end: Ending index (inclusive)\n    \n    Returns:\n        Sum of elements from index start to end (inclusive)\n    \"\"\"\n    return sum(lst[start:end+1])"}
{"task_id": "Mbpp/171", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of one side.\n    \n    Args:\n        side_length (float or int): The length of one side of the pentagon\n        \n    Returns:\n        float or int: The perimeter of the pentagon (5 × side_length)\n    \"\"\"\n    return 5 * side_length"}
{"task_id": "Mbpp/172", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_occurance(s):\n    \"\"\"\n    Count the number of occurrences of the string 'std' in a given string.\n    \n    Args:\n        s (str): The input string to search in\n        \n    Returns:\n        int: The number of occurrences of 'std'\n    \"\"\"\n    return s.count('std')"}
{"task_id": "Mbpp/222", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_type(seq):\n    # Handle empty sequence case\n    if not seq:\n        return True\n    \n    # Get the type of the first element\n    first_type = type(seq[0])\n    \n    # Check if all elements have the same type as the first element\n    for element in seq:\n        if type(element) != first_type:\n            return False\n    \n    return True"}
{"task_id": "Mbpp/223", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_majority(arr, n, x):\n    # Find the first occurrence of x\n    def find_first(arr, n, x):\n        low, high = 0, n - 1\n        first = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                first = mid\n                high = mid - 1  # Continue searching in the left half\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return first\n    \n    # Find the last occurrence of x\n    def find_last(arr, n, x):\n        low, high = 0, n - 1\n        last = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                last = mid\n                low = mid + 1  # Continue searching in the right half\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return last\n    \n    # Find first and last occurrences\n    first = find_first(arr, n, x)\n    last = find_last(arr, n, x)\n    \n    # If element is not found at all\n    if first == -1 or last == -1:\n        return False\n    \n    # Calculate count and check if it's greater than n/2\n    count = last - first + 1\n    return count > n // 2"}
{"task_id": "Mbpp/224", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_Set_Bits(n):\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a number.\n    \n    Args:\n        n (int): The input number\n        \n    Returns:\n        int: The count of set bits in n\n    \"\"\"\n    # Convert to binary string and count '1's\n    # bin(n) returns a string like '0b1010', so we count '1' characters\n    return bin(n).count('1')"}
{"task_id": "Mbpp/226", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef odd_values_string(s):\n    \"\"\"\n    Remove characters at odd indices from the given string.\n    Keep characters at even indices (0, 2, 4, ...).\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with odd-indexed characters removed\n    \"\"\"\n    return s[::2]"}
{"task_id": "Mbpp/227", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_of_three(a, b, c):\n    return min(a, b, c)"}
{"task_id": "Mbpp/230", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef replace_blank(string, char):\n    return string.replace(' ', char)"}
{"task_id": "Mbpp/232", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef larg_nnum(lst, n):\n    # Sort the list in descending order and take the first n elements\n    return sorted(lst, reverse=True)[:n]"}
{"task_id": "Mbpp/233", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n    \n    Formula: Lateral Surface Area = 2 * π * r * h\n    \n    Parameters:\n    r (float): radius of the cylinder\n    h (float): height of the cylinder\n    \n    Returns:\n    float: lateral surface area of the cylinder\n    \"\"\"\n    return 2 * math.pi * r * h"}
{"task_id": "Mbpp/234", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n    \n    Args:\n        side_length (float or int): The length of one side of the cube\n        \n    Returns:\n        float or int: The volume of the cube (side_length cubed)\n    \"\"\"\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef even_bit_set_number(n):\n    # Create a mask with 1s at positions 1, 3, 5, ... (0-indexed from right)\n    # For a 32-bit integer, this is 0xAAAAAAAA\n    mask = 0xAAAAAAAA\n    # Apply the mask using bitwise OR\n    return n | mask"}
{"task_id": "Mbpp/237", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_occurences(lst):\n    # Dictionary to store the count of each canonical tuple\n    count_dict = {}\n    \n    # Process each tuple in the list\n    for item in lst:\n        # Convert to tuple if it's a list\n        if isinstance(item, list):\n            item = tuple(item)\n        \n        # Create canonical form by sorting the elements\n        # This ensures (a,b) and (b,a) become the same key\n        canonical = tuple(sorted(item))\n        \n        # Increment count for this canonical form\n        if canonical in count_dict:\n            count_dict[canonical] += 1\n        else:\n            count_dict[canonical] = 1\n    \n    return count_dict"}
{"task_id": "Mbpp/238", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef number_of_substrings(s):\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        int: The number of non-empty substrings\n    \"\"\"\n    n = len(s)\n    return n * (n + 1) // 2"}
{"task_id": "Mbpp/239", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_total_number_of_sequences(m, n):\n    # dp[i][j] represents number of sequences of length i ending with j\n    # We only need the current and previous row\n    prev_dp = [0] * (m + 1)\n    \n    # Base case: sequences of length 1\n    for j in range(1, m + 1):\n        prev_dp[j] = 1\n    \n    # Fill DP table for sequences of length 2 to n\n    for i in range(2, n + 1):\n        curr_dp = [0] * (m + 1)\n        # Calculate prefix sums of prev_dp to optimize summation\n        prefix_sum = [0] * (m + 2)\n        for j in range(1, m + 1):\n            prefix_sum[j] = prefix_sum[j-1] + prev_dp[j]\n        \n        # For each possible ending value j\n        for j in range(1, m + 1):\n            # We need to count sequences where previous value k satisfies 2*k <= j\n            # That means k <= j//2\n            max_prev = j // 2\n            if max_prev >= 1:\n                curr_dp[j] = prefix_sum[max_prev]\n        \n        prev_dp = curr_dp\n    \n    # Sum all sequences of length n\n    return sum(prev_dp[j] for j in range(1, m + 1))"}
{"task_id": "Mbpp/240", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n        list1: The first list whose last element will be replaced\n        list2: The second list whose elements will replace the last element of list1\n    \n    Returns:\n        A new list with the last element of list1 replaced by all elements of list2\n    \"\"\"\n    # Handle edge case where list1 is empty\n    if not list1:\n        return list2[:]\n    \n    # Take all elements except the last one from list1 and concatenate with list2\n    return list1[:-1] + list2"}
{"task_id": "Mbpp/242", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_charac(s):\n    \"\"\"\n    Count the total number of characters in a string.\n    \n    Args:\n        s (str): The input string\n        \n    Returns:\n        int: The total number of characters in the string\n    \"\"\"\n    return len(s)"}
{"task_id": "Mbpp/244", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef next_Perfect_Square(n):\n    # Find the floor of the square root of n and add 1\n    # This gives us the smallest integer whose square is greater than n\n    next_root = math.floor(math.sqrt(n)) + 1\n    return next_root * next_root"}
{"task_id": "Mbpp/245", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # inc[i] stores the maximum sum of increasing subsequence ending at index i\n    inc = [0] * n\n    # dec[i] stores the maximum sum of decreasing subsequence starting at index i\n    dec = [0] * n\n    \n    # Initialize the first element of inc and last element of dec\n    for i in range(n):\n        inc[i] = arr[i]\n        dec[i] = arr[i]\n    \n    # Fill inc[] such that inc[i] stores the maximum sum of increasing subsequence ending at i\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    # Fill dec[] such that dec[i] stores the maximum sum of decreasing subsequence starting at i\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    # Find the maximum sum by combining inc[i] and dec[i] for all i\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_bitonic_sum"}
{"task_id": "Mbpp/247", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef lps(s):\n    n = len(s)\n    # Create a 2D DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length 2 to n\n    for cl in range(2, n + 1):  # cl is the chain length\n        for i in range(n - cl + 1):\n            j = i + cl - 1  # Ending index of the current substring\n            \n            if s[i] == s[j]:\n                if cl == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    return dp[0][n - 1]"}
{"task_id": "Mbpp/250", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_X(tuple_input, element):\n    \"\"\"\n    Count the occurrences of an element in a tuple.\n    \n    Args:\n        tuple_input: A tuple (or list) to search in\n        element: The element to count occurrences of\n    \n    Returns:\n        int: The number of occurrences of the element in the tuple\n    \"\"\"\n    return tuple_input.count(element)"}
{"task_id": "Mbpp/251", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef insert_element(lst, element):\n    if not lst:\n        return []\n    \n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    \n    return result"}
{"task_id": "Mbpp/252", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef convert(z):\n    \"\"\"\n    Convert a complex number (or real number) to polar coordinates (r, θ)\n    \n    Args:\n        z: A complex number or real number\n        \n    Returns:\n        tuple: (r, θ) where r is the magnitude and θ is the phase in radians\n    \"\"\"\n    r, theta = cmath.polar(z)\n    return (r, theta)"}
{"task_id": "Mbpp/253", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_integer(lst):\n    \"\"\"\n    Returns the number of integer elements in a given list.\n    \n    Args:\n        lst: A list containing elements of various types\n        \n    Returns:\n        int: The count of integer elements in the list\n    \"\"\"\n    count = 0\n    for element in lst:\n        if isinstance(element, int) and not isinstance(element, bool):\n            count += 1\n    return count"}
{"task_id": "Mbpp/255", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef combinations_colors(colors, n):\n    \"\"\"\n    Generate all combinations with repetition of length n from the given list of colors.\n    \n    Args:\n        colors: List of color strings\n        n: Length of each combination\n        \n    Returns:\n        List of tuples, each containing a combination of colors\n    \"\"\"\n    # Use itertools.combinations_with_replacement to generate all combinations\n    # with repetition allowed, then convert to list of tuples\n    return list(combinations_with_replacement(colors, n))"}
{"task_id": "Mbpp/256", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_Primes_nums(n):\n    if n < 2:\n        return 0\n    \n    # Create a boolean array \"is_prime[0..n-1]\" and initialize\n    # all entries as True. A value in is_prime[i] will finally be\n    # False if i is not a prime, else True.\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Start from 2, the first prime\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as not prime\n            # Starting from i*i because smaller multiples are already marked\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count all prime numbers\n    return sum(is_prime)"}
{"task_id": "Mbpp/257", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef swap_numbers(a, b):\n    return (b, a)"}
{"task_id": "Mbpp/259", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        # Get the corresponding tuples from both inputs\n        t1 = tuple1[i]\n        t2 = tuple2[i]\n        \n        # Create a new tuple with maximum elements at each position\n        max_tuple = tuple(max(a, b) for a, b in zip(t1, t2))\n        \n        # Add to result\n        result.append(max_tuple)\n    \n    # Convert list to tuple and return\n    return tuple(result)"}
{"task_id": "Mbpp/260", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef newman_prime(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Initialize the first two NSW numbers\n    nsw_prev2 = 1  # NSW(0)\n    nsw_prev1 = 1  # NSW(1)\n    \n    count = 0  # Count of NSW primes found\n    \n    # Check if the first two NSW numbers are prime (they're not, but for completeness)\n    if is_prime(nsw_prev2):\n        count += 1\n        if count == n:\n            return nsw_prev2\n    \n    if is_prime(nsw_prev1):\n        count += 1\n        if count == n:\n            return nsw_prev1\n    \n    # Generate NSW numbers and check for primes\n    index = 2\n    while True:\n        # Calculate next NSW number\n        nsw_current = 2 * nsw_prev1 + nsw_prev2\n        \n        # Check if it's prime\n        if is_prime(nsw_current):\n            count += 1\n            if count == n:\n                return nsw_current\n        \n        # Update for next iteration\n        nsw_prev2 = nsw_prev1\n        nsw_prev1 = nsw_current\n        index += 1"}
{"task_id": "Mbpp/261", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef division_elements(tuple1, tuple2):\n    \"\"\"\n    Performs element-wise division of two sequences.\n    \n    Args:\n        tuple1: First sequence (tuple or list) of numbers\n        tuple2: Second sequence (tuple or list) of numbers\n    \n    Returns:\n        A tuple containing the element-wise division results\n    \"\"\"\n    return tuple(a / b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/262", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef split_two_parts(lst, L):\n    # Split the list into two parts\n    first_part = lst[:L]\n    second_part = lst[L:]\n    \n    # Return as a tuple\n    return (first_part, second_part)"}
{"task_id": "Mbpp/264", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef dog_age(human_years):\n    if human_years <= 2:\n        return int(human_years * 10.5)\n    else:\n        return int(2 * 10.5 + (human_years - 2) * 4)"}
{"task_id": "Mbpp/265", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef list_split(lst, n):\n    # Create n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate through the list with index\n    for i, element in enumerate(lst):\n        # Determine which sublist to put the element in\n        sublist_index = i % n\n        # Add the element to the appropriate sublist\n        result[sublist_index].append(element)\n    \n    return result"}
{"task_id": "Mbpp/266", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n    \n    The lateral surface area of a cube is the area of all vertical faces,\n    excluding the top and bottom faces.\n    \n    Formula: 4 * side_length^2\n    \n    Args:\n        side_length (float): The length of a side of the cube\n        \n    Returns:\n        float: The lateral surface area of the cube\n    \"\"\"\n    return 4 * (side_length ** 2)"}
{"task_id": "Mbpp/267", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef square_Sum(n):\n    \"\"\"\n    Returns the sum of the squares of the first n odd natural numbers.\n    \n    Args:\n        n (int): The number of odd natural numbers to consider\n        \n    Returns:\n        float: The sum of squares of the first n odd natural numbers\n    \"\"\"\n    # Using the formula: n(2n-1)(2n+1)/3\n    return float(n * (2 * n - 1) * (2 * n + 1) / 3)"}
{"task_id": "Mbpp/268", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_star_num(n):\n    \"\"\"\n    Find the n-th star number using the formula: S_n = 6n(n-1) + 1\n    \n    Args:\n        n (int): The position of the star number to find (1-indexed)\n        \n    Returns:\n        int: The n-th star number\n    \"\"\"\n    return 6 * n * (n - 1) + 1"}
{"task_id": "Mbpp/269", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef ascii_value(char):\n    \"\"\"\n    Returns the ASCII value of a given character.\n    \n    Args:\n        char (str): A single character\n        \n    Returns:\n        int: The ASCII value of the character\n    \"\"\"\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_even_and_even_index(lst):\n    total = 0\n    for i in range(0, len(lst), 2):  # Only iterate through even indices\n        if lst[i] % 2 == 0:  # Check if the number at even index is even\n            total += lst[i]\n    return total"}
{"task_id": "Mbpp/271", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef even_Power_Sum(n):\n    \"\"\"\n    Calculate the sum of the first n even natural numbers raised to the fifth power.\n    \n    Args:\n        n (int): Number of even natural numbers to consider\n        \n    Returns:\n        int: Sum of first n even natural numbers raised to the fifth power\n    \"\"\"\n    total_sum = 0\n    \n    # Iterate through first n even natural numbers\n    # The k-th even natural number is 2*k\n    for k in range(1, n + 1):\n        even_number = 2 * k\n        total_sum += even_number ** 5\n    \n    return total_sum"}
{"task_id": "Mbpp/272", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef rear_extract(tuple_list):\n    \"\"\"\n    Takes a list of tuples/lists and returns a list containing \n    the rear (last) element of each tuple/list.\n    \n    Args:\n        tuple_list: A list of tuples or lists\n        \n    Returns:\n        A list containing the last element of each tuple/list\n    \"\"\"\n    return [item[-1] for item in tuple_list]"}
{"task_id": "Mbpp/273", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef substract_elements(tuple1, tuple2):\n    \"\"\"\n    Subtracts elements of the second tuple from the first tuple element-wise.\n    \n    Args:\n        tuple1: First sequence of numbers\n        tuple2: Second sequence of numbers\n    \n    Returns:\n        A tuple containing the element-wise differences\n    \"\"\"\n    return tuple(a - b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/274", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculate the sum of even index binomial coefficients for a given positive integer n.\n    \n    The even index binomial coefficients are C(n,0) + C(n,2) + C(n,4) + ...\n    \n    Args:\n        n (int): A positive integer\n        \n    Returns:\n        int: Sum of even index binomial coefficients\n    \"\"\"\n    # For n >= 1, the sum of even index binomial coefficients equals 2^(n-1)\n    # This is because the sum of even index coefficients equals the sum of odd index coefficients,\n    # and their total sum is 2^n\n    \n    if n == 0:\n        return 1  # Only C(0,0) = 1\n    \n    return 2 ** (n - 1)"}
{"task_id": "Mbpp/276", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n    \n    Formula: V = π × r² × h\n    \n    Args:\n        radius (float): The radius of the cylinder\n        height (float): The height of the cylinder\n    \n    Returns:\n        float: The volume of the cylinder\n    \"\"\"\n    return math.pi * radius**2 * height"}
{"task_id": "Mbpp/277", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef dict_filter(dictionary, n):\n    \"\"\"\n    Filters a dictionary to only include entries with values greater than or equal to n.\n    \n    Args:\n        dictionary (dict): The input dictionary to filter\n        n (int): The threshold value\n        \n    Returns:\n        dict: A new dictionary containing only entries with values >= n\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value >= n}"}
{"task_id": "Mbpp/278", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_first_elements(sequence):\n    \"\"\"\n    Count the number of elements that occur before the first tuple or list element in the given sequence.\n    \n    Args:\n        sequence: A sequence (tuple or list) that may contain various elements including nested tuples/lists\n        \n    Returns:\n        int: The count of elements before the first tuple or list element\n    \"\"\"\n    for index, element in enumerate(sequence):\n        # Check if the current element is a tuple or list\n        if isinstance(element, (tuple, list)):\n            return index\n    \n    # If no tuple or list is found, return the length of the sequence\n    return len(sequence)"}
{"task_id": "Mbpp/279", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_num_decagonal(n):\n    \"\"\"\n    Find the nth decagonal number using the formula: D(n) = 4n² - 3n\n    \n    Args:\n        n (int): The position of the decagonal number to find\n        \n    Returns:\n        int: The nth decagonal number\n    \"\"\"\n    return 4 * n * n - 3 * n"}
{"task_id": "Mbpp/280", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sequential_search(arr, target):\n    \"\"\"\n    Performs a sequential (linear) search for the target element in the array.\n    \n    Args:\n        arr: List of elements to search through\n        target: Element to search for\n    \n    Returns:\n        Tuple containing (found: bool, index: int)\n        - found: True if element is found, False otherwise\n        - index: Index of element if found, -1 if not found\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return (True, i)\n    \n    return (False, -1)"}
{"task_id": "Mbpp/281", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sub_list(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i] - list2[i])\n    return result"}
{"task_id": "Mbpp/283", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef validate(n):\n    # Convert integer to string to iterate through digits\n    str_n = str(abs(n))  # Use abs to handle negative numbers\n    \n    # Count frequency of each digit\n    freq = {}\n    for digit in str_n:\n        freq[digit] = freq.get(digit, 0) + 1\n    \n    # Check if frequency of each digit is <= digit value\n    for digit, count in freq.items():\n        digit_value = int(digit)\n        if count > digit_value:\n            return False\n    \n    return True"}
{"task_id": "Mbpp/284", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_element(lst, element):\n    \"\"\"\n    Check if all items in the list are equal to the given element.\n    \n    Args:\n        lst: A list of elements\n        element: The element to compare against\n        \n    Returns:\n        bool: True if all elements in the list equal the given element, False otherwise\n    \"\"\"\n    # Handle empty list case - vacuously true\n    if not lst:\n        return True\n    \n    # Check each element in the list\n    for item in lst:\n        if item != element:\n            return False\n    \n    # If we've checked all elements and none failed, return True\n    return True"}
{"task_id": "Mbpp/285", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef text_match_two_three(text):\n    \"\"\"\n    Check if a string contains 'a' followed by exactly 2 or 3 'b' characters.\n    \n    Args:\n        text (str): The input string to check\n        \n    Returns:\n        bool: True if pattern is found, False otherwise\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/286", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_sub_array_sum_repeated(arr, n, k):\n    def kadane(nums):\n        max_ending_here = max_so_far = nums[0]\n        for i in range(1, len(nums)):\n            max_ending_here = max(nums[i], max_ending_here + nums[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    # Step 1: Calculate total sum of array\n    total_sum = sum(arr)\n    \n    # Step 2: Apply Kadane's algorithm on single array\n    max_kadane = kadane(arr)\n    \n    # If k is 1, just return result from Kadane\n    if k == 1:\n        return max_kadane\n    \n    # Step 3: Calculate maximum prefix sum\n    max_prefix_sum = float('-inf')\n    current_prefix_sum = 0\n    for i in range(n):\n        current_prefix_sum += arr[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n    \n    # Step 4: Calculate maximum suffix sum\n    max_suffix_sum = float('-inf')\n    current_suffix_sum = 0\n    for i in range(n-1, -1, -1):\n        current_suffix_sum += arr[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n    \n    # Step 5: Consider combinations\n    # Max sum using prefix and suffix (across two copies)\n    max_prefix_suffix = max_prefix_sum + max_suffix_sum\n    \n    # If total sum is positive, adding (k-2) full arrays increases sum\n    if total_sum > 0:\n        max_prefix_suffix += (k - 2) * total_sum\n    \n    # Return maximum among all considered options\n    return max(max_kadane, max_prefix_suffix)"}
{"task_id": "Mbpp/287", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef square_Sum(n):\n    \"\"\"\n    Returns the sum of squares of first n even natural numbers.\n    \n    The formula used is: 2*n*(n+1)*(2*n+1)/3\n    \n    Args:\n        n (int): Number of even natural numbers to consider\n        \n    Returns:\n        float: Sum of squares of first n even natural numbers\n    \"\"\"\n    return 2 * n * (n + 1) * (2 * n + 1) / 3"}
{"task_id": "Mbpp/290", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_length(lists):\n    if not lists:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for lst in lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)"}
{"task_id": "Mbpp/292", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find(a, b):\n    \"\"\"\n    Find the quotient of two numbers rounded down to the nearest integer.\n    \n    Args:\n        a (int/float): dividend\n        b (int/float): divisor\n    \n    Returns:\n        int: quotient rounded down to nearest integer\n    \n    Raises:\n        ZeroDivisionError: if b is zero\n    \"\"\"\n    if b == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    \n    return a // b"}
{"task_id": "Mbpp/293", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef otherside_rightangle(a, b):\n    \"\"\"\n    Find the third side (hypotenuse) of a right angled triangle given two sides.\n    \n    Args:\n        a (float): Length of first side\n        b (float): Length of second side\n    \n    Returns:\n        float: Length of the hypotenuse\n    \"\"\"\n    # Using Pythagorean theorem: c = sqrt(a^2 + b^2)\n    c = math.sqrt(a**2 + b**2)\n    return c"}
{"task_id": "Mbpp/294", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_val(lst):\n    max_value = float('-inf')  # Initialize with negative infinity\n    \n    for item in lst:\n        # Check if the item is numeric (int or float, but not bool since bool is subclass of int)\n        if isinstance(item, (int, float)) and not isinstance(item, bool):\n            if item > max_value:\n                max_value = item\n                \n    return max_value"}
{"task_id": "Mbpp/296", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_Inv_Count(arr):\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i, j, k = left, mid + 1, left\n        inv_count = 0\n        \n        # Merge the two sorted halves while counting inversions\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are (mid - i + 1) inversions since arr[i] > arr[j]\n                # and all elements from i to mid are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy remaining elements from left subarray\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy remaining elements from right subarray\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy merged elements back to original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n            \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        \n        return inv_count\n    \n    # Create a copy of the array to avoid modifying the original\n    arr_copy = arr[:]\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr_copy, temp_arr, 0, len(arr) - 1)"}
{"task_id": "Mbpp/297", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef flatten_list(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result"}
{"task_id": "Mbpp/299", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_aggregate(lst):\n    # Dictionary to store the cumulative scores for each person\n    scores = {}\n    \n    # Iterate through each tuple in the list\n    for name, score in lst:\n        # Add the score to the existing score for that person\n        # If the person is not in the dictionary, initialize with 0\n        scores[name] = scores.get(name, 0) + score\n    \n    # Find the person with the maximum aggregate score\n    max_person = max(scores, key=scores.get)\n    max_score = scores[max_person]\n    \n    # Return the result as a tuple\n    return (max_person, max_score)"}
{"task_id": "Mbpp/300", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_binary_seq(n):\n    \"\"\"\n    Find the count of all binary sequences of length 2n such that \n    sum of first n bits is same as sum of last n bits.\n    \n    Args:\n        n (int): Half the length of the binary sequence\n        \n    Returns:\n        float: Count of valid binary sequences\n    \"\"\"\n    # The count is equal to the central binomial coefficient C(2n, n)\n    return float(math.comb(2 * n, n))"}
{"task_id": "Mbpp/301", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef dict_depth(d):\n    if not isinstance(d, dict):\n        return 0\n    if not d:\n        return 1\n    return 1 + max(dict_depth(value) for value in d.values())"}
{"task_id": "Mbpp/305", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef start_withp(words_list):\n    found_words = []\n    \n    # Iterate through each string in the list\n    for string in words_list:\n        # Split the string into words\n        words = string.split()\n        \n        # Check each word to see if it starts with 'p' or 'P'\n        for word in words:\n            if word.lower().startswith('p'):\n                found_words.append(word)\n                \n                # If we've found two words, return them as a tuple\n                if len(found_words) == 2:\n                    return (found_words[0], found_words[1])\n    \n    # This shouldn't happen according to problem constraints\n    # but returning empty tuple or handling error might be needed\n    return tuple(found_words) if len(found_words) >= 2 else ()"}
{"task_id": "Mbpp/306", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # dp[j] will store the maximum sum of increasing subsequence ending at index j\n    dp = [0] * (i + 1)\n    \n    # Initialize dp array with respective array values\n    for j in range(i + 1):\n        dp[j] = arr[j]\n        \n    # Fill dp array\n    for j in range(1, i + 1):\n        for m in range(j):\n            if arr[m] < arr[j]:\n                dp[j] = max(dp[j], dp[m] + arr[j])\n                \n    # Find the maximum sum subsequence ending at some index <= i,\n    # where the last element is smaller than arr[k]\n    max_sum_before_k = 0\n    for j in range(i + 1):\n        if arr[j] < arr[k]:\n            max_sum_before_k = max(max_sum_before_k, dp[j])\n            \n    # Include the kth element in the final answer\n    return max_sum_before_k + arr[k]"}
{"task_id": "Mbpp/308", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef large_product(list1, list2, n):\n    # Generate all possible products\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]"}
{"task_id": "Mbpp/309", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximum(a, b):\n    return max(a, b)"}
{"task_id": "Mbpp/310", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef string_to_tuple(s):\n    return tuple(s)"}
{"task_id": "Mbpp/311", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef set_left_most_unset_bit(n):\n    # Handle special case of 0\n    if n == 0:\n        return 1\n    \n    # Get the number of bits needed to represent n\n    bit_length = n.bit_length()\n    \n    # Check from the highest bit down to 0 to find the leftmost unset bit\n    for i in range(bit_length, -1, -1):\n        # Check if bit at position i is unset (0)\n        if not (n & (1 << i)):\n            # Set the bit at position i\n            return n | (1 << i)\n    \n    # If all bits are set, return n as is\n    return n"}
{"task_id": "Mbpp/312", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given its radius and height.\n    \n    Formula: V = (1/3) * π * r² * h\n    \n    Args:\n        radius (float): The radius of the cone's base\n        height (float): The height of the cone\n    \n    Returns:\n        float: The volume of the cone\n    \"\"\"\n    return (1/3) * math.pi * radius**2 * height"}
{"task_id": "Mbpp/388", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef highest_Power_of_2(n):\n    if n < 1:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power"}
{"task_id": "Mbpp/389", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize first two Lucas numbers\n    prev2 = 2  # L(0)\n    prev1 = 1  # L(1)\n    \n    # Calculate Lucas numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"}
{"task_id": "Mbpp/390", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef add_string(elements, format_string):\n    \"\"\"\n    Apply a given format string to all elements in a list.\n    \n    Args:\n        elements: A list of elements to format\n        format_string: A string containing {0} as a placeholder\n        \n    Returns:\n        A list of formatted strings\n    \"\"\"\n    result = []\n    for element in elements:\n        formatted_element = format_string.format(element)\n        result.append(formatted_element)\n    return result"}
{"task_id": "Mbpp/391", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef convert_list_dictionary(list1, list2, list3):\n    result = []\n    for item1, item2, item3 in zip(list1, list2, list3):\n        result.append({item1: {item2: item3}})\n    return result"}
{"task_id": "Mbpp/392", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_max_sum(n):\n    # Memoization dictionary to store computed values\n    memo = {}\n    \n    def f(num):\n        # If already computed, return from memo\n        if num in memo:\n            return memo[num]\n        \n        # Base cases\n        if num <= 1:\n            memo[num] = num\n            return num\n        \n        # Calculate the sum of breaking down the number\n        breakdown_sum = f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5)\n        \n        # Take the maximum of the number itself and the breakdown sum\n        result = max(num, breakdown_sum)\n        \n        # Store in memo before returning\n        memo[num] = result\n        return result\n    \n    return f(n)"}
{"task_id": "Mbpp/394", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_distinct(tup):\n    \"\"\"\n    Check if given tuple contains no duplicates.\n    \n    Args:\n        tup: A tuple to check for duplicates\n        \n    Returns:\n        bool: True if no duplicates, False if duplicates exist\n    \"\"\"\n    return len(tup) == len(set(tup))"}
{"task_id": "Mbpp/395", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef first_non_repeating_character(s):\n    # Count frequency of each character\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character found\n    return None"}
{"task_id": "Mbpp/397", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef median_numbers(a, b, c):\n    # Put the three numbers in a list and sort them\n    numbers = [a, b, c]\n    numbers.sort()\n    \n    # Return the middle element (index 1) as a float\n    return float(numbers[1])"}
{"task_id": "Mbpp/398", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_of_digits(numbers):\n    total = 0\n    \n    for item in numbers:\n        # Check if the item is a number (int or float)\n        if isinstance(item, (int, float)):\n            # Take absolute value to handle negative numbers\n            abs_value = abs(item)\n            # Convert to string to access digits\n            str_value = str(abs_value)\n            \n            # Process each character in the string representation\n            for char in str_value:\n                # Skip decimal point in case of floats\n                if char.isdigit():\n                    total += int(char)\n    \n    return total"}
{"task_id": "Mbpp/404", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum(a, b):\n    \"\"\"\n    Find the minimum of two numbers.\n    \n    Args:\n        a: First number\n        b: Second number\n    \n    Returns:\n        The smaller of the two numbers\n    \"\"\"\n    return min(a, b)"}
{"task_id": "Mbpp/405", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n        tuplex: A tuple to search in\n        element: The element to search for\n    \n    Returns:\n        bool: True if element exists in tuple, False otherwise\n    \"\"\"\n    return element in tuplex"}
{"task_id": "Mbpp/406", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Parity(n):\n    # Count the number of 1-bits in the binary representation\n    count_of_ones = bin(n).count('1')\n    # Return True if the count is odd (odd parity), False otherwise\n    return count_of_ones % 2 == 1"}
{"task_id": "Mbpp/409", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_product_tuple(tuple_list):\n    # Handle edge case of empty list\n    if not tuple_list:\n        return None\n    \n    # Initialize minimum product with the product of the first tuple\n    min_product = tuple_list[0][0] * tuple_list[0][1]\n    \n    # Iterate through the rest of the tuples\n    for tuple_item in tuple_list[1:]:\n        # Calculate product of current tuple\n        product = tuple_item[0] * tuple_item[1]\n        # Update minimum if current product is smaller\n        if product < min_product:\n            min_product = product\n    \n    return min_product"}
{"task_id": "Mbpp/410", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_val(lst):\n    # Initialize min_value as None\n    min_value = None\n    \n    # Iterate through the list\n    for item in lst:\n        # Check if the item is an integer\n        if isinstance(item, int):\n            # If min_value is None or item is smaller than min_value, update min_value\n            if min_value is None or item < min_value:\n                min_value = item\n    \n    return min_value"}
{"task_id": "Mbpp/412", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_odd(numbers):\n    \"\"\"\n    Remove odd numbers from a given list, keeping only even numbers.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        A new list containing only the even numbers from the input list\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]"}
{"task_id": "Mbpp/413", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_nth_element(lst, n):\n    \"\"\"\n    Extract the nth element from each tuple/list in the given list.\n    \n    Args:\n        lst: A list of tuples or lists\n        n: The index of the element to extract from each sub-list\n    \n    Returns:\n        A list containing the nth element from each sub-list\n    \"\"\"\n    return [sublist[n] for sublist in lst]"}
{"task_id": "Mbpp/414", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n        seq1: First sequence (list, tuple, etc.)\n        seq2: Second sequence (list, tuple, etc.)\n        \n    Returns:\n        bool: True if there's any overlap, False otherwise\n    \"\"\"\n    # Convert the second sequence to a set for O(1) lookup\n    set2 = set(seq2)\n    \n    # Check if any element from seq1 exists in set2\n    for element in seq1:\n        if element in set2:\n            return True\n    \n    # If no overlapping elements found, return False\n    return False"}
{"task_id": "Mbpp/415", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_Product(arr):\n    # Handle edge case\n    if len(arr) < 2:\n        return None\n    \n    # Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Get the two smallest and two largest elements\n    smallest_pair_product = sorted_arr[0] * sorted_arr[1]\n    largest_pair_product = sorted_arr[-1] * sorted_arr[-2]\n    \n    # Return the pair with the higher product\n    if smallest_pair_product > largest_pair_product:\n        return (sorted_arr[0], sorted_arr[1])\n    else:\n        return (sorted_arr[-2], sorted_arr[-1])"}
{"task_id": "Mbpp/418", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Find_Max(lst):\n    \"\"\"\n    Find the element of a list having maximum length.\n    \n    Args:\n        lst: A list of lists\n        \n    Returns:\n        The element (sublist) with maximum length\n    \"\"\"\n    return max(lst, key=len)"}
{"task_id": "Mbpp/419", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef round_and_sum(numbers):\n    # Round each number in the list\n    rounded_numbers = [round(num) for num in numbers]\n    \n    # Calculate the sum of rounded numbers\n    total_sum = sum(rounded_numbers)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(numbers)\n    \n    return result"}
{"task_id": "Mbpp/420", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef cube_Sum(n):\n    \"\"\"\n    Calculate the cube sum of first n even natural numbers.\n    \n    The first n even natural numbers are: 2, 4, 6, ..., 2n\n    We need to compute: 2³ + 4³ + 6³ + ... + (2n)³\n    \n    This equals: 8 * (1³ + 2³ + 3³ + ... + n³)\n    Using the formula: 1³ + 2³ + 3³ + ... + n³ = [n(n+1)/2]²\n    \n    Therefore: cube_Sum(n) = 8 * [n(n+1)/2]² = 2 * [n(n+1)]²\n    \"\"\"\n    return 2 * (n * (n + 1)) ** 2"}
{"task_id": "Mbpp/421", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef concatenate_tuple(input_tuple):\n    # Convert all elements to strings and join them with '-'\n    return '-'.join(str(element) for element in input_tuple)"}
{"task_id": "Mbpp/422", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Average_Of_Cube(n):\n    # Calculate sum of cubes of first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    \n    # Calculate and return the average\n    return sum_of_cubes / n"}
{"task_id": "Mbpp/424", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_rear(strings):\n    \"\"\"\n    Extract the last character from each string in the input tuple/list.\n    \n    Args:\n        strings: A tuple or list of strings\n        \n    Returns:\n        A list containing the last character of each string\n    \"\"\"\n    return [string[-1] for string in strings]"}
{"task_id": "Mbpp/425", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n        list_of_lists: A list of lists\n        element: The element to search for\n        \n    Returns:\n        int: The number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count"}
{"task_id": "Mbpp/426", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef filter_oddnumbers(numbers):\n    \"\"\"\n    Filter and return only the odd numbers from the input list.\n    \n    Args:\n        numbers (list): A list of integers\n        \n    Returns:\n        list: A list containing only the odd numbers from the input list\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef change_date_format(date_str):\n    # Split the date string by '-' to get year, month, and day\n    year, month, day = date_str.split('-')\n    \n    # Rearrange to dd-mm-yyyy format and return\n    return f\"{day}-{month}-{year}\""}
{"task_id": "Mbpp/428", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef shell_sort(arr):\n    n = len(arr)\n    # Create a copy to avoid modifying the original array\n    arr_copy = arr[:]\n    \n    # Calculate initial gap using Knuth sequence (3x + 1)\n    gap = 1\n    while gap < n // 3:\n        gap = 3 * gap + 1  # 1, 4, 13, 40, 121, ...\n    \n    # Start with the largest gap and reduce it\n    while gap >= 1:\n        # Perform gapped insertion sort\n        for i in range(gap, n):\n            # Save current element\n            temp = arr_copy[i]\n            # Shift earlier gap-sorted elements up until correct location for arr_copy[i] is found\n            j = i\n            while j >= gap and arr_copy[j - gap] > temp:\n                arr_copy[j] = arr_copy[j - gap]\n                j -= gap\n            # Put temp in its correct location\n            arr_copy[j] = temp\n        # Reduce gap\n        gap //= 3\n    \n    return arr_copy"}
{"task_id": "Mbpp/429", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef and_tuples(tuple1, tuple2):\n    # Convert inputs to tuples if they're lists\n    if isinstance(tuple1, list):\n        tuple1 = tuple(tuple1)\n    if isinstance(tuple2, list):\n        tuple2 = tuple(tuple2)\n    \n    # Perform element-wise bitwise AND operation\n    result = tuple(a & b for a, b in zip(tuple1, tuple2))\n    \n    return result"}
{"task_id": "Mbpp/430", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef parabola_directrix(a, b, c):\n    return c - 4 * a * (b**2 + 1)"}
{"task_id": "Mbpp/432", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef median_trapezium(base1, base2, other):\n    \"\"\"\n    Calculate the median length of a trapezium.\n    \n    The median of a trapezium is the line segment connecting the midpoints \n    of the non-parallel sides, and its length equals the average of the \n    lengths of the parallel sides.\n    \n    Args:\n        base1 (float): Length of the first parallel side\n        base2 (float): Length of the second parallel side\n        other (float): Third parameter (height or leg length, not used in calculation)\n        \n    Returns:\n        float: The median length of the trapezium\n    \"\"\"\n    return (base1 + base2) / 2"}
{"task_id": "Mbpp/433", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Args:\n        arr: List of numbers\n        num: Number to compare against array elements\n    \n    Returns:\n        bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > element for element in arr)"}
{"task_id": "Mbpp/435", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef last_Digit(num):\n    return num % 10"}
{"task_id": "Mbpp/436", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef neg_nos(numbers):\n    \"\"\"\n    Returns a list containing only the negative numbers from the input list.\n    \n    Args:\n        numbers (list): A list of integers\n        \n    Returns:\n        list: A list containing only the negative numbers from the input\n    \"\"\"\n    return [num for num in numbers if num < 0]"}
{"task_id": "Mbpp/437", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from a string.\n    Actually keeps characters at odd indices (1, 3, 5, ...) and removes even indices (0, 2, 4, ...)\n    Based on test cases like 'python' -> 'yhn' where chars at positions 1,3,5 are kept.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with characters at odd indices\n    \"\"\"\n    return s[1::2]"}
{"task_id": "Mbpp/439", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef multiple_to_single(int_list):\n    if not int_list:\n        return 0\n    \n    # Convert all integers to strings and join them\n    concatenated_str = ''.join(str(num) for num in int_list)\n    \n    # Convert back to integer\n    return int(concatenated_str)"}
{"task_id": "Mbpp/440", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_adverb_position(sentence):\n    # Find the position of the first \"!!\"\n    exclamation_pos = sentence.find(\"!!\")\n    \n    # If \"!!\" is found\n    if exclamation_pos != -1:\n        # Extract the adverb (everything before the \"!!\")\n        adverb = sentence[:exclamation_pos]\n        \n        # Return the tuple (start_position, end_position, adverb)\n        # Start position is always 0\n        # End position is where \"!!\" starts\n        return (0, exclamation_pos, adverb)\n    \n    # This shouldn't happen based on the problem constraints\n    # but returning None for safety\n    return None"}
{"task_id": "Mbpp/441", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef surfacearea_cube(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given its side length.\n    \n    Args:\n        side_length (int or float): The length of one side of the cube\n        \n    Returns:\n        int or float: The surface area of the cube\n    \"\"\"\n    return 6 * (side_length ** 2)"}
{"task_id": "Mbpp/445", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef index_multiplication(tuple1, tuple2):\n    # Use zip to iterate over corresponding pairs from both tuples\n    result = tuple(\n        tuple(a * b for a, b in zip(inner_tuple1, inner_tuple2))\n        for inner_tuple1, inner_tuple2 in zip(tuple1, tuple2)\n    )\n    return result"}
{"task_id": "Mbpp/446", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_Occurrence(tuple_input, list_input):\n    # Convert list to set for faster lookup\n    search_elements = set(list_input)\n    \n    # Count occurrences of elements from the list in the tuple\n    count = 0\n    for element in tuple_input:\n        if element in search_elements:\n            count += 1\n    \n    return count"}
{"task_id": "Mbpp/447", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef cube_nums(nums):\n    \"\"\"\n    Function to find cubes of individual elements in a list.\n    \n    Args:\n        nums: A list of numbers\n    \n    Returns:\n        A list containing the cubes of the input numbers\n    \"\"\"\n    return [num ** 3 for num in nums]"}
{"task_id": "Mbpp/448", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef cal_sum(n):\n    if n <= 0:\n        return 0\n    \n    # Initialize the first three Perrin numbers\n    perrin = [3, 0, 2]\n    \n    # If n is less than or equal to 3, return sum of first n numbers\n    if n <= 3:\n        return sum(perrin[:n])\n    \n    # Generate Perrin numbers up to n-1 (since we're counting from 0)\n    for i in range(3, n):\n        next_perrin = perrin[i-2] + perrin[i-3]\n        perrin.append(next_perrin)\n    \n    # Return the sum of the first n Perrin numbers\n    return sum(perrin)"}
{"task_id": "Mbpp/450", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_string(strings, length):\n    \"\"\"\n    Extract strings of specified length from a given list of strings.\n    \n    Args:\n        strings: List of string values\n        length: Target length to match\n    \n    Returns:\n        List of strings that have exactly the specified length\n    \"\"\"\n    result = []\n    for string in strings:\n        if len(string) == length:\n            result.append(string)\n    return result"}
{"task_id": "Mbpp/451", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with all whitespaces removed\n    \"\"\"\n    # Split the string by whitespace (default behavior) and join back together\n    # This removes all types of whitespace characters (spaces, tabs, newlines, etc.)\n    return ''.join(s.split())"}
{"task_id": "Mbpp/453", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sumofFactors(n):\n    if n <= 0:\n        return 0\n    \n    even_factor_sum = 0\n    \n    # Iterate from 1 to sqrt(n)\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            # i is a factor\n            if i % 2 == 0:\n                even_factor_sum += i\n            \n            # n//i is also a factor (but avoid double counting when i == n//i)\n            if i != n // i and (n // i) % 2 == 0:\n                even_factor_sum += n // i\n        \n        i += 1\n    \n    return even_factor_sum"}
{"task_id": "Mbpp/454", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef text_match_wordz(text):\n    # Pattern explanation:\n    # \\b - word boundary to ensure we match complete words\n    # \\w* - zero or more word characters (letters, digits, underscore)\n    # [zZ] - matches either lowercase 'z' or uppercase 'Z'\n    # \\w* - zero or more word characters\n    # \\b - word boundary at the end\n    pattern = r'\\b\\w*[zZ]\\w*\\b'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/455", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_monthnumb_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 31 days or not.\n    \n    Args:\n        month_number (int): The month number (1-12)\n        \n    Returns:\n        bool: True if the month has 31 days, False otherwise\n    \"\"\"\n    # Set of month numbers that have 31 days\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the given month number is in the set\n    return month_number in months_with_31_days"}
{"task_id": "Mbpp/456", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n    \n    Args:\n        string_list (list): A list of strings to be reversed\n        \n    Returns:\n        list: A new list with each string reversed\n    \"\"\"\n    return [string[::-1] for string in string_list]"}
{"task_id": "Mbpp/457", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Find_Min(lst):\n    # Handle edge case: empty input\n    if not lst:\n        return None\n    \n    # Initialize with the first sublist\n    min_sublist = lst[0]\n    min_length = len(lst[0])\n    \n    # Iterate through the rest of the sublists\n    for sublist in lst[1:]:\n        # If we find a shorter sublist, update our minimum\n        if len(sublist) < min_length:\n            min_sublist = sublist\n            min_length = len(sublist)\n    \n    return min_sublist"}
{"task_id": "Mbpp/458", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    \n    Args:\n        length (int or float): The length of the rectangle\n        width (int or float): The width of the rectangle\n    \n    Returns:\n        int or float: The area of the rectangle (length * width)\n    \"\"\"\n    return length * width"}
{"task_id": "Mbpp/459", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_uppercase(s):\n    \"\"\"\n    Remove uppercase substrings from a given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with all uppercase characters removed\n    \"\"\"\n    return ''.join(char for char in s if not char.isupper())"}
{"task_id": "Mbpp/460", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"task_id": "Mbpp/462", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef combinations_list(lst):\n    result = [[]]\n    for item in lst:\n        # For each existing combination, create a new one by adding the current item\n        # We iterate over a snapshot of the current result to avoid infinite loops\n        current_length = len(result)\n        for i in range(current_length):\n            result.append([item] + result[i])\n    return result"}
{"task_id": "Mbpp/463", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    # Initialize variables to track maximum and minimum products ending at current position\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # Store the current max_ending_here before updating\n        temp_max = max_ending_here\n        \n        # Update max_ending_here and min_ending_here\n        # Consider three possibilities: \n        # 1. Current element alone\n        # 2. Current element * previous max product\n        # 3. Current element * previous min product (for negative numbers)\n        max_ending_here = max(arr[i], arr[i] * max_ending_here, arr[i] * min_ending_here)\n        min_ending_here = min(arr[i], arr[i] * temp_max, arr[i] * min_ending_here)\n        \n        # Update the overall maximum\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far"}
{"task_id": "Mbpp/465", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef drop_empty(dictionary):\n    \"\"\"\n    Drop empty items (items with None values) from a dictionary.\n    \n    Args:\n        dictionary (dict): The input dictionary\n        \n    Returns:\n        dict: A new dictionary with None values removed\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"task_id": "Mbpp/468", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_product(arr):\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # dp[i] represents the maximum product of increasing subsequence ending at index i\n    dp = [0] * n\n    \n    # Initialize: each element forms a subsequence by itself\n    for i in range(n):\n        dp[i] = arr[i]\n    \n    # Fill the dp array\n    for i in range(1, n):\n        for j in range(i):\n            # If we can extend the subsequence ending at j\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] * arr[i])\n    \n    # Return the maximum product among all positions\n    return max(dp)"}
{"task_id": "Mbpp/470", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef add_pairwise(seq):\n    \"\"\"\n    Find the pairwise addition of neighboring elements in the given sequence.\n    \n    Args:\n        seq: A sequence (tuple or list) of numbers\n        \n    Returns:\n        A tuple containing the sums of adjacent pairs\n    \"\"\"\n    result = []\n    for i in range(len(seq) - 1):\n        result.append(seq[i] + seq[i + 1])\n    return tuple(result)"}
{"task_id": "Mbpp/471", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_remainder(arr, n):\n    # Handle edge case where n is 1\n    if n == 1:\n        return 0\n    \n    # Initialize result to 1\n    result = 1\n    \n    # Multiply each element and take modulo at each step\n    for num in arr:\n        result = (result * num) % n\n    \n    return result"}
{"task_id": "Mbpp/472", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_Consecutive(lst):\n    # Handle edge cases: empty list or single element\n    if len(lst) <= 1:\n        return True\n    \n    # Check for duplicates by comparing list length with set length\n    if len(lst) != len(set(lst)):\n        return False\n    \n    # For consecutive numbers, max - min should equal length - 1\n    return max(lst) - min(lst) == len(lst) - 1"}
{"task_id": "Mbpp/473", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tuple_intersection(list1, list2):\n    # Normalize tuples by sorting their elements\n    def normalize_tuple(t):\n        return tuple(sorted(t))\n    \n    # Create sets of normalized tuples for efficient lookup\n    normalized_set1 = {normalize_tuple(t): t for t in list1}\n    normalized_set2 = {normalize_tuple(t) for t in list2}\n    \n    # Find intersection of normalized tuples\n    intersection_normalized = set(normalized_set1.keys()) & normalized_set2\n    \n    # Return original tuples from list1 that have matches in list2\n    return {normalized_set1[normalized_t] for normalized_t in intersection_normalized}"}
{"task_id": "Mbpp/474", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sort_counter(d):\n    \"\"\"\n    Sort a dictionary by its values in descending order.\n    \n    Args:\n        d (dict): Dictionary to sort\n        \n    Returns:\n        list: List of tuples (key, value) sorted by value in descending order\n    \"\"\"\n    return sorted(d.items(), key=lambda item: item[1], reverse=True)"}
{"task_id": "Mbpp/476", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n        arr: A list of numbers\n        \n    Returns:\n        The sum of the maximum and minimum values in the array\n    \"\"\"\n    if not arr:  # Handle empty array case\n        return 0\n    \n    return max(arr) + min(arr)"}
{"task_id": "Mbpp/477", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n        s (str): The input string to convert\n        \n    Returns:\n        str: The string converted to lower case\n    \"\"\"\n    return s.lower()"}
{"task_id": "Mbpp/478", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_lowercase(s):\n    \"\"\"\n    Remove all lowercase substrings/characters from a given string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with all lowercase characters removed\n    \"\"\"\n    return ''.join(char for char in s if not char.islower())"}
{"task_id": "Mbpp/479", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef first_Digit(n):\n    # Convert to string and remove negative sign if present\n    n_str = str(abs(n))\n    # Return the first digit as an integer\n    return int(n_str[0])"}
{"task_id": "Mbpp/554", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Split(numbers):\n    \"\"\"\n    Takes a list of integers and returns only the odd ones.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        A list containing only the odd integers from the input list\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/555", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef difference(n):\n    # Calculate sum of first n natural numbers\n    sum_natural = n * (n + 1) // 2\n    \n    # Calculate sum of cubes of first n natural numbers\n    # Using the formula: (sum of first n natural numbers)^2\n    sum_cubes = sum_natural * sum_natural\n    \n    # Return the difference\n    return sum_cubes - sum_natural"}
{"task_id": "Mbpp/556", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Odd_Pair(arr, n):\n    \"\"\"\n    Count the number of pairs whose XOR value is odd.\n    \n    Args:\n        arr: List of integers\n        n: Length of the array\n    \n    Returns:\n        Number of pairs with odd XOR value\n    \"\"\"\n    # Count even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Pairs with odd XOR = (number of even numbers) * (number of odd numbers)\n    return even_count * odd_count"}
{"task_id": "Mbpp/557", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef toggle_string(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char  # Keep non-alphabetic characters unchanged\n    return result"}
{"task_id": "Mbpp/558", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef digit_distance_nums(num1, num2):\n    # Convert numbers to strings\n    str1 = str(num1)\n    str2 = str(num2)\n    \n    # Pad the shorter string with leading zeros\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    \n    # Calculate sum of absolute differences\n    total = 0\n    for i in range(max_len):\n        digit1 = int(str1[i])\n        digit2 = int(str2[i])\n        total += abs(digit1 - digit2)\n    \n    return total"}
{"task_id": "Mbpp/559", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_sub_array_sum(arr, n):\n    # Handle edge case of empty array\n    if n == 0:\n        return 0\n    \n    # Initialize variables for Kadane's algorithm\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, n):\n        # Either extend the existing subarray or start a new one\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        \n        # Update the maximum sum found so far\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far"}
{"task_id": "Mbpp/560", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef union_elements(tuple1, tuple2):\n    # Convert inputs to sets to handle duplicates and allow union operation\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find union of both sets\n    union_set = set1 | set2\n    \n    # Sort the elements and convert to tuple\n    result = tuple(sorted(union_set))\n    \n    return result"}
{"task_id": "Mbpp/562", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Find_Max_Length(lst):\n    \"\"\"\n    Find the length of the longest sublist in a list of lists.\n    \n    Args:\n        lst: A list of lists\n        \n    Returns:\n        int: The length of the longest sublist\n    \"\"\"\n    if not lst:  # Handle empty list case\n        return 0\n    \n    # Find the longest sublist using max() with len as key\n    longest_sublist = max(lst, key=len)\n    \n    # Return the length of the longest sublist\n    return len(longest_sublist)"}
{"task_id": "Mbpp/563", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_values(s):\n    # Use regex to find all values between quotation marks\n    # Pattern explanation:\n    # \"([^\"]*)\" - matches a quote, followed by any non-quote characters (captured), followed by a quote\n    return re.findall(r'\"([^\"]*)\"', s)"}
{"task_id": "Mbpp/564", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_Pairs(arr, n):\n    # Count frequency of each element\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Calculate total number of pairs\n    total_pairs = n * (n - 1) // 2\n    \n    # Calculate number of equal pairs\n    equal_pairs = 0\n    for count in freq.values():\n        equal_pairs += count * (count - 1) // 2\n    \n    # Return number of unequal pairs\n    return total_pairs - equal_pairs"}
{"task_id": "Mbpp/565", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef split(s):\n    return list(s)"}
{"task_id": "Mbpp/566", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_digits(n):\n    \"\"\"\n    Calculate the sum of digits of a non-negative integer.\n    \n    Args:\n        n (int): A non-negative integer\n        \n    Returns:\n        int: Sum of all digits in n\n    \"\"\"\n    total = 0\n    while n > 0:\n        digit = n % 10  # Extract the last digit\n        total += digit  # Add it to our running sum\n        n = n // 10     # Remove the last digit\n    return total"}
{"task_id": "Mbpp/567", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef issort_list(lst):\n    # Handle edge cases: empty list or single element list\n    if len(lst) <= 1:\n        return True\n    \n    # Iterate through the list, comparing each element with the next one\n    for i in range(len(lst) - 1):\n        # If current element is greater than the next element, it's not sorted\n        if lst[i] > lst[i + 1]:\n            return False\n    \n    # If we've gone through the entire list without finding an out-of-order pair, it's sorted\n    return True"}
{"task_id": "Mbpp/568", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef empty_list(N):\n    return [{} for _ in range(N)]"}
{"task_id": "Mbpp/569", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sort_sublists(list_of_lists):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n    \n    Args:\n        list_of_lists: A list containing sublists of strings\n        \n    Returns:\n        A new list of lists where each sublist is sorted alphabetically\n    \"\"\"\n    result = []\n    for sublist in list_of_lists:\n        # Sort each sublist and append to result\n        sorted_sublist = sorted(sublist)\n        result.append(sorted_sublist)\n    \n    return result"}
{"task_id": "Mbpp/572", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef two_unique_nums(nums):\n    # Count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Filter numbers that appear exactly once, maintaining original order\n    result = []\n    for num in nums:\n        if count_dict[num] == 1:\n            result.append(num)\n    \n    return result"}
{"task_id": "Mbpp/573", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef unique_product(lst):\n    # Get unique numbers using set\n    unique_numbers = set(lst)\n    \n    # Handle empty set case - product of no numbers is 1\n    if not unique_numbers:\n        return 1\n    \n    # Calculate product of all unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product"}
{"task_id": "Mbpp/576", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_Sub_Array(main_list, sub_list):\n    # Handle edge cases\n    if len(sub_list) == 0:\n        return True\n    \n    if len(sub_list) > len(main_list):\n        return False\n    \n    # Check for contiguous subarray using sliding window\n    for i in range(len(main_list) - len(sub_list) + 1):\n        # Check if the slice matches the sub_list\n        if main_list[i:i + len(sub_list)] == sub_list:\n            return True\n    \n    return False"}
{"task_id": "Mbpp/577", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef last_Digit_Factorial(n):\n    if n < 5:\n        # Calculate factorial directly for small values\n        factorial = 1\n        for i in range(1, n + 1):\n            factorial *= i\n        return factorial % 10\n    else:\n        # For n >= 5, the last digit is always 0\n        return 0"}
{"task_id": "Mbpp/578", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef interleave_lists(list1, list2, list3):\n    result = []\n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result"}
{"task_id": "Mbpp/579", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_dissimilar(tuple1, tuple2):\n    # Convert to sets for efficient difference operations\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements in tuple1 but not in tuple2\n    only_in_first = [x for x in tuple1 if x not in set2]\n    \n    # Find elements in tuple2 but not in tuple1\n    only_in_second = [x for x in tuple2 if x not in set1]\n    \n    # Combine and return as tuple\n    return tuple(only_in_first + only_in_second)"}
{"task_id": "Mbpp/581", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef surface_Area(base_edge, height):\n    # Calculate base area\n    base_area = base_edge ** 2\n    \n    # Calculate slant height using Pythagorean theorem\n    # slant_height = sqrt(height^2 + (base_edge/2)^2)\n    slant_height = math.sqrt(height ** 2 + (base_edge / 2) ** 2)\n    \n    # Calculate lateral surface area (4 triangular faces)\n    lateral_area = 2 * base_edge * slant_height\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return int(total_surface_area) if total_surface_area.is_integer() else total_surface_area"}
{"task_id": "Mbpp/583", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef catalan_number(n):\n    if n <= 1:\n        return 1\n    \n    # Create array to store catalan numbers\n    catalan = [0] * (n + 1)\n    \n    # Base cases\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    # Fill catalan array using recurrence relation\n    for i in range(2, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - 1 - j]\n    \n    return catalan[n]"}
{"task_id": "Mbpp/585", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef expensive_items(items, n):\n    # Sort items by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    # Return the first n items\n    return sorted_items[:n]"}
{"task_id": "Mbpp/586", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef split_Arr(arr, n):\n    # Split the array at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    return second_part + first_part"}
{"task_id": "Mbpp/587", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef list_tuple(lst):\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \n    Args:\n        nums: A list of numbers\n        \n    Returns:\n        The difference between the maximum and minimum values in the list\n        \n    Raises:\n        ValueError: If the list is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List cannot be empty\")\n    \n    return max(nums) - min(nums)"}
{"task_id": "Mbpp/589", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef perfect_squares(lower_bound, upper_bound):\n    # Find the smallest integer whose square is >= lower_bound\n    start = math.ceil(math.sqrt(lower_bound))\n    \n    # Find the largest integer whose square is <= upper_bound\n    end = math.floor(math.sqrt(upper_bound))\n    \n    # Generate perfect squares by squaring integers from start to end (inclusive)\n    result = []\n    for i in range(start, end + 1):\n        square = i * i\n        # Double-check that the square is within bounds (handles edge cases with floats)\n        if lower_bound <= square <= upper_bound:\n            result.append(square)\n    \n    return result"}
{"task_id": "Mbpp/590", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef polar_rect(x, y):\n    # Calculate magnitude (r) and angle (theta) from rectangular coordinates\n    magnitude = math.sqrt(x**2 + y**2)\n    angle = math.atan2(y, x)\n    \n    # Create complex number representation\n    complex_form = complex(x, y)\n    \n    return ((magnitude, angle), complex_form)"}
{"task_id": "Mbpp/591", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef swap_List(lst):\n    # Handle edge cases: empty list or single element list\n    if len(lst) <= 1:\n        return lst\n    \n    # Swap first and last elements using tuple unpacking\n    lst[0], lst[-1] = lst[-1], lst[0]\n    \n    return lst"}
{"task_id": "Mbpp/592", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_Of_product(n):\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n    \n    This uses the mathematical identity:\n    Sum of C(n,k) * C(n,k+1) for k from 0 to n-1 equals C(2n, n+1)\n    \n    Args:\n        n (int): The upper index for the binomial coefficients\n        \n    Returns:\n        int: The sum of products of consecutive binomial coefficients\n    \"\"\"\n    # Using the identity: sum of C(n,k) * C(n,k+1) = C(2n, n+1)\n    # Calculate C(2n, n+1) = (2n)! / ((n+1)! * (n-1)!)\n    \n    # We can compute this efficiently as:\n    # C(2n, n+1) = (2n * (2n-1) * ... * (n+2)) / ((n-1) * (n-2) * ... * 1)\n    \n    if n == 0:\n        return 0\n    \n    # Calculate C(2n, n+1)\n    result = 1\n    for i in range(n - 1):\n        result = result * (2 * n - i) // (i + 1)\n    \n    return result"}
{"task_id": "Mbpp/593", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef removezero_ip(ip):\n    # Split the IP address by dots\n    octets = ip.split('.')\n    \n    # Remove leading zeros from each octet by converting to int and back to string\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    \n    # Join the octets back together with dots\n    return '.'.join(cleaned_octets)"}
{"task_id": "Mbpp/594", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n            \n        # If we've found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even - first_odd\n    \n    # This shouldn't happen according to the problem constraints\n    # but including it for completeness\n    return first_even - first_odd if first_even is not None and first_odd is not None else 0"}
{"task_id": "Mbpp/596", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tuple_size(input_sequence):\n    # Convert the input sequence to a tuple\n    t = tuple(input_sequence)\n    # Return the size of the tuple in bytes\n    return sys.getsizeof(t)"}
{"task_id": "Mbpp/597", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_kth(arr1, arr2, k):\n    # Make sure arr1 is the smaller array for efficiency\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    n1, n2 = len(arr1), len(arr2)\n    \n    # Handle edge cases\n    if n1 == 0:\n        return arr2[k-1]\n    if n2 == 0:\n        return arr1[k-1]\n    \n    # Binary search on arr1\n    left, right = max(0, k - n2), min(n1, k)\n    \n    while left <= right:\n        # Number of elements taken from arr1\n        mid1 = (left + right) // 2\n        # Number of elements taken from arr2\n        mid2 = k - mid1\n        \n        # Get boundary values\n        arr1_left_max = float('-inf') if mid1 == 0 else arr1[mid1 - 1]\n        arr1_right_min = float('inf') if mid1 == n1 else arr1[mid1]\n        \n        arr2_left_max = float('-inf') if mid2 == 0 else arr2[mid2 - 1]\n        arr2_right_min = float('inf') if mid2 == n2 else arr2[mid2]\n        \n        # Check if we found the correct partition\n        if arr1_left_max <= arr2_right_min and arr2_left_max <= arr1_right_min:\n            return max(arr1_left_max, arr2_left_max)\n        elif arr1_left_max > arr2_right_min:\n            # Too many elements from arr1, move left\n            right = mid1 - 1\n        else:\n            # Too few elements from arr1, move right\n            left = mid1 + 1\n    \n    # This shouldn't happen with valid inputs\n    raise ValueError(\"Invalid input\")"}
{"task_id": "Mbpp/598", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef armstrong_number(n):\n    # Convert number to string to easily access digits\n    str_n = str(n)\n    \n    # Count number of digits\n    num_digits = len(str_n)\n    \n    # Calculate sum of each digit raised to the power of number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in str_n)\n    \n    # Check if sum equals original number\n    return sum_of_powers == n"}
{"task_id": "Mbpp/599", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_average(n):\n    # Calculate sum using formula: n * (n + 1) / 2\n    total_sum = n * (n + 1) // 2\n    \n    # Calculate average by dividing sum by n\n    average = total_sum / n\n    \n    # Return both values as a tuple\n    return (total_sum, average)"}
{"task_id": "Mbpp/600", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_Even(number):\n    \"\"\"\n    Check whether the given number is even or not.\n    \n    Args:\n        number (int): The number to check\n        \n    Returns:\n        bool: True if the number is even, False otherwise\n    \"\"\"\n    return number % 2 == 0"}
{"task_id": "Mbpp/602", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"}
{"task_id": "Mbpp/603", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_ludic(n):\n    if n < 1:\n        return []\n    \n    # Start with list of numbers from 1 to n\n    candidates = list(range(1, n + 1))\n    ludic_numbers = []\n    \n    while candidates:\n        # The first number is always a Ludic number\n        first = candidates[0]\n        ludic_numbers.append(first)\n        \n        # If the first number is greater than the length of candidates,\n        # we can't do any more sieving, so just add all remaining numbers\n        if first > len(candidates):\n            # All remaining numbers are Ludic\n            ludic_numbers.extend(candidates[1:])\n            break\n            \n        # Remove every 'first' number from the list starting from index 0\n        # We do this by keeping only the numbers that are NOT at positions\n        # first-1, 2*first-1, 3*first-1, etc. (0-indexed)\n        new_candidates = []\n        for i in range(len(candidates)):\n            # Position in 1-indexed terms is i+1\n            # We keep it if (i+1) mod first != 0\n            if (i + 1) % first != 0:\n                new_candidates.append(candidates[i])\n                \n        candidates = new_candidates\n    \n    return ludic_numbers"}
{"task_id": "Mbpp/604", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the order of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string\n    return ' '.join(reversed_words)"}
{"task_id": "Mbpp/605", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef prime_num(n):\n    # Handle edge cases\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check for odd divisors from 3 to sqrt(n)\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    \n    return True"}
{"task_id": "Mbpp/606", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n    \n    Args:\n        degrees (float): Angle in degrees\n        \n    Returns:\n        float: Angle in radians\n    \"\"\"\n    return degrees * (math.pi / 180)"}
{"task_id": "Mbpp/607", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_literals(text, pattern):\n    \"\"\"\n    Search for a literal string pattern in text and return the match with indices.\n    \n    Args:\n        text (str): The text to search in\n        pattern (str): The literal string pattern to search for\n    \n    Returns:\n        tuple: A tuple containing (matched_string, start_index, end_index)\n               or None if pattern is not found\n    \"\"\"\n    start_index = text.find(pattern)\n    \n    # If pattern is not found, find() returns -1\n    if start_index == -1:\n        return None\n    \n    # Calculate end index (start + length of pattern)\n    end_index = start_index + len(pattern)\n    \n    # Return the pattern and its indices\n    return (pattern, start_index, end_index)"}
{"task_id": "Mbpp/608", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef bell_Number(n):\n    if n == 0:\n        return 1\n    \n    # Initialize Bell's triangle\n    # We only need to keep track of the current and previous rows\n    prev_row = [1]  # Row 0\n    \n    for i in range(1, n + 1):\n        # Start new row with the last element of previous row\n        curr_row = [prev_row[-1]]\n        \n        # Fill the rest of the row\n        for j in range(len(prev_row)):\n            curr_row.append(curr_row[j] + prev_row[j])\n        \n        # Update previous row for next iteration\n        prev_row = curr_row\n    \n    # The first element of the last row is our answer\n    return prev_row[0]"}
{"task_id": "Mbpp/610", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_kth_element(lst, k):\n    # k is 1-indexed, so we subtract 1 to get the 0-indexed position\n    index_to_remove = k - 1\n    \n    # Return a new list excluding the k-th element\n    # Slice from beginning to index_to_remove, then from index_to_remove+1 to end\n    return lst[:index_to_remove] + lst[index_to_remove + 1:]"}
{"task_id": "Mbpp/611", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_of_nth(matrix, n):\n    # Extract the nth column elements from all rows\n    column_elements = [row[n] for row in matrix]\n    # Return the maximum value in that column\n    return max(column_elements)"}
{"task_id": "Mbpp/612", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef merge(list_of_lists):\n    # Use zip with unpacking to transpose the list of lists\n    # This will group all first elements together and all second elements together\n    transposed = zip(*list_of_lists)\n    # Convert each tuple in the result to a list\n    return [list(group) for group in transposed]"}
{"task_id": "Mbpp/614", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef cummulative_sum(tuple_list):\n    total = 0\n    for tup in tuple_list:\n        for element in tup:\n            total += element\n    return total"}
{"task_id": "Mbpp/615", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef average_tuple(tuples):\n    \"\"\"\n    Takes a tuple of tuples and returns the average value for each tuple as a list.\n    \n    Args:\n        tuples: A tuple of tuples containing numerical values\n        \n    Returns:\n        A list of averages, where each average corresponds to one inner tuple\n    \"\"\"\n    result = []\n    for t in tuples:\n        avg = sum(t) / len(t)\n        result.append(avg)\n    return result"}
{"task_id": "Mbpp/616", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tuple_modulo(tuple1, tuple2):\n    \"\"\"\n    Takes two iterables of the same length and performs element-wise modulo operation.\n    \n    Args:\n        tuple1: First iterable (list or tuple)\n        tuple2: Second iterable (list or tuple)\n        \n    Returns:\n        A tuple containing the element-wise modulo results\n    \"\"\"\n    return tuple(a % b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/618", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef div_list(list1, list2):\n    \"\"\"\n    Divide two lists element-wise.\n    \n    Args:\n        list1: First list of numbers\n        list2: Second list of numbers\n    \n    Returns:\n        A list containing the element-wise division results as floats\n    \"\"\"\n    result = []\n    for a, b in zip(list1, list2):\n        result.append(float(a) / float(b))\n    return result"}
{"task_id": "Mbpp/619", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef move_num(s):\n    # Collect non-digit characters\n    non_digits = []\n    digits = []\n    \n    for char in s:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    \n    # Concatenate non-digits and digits\n    return ''.join(non_digits) + ''.join(digits)"}
{"task_id": "Mbpp/620", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef largest_subset(nums):\n    if not nums:\n        return 0\n    \n    # Sort the array to ensure smaller numbers come first\n    nums.sort()\n    n = len(nums)\n    \n    # dp[i] represents the size of the largest divisible subset ending at index i\n    dp = [1] * n\n    \n    # Fill the dp array\n    for i in range(1, n):\n        for j in range(i):\n            # If nums[i] is divisible by nums[j], we can extend the subset ending at j\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # Return the maximum value in dp array\n    return max(dp)"}
{"task_id": "Mbpp/622", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_median(arr1, arr2, n):\n    # Ensure arr1 is the smaller array for consistency, though both are same size\n    if n == 0:\n        return 0.0\n    \n    # Binary search in arr1\n    low = 0\n    high = n\n    \n    while low <= high:\n        # Partition arr1\n        i = (low + high) // 2\n        # Partition arr2 such that left half has n elements\n        j = n - i\n        \n        # Handle edge cases for indices\n        # Left elements\n        max_left_arr1 = float('-inf') if i == 0 else arr1[i-1]\n        max_left_arr2 = float('-inf') if j == 0 else arr2[j-1]\n        \n        # Right elements\n        min_right_arr1 = float('inf') if i == n else arr1[i]\n        min_right_arr2 = float('inf') if j == n else arr2[j]\n        \n        # Check if we have found the correct partition\n        if max_left_arr1 <= min_right_arr2 and max_left_arr2 <= min_right_arr1:\n            # Found the correct partition\n            # Median is average of max of left and min of right\n            return (max(max_left_arr1, max_left_arr2) + min(min_right_arr1, min_right_arr2)) / 2.0\n        elif max_left_arr1 > min_right_arr2:\n            # Too far right in arr1, move left\n            high = i - 1\n        else:\n            # Too far left in arr1, move right\n            low = i + 1\n    \n    # This should never happen for valid input\n    return 0.0"}
{"task_id": "Mbpp/623", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef nth_nums(nums, n):\n    \"\"\"\n    Compute the n-th power of each number in a list.\n    \n    Args:\n        nums: A list of numbers\n        n: The power to raise each number to\n    \n    Returns:\n        A list containing each number raised to the n-th power\n    \"\"\"\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_upper(s):\n    \"\"\"\n    Convert a given string to uppercase.\n    \n    Args:\n        s (str): The input string to convert\n        \n    Returns:\n        str: The uppercase version of the input string\n    \"\"\"\n    return s.upper()"}
{"task_id": "Mbpp/626", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef triangle_area(radius):\n    # Handle invalid radius\n    if radius < 0:\n        return None\n    \n    # Handle degenerate case\n    if radius == 0:\n        return 0\n    \n    # For a semicircle, the largest inscribed triangle has:\n    # - Base = diameter = 2 * radius\n    # - Height = radius (perpendicular from top of semicircle to diameter)\n    # Area = (1/2) * base * height = (1/2) * 2 * radius * radius = radius^2\n    return radius * radius"}
{"task_id": "Mbpp/628", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef replace_spaces(string):\n    return string.replace(' ', '%20')"}
{"task_id": "Mbpp/629", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Split(numbers):\n    \"\"\"\n    Find even numbers from a list of numbers.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        A list containing only the even numbers from the input list,\n        preserving their original order\n    \"\"\"\n    even_numbers = []\n    for num in numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers"}
{"task_id": "Mbpp/630", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_coordinates(coordinate):\n    \"\"\"\n    Extract all the adjacent coordinates of the given coordinate tuple.\n    \n    Args:\n        coordinate: A tuple or list containing two integers (x, y)\n        \n    Returns:\n        A list of lists containing all adjacent coordinates including the original\n    \"\"\"\n    x, y = coordinate\n    \n    # Generate all adjacent coordinates including the original\n    result = []\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            result.append([i, j])\n            \n    return result"}
{"task_id": "Mbpp/631", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef replace_spaces(s):\n    # Create a translation table to swap spaces and underscores\n    translation_table = str.maketrans(' _', '_ ')\n    # Apply the translation\n    return s.translate(translation_table)"}
{"task_id": "Mbpp/632", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef move_zero(nums):\n    # Create a copy to avoid modifying the original list\n    result = nums[:]\n    \n    # Pointer to track where to place the next non-zero element\n    write_index = 0\n    \n    # First pass: move all non-zero elements to the front\n    for read_index in range(len(result)):\n        if result[read_index] != 0:\n            result[write_index] = result[read_index]\n            write_index += 1\n    \n    # Second pass: fill the remaining positions with zeros\n    for i in range(write_index, len(result)):\n        result[i] = 0\n    \n    return result"}
{"task_id": "Mbpp/633", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef pair_xor_Sum(arr, n):\n    total_sum = 0\n    \n    # Iterate through all 32 bit positions\n    for i in range(32):\n        # Count how many numbers have bit i set\n        count_ones = 0\n        for num in arr:\n            if num & (1 << i):\n                count_ones += 1\n        \n        # Calculate contribution of this bit position\n        # count_ones numbers have bit 1, (n - count_ones) have bit 0\n        # Number of pairs with different bits = count_ones * (n - count_ones)\n        # Each such pair contributes 2^i to the sum\n        contribution = count_ones * (n - count_ones) * (1 << i)\n        total_sum += contribution\n    \n    return total_sum"}
{"task_id": "Mbpp/635", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef heap_sort(arr):\n    def heapify(arr, n, i):\n        # Initialize largest as root\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        # If left child exists and is greater than root\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n            \n        # If right child exists and is greater than current largest\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n            \n        # If largest is not root, swap and continue heapifying\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n    \n    # Build a max heap\n    n = len(arr)\n    # Start from last non-leaf node and heapify each node\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n        \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[0], arr[i] = arr[i], arr[0]\n        # Call heapify on reduced heap\n        heapify(arr, i, 0)\n        \n    return arr"}
{"task_id": "Mbpp/637", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef noprofit_noloss(amount1, amount2):\n    \"\"\"\n    Check whether the given amounts have no profit and no loss.\n    \n    Args:\n        amount1: First amount (e.g., cost price)\n        amount2: Second amount (e.g., selling price)\n        \n    Returns:\n        bool: True if both amounts are equal (no profit, no loss), False otherwise\n    \"\"\"\n    return amount1 == amount2"}
{"task_id": "Mbpp/638", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef wind_chill(v, t):\n    \"\"\"\n    Calculate the wind chill index given wind velocity and temperature.\n    \n    Args:\n        v (float): Wind velocity in km/h\n        t (float): Temperature in Celsius\n    \n    Returns:\n        int: Wind chill index rounded to the nearest integer\n    \"\"\"\n    # Wind chill formula: \n    # 13.12 + 0.6215*T - 11.37*V^0.16 + 0.3965*T*V^0.16\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    \n    # Round to the nearest integer\n    return round(wind_chill_index)"}
{"task_id": "Mbpp/639", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sample_nam(names):\n    # Filter names that start with uppercase letter and sum their lengths\n    return sum(len(name) for name in names if name and name[0].isupper())"}
{"task_id": "Mbpp/641", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_nonagonal(n):\n    \"\"\"\n    Calculate the nth nonagonal number using the formula:\n    N(n) = n(7n - 5)/2\n    \n    Args:\n        n (int): The position of the nonagonal number to calculate\n        \n    Returns:\n        int: The nth nonagonal number\n    \"\"\"\n    return n * (7 * n - 5) // 2"}
{"task_id": "Mbpp/643", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef text_match_wordz_middle(text):\n    # If string has less than 3 characters, 'z' can only be at start or end\n    if len(text) < 3:\n        return False\n    \n    # Check if 'z' exists in the middle portion (excluding first and last characters)\n    middle_portion = text[1:-1]\n    return 'z' in middle_portion"}
{"task_id": "Mbpp/644", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef reverse_Array_Upto_K(arr, k):\n    # Handle edge cases\n    if k <= 0:\n        return arr[:]\n    if k >= len(arr):\n        return arr[::-1]\n    \n    # Reverse first k elements and concatenate with remaining elements\n    return arr[:k][::-1] + arr[k:]"}
{"task_id": "Mbpp/721", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maxAverageOfPath(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    n = len(matrix)\n    \n    # Create DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: first cell\n    dp[0][0] = matrix[0][0]\n    \n    # Fill first row (can only come from left)\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill first column (can only come from above)\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    # The maximum sum is at the bottom-right corner\n    max_sum = dp[n-1][n-1]\n    \n    # Path length is always 2*n - 1\n    path_length = 2 * n - 1\n    \n    # Return the average\n    return max_sum / path_length"}
{"task_id": "Mbpp/722", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef filter_data(students, min_height, min_weight):\n    \"\"\"\n    Filters students based on minimum height and weight criteria.\n    \n    Args:\n        students (dict): Dictionary with student names as keys and (height, weight) as values\n        min_height (float): Minimum height threshold\n        min_weight (float): Minimum weight threshold\n    \n    Returns:\n        dict: Filtered dictionary containing only students meeting both criteria\n    \"\"\"\n    filtered_students = {}\n    \n    for name, (height, weight) in students.items():\n        if height > min_height and weight > min_weight:\n            filtered_students[name] = (height, weight)\n    \n    return filtered_students"}
{"task_id": "Mbpp/723", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_same_pair(list1, list2):\n    count = 0\n    for val1, val2 in zip(list1, list2):\n        if val1 == val2:\n            count += 1\n    return count"}
{"task_id": "Mbpp/724", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef power_base_sum(base, power):\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert to string to access individual digits\n    result_str = str(result)\n    \n    # Sum all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum"}
{"task_id": "Mbpp/725", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between double quotation marks from the given string.\n    \n    Args:\n        s (str): Input string containing text with double-quoted substrings\n        \n    Returns:\n        list: List of strings found between double quotation marks\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)"}
{"task_id": "Mbpp/726", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef multiply_elements(t):\n    # Convert input to tuple if it's a list\n    if isinstance(t, list):\n        t = tuple(t)\n    \n    # If tuple has only one element or is empty, return empty tuple\n    if len(t) <= 1:\n        return ()\n    \n    # Create result tuple by multiplying consecutive elements\n    result = []\n    for i in range(len(t) - 1):\n        result.append(t[i] * t[i + 1])\n    \n    return tuple(result)"}
{"task_id": "Mbpp/728", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_list(list1, list2):\n    \"\"\"\n    Takes two lists of equal length and returns a new list where each element\n    is the sum of corresponding elements from the input lists.\n    \n    Args:\n        list1: First list of numbers\n        list2: Second list of numbers\n    \n    Returns:\n        A new list containing element-wise sums\n    \"\"\"\n    result = []\n    for a, b in zip(list1, list2):\n        result.append(a + b)\n    return result"}
{"task_id": "Mbpp/730", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    result = [lst[0]]  # Add the first element\n    \n    for i in range(1, len(lst)):\n        if lst[i] != lst[i-1]:  # If current element is different from previous\n            result.append(lst[i])\n    \n    return result"}
{"task_id": "Mbpp/731", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef lateralsurface_cone(r, h):\n    # Calculate the slant height using Pythagorean theorem\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate the lateral surface area using the formula: π × r × l\n    lateral_surface_area = math.pi * r * l\n    \n    return lateral_surface_area"}
{"task_id": "Mbpp/732", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef replace_specialchar(text):\n    # Create a translation table that maps space, comma, and dot to colon\n    translation_table = str.maketrans(' ,.', ':::')\n    # Apply the translation to replace all occurrences\n    return text.translate(translation_table)"}
{"task_id": "Mbpp/733", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            result = mid  # Record the occurrence\n            right = mid - 1  # Continue searching in the left half\n        elif arr[mid] < target:\n            left = mid + 1  # Search in the right half\n        else:\n            right = mid - 1  # Search in the left half\n    \n    return result"}
{"task_id": "Mbpp/734", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_Of_Subarray_Prod(arr):\n    if not arr:\n        return 0\n    \n    total_sum = 0\n    subarray_sum_ending_here = 0\n    \n    for num in arr:\n        # Calculate sum of products of subarrays ending at current position\n        subarray_sum_ending_here = num * (1 + subarray_sum_ending_here)\n        # Add to overall sum\n        total_sum += subarray_sum_ending_here\n        \n    return total_sum"}
{"task_id": "Mbpp/735", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef toggle_middle_bits(n):\n    if n <= 1:\n        return n\n    \n    # Find the position of the most significant bit (0-indexed)\n    bit_length = n.bit_length()\n    \n    # Create a mask with all bits set to 1 for the bit length of n\n    all_ones = (1 << bit_length) - 1\n    \n    # Create a mask that excludes the first and last bits\n    # Clear the most significant bit\n    mask = all_ones & ~(1 << (bit_length - 1))\n    # Clear the least significant bit\n    mask = mask & ~1\n    \n    # Toggle the middle bits using XOR\n    return n ^ mask"}
{"task_id": "Mbpp/736", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef left_insertion(sorted_list, value):\n    \"\"\"\n    Find the leftmost insertion point for a value in a sorted list.\n    \n    Args:\n        sorted_list: A list sorted in ascending order\n        value: The value to insert\n        \n    Returns:\n        The index where the value should be inserted to maintain sorted order\n    \"\"\"\n    left, right = 0, len(sorted_list)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if sorted_list[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left"}
{"task_id": "Mbpp/737", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_str(s):\n    \"\"\"\n    Check whether the given string starts with a vowel or not using regex.\n    \n    Args:\n        s (str): The input string to check\n        \n    Returns:\n        bool: True if string starts with a vowel, False otherwise\n    \"\"\"\n    # Pattern to match strings that start with a vowel (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.match to check if string starts with a vowel\n    return bool(re.match(pattern, s))"}
{"task_id": "Mbpp/739", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_Index(n):\n    # For n=1, the first triangular number is 1, which has 1 digit\n    if n == 1:\n        return 1\n    \n    # We want the smallest k such that k*(k+1)/2 >= 10^(n-1)\n    # This leads to solving k^2 + k - 2*10^(n-1) >= 0\n    # Using quadratic formula: k >= (-1 + sqrt(1 + 8*10^(n-1)))/2\n    \n    target = 10 ** (n - 1)\n    discriminant = 1 + 8 * target\n    sqrt_discriminant = math.sqrt(discriminant)\n    k_approx = (-1 + sqrt_discriminant) / 2\n    \n    # Start with the ceiling of the approximation\n    k = math.ceil(k_approx)\n    \n    # Check if this k gives us a triangular number with exactly n digits\n    while True:\n        triangular_num = k * (k + 1) // 2\n        # Count digits in triangular_num\n        digit_count = len(str(triangular_num))\n        \n        if digit_count == n:\n            return k\n        elif digit_count < n:\n            k += 1\n        else:  # digit_count > n\n            # This shouldn't happen with our approximation, but just in case\n            k -= 1"}
{"task_id": "Mbpp/740", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        t: A tuple with even number of elements\n        \n    Returns:\n        A dictionary where adjacent pairs in the tuple become key-value pairs\n    \"\"\"\n    result = {}\n    # Iterate through the tuple with step 2 to get pairs\n    for i in range(0, len(t), 2):\n        # Use current element as key and next element as value\n        result[t[i]] = t[i + 1]\n    return result"}
{"task_id": "Mbpp/741", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef all_Characters_Same(s):\n    # Handle edge cases\n    if len(s) <= 1:\n        return True\n    \n    # Get the first character to compare against\n    first_char = s[0]\n    \n    # Check if all characters are the same as the first character\n    for char in s:\n        if char != first_char:\n            return False\n    \n    return True"}
{"task_id": "Mbpp/742", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef area_tetrahedron(edge_length):\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron.\n    \n    A regular tetrahedron has 4 equilateral triangular faces.\n    Surface area = sqrt(3) * edge_length^2\n    \n    Args:\n        edge_length: The length of an edge of the tetrahedron\n        \n    Returns:\n        The surface area of the tetrahedron\n    \"\"\"\n    return math.sqrt(3) * edge_length ** 2"}
{"task_id": "Mbpp/743", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef rotate_right(lst, n):\n    # Handle edge cases\n    if not lst or n == 0:\n        return lst\n    \n    # Calculate effective rotation (in case n > length of list)\n    n = n % len(lst)\n    \n    # If n is 0 after modulo, no rotation needed\n    if n == 0:\n        return lst\n    \n    # Split the list and rotate\n    # Take last n elements and put them at the beginning\n    return lst[-n:] + lst[:-n]"}
{"task_id": "Mbpp/744", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_none(sequence):\n    \"\"\"\n    Check if the given sequence (tuple or list) has any None value.\n    \n    Args:\n        sequence: A tuple or list to check for None values\n        \n    Returns:\n        bool: True if None is found, False otherwise\n    \"\"\"\n    for element in sequence:\n        if element is None:\n            return True\n    return False"}
{"task_id": "Mbpp/745", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef divisible_by_digits(startnum, endnum):\n    def is_divisible_by_all_digits(n):\n        # Convert number to string to easily access each digit\n        str_n = str(n)\n        \n        # Check each digit\n        for digit_char in str_n:\n            digit = int(digit_char)\n            \n            # Skip if digit is 0 (division by zero)\n            if digit == 0:\n                return False\n            \n            # Check if n is divisible by this digit\n            if n % digit != 0:\n                return False\n        \n        # If we get here, n is divisible by all its digits\n        return True\n    \n    # List to store results\n    result = []\n    \n    # Check each number in the range\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_all_digits(num):\n            result.append(num)\n    \n    return result"}
{"task_id": "Mbpp/748", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef capital_words_spaces(text):\n    if not text:\n        return \"\"\n    \n    result = text[0]  # First character doesn't need a preceding space\n    \n    for i in range(1, len(text)):\n        if text[i].isupper():\n            result += \" \" + text[i]\n        else:\n            result += text[i]\n    \n    return result"}
{"task_id": "Mbpp/749", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sort_numeric_strings(lst):\n    # Convert each string in the list to an integer\n    int_list = [int(x) for x in lst]\n    # Sort the list of integers\n    sorted_list = sorted(int_list)\n    # Return the sorted list\n    return sorted_list"}
{"task_id": "Mbpp/750", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of a tuple to the end of a list.\n    \n    Args:\n        lst: A list to which elements will be added\n        tup: A tuple whose elements will be added to the list\n    \n    Returns:\n        A new list containing all elements from the original list followed by all elements from the tuple\n    \"\"\"\n    return lst + list(tup)"}
{"task_id": "Mbpp/751", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_min_heap(arr):\n    \"\"\"\n    Check if the given array represents a min heap.\n    \n    Args:\n        arr: List of integers representing a binary tree in level order\n        \n    Returns:\n        bool: True if array represents a min heap, False otherwise\n    \"\"\"\n    n = len(arr)\n    \n    # An empty array or single element is a valid min heap\n    if n <= 1:\n        return True\n    \n    # Check all parent nodes (from index 0 to (n-2)//2)\n    # For each parent, verify it's <= its children\n    for i in range((n - 2) // 2 + 1):\n        # Check left child (2*i + 1)\n        left_child_index = 2 * i + 1\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n            \n        # Check right child (2*i + 2)\n        right_child_index = 2 * i + 2\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    return True"}
{"task_id": "Mbpp/752", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef jacobsthal_num(n):\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Calculate iteratively from J(2) to J(n)\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1"}
{"task_id": "Mbpp/753", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element.\n    \n    Args:\n        records: List of tuples where each tuple has a string and a numeric value\n        k: Number of minimum records to return\n    \n    Returns:\n        List of k tuples with the smallest second elements\n    \"\"\"\n    # Sort the records based on the second element (numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements which are the k smallest records\n    return sorted_records[:k]"}
{"task_id": "Mbpp/754", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_index_list(l1, l2, l3):\n    # Find the minimum length among all three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize result list\n    result = []\n    \n    # Iterate through indices up to the minimum length\n    for i in range(min_length):\n        # Check if all three lists have the same element at index i\n        if l1[i] == l2[i] == l3[i]:\n            # Add the common element to the result list\n            result.append(l1[i])\n    \n    return result"}
{"task_id": "Mbpp/755", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef second_smallest(numbers):\n    # Get unique numbers and sort them\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if we have at least 2 unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest (index 1)\n    return unique_numbers[1]"}
{"task_id": "Mbpp/757", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_reverse_pairs(strings):\n    count = 0\n    n = len(strings)\n    \n    # For each string, check if its reverse exists in the remaining part of the list\n    for i in range(n):\n        current_string = strings[i]\n        reversed_string = current_string[::-1]\n        \n        # Check in the remaining part of the list to avoid double counting\n        for j in range(i + 1, n):\n            if strings[j] == reversed_string:\n                count += 1\n                break  # Found the pair, no need to check further\n    \n    return count"}
{"task_id": "Mbpp/758", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Count occurrences of each sublist in the input list.\n    \n    Args:\n        list_of_lists: A list containing sublists\n        \n    Returns:\n        A dictionary where keys are tuples (converted from sublists) \n        and values are their occurrence counts\n    \"\"\"\n    count_dict = {}\n    \n    # Iterate through each sublist\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_key = tuple(sublist)\n        \n        # Increment the count for this tuple key\n        if tuple_key in count_dict:\n            count_dict[tuple_key] += 1\n        else:\n            count_dict[tuple_key] = 1\n    \n    return count_dict"}
{"task_id": "Mbpp/759", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_decimal(s):\n    # Regular expression pattern to match a decimal number with exactly 2 digits after the decimal point\n    pattern = r'^\\d+\\.\\d{2}$'\n    \n    # Check if the string matches the pattern\n    return bool(re.match(pattern, s))"}
{"task_id": "Mbpp/760", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef unique_Element(lst):\n    # Handle edge case: empty list\n    if not lst:\n        return True\n    \n    # Convert list to set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if there's only one distinct element\n    return len(unique_elements) == 1"}
{"task_id": "Mbpp/762", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_monthnumber_number(month_number):\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n    \n    Args:\n        month_number (int): Month number from 1 to 12\n        \n    Returns:\n        bool: True if the month has exactly 30 days, False otherwise\n    \"\"\"\n    # Months with exactly 30 days: April(4), June(6), September(9), November(11)\n    months_with_30_days = {4, 6, 9, 11}\n    \n    return month_number in months_with_30_days"}
{"task_id": "Mbpp/763", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_min_diff(arr, n):\n    # Handle edge case\n    if n < 2:\n        return 0\n    \n    # Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Initialize minimum difference with a large value\n    min_diff = float('inf')\n    \n    # Find the minimum difference between adjacent elements\n    for i in range(n - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef number_ctr(str1):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n        str1 (str): The input string to analyze\n        \n    Returns:\n        int: The count of digit characters in the string\n    \"\"\"\n    return sum(1 for char in str1 if char.isdigit())"}
{"task_id": "Mbpp/765", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    Powers of 2 are the only impolite numbers.\n    \n    Args:\n        n: The position of the polite number to find (1-indexed)\n        \n    Returns:\n        The nth polite number\n    \"\"\"\n    count = 0  # Counter for polite numbers found\n    num = 1    # Current number being checked\n    \n    while count < n:\n        # Check if num is NOT a power of 2 (i.e., is polite)\n        # A number is a power of 2 if (num & (num - 1)) == 0 and num > 0\n        if not (num > 0 and (num & (num - 1)) == 0):\n            count += 1\n            if count == n:\n                return num\n        num += 1\n    \n    return num"}
{"task_id": "Mbpp/766", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst: A list of elements\n        \n    Returns:\n        A list of tuples where each tuple contains two consecutive elements\n    \"\"\"\n    # Handle edge cases: empty list or single element list\n    if len(lst) <= 1:\n        return []\n    \n    # Create pairs of consecutive elements\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i + 1]))\n    \n    return result"}
{"task_id": "Mbpp/767", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef get_pairs_count(arr, target_sum):\n    \"\"\"\n    Count the number of pairs in the array whose sum equals target_sum.\n    \n    Args:\n        arr: List of integers\n        target_sum: Target sum to find pairs for\n    \n    Returns:\n        Number of pairs whose sum equals target_sum\n    \"\"\"\n    freq = {}\n    count = 0\n    \n    for num in arr:\n        complement = target_sum - num\n        \n        # If complement exists in freq, add its frequency to count\n        if complement in freq:\n            count += freq[complement]\n        \n        # Update frequency of current number\n        freq[num] = freq.get(num, 0) + 1\n    \n    return float(count)"}
{"task_id": "Mbpp/769", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef Diff(list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find elements in list1 but not in list2, preserving order\n    diff1 = [x for x in list1 if x not in set2]\n    \n    # Find elements in list2 but not in list1, preserving order\n    diff2 = [x for x in list2 if x not in set1]\n    \n    # Combine the differences\n    return diff1 + diff2"}
{"task_id": "Mbpp/770", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef odd_num_sum(n):\n    \"\"\"\n    Find the sum of fourth power of first n odd natural numbers.\n    \n    Args:\n        n (int): Number of odd natural numbers to consider\n        \n    Returns:\n        int: Sum of fourth powers of first n odd natural numbers\n    \"\"\"\n    total = 0\n    for k in range(1, n + 1):\n        odd_number = 2 * k - 1\n        total += odd_number ** 4\n    return total"}
{"task_id": "Mbpp/771", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_expression(expression):\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to map closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Set of opening brackets for quick lookup\n    opening_brackets = {'(', '{', '['}\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If it's an opening bracket, push to stack\n        if char in opening_brackets:\n            stack.append(char)\n        # If it's a closing bracket\n        elif char in bracket_map:\n            # If stack is empty or the top doesn't match, it's unbalanced\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    \n    # If stack is empty, all brackets were matched\n    return len(stack) == 0"}
{"task_id": "Mbpp/772", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_length(s, k):\n    # Split the string into words\n    words = s.split()\n    \n    # Filter out words with length k\n    filtered_words = [word for word in words if len(word) != k]\n    \n    # Join the remaining words back into a string\n    return ' '.join(filtered_words)"}
{"task_id": "Mbpp/773", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef occurance_substring(text, substring):\n    # Find the starting position of the substring\n    start_pos = text.find(substring)\n    \n    # If substring is not found, return None\n    if start_pos == -1:\n        return None\n    \n    # Calculate the end position (exclusive)\n    end_pos = start_pos + len(substring)\n    \n    # Return the result as a tuple\n    return (substring, start_pos, end_pos)"}
{"task_id": "Mbpp/775", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef odd_position(lst):\n    # Check elements at odd indices (1, 3, 5, ...)\n    for i in range(1, len(lst), 2):\n        # If any element at odd index is even, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If all elements at odd indices are odd, return True\n    return True"}
{"task_id": "Mbpp/777", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_sum(lst):\n    return sum(set(lst))"}
{"task_id": "Mbpp/778", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    result = []\n    current_group = [lst[0]]\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current_group.append(lst[i])\n        else:\n            result.append(current_group)\n            current_group = [lst[i]]\n    \n    # Don't forget to add the last group\n    result.append(current_group)\n    \n    return result"}
{"task_id": "Mbpp/780", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_combinations(tuple_list):\n    import itertools\n    \n    # Generate all combinations of 2 tuples from the input list\n    combinations = list(itertools.combinations(tuple_list, 2))\n    \n    # For each combination, compute the element-wise sum\n    result = []\n    for combo in combinations:\n        # Element-wise sum of the two tuples\n        summed_tuple = tuple(a + b for a, b in zip(combo[0], combo[1]))\n        result.append(summed_tuple)\n    \n    return result"}
{"task_id": "Mbpp/781", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n    \n    Args:\n        n (int): A positive integer\n        \n    Returns:\n        bool: True if the count of divisors is even, False otherwise\n    \"\"\"\n    # A number has an odd number of divisors if and only if it's a perfect square\n    # So we return True if it's NOT a perfect square (even count of divisors)\n    sqrt_n = int(n ** 0.5)\n    return sqrt_n * sqrt_n != n"}
{"task_id": "Mbpp/782", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef odd_length_sum(arr):\n    n = len(arr)\n    total_sum = 0\n    \n    # Iterate through all odd lengths\n    for length in range(1, n + 1, 2):  # Start at 1, go up to n, increment by 2\n        # For each odd length, iterate through all possible starting positions\n        for start in range(n - length + 1):\n            # Calculate sum of subarray from start to start+length\n            subarray_sum = sum(arr[start:start + length])\n            total_sum += subarray_sum\n    \n    return total_sum"}
{"task_id": "Mbpp/784", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef mul_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n            \n        # If we've found both, we can return early\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # This shouldn't happen according to the problem's test cases\n    # but let's handle it gracefully anyway\n    return 0"}
{"task_id": "Mbpp/785", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef tuple_str_int(s):\n    # Remove the parentheses and strip any leading/trailing whitespace\n    inner_content = s[1:-1].strip()\n    \n    # Handle empty tuple case\n    if not inner_content:\n        return ()\n    \n    # Split by comma, strip whitespace from each part, and convert to integers\n    numbers = [int(part.strip()) for part in inner_content.split(',')]\n    \n    # Convert list to tuple and return\n    return tuple(numbers)"}
{"task_id": "Mbpp/786", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef right_insertion(arr, val):\n    \"\"\"\n    Find the right insertion point for a specified value in sorted order.\n    \n    Args:\n        arr: A sorted list of elements\n        val: The value to find the insertion point for\n        \n    Returns:\n        The index where the value should be inserted to maintain sorted order,\n        after any existing equal elements\n    \"\"\"\n    left, right = 0, len(arr)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= val:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left"}
{"task_id": "Mbpp/787", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef text_match_three(text):\n    \"\"\"\n    Check if a string contains an 'a' followed by exactly three 'b's.\n    \n    Args:\n        text (str): The input string to check\n        \n    Returns:\n        bool: True if the string contains 'abbb', False otherwise\n    \"\"\"\n    return 'abbb' in text"}
{"task_id": "Mbpp/788", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef new_tuple(lst, string):\n    return (*lst, string)"}
{"task_id": "Mbpp/790", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef even_position(nums):\n    # Check each even index position\n    for i in range(0, len(nums), 2):  # Start at 0, go to end, step by 2\n        if nums[i] % 2 != 0:  # If the number at even index is odd\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_nested(input_tuple):\n    \"\"\"\n    Remove nested tuples from the given tuple.\n    \n    Args:\n        input_tuple: A tuple that may contain nested tuples\n        \n    Returns:\n        A new tuple with nested tuples removed\n    \"\"\"\n    result = []\n    for element in input_tuple:\n        if not isinstance(element, tuple):\n            result.append(element)\n    return tuple(result)"}
{"task_id": "Mbpp/792", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_list(lists):\n    return len(lists)"}
{"task_id": "Mbpp/793", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef last(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            result = mid  # Update result when target is found\n            left = mid + 1  # Continue searching in the right half\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result if result != -1 else -1"}
{"task_id": "Mbpp/794", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef text_starta_endb(text):\n    \"\"\"\n    Check if a string starts with 'a' and ends with 'b'\n    \n    Args:\n        text (str): The string to check\n        \n    Returns:\n        bool: True if string starts with 'a' and ends with 'b', False otherwise\n    \"\"\"\n    return text.startswith('a') and text.endswith('b')"}
{"task_id": "Mbpp/796", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef return_sum(d):\n    \"\"\"\n    Calculate the sum of all values in a dictionary.\n    \n    Args:\n        d (dict): A dictionary with numeric values\n        \n    Returns:\n        int/float: The sum of all values in the dictionary\n    \"\"\"\n    return sum(d.values())"}
{"task_id": "Mbpp/797", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sum_in_range(l, r):\n    \"\"\"\n    Find the sum of all odd natural numbers within the range l and r (inclusive).\n    \n    Args:\n        l (int): Left boundary of the range\n        r (int): Right boundary of the range\n    \n    Returns:\n        int: Sum of all odd numbers in the range\n    \"\"\"\n    total_sum = 0\n    \n    # Iterate through all numbers in the range [l, r]\n    for num in range(l, r + 1):\n        # Check if the number is odd\n        if num % 2 != 0:\n            total_sum += num\n    \n    return total_sum"}
{"task_id": "Mbpp/798", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total"}
{"task_id": "Mbpp/799", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef left_rotate(n, d):\n    # Ensure d is within 0-31 range for 32-bit operations\n    d = d % 32\n    \n    # Perform left rotation using the formula\n    # Left shift by d bits and OR with right shift by (32-d) bits\n    # Apply 32-bit mask to keep result within 32 bits\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF"}
{"task_id": "Mbpp/800", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a string.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        str: String with all whitespaces removed\n    \"\"\"\n    return ''.join(s.split())"}
{"task_id": "Mbpp/801", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef test_three_equal(a, b, c):\n    # Count how many numbers are equal\n    if a == b == c:\n        # All three are equal\n        return 3\n    elif a == b or b == c or a == c:\n        # Exactly two are equal\n        return 2\n    else:\n        # All are different\n        return 0"}
{"task_id": "Mbpp/803", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_perfect_square(n):\n    # Handle edge cases\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    \n    # Binary search for the square root\n    left, right = 1, n // 2 + 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        \n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return False"}
{"task_id": "Mbpp/804", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_product_even(lst):\n    \"\"\"\n    Check whether the product of numbers in a list is even or not.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        bool: True if the product is even, False if the product is odd\n    \"\"\"\n    # A product is even if at least one number in the list is even\n    for num in lst:\n        if num % 2 == 0:\n            return True\n    \n    # If no even number found, all numbers are odd, so product is odd\n    return False"}
{"task_id": "Mbpp/805", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n        lists: A list of lists containing numbers\n        \n    Returns:\n        The sublist with the maximum sum of elements\n    \"\"\"\n    return max(lists, key=sum)"}
{"task_id": "Mbpp/806", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_run_uppercase(s):\n    if not s:\n        return 0\n    \n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run"}
{"task_id": "Mbpp/807", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num"}
{"task_id": "Mbpp/808", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_K(collection, k):\n    \"\"\"\n    Check if the given collection contains the value k.\n    \n    Args:\n        collection: A tuple or list to search in\n        k: The value to search for\n    \n    Returns:\n        bool: True if k is found in collection, False otherwise\n    \"\"\"\n    return k in collection"}
{"task_id": "Mbpp/809", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef check_smaller(t1, t2):\n    \"\"\"\n    Check if each element of second tuple is smaller than its corresponding element in the first tuple.\n    \n    Args:\n        t1: First tuple\n        t2: Second tuple\n    \n    Returns:\n        bool: True if all elements in t2 are smaller than corresponding elements in t1, False otherwise\n    \"\"\"\n    for elem1, elem2 in zip(t1, t2):\n        if elem2 >= elem1:\n            return False\n    return True"}
{"task_id": "Mbpp/106", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple and return a new tuple.\n    \n    Args:\n        lst: A list of elements to append\n        tpl: A tuple of elements to which the list will be appended\n    \n    Returns:\n        A new tuple containing all elements from tpl followed by all elements from lst\n    \"\"\"\n    # Convert the list to a tuple and concatenate with the original tuple\n    return tpl + tuple(lst)"}
{"task_id": "Mbpp/124", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef angle_complex(real, imag):\n    \"\"\"\n    Calculate the angle (argument) of a complex number given its real and imaginary parts.\n    \n    Args:\n        real: The real part of the complex number\n        imag: The imaginary part of the complex number (including the 'j')\n        \n    Returns:\n        The angle in radians\n    \"\"\"\n    # Extract the imaginary coefficient if imag is a complex number\n    if isinstance(imag, complex):\n        imag_coeff = imag.imag\n    else:\n        imag_coeff = imag\n    \n    # Calculate angle using atan2\n    return math.atan2(imag_coeff, real)"}
{"task_id": "Mbpp/580", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extract_even(nested_tuple):\n    result = []\n    \n    for element in nested_tuple:\n        if isinstance(element, int):\n            # If it's an integer, only include it if it's even\n            if element % 2 == 0:\n                result.append(element)\n        elif isinstance(element, tuple):\n            # If it's a tuple, recursively process it\n            processed_tuple = extract_even(element)\n            # Only include the processed tuple if it's not empty\n            if processed_tuple:\n                result.append(processed_tuple)\n    \n    return tuple(result)"}
{"task_id": "Mbpp/720", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef add_dict_to_tuple(input_tuple, input_dict):\n    # Create a new tuple by concatenating the input tuple with a tuple containing the dictionary\n    return input_tuple + (input_dict,)"}
