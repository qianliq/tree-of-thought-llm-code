{"task_id": "1575_A. Another Sorting Problem", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sorted_books(n, m, titles):\n    # Create a list of tuples containing sorting keys and their original indices\n    indexed_titles = [(title, i + 1) for i, title in enumerate(titles)]\n    \n    # Define the sorting function based on the specified asc-desc-endingly rules\n    def custom_sort_key(title_info):\n        title, original_index = title_info\n        # Create the sort key: odd indexed ascending, even indexed descending\n        sort_key = tuple(\n            title[i] if (i % 2 == 0) else -ord(title[i])  # ord for descending\n            for i in range(m)\n        )\n        return sort_key\n    \n    # Sort the titles using the custom key while keeping track of original indices\n    sorted_titles = sorted(indexed_titles, key=custom_sort_key)\n    \n    # Extract the original indices from the sorted list\n    result_indices = [index for title, index in sorted_titles]\n    \n    return result_indices\n\n# Reading input from stdin and executing the function\nimport sys\n\ninput_data = sys.stdin.read().strip().split('\\n')\nn, m = map(int, input_data[0].split())\ntitles = input_data[1:n+1]\n\nresult = sorted_books(n, m, titles)\n\n# Print the result indices\nprint(' '.join(map(str, result)))"}
{"task_id": "1575_B. Building an Amusement Park", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport math\nimport sys\n\ndef minimum_radius(n, k, habitats):\n    # Calculate distances from origin for each habitat\n    distances = [math.sqrt(x * x + y * y) for x, y in habitats]\n\n    # Sort the distances\n    distances.sort()\n\n    # The minimum radius to include at least k habitats is the k-th smallest distance\n    return distances[k - 1]\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip().splitlines()\n    \n    # Read n and k\n    n, k = map(int, input_data[0].split())\n    \n    # Read the coordinates of the habitats\n    habitats = [tuple(map(int, input_data[i + 1].split())) for i in range(n)]\n    \n    # Calculate the minimum radius\n    result = minimum_radius(n, k, habitats)\n    \n    # Print the result with the required precision\n    print(f\"{result:.10f}\")"}
{"task_id": "1575_C. Cyclic Sum", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_segments(n, m, k, a):\n    MOD = 10**9 + 7\n    \n    # Step 1: Prepare prefix sums modulo k\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = (prefix_sum[i] + a[i]) % k\n    \n    # Step 2: Count occurrences of each prefix sum mod k\n    count_mod = {}\n    count_mod[0] = 1  # We consider the empty prefix as mod 0\n    total_segments = 0\n    \n    # We analyze the prefix sums for m times\n    for _ in range(m):\n        for j in range(1, n + 1):\n            mod_value = prefix_sum[j]\n            total_segments = (total_segments + count_mod.get(mod_value, 0)) % MOD\n            \n            # Increment the count for this prefix sum mod value\n            if mod_value in count_mod:\n                count_mod[mod_value] += 1\n            else:\n                count_mod[mod_value] = 1\n\n    return total_segments\n\n# Reading the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\n\n# Output the result\nprint(count_segments(n, m, k, a))"}
{"task_id": "1575_D. Divisible by Twenty-Five", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_possibilities(s):\n    n = len(s)\n    valid_endings = ['00', '25', '50', '75']\n    total_count = 0\n    \n    for ending in valid_endings:\n        if n < 2:\n            continue  # We need at least 2 positions for an ending\n        \n        # Check if we can place this ending in the last two positions\n        for i in range(2):\n            if s[n - 2 + i] != '_' and s[n - 2 + i] != ending[i]:\n                break\n        else:\n            # Valid placement for the ending\n            # Now check the leading part (s[:-2])\n            lead_part = s[:-2]\n            if lead_part and lead_part[0] == '0' and lead_part != '0':\n                continue  # Leading zero is invalid unless it's just \"0\"\n            \n            # Count the possibilities\n            possibilities = 1  # Start with one way to fill\n            \n            for j in range(n - 2):\n                if lead_part[j] == '_':\n                    possibilities *= 10  # Any digit can work (0-9)\n                elif lead_part[j] == 'X':\n                    # If it's 'X', we have to assign it a digit\n                    possibilities *= 9 if j == 0 else 10  # First position can't be zero if it's part of a multi-digit number\n            \n            # Now handle the ending\n            if ending[0] == '0':\n                # Special case for ending 00, make sure it's counted correctly\n                if lead_part == \"\" or lead_part == \"0\":\n                    total_count += possibilities\n            else:\n                # Count the fixed possibilities for the ending\n                total_count += possibilities\n    \n    return total_count\n\n# Main function to read input and output result\ndef main():\n    import sys\n    input = sys.stdin.read\n    s = input().strip()\n    print(count_possibilities(s))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_E. Eye-Pleasing City Park Tour", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nfrom collections import defaultdict, deque\n\nMOD = 10**9 + 7\n\ndef total_happiness(n, k, happiness, edges):\n    # Tree representation\n    tree = defaultdict(list)\n    color = {}\n    \n    for u, v, t in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n        color[(u, v)] = t\n        color[(v, u)] = t\n    \n    # Total happiness initialized\n    total_sum = 0\n\n    # Initialize visited array and ticket usage tracking\n    visited = [False] * (n + 1)\n\n    # Function to perform DFS\n    def dfs(node, tickets_used, current_happiness):\n        nonlocal total_sum\n        \n        # Mark current node as visited\n        visited[node] = True\n        \n        # Include happiness of the current node\n        current_happiness += happiness[node - 1]\n        \n        # Update total_sum with valid tours ending at `node`\n        total_sum = (total_sum + current_happiness) % MOD\n        \n        # Traverse to connected nodes\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                # Check the edge color\n                used_tickets = tickets_used\n                \n                if color[(node, neighbor)] == 1: # White edge\n                    if tickets_used < k:\n                        # We can switch to white (cost 1 ticket)\n                        used_tickets += 1\n                        dfs(neighbor, used_tickets, current_happiness)\n                else: # Black edge\n                    # Stay on black (cost 0 tickets)\n                    dfs(neighbor, used_tickets, current_happiness)\n\n        # Backtrack\n        visited[node] = False\n    \n    # Start DFS from each node allowing k tickets\n    for start_node in range(1, n + 1):\n        # Reset visited list\n        visited = [False] * (n + 1)\n        dfs(start_node, 0, 0)\n\n    return total_sum\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, k = map(int, data[0].split())\n    happiness = list(map(int, data[1].split()))\n    edges = []\n    \n    for line in data[2:n + 1]:\n        u, v, t = map(int, line.split())\n        edges.append((u, v, t))\n\n    result = total_happiness(n, k, happiness, edges)\n    print(result)"}
{"task_id": "1575_F. Finding Expected Value", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef mod_inv(x, mod):\n    \"\"\" Function to compute modular inverse using Fermat's Little Theorem \"\"\"\n    return pow(x, mod - 2, mod)\n\ndef expected_operations(n, k, a):\n    MOD = 10**9 + 7\n\n    # Count distinct values and -1's\n    distinct = set()\n    count_minus_one = 0\n    \n    for val in a:\n        if val == -1:\n            count_minus_one += 1\n        else:\n            distinct.add(val)\n\n    g = len(distinct)  # Current distinct count without counting -1's\n    c = count_minus_one  # Count of -1's\n\n    # Total expected operations\n    total_operations = 0\n    \n    # Go through possible number of distinct values\n    for d in range(g, min(k, g + c) + 1):\n        # Expected operations when we have exactly d distinct numbers\n        expected = 0\n        for i in range(1, d + 1):\n            expected += n * mod_inv(i, MOD)  # Equivalent to n / i mod MOD\n            expected %= MOD\n\n        # Accumulate total with current expected operations\n        total_operations += expected\n        total_operations %= MOD\n\n    # Since there are k^c configurations, each being equally likely\n    configurations = pow(k, c, MOD)\n\n    # Total expected value\n    p = total_operations\n    q = configurations\n    \n    # Result is p * q^{-1} mod MOD\n    result = p * mod_inv(q, MOD) % MOD\n    return result\n\n# Main function to read input and produce output\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    print(expected_operations(n, k, a))"}
{"task_id": "1575_G. GCD Festival", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef calculate_prettiness(n, a):\n    MOD = 10**9 + 7\n    max_a = 100000\n    \n    # Count frequency of each value in the array\n    freq = [0] * (max_a + 1)\n    for number in a:\n        freq[number] += 1\n    \n    total_prettiness = 0\n    \n    # Iterate through each possible divisor\n    for d in range(1, max_a + 1):\n        count_a = 0  # Count of numbers divisible by d\n        count_index = 0  # Count of indices divisible by d\n        \n        # Count numbers in a that are multiples of d\n        for multiple in range(d, max_a + 1, d):\n            count_a += freq[multiple]\n        \n        # Count indices that are multiples of d\n        for multiple in range(d, n + 1, d):\n            count_index += 1\n        \n        if count_a > 0 and count_index > 0:\n            # GCD contribution for this divisor\n            gcd_contribution = d * count_a * count_index\n            total_prettiness = (total_prettiness + gcd_contribution) % MOD\n    \n    return total_prettiness\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n+1]))\n\n# Calculate and output prettiness value\nresult = calculate_prettiness(n, a)\nprint(result)"}
{"task_id": "1575_H. Holiday Wall Ornaments", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_changes_to_create_k_occurrences(n, m, a, b):\n    # Array to hold the number of changes needed at each position\n    change_count = [0] * (n - m + 1)\n\n    # Compute the required changes for each starting position\n    for i in range(n - m + 1):\n        change_count[i] = sum(1 for j in range(m) if a[i + j] != b[j])\n    \n    # Initialize the results array\n    results = [float('inf')] * (n - m + 2)\n    results[0] = 0  # To achieve 0 occurrences, we need 0 changes by default.\n\n    # Iterate to find minimum changes for each number of occurrences\n    for k in range(1, n - m + 2):  # k occurrences from 1 to n-m+1\n        for i in range(n - m + 1):\n            if k == 1:\n                results[k] = min(results[k], change_count[i])\n            else:\n                # We check previous positions to prevent overlaps\n                prev_pos = i - m if k > 1 else -1\n                if prev_pos < 0:\n                    continue\n                results[k] = min(results[k], results[k - 1] + change_count[i])\n\n            # Check for overlaps\n            if k > 1 and results[k - 1] < float('inf'):\n                next_change = results[k - 1] + change_count[i]\n                if prev_pos >= 0:\n                    results[k] = min(results[k], next_change)\n\n    # Post-process results to replace float('inf') with -1 where needed\n    for k in range(n - m + 2):\n        if results[k] == float('inf'):\n            results[k] = -1\n    \n    return results\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn, m = map(int, data[0].split())\na = data[1].strip()\nb = data[2].strip()\n\n# Execute function and print results\nresults = min_changes_to_create_k_occurrences(n, m, a, b)\nprint(\" \".join(map(str, results)))"}
{"task_id": "1575_I. Illusions of the Desert", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nHere's the implementation based on the described approach:\n\n```python\nfrom sys import stdin, stdout\nimport sys\nfrom collections import defaultdict\n\ninput = stdin.read\nsys.setrecursionlimit(200000)\n\nclass LCATree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n        self.parent = [0] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.illusion = [0] * (n + 1)\n        self.lift = [[0] * 20 for _ in range(n + 1)]\n        self.energy_cache = []\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, node, par, depth):\n        self.parent[node] = par\n        self.depth[node] = depth\n        self.lift[node][0] = par\n        for i in range(1, 20):\n            if self.lift[node][i-1] != 0:\n                self.lift[node][i] = self.lift[self.lift[node][i-1]][i-1]\n\n        for neighbor in self.adj[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, depth + 1)\n\n    def initialize(self, a):\n        self.illusion = a\n        self.dfs(1, 0, 0)\n\n    def lca(self, u, v):\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        \n        # Both nodes at the same depth\n        for i in range(19, -1, -1):\n            if self.depth[self.lift[u][i]] >= self.depth[v]:\n                u = self.lift[u][i]\n\n        if u == v:\n            return u\n        \n        for i in range(19, -1, -1):\n            if self.lift[u][i] != self.lift[v][i]:\n                u = self.lift[u][i]\n                v = self.lift[v][i]\n        \n        return self.lift[u][0]\n\n    def energy_between(self, u, v):\n        lca_node = self.lca(u, v)\n        total_energy = 0\n        \n        path_nodes = []\n        x = u\n        while x != lca_node:\n            path_nodes.append(x)\n            x = self.parent[x]\n        path_nodes.append(lca_node)\n        \n        x = v\n        while x != lca_node:\n            path_nodes.append(x)\n            x = self.parent[x]\n\n        for i in range(len(path_nodes) - 1):\n            u = path_nodes[i]\n            v = path_nodes[i + 1]\n            total_energy += max(abs(self.illusion[u] + self.illusion[v]),\n                                abs(self.illusion[u] - self.illusion[v]))\n        \n        return total_energy\n    \n    def update_illusion(self,room, new_value):\n        self.illusion[room] = new_value\n\ndef main():\n    input_data = input().splitlines()\n    n, q = map(int, input_data[0].split())\n    illusions = list(map(int, input_data[1]."}
{"task_id": "1575_J. Jeopardy of Dropped Balls", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef dropping_balls(n, m, k, grid, columns):\n    results = []\n    \n    for c in columns:\n        current_col = c - 1  # Convert to 0-indexed\n        row = 0\n        \n        while row < n:\n            direction = grid[row][current_col]\n            if direction == 1:  # move right\n                if current_col + 1 < m:\n                    current_col += 1\n                else:\n                    results.append(current_col + 1)  # out of bounds to the right\n                    break\n            elif direction == 2:  # move down\n                row += 1\n                grid[row - 1][current_col] = 2  # set the cell value to 2 (moving down)\n            elif direction == 3:  # move left\n                if current_col - 1 >= 0:\n                    current_col -= 1\n                else:\n                    results.append(current_col + 1)  # out of bounds to the left\n                    break\n            # Check if we've dropped out of grid after moving down\n            if row >= n:\n                results.append(current_col + 1)  # out of bounds below\n                break\n    return results\n\n# Read input from stdin and run the algorithm\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Read the first line\nn, m, k = map(int, data[0].split())\n# Read the grid\ngrid = [list(map(int, line.split())) for line in data[1:n+1]]\n# Read the columns from which balls are dropped\ncolumns = list(map(int, data[n+1].split()))\n\n# Get results\nresults = dropping_balls(n, m, k, grid, columns)\n# Print results\nprint(' '.join(map(str, results)))"}
{"task_id": "1575_K. Knitting Batik", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef mod_exp(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:  # If exp is odd\n            result = (result * base) % mod\n        exp = exp >> 1  # Divide exp by 2\n        base = (base * base) % mod\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    r = int(data[3])\n    c = int(data[4])\n    \n    # Input the corners of the sub-rectangles (not actually used in computation)\n    a_x = int(data[5])\n    a_y = int(data[6])\n    b_x = int(data[7])\n    b_y = int(data[8])\n    \n    # Total number of cells in the selected sub-rectangle\n    total_cells = r * c\n    \n    # Number of valid color combinations\n    mod = 10**9 + 7\n    result = mod_exp(k, total_cells, mod)\n    \n    print(result)"}
{"task_id": "1575_L. Longest Array Deconstruction", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_f(n, a):\n    count = [0] * (n + 1)  # Create a count array for indices 1 to n\n    \n    # Count occurrences of each number\n    for num in a:\n        if 1 <= num <= n:  # We only care about numbers in the range [1, n]\n            count[num] += 1\n            \n    f_a = 0  # This will hold the maximum value of f(a)\n    \n    # Iterate through all possible indices from 1 to n\n    for i in range(1, n + 1):\n        if count[i] > 0:  # If there's at least one occurrence of i\n            f_a += 1  # We can match index i with value i\n            count[i] -= 1  # Remove it from consideration\n    \n    return f_a\n\n# Reading input and outputting the solution\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    result = maximize_f(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_M. Managing Telephone Poles", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n, m, grid):\n    # Step 1: Initiate distance grid with high values\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    queue = deque()\n\n    # Step 2: Add all poles to the queue and set their distance to 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distances[i][j] = 0\n                queue.append((i, j))\n\n    # Step 3: Multi-source BFS\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distances[nx][ny] > distances[x][y] + 1:\n                    distances[nx][ny] = distances[x][y] + 1\n                    queue.append((nx, ny))\n\n    # Step 4: Calculate the sum of squared distances\n    total_sum = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            total_sum += distances[i][j] ** 2\n\n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\ngrid = [list(map(int, data[i + 1])) for i in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)"}
{"task_id": "1579_A. Casimir's String Solitaire", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_erase_string(test_cases):\n    results = []\n    for s in test_cases:\n        a_count = s.count('A')\n        b_count = s.count('B')\n        c_count = s.count('C')\n        \n        # Length of the string must be even and b_count must be at least a_count + c_count\n        if len(s) % 2 == 0 and b_count >= a_count + c_count:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nt = int(data[0])  # Number of test cases\ntest_cases = data[1:t + 1]  # The test cases\n\n# Get results\nresults = can_erase_string(test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "1579_B. Shifting Sort", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef sort_using_cyclic_shifts(tests):\n    results = []\n    for test in tests:\n        n, a = test\n        sorted_a = sorted(a)\n        actions = []\n        \n        # Process each element in the original array\n        for i in range(n):\n            while a[i] != sorted_a[i]:\n                # Find the position of sorted_a[i] in the original array\n                target_value = sorted_a[i]\n                target_index = a.index(target_value, i)  # Locate the index of target value\n                \n                # Prepare for a cyclic shift\n                # Segment will go from i to target_index\n                l = i + 1  # converting to 1-based index\n                r = target_index + 1  # converting to 1-based index\n                \n                # Calculate the number of offsets\n                d = r - l  # This is the size of the segment we will rotate\n                \n                # Perform the shift operation\n                segment = a[l-1:r]  # extracting the segment in 0-index\n                shifted_segment = segment[d:] + segment[:d]  # Perform the left shift\n                a[l-1:r] = shifted_segment  # place it back in the array\n                \n                # Record the action\n                actions.append((l, r, d))\n        \n        results.append(f\"{len(actions)}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    return \"\\n\".join(results)\n\n# Reading inputs\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])\n    tests = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        tests.append((n, a))\n        index += 2\n    \n    result = sort_using_cyclic_shifts(tests)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1579_C. Ticks", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_draw_ticks(n, m, k, grid):\n    marked = [[False] * m for _ in range(n)]  # To mark cells that can form ticks\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*' and not marked[i][j]:\n                # Determine the maximum size of the tick we can place with center (i, j)\n                d = 0\n                while True:\n                    # Check if we can draw a tick of size d\n                    if i - d < 0 or j - d < 0 or j + d >= m:  # Out of bounds\n                        break\n                    \n                    # Check if all necessary cells are '*'\n                    can_draw = True\n                    for h in range(d + 1):\n                        if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n                            can_draw = False\n                            break\n                    \n                    if can_draw:\n                        d += 1\n                    else:\n                        break\n                \n                d -= 1  # d is now the maximum size we can draw at (i, j)\n                \n                if d >= k:\n                    # Mark all cells affected by this tick\n                    for h in range(d + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n    # After processing, check if any '*' remains unmarked\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\ndef process_test_cases():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    result = []\n    index = 1\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        grid = [data[index + i] for i in range(n)]\n        index += n\n        \n        result.append(can_draw_ticks(n, m, k, grid))\n    \n    print(\"\\n\".join(result))\n\n# This code reads input, processes each test case, and prints the output."}
{"task_id": "1579_D. Productive Meeting", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport heapq\nimport sys\ninput = sys.stdin.read\n\ndef max_talks(t, test_cases):\n    results = []\n    \n    for x in range(t):\n        n = test_cases[x][0]\n        a = test_cases[x][1]\n        \n        # Create a max heap with (-sociability, index)\n        max_heap = []\n        for index in range(n):\n            if a[index] > 0:\n                heapq.heappush(max_heap, (-a[index], index + 1))  # Store index as 1-based\n        \n        talks = []\n        while len(max_heap) > 1:\n            # Get two people with the highest sociability\n            first_sociability, first_index = heapq.heappop(max_heap)\n            second_sociability, second_index = heapq.heappop(max_heap)\n            \n            # Record the talk between these two\n            talks.append((first_index, second_index))\n            \n            # Decrease their sociability\n            first_sociability += 1  # since it's negative, we add\n            second_sociability += 1  # since it's negative, we add\n            \n            # If they still have sociability left, push them back\n            if first_sociability < 0:\n                heapq.heappush(max_heap, (first_sociability, first_index))\n            if second_sociability < 0:\n                heapq.heappush(max_heap, (second_sociability, second_index))\n        \n        # Prepare the result for this test case\n        results.append(str(len(talks)))\n        for talk in talks:\n            results.append(f\"{talk[0]} {talk[1]}\")\n    \n    # Print all results as required\n    print(\"\\n\".join(results))\n\n# Example of reading from input and calling the function\nif __name__ == \"__main__\":\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    \n    for i in range(1, 2 * t, 2):\n        n = int(data[i])\n        a = list(map(int, data[i + 1].split()))\n        test_cases.append((n, a))\n    \n    max_talks(t, test_cases)"}
{"task_id": "1579_E2. Array Optimization by Deque", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_inversions_in_deque(test_cases):\n    output = []\n    \n    for a in test_cases:\n        front = []\n        back = []\n        inversions = 0\n        \n        for value in a:\n            if not back or value >= back[-1]:  # Try adding to the back\n                back.append(value)\n            elif not front or value <= front[0]:  # Try adding to the front\n                front.insert(0, value)\n            else:\n                # Need to decide which side to add\n                # If we can't add to either current side without creating an inversion,\n                # Compare both sides and choose wisely.\n\n                # Check future conditions for inversions\n                if value < back[-1]:\n                    front.insert(0, value)\n                    # Any elements in back greater than value now contribute to inversions\n                    inversions += len(back)  # Every element in the back is an inversion with value\n                else:\n                    back.append(value)\n        \n        # Count the total number of inversions based on front and back.\n        # This simple accounting can be adjusted if needed based on specific conditions.\n        \n        # This method assumes transverse checking, which ensures directionality is respected.\n        output.append(inversions)\n\n    return output\n\n# Reading inputs and outputs; typical usage would read from standard input.\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])  # Number of test cases\n    test_cases = []\n    \n    for i in range(t):\n        n = int(data[2 * i + 1])  # Size of array\n        array = list(map(int, data[2 * i + 2].split()))  # Elements of array\n        test_cases.append(array)\n    \n    results = min_inversions_in_deque(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1579_F. Array Stabilization (AND version)", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef process_array(t, test_cases):\n    results = []\n    for test in test_cases:\n        n, d = test[0]\n        a = test[1]\n        \n        if all(x == 0 for x in a):\n            results.append(0)\n            continue\n        \n        steps = 0\n        original_a = a[:]\n        while True:\n            steps += 1\n            # Perform the cyclic shift and AND operation\n            new_a = [0] * n\n            for i in range(n):\n                shifted_index = (i + n - d) % n\n                new_a[i] = original_a[i] & original_a[shifted_index]\n            \n            # Check if it is the same as the previous one\n            if new_a == original_a:\n                # No change, check if there are still 1s\n                if any(x == 1 for x in original_a):\n                    results.append(-1)\n                else:\n                    results.append(steps - 1)  # One less as we have stabilized\n                break\n            \n            # Update the original array for the next iteration\n            original_a = new_a\n            \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Parse input\nt = int(data[0])\ntest_cases = []\nline_index = 1\nfor _ in range(t):\n    n, d = map(int, data[line_index].split())\n    a = list(map(int, data[line_index + 1].split()))\n    test_cases.append(((n, d), a))\n    line_index += 2\n\n# Process and output results\nresults = process_array(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1579_G. Minimal Coverage", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimal_coverage(test_cases):\n    results = []\n    \n    for segments in test_cases:\n        n = segments[0]  # number of segments\n        lengths = segments[1]  # the lengths of the segments\n        \n        # Coverage tracking\n        current_end = lengths[0]\n        min_coverage = 0  # this will represent the minimum starting point covered\n        max_coverage = current_end  # this will represent the maximum end point covered\n\n        for i in range(1, n):\n            current_length = lengths[i]\n            # Option 1: Place segment to the left\n            new_left_position = current_end - current_length\n            # Option 2: Place segment to the right\n            new_right_position = current_end + current_length\n            \n            # Update coverage\n            # They can influence min and max coverage\n            if new_right_position > max_coverage:\n                max_coverage = new_right_position\n            if new_left_position < min_coverage:\n                min_coverage = new_left_position\n            \n            # Move to end of current segment (choosing the right position for optimal coverage)\n            current_end = new_right_position\n        \n        # Final coverage length\n        total_length = max_coverage - min_coverage\n        results.append(total_length)\n    \n    return results\n\n# Using this function requires reading input via standard input, but\n# the logic is encapsulated to ease testing and understanding."}
{"task_id": "1580_A. Portal", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nHere is the Python code to execute the above approach:\n\n```python\ndef min_operations_to_portal(n, m, grid):\n    min_operations = float('inf')\n    \n    # Check potential portals with height >= 5 and width >= 4\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    operations = 0\n                    \n                    # Check corners\n                    if grid[i][j] == '1':  # Top-left corner\n                        operations += 0  # Can be obsidian\n                    else:\n                        operations += 1  # Needs to become obsidian\n                    \n                    if grid[i][j + b - 1] == '1':  # Top-right corner\n                        operations += 0  # Can be obsidian\n                    else:\n                        operations += 1  # Needs to become obsidian\n                    \n                    if grid[i + a - 1][j] == '1':  # Bottom-left corner\n                        operations += 0  # Can be obsidian\n                    else:\n                        operations += 1  # Needs to become obsidian\n                    \n                    if grid[i + a - 1][j + b - 1] == '1':  # Bottom-right corner\n                        operations += 0  # Can be obsidian\n                    else:\n                        operations += 1  # Needs to become obsidian\n                    \n                    # Check left and right border (1 < x < a)\n                    for x in range(1, a - 1):\n                        if grid[i + x][j] == '1':  # Left border\n                            operations += 0  # Already obsidian\n                        else:\n                            operations += 1  # Needs to become obsidian\n                        \n                        if grid[i + x][j + b - 1] == '1':  # Right border\n                            operations += 0  # Already obsidian\n                        else:\n                            operations += 1  # Needs to become obsidian\n                    \n                    # Check top and bottom border (1 < y < b)\n                    for y in range(1, b - 1):\n                        if grid[i][j + y] == '1':  # Top border\n                            operations += 0  # Already obsidian\n                        else:\n                            operations += 1  # Needs to become obsidian\n                        \n                        if grid[i + a - 1][j + y] == '1':  # Bottom border\n                            operations += 0  # Already obsidian\n                        else:\n                            operations += 1  # Needs to become obsidian\n                    \n                    # Check the inner area (1 < x < a, 1 < y < b)\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[i + x][j + y] == '0':  # Inner block should be empty\n                                operations += 0  # Already empty\n                            else:\n                                operations += 1  # Needs to become empty\n                    \n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\n# Read input and run the function\nimport sys\ninput = sys.stdin.read\ndata = input"}
{"task_id": "1580_B. Mathematics Curriculum", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef factorial_mod(n, p):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % p\n    return fact\n\ndef count_permutations(n, m, k, p):\n    # Step 1: Prepare factorial modulo p\n    fact = factorial_mod(n, p)\n\n    # Step 2: Initialize the DP table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Step 3: Fill the DP table\n    for length in range(1, n + 1):\n        for good in range(1, min(length, k) + 1):\n            # Add the current number\n            # When the current number is the maximum number seen, it can form a new \"good\" number\n            dp[good][length] = (dp[good][length] + dp[good - 1][length - 1] * fact[length - 1]) % p\n            if good <= length - 1:  # The current number is not the max\n                dp[good][length] = (dp[good][length] + dp[good][length - 1] * (length - 1)) % p\n\n    return dp[k][n]\n\n# Reading inputs from stdin\nimport sys\ninput = sys.stdin.read\ndef main():\n    data = input().strip().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    p = int(data[3])\n\n    result = count_permutations(n, m, k, p)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1580_C. Train Maintenance", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef train_maintenance(n, m, models, operations):\n    from collections import defaultdict\n    \n    # Result to hold counts of maintenance each day\n    results = []\n    # To track current state of each train model\n    trains = {}\n    \n    # Process each operation day by day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Adding a train\n            x, y = models[k-1]  # Get model parameters (x_i, y_i)\n            cycle_length = x + y\n            \n            # Add the train state\n            trains[k] = {\n                'x': x,\n                'y': y,\n                'added_day': day,\n                'in_maintenance': False,  # Will determine if it starts in maintenance\n            }\n            \n            # Determine if this train goes into maintenance immediately\n            current_day_in_cycle = (day - trains[k]['added_day']) % cycle_length\n            if current_day_in_cycle >= x:\n                trains[k]['in_maintenance'] = True\n        \n        elif op == 2:  # Removing a train\n            if k in trains:\n                del trains[k]  # Remove the train as it has finished working\n        \n        # Count trains in maintenance today\n        maintenance_count = sum(1 for train in trains.values() if train['in_maintenance'])\n        results.append(maintenance_count)\n    \n    return results\n\n# Input Processing\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    models = [tuple(map(int, data[i + 1].split())) for i in range(n)]  # read models\n    operations = [tuple(map(int, data[i + n + 1].split())) for i in range(m)]  # read operations\n\n    results = train_maintenance(n, m, models, operations)\n    \n    # Print the results\n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1580_D. Subsequence", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_subsequence_value(n, m, a):\n    # Sort array and take the largest m elements\n    a.sort()\n    selected = a[-m:]\n\n    # Calculate the first term\n    first_term = m * sum(selected)\n    \n    # The minimum of the selected elements will influence the second term significantly\n    min_selected = min(selected)\n    \n    # Count the pairs (i, j) where min >= min_selected\n    # The contribution from this min_selected will be:\n    # (m * (m - 1)) // 2 pairs of selected elements\n    total_pairs = m * m  # m*m pairs in total\n    second_term = total_pairs * min_selected\n    \n    # Final value\n    value = first_term - second_term\n    \n    return value\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:n + 2]))\n\n# Get result\nresult = maximize_subsequence_value(n, m, a)\n\n# Print output\nprint(result)"}
{"task_id": "1580_E. Railway Construction", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nimport heapq\n\ndef dijkstra(n, graph, start):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]  # (distance, node)\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can only be added once, so if we get a higher distance, we skip processing\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef compute_minimum_cost(n, m, q, w, edges, incidents):\n    # Build the graph from edges\n    graph = [[] for _ in range(n + 1)]\n    for u, v, d in edges:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Calculate shortest paths from station 1\n    shortest_distances = dijkstra(n, graph, 1)\n\n    # Finding minimum cost for two distinct shortest paths\n    # To ensure we always have two distinct paths, we will assume\n    # at least one outgoing one-way railway must be constructed from each required station.\n    \n    min_cost = 0\n    for i in range(2, n + 1):\n        min_cost += w[i - 1]  # since w is 0-indexed but stations are 1-indexed\n    \n    costs_after_incidents = [min_cost]\n\n    # Process each incident\n    for k, x in incidents:\n        w[k - 1] += x  # Update the cost\n        min_cost = 0\n        for i in range(2, n + 1):\n            min_cost += w[i - 1]\n        costs_after_incidents.append(min_cost)\n    \n    return costs_after_incidents\n\n# Read input\ninput_data = sys.stdin.read().strip().splitlines()\nn, m, q = map(int, input_data[0].split())\nw = list(map(int, input_data[1].split()))\n\nedges = []\nfor i in range(2, 2 + m):\n    u, v, d = map(int, input_data[i].split())\n    edges.append((u, v, d))\n\nincidents = []\nfor i in range(2 + m, 2 + m + q):\n    k, x = map(int, input_data[i].split())\n    incidents.append((k, x))\n\nresult = compute_minimum_cost(n, m, q, w, edges, incidents)\nsys.stdout.write('\\n'.join(map(str, result)) + '\\n')"}
{"task_id": "1580_F. Problems for Codeforces", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    n, m = map(int, input().strip().split())\n    \n    MOD = 998244353\n    \n    if m <= 1:  # If m = 1, there's only one valid sequence: all zeros.\n        print(1)\n        return\n    \n    k = m - 1  # Set k = m - 1\n\n    # We need to calculate all options for the first problem and how it affects others.\n    # For a fixed first problem `a_1`, the last `a_n` can vary as well.\n    # For each fixed `a_1`, we can calculate possible sum pairs.\n    \n    total_ways = 0\n    \n    # Iterate over possible values for the first one\n    for first in range(0, k + 1):\n        # For this first choice, we calculate valid pairs (first, a2) -> where a2 < k - first.\n        # a_n can be constrained by (1) next pair from last to first.\n        # a_2 can take values from 0 to k - first\n        last_options = (k - first)  # a_n can take [0..k - first]\n        total_ways += (last_options + 1) * k  # k possible choices for each intermediate a_i\n        total_ways %= MOD\n\n    # Now, total_ways has considered first and last pairs.\n    # The sequence has (n - 2) remaining pairs to fill because we consolidate the choices for a1 and an.\n    total_ways = total_ways * pow(n, n - 2, MOD) % MOD  # Multiply by n^(n-2) for the rest\n    \n    print(total_ways)"}
{"task_id": "1581_A. CQXYM Count Permutations", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nMOD = 1000000007\n\ndef precompute_factorials_and_inverses(max_n):\n    max_fact = 2 * max_n\n    fac = [1] * (max_fact + 1)\n    for i in range(2, max_fact + 1):\n        fac[i] = fac[i - 1] * i % MOD\n        \n    inv = [1] * (max_fact + 1)\n    inv[max_fact] = pow(fac[max_fact], MOD - 2, MOD)\n    for i in range(max_fact - 1, 0, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n        \n    return fac, inv\n\ndef catalan_number(n, fac, inv):\n    if n == 0:\n        return 1\n    return fac[2 * n] * inv[n + 1] % MOD * inv[n] % MOD\n\ndef count_valid_permutations(test_cases):\n    max_n = max(test_cases)\n    fac, inv = precompute_factorials_and_inverses(max_n)\n    \n    results = []\n    for n in test_cases:\n        C_n = catalan_number(n, fac, inv)\n        answer = C_n * pow(2, n, MOD) % MOD\n        results.append(answer)\n    \n    return results\n\n# Read inputs and execute the function\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\ntest_cases = list(map(int, data[1:t + 1]))\n\nresults = count_valid_permutations(test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1581_B. Diameter of Graph", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_possible_graph(t, test_cases):\n    results = []\n    for i in range(t):\n        n, m, k = test_cases[i]\n        \n        if m < n - 1:\n            results.append(\"NO\")\n            continue\n        \n        if k == 1:\n            results.append(\"NO\")\n            continue\n        \n        if k == 2:\n            if m >= n - 1:\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n            continue\n            \n        # At this point, we can have k >= 3\n        if m <= n * (n - 1) // 2:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input from stdin, process it and print output to stdout\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split(\"\\n\")\n    t = int(data[0])  # number of test cases\n    test_cases = []\n    \n    for i in range(1, t + 1):\n        n, m, k = map(int, data[i].split())\n        test_cases.append((n, m, k))\n        \n    results = is_possible_graph(t, test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1582_A. Luntik and Concerts", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_difference(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b, c = test_cases[i]\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\n# Main function to handle input and output\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n    results = min_difference(t, test_cases)\n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1582_B. Luntik and Subsequences", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef nearly_full_subsequences(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum - 1\n        \n        count_of_ones = a.count(1)\n        count_of_others = n - count_of_ones\n        \n        if count_of_ones == 0:\n            results.append(0)\n        else:\n            # 2^count_of_others can be computed using bit shifting\n            subsequences_count = count_of_ones * (1 << count_of_others)\n            results.append(subsequences_count)\n    \n    return results\n\n# Example of how to read input\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    for i in range(t):\n        n = int(data[2*i + 1])\n        a = list(map(int, data[2*i + 2].split()))\n        test_cases.append((n, a))\n    \n    results = nearly_full_subsequences(t, test_cases)\n    \n    for result in results:\n        print(result)"}
{"task_id": "1582_C. Grandma Capa Knits a Scarf", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_erasures_to_palindrome(test_cases):\n    results = []\n    \n    for s in test_cases:\n        n = len(s)\n        min_erasures = float('inf')\n        \n        # Try each character from 'a' to 'z'\n        for char in range(26):\n            c = chr(ord('a') + char)\n            left = 0\n            right = n - 1\n            erasures = 0\n            \n            while left < right:\n                if s[left] == s[right]:\n                    left += 1\n                    right -= 1\n                elif s[left] == c:\n                    erasures += 1\n                    left += 1\n                elif s[right] == c:\n                    erasures += 1\n                    right -= 1\n                else:\n                    erasures = float('inf')  # Impossible with the current character\n                    break\n            \n            if erasures != float('inf'):\n                min_erasures = min(min_erasures, erasures)\n        \n        if min_erasures == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_erasures)\n    \n    return results\n\n\n# Reading input\nt = int(input())\ntest_cases = [input().strip() for _ in range(t)]\n\n# Getting results\nresults = min_erasures_to_palindrome(test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1582_D. Vupsen, Pupsen and 0", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_b_arrays(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        b = []\n        for i in range(n):\n            if i % 2 == 0:\n                b.append(1)\n            else:\n                b.append(-1)\n        results.append(b)\n        \n    return results\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Get the results and print\nresults = find_b_arrays(t, test_cases)\nfor res in results:\n    print(' '.join(map(str, res)))"}
{"task_id": "1582_E. Pchelyonok and Segments", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximal_beautiful_segments(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, array = case\n        if n == 0:\n            results.append(0)\n            continue\n        \n        # Calculate sums for possible segment lengths\n        segment_sums = {}\n        for length in range(1, n + 1):\n            segment_sums[length] = []\n            current_sum = sum(array[:length])\n            segment_sums[length].append((current_sum, 0))  # (sum, start_index)\n            for start in range(1, n - length + 1):\n                current_sum = current_sum - array[start - 1] + array[start + length - 1]\n                segment_sums[length].append((current_sum, start))\n        \n        # To find the maximum k\n        max_k = 0\n        \n        for k in range(1, n + 1):\n            last_end = -1\n            last_sum = -1\n            valid = True\n            \n            for length in range(k, 0, -1):\n                found = False\n                for s_sum, start in segment_sums[length]:\n                    if start > last_end and (last_sum == -1 or s_sum > last_sum):\n                        last_end = start + length - 1  # Update to the end of this segment\n                        last_sum = s_sum  # Update last sum\n                        found = True\n                        break\n                if not found:\n                    valid = False\n                    break\n            \n            if valid:\n                max_k = k\n        \n        results.append(max_k)\n    \n    return results\n\n# Example Usage:\nt = 5\ntest_cases = [\n    (1, [1]),\n    (3, [1, 2, 3]),\n    (5, [1, 1, 2, 2, 3]),\n    (7, [1, 2, 1, 1, 3, 2, 6]),\n    (5, [9, 6, 7, 9, 7])\n]\n\nmaximal_beautiful_segments(t, test_cases)"}
{"task_id": "1582_F1. Korney Korneevich and XOR (easy version)", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_xor_values(n, a):\n    xor_results = {0}  # Initialize with the XOR of the empty subsequence\n    \n    for number in sorted(set(a)):  # Use set to avoid duplicates and sort them\n        new_results = set()\n        for existing_xor in xor_results:\n            new_results.add(existing_xor ^ number)  # Compute the new XOR by including the current number\n        xor_results.update(new_results)  # Update the main results with the new XORs\n    \n    # Convert to a sorted list\n    sorted_results = sorted(xor_results)\n    \n    # Print results\n    print(len(sorted_results))\n    print(\" \".join(map(str, sorted_results)))\n\n# Reading the input\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    a = list(map(int, data[1].split()))\n    \n    find_xor_values(n, a)"}
{"task_id": "1582_F2. Korney Korneevich and XOR (hard version)", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_xor_values(n, a):\n    # Set to store all unique XOR values found.\n    possible_xors = {0}  # Start with the empty subsequence giving XOR = 0\n\n    # Iterate over each number in the array\n    for num in a:\n        # Collect the current possible xors to iterate over them safely\n        current_xors = list(possible_xors)  # Make a list from set\n        for px in current_xors:\n            new_xor = px ^ num  # Compute new XOR\n            possible_xors.add(new_xor)  # Add new XOR value to set\n            \n    # Convert the set to a sorted list\n    result = sorted(possible_xors)\n    k = len(result)  # The count of unique XOR values\n\n    return k, result\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn = int(data[0])  # Length of the array\na = list(map(int, data[1].split()))  # The array elements\n\n# Solve the problem\nk, result = find_xor_values(n, a)\n\n# Print output\nprint(k)  # Number of unique XOR values\nprint(\" \".join(map(str, result)))  # Sorted XOR values"}
{"task_id": "1582_G. Kuzya and Homework", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_simple_segments(n, a, b):\n    l = 0\n    x = 1\n    count = 0\n\n    for r in range(n):\n        if b[r] == '*':\n            x *= a[r]\n        else:\n            if x % a[r] != 0:\n                # Reset `l` until `x % a[l] == 0`\n                while l <= r and x % a[r] != 0:\n                    if b[l] == '*':\n                        x //= a[l]\n                    else:\n                        # When we are dividing, we need to adjust\n                        if l < r:  # no need to adjust if l == r\n                            x *= a[l]  # reverse the last division\n                    l += 1\n            \n            # Divide now as we ensured we have a valid segment\n            x //= a[r]\n        \n        # All segments from `l` to `r` are valid simple segments\n        count += (r - l + 1)\n        \n        # If we are using division, we need to multiply back the current a[r]\n        # to correctly compute x for the next iteration\n        if b[r] == '/':\n            x *= a[r]  # this will be only effective for the next segment calculation\n    \n    return count\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nb = data[n+1]\n\n# Calculate and print the result\nprint(count_simple_segments(n, a, b))"}
{"task_id": "1586_A. Windblume Ode", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    results = []\n\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        \n        total_sum = sum(a)\n        if not is_prime(total_sum):  # If sum is composite\n            results.append(f\"{n}\")\n            results.append(\" \".join(str(i + 1) for i in range(n)))\n        else:\n            # The sum is prime, try to find an odd number to exclude\n            odd_indices = [i for i in range(n) if a[i] % 2 != 0]\n            if odd_indices:\n                # We can remove one odd number to make the sum composite\n                selected_indices = list(range(n))\n                selected_indices.remove(odd_indices[0])  # Remove the first odd index\n                results.append(f\"{n - 1}\")  # Size of the subset after removing one element\n                results.append(\" \".join(str(i + 1) for i in selected_indices))\n            else:\n                # It shouldn't get here, because if total sum is odd and prime,\n                # there should be at least one odd number.\n                results.append(f\"{n}\")\n                results.append(\" \".join(str(i + 1) for i in range(n)))\n\n        index += 2\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1586_B. Omkar and Heavenly Tree", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef construct_tree(t, test_cases):\n    results = []\n    \n    for n, m, restrictions in test_cases:\n        edges = []\n        for i in range(2, n + 1):\n            edges.append(f\"1 {i}\")\n        results.append(\"\\n\".join(edges))\n    \n    return \"\\n\\n\".join(results)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[idx].split())\n        idx += 1\n        restrictions = [tuple(map(int, data[idx + i].split())) for i in range(m)]\n        idx += m\n        test_cases.append((n, m, restrictions))\n    \n    # Generate the tree and print it\n    result = construct_tree(t, test_cases)\n    print(result)\n\nmain()"}
{"task_id": "1586_C. Omkar and Determination", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_determinable(n, m, grid, queries):\n    # Create an array to store the lowest row index with an 'X' for each column\n    lowest_filled = [n] * m\n    \n    # Fill the lowest_filled array\n    for x in range(m):\n        for y in range(n-1, -1, -1):\n            if grid[y][x] == 'X':\n                lowest_filled[x] = y  # Record the lowest filled cell\n                break\n\n    results = []\n    for x1, x2 in queries:\n        x1 -= 1  # Convert to 0-based index\n        x2 -= 1  # Convert to 0-based index\n        is_determinable = True\n\n        # Check for validity in the range x1 to x2\n        for x in range(x1, x2 + 1):\n            # If the lowest filled index of this column x is not the last row\n            if lowest_filled[x] < n:  # means there is an 'X' in this column\n                # We must check if any cell in the range x1 to x2 could block exitability\n                # Check the row above the filled cell if it exists\n                if lowest_filled[x] > 0:\n                    # Check other columns for blockages\n                    for y in range(lowest_filled[x] - 1, -1, -1):  # Cell above the filled cell\n                        if grid[y][x] == 'X':\n                            is_determinable = False\n                            break\n            if not is_determinable:\n                break\n        \n        if is_determinable:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Input reading and function execution\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    n, m = map(int, data[0].split())\n    grid = [data[i+1] for i in range(n)]\n    q = int(data[n+1])\n    queries = [list(map(int, data[n+2+i].split())) for i in range(q)]\n    \n    results = is_determinable(n, m, grid, queries)\n    # Output results\n    print('\\n'.join(results))\n\n# The following call on a competitive programming platform would directly use the input from standard input.\n# if __name__ == \"__main__\":\n#    main()"}
{"task_id": "1586_D. Omkar and the Meaning of Life", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])  # Read the length of the permutation\n    \n    # Prepare to collect results\n    responses = []\n\n    # Make queries for a = [1, 1, ..., 1] through a = [n, n, ..., n]\n    for value in range(1, n + 1):\n        query = [value] * n\n        query_str = \" \".join(map(str, query))\n        \n        # Print the query\n        print(f\"? {query_str}\")\n        sys.stdout.flush()  # Flush the output to ensure the query is sent\n        \n        response = int(sys.stdin.readline().strip())\n        responses.append(response)\n\n    # Now we have all responses and we need to determine the permutation p\n    # Initializing the mapping\n    position_map = {}\n\n    for idx, resp in enumerate(responses):\n        if resp > 0:  # If there was a duplicate found (1-indexed)\n            pos = resp - 1  # Convert to 0-indexed\n            # Map this response position to the value used in query\n            if pos not in position_map:\n                position_map[pos] = value\n                \n    # Construct the result permutation p\n    p = [0] * n\n    for idx, value in position_map.items():\n        p[idx] = value\n\n    # Fill the remaining values in p with remaining integers 1 to n\n    used_values = set(position_map.values())\n    remaining_values = [i for i in range(1, n + 1) if i not in used_values]\n    \n    remaining_idx = 0\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = remaining_values[remaining_idx]\n            remaining_idx += 1\n\n    # Output the permutation found\n    print(\"! \" + \" \".join(map(str, p)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1586_E. Moment of Bloom", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nfrom collections import defaultdict, deque\nimport sys\n\ninput = sys.stdin.read\n\ndef bfs_path(graph, start, end):\n    queue = deque([start])\n    parents = {start: None}\n    \n    # BFS to find the path from start to end\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            break\n            \n        for neighbor in graph[current]:\n            if neighbor not in parents:\n                parents[neighbor] = current\n                queue.append(neighbor)\n    \n    # Reconstructing the path\n    path = []\n    node = end\n    while node is not None:\n        path.append(node)\n        node = parents[node]\n    \n    return path[::-1]  # Return the path in the correct order\n\ndef solve():\n    data = input().splitlines()\n    index = 0\n    n, m = map(int, data[index].split())\n    index += 1\n    \n    graph = defaultdict(list)\n    \n    # Building the graph\n    edges = []\n    for _ in range(m):\n        x, y = map(int, data[index].split())\n        graph[x].append(y)\n        graph[y].append(x)\n        edges.append((x, y))\n        index += 1\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        a, b = map(int, data[index].split())\n        queries.append((a, b))\n        index += 1\n\n    # Count the number of times each edge is used\n    edge_usage = defaultdict(int)\n    paths = []\n    \n    # Process each query\n    for a, b in queries:\n        path = bfs_path(graph, a, b)\n        paths.append(path)\n        \n        # Update the edge usage\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i + 1]\n            edge_usage[(u, v)] += 1\n            edge_usage[(v, u)] += 1  # Because the graph is undirected\n\n    # Check if all edges have even usage\n    odd_edges = 0\n    for edge, count in edge_usage.items():\n        if count % 2 != 0:\n            odd_edges += 1\n            \n    if odd_edges == 0:\n        # All edges are even\n        print(\"YES\")\n        for path in paths:\n            print(len(path))\n            print(' '.join(map(str, path)))\n    else:\n        # Not all edges are even\n        print(\"NO\")\n        print((odd_edges + 1) // 2)  # Minimum queries needed, one additional for each pair of odd usage"}
{"task_id": "1586_F. Defender of Childhood Dreams", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef main():\n    import sys\n    input = sys.stdin.read\n    n, k = map(int, input().strip().split())\n    \n    # Step 1: Determine the minimum number of colors\n    if k >= n - 1:\n        # If k is greater than or equal to n-1, we need at least 2 colors\n        c = 2\n    else:\n        # For k < n - 1\n        c = (k + 1)  # We can use c colors for the conditions needed\n    \n    # Step 2: Creating the color array\n    edge_colors = []\n    color_index = 0\n    \n    # Number of edges is (n * (n - 1)) // 2\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            # Color edges (i, j)\n            # Using a pattern that ensures at least two different colors for paths of length k\n            if (j - i) >= k:\n                color_index += 1  # Change color for long enough edges\n                if color_index > c:\n                    color_index = 1\n            else:\n                color_index = 1  # Use the first color for short edges\n            edge_colors.append(color_index)\n    \n    # Step 3: Output the results\n    print(c)\n    print(\" \".join(map(str, edge_colors)))"}
{"task_id": "1586_G. Omkar and Time Travel", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef time_travel_tasks(n, task_info, t, funny_scene):\n    MOD = 10**9 + 7\n    tasks = []\n    \n    for i in range(n):\n        a_k, b_k = task_info[i]\n        tasks.append((a_k, b_k, i + 1))  # Store task number as well\n\n    # Sort tasks based on b_k, the time when Okabe realizes he needs to complete the task\n    tasks.sort(key=lambda x: x[1])\n\n    # Track which tasks are completed\n    completed = set()\n    time_travels = 0\n    current_time = 0\n    funny_set = set(funny_scene)\n\n    # Now process events in order of their b_k\n    for a_k, b_k, task_num in tasks:\n        # Advance time to b_k if needed\n        if current_time < b_k:\n            current_time = b_k\n        \n        # Check if the task is completed; if not, we must time travel\n        if task_num not in completed:\n            time_travels += 1  # Count the time travel\n            current_time = a_k  # Travel back to the appropriate a_k\n            completed.add(task_num)  # Mark this task as completed\n            \n            # Undo any tasks completed after a_k\n            for _, _, j in tasks:\n                if j not in completed and (a_k < tasks[j-1][0] <= current_time):  # Check if task j was completed after a_k\n                    completed.discard(j)\n\n        # Check for the funny scene condition\n        if funny_set.issubset(completed):\n            return time_travels % MOD\n            \n    return time_travels % MOD\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\ntask_info = [tuple(map(int, line.split())) for line in data[1:n+1]]\nt = int(data[n+1])\nfunny_scene = list(map(int, data[n+2].split()))\n\noutput = time_travel_tasks(n, task_info, t, funny_scene)\nprint(output)"}
{"task_id": "1586_H. Omkar and Tours", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    from collections import defaultdict\n    import heapq\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    idx = 0\n    n, q = map(int, data[idx].split())\n    idx += 1\n    \n    enjoyment_values = list(map(int, data[idx].split()))\n    idx += 1\n\n    # Graph representation\n    graph = defaultdict(list)\n    \n    # Read roads\n    for _ in range(n - 1):\n        a, b, c, t = map(int, data[idx].split())\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n        idx += 1\n\n    # Queries\n    queries = []\n    for _ in range(q):\n        v, x = map(int, data[idx].split())\n        queries.append((v, x))\n        idx += 1\n\n    # Result container\n    results = []\n    \n    # Preprocessing with DFS to store maximum enjoyment value and minimum tolls\n    # We need to maintain a structure to keep track of the tolls per capacity\n    def dfs(node, parent):\n        max_enjoyment = enjoyment_values[node - 1]\n        edge_data = []\n        \n        for neigh, cap, tol in graph[node]:\n            if neigh == parent:\n                continue\n            child_max_enjoyment, child_edge_data = dfs(neigh, node)\n            if child_max_enjoyment > max_enjoyment:\n                max_enjoyment = child_max_enjoyment\n            \n            edge_data.extend(child_edge_data)\n            edge_data.append((cap, tol))\n\n        return max_enjoyment, edge_data\n\n    # We can start DFS from any node, for simplicity we start from node 1\n    overall_max_enjoyment, edges_collection = dfs(1, -1)\n\n    # Answer the queries\n    for v, x in queries:\n        max_enjoyable = 0\n        highest_toll = 0\n\n        if enjoyment_values[x - 1] > max_enjoyable:\n            max_enjoyable = enjoyment_values[x - 1]\n\n        # Gathering edges from the paths from x to all reachable cities.\n        reachable_edges = [edge for edge in edges_collection]\n\n        # Filter reachable roads based on capacity constraint\n        valid_tolls = [tol for cap, tol in reachable_edges if cap >= v]\n        \n        if valid_tolls:\n            highest_toll = max(valid_tolls)\n\n        results.append(f\"{max_enjoyable} {highest_toll}\")\n\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")"}
{"task_id": "1586_I. Omkar and Mosaic", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n## Format: Read the inputs from stdin solve the problem and write the answer to stdout (do not directly test on the sample inputs). Enclose your code within delimiters as follows. Ensure that when the python program runs, it reads the inputs, runs the algorithm and writes output to STDOUT.\n```python\ndef is_valid_tile(grid, x, y, n):\n    count_s = count_g = 0\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] != '.':\n            if grid[nx][ny] == 'S':\n                count_s += 1\n            else:\n                count_g += 1\n    return count_s, count_g\n\ndef can_be_mastapeece(n, grid):\n    from collections import deque\n    \n    queue = deque()\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] != '.':\n                queue.append((i, j))\n\n    while queue:\n        x, y = queue.popleft()\n        current_tile = grid[x][y]\n        \n        # For each neighbor, fill in the empty spots if needed\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                if grid[nx][ny] == '.':\n                    # Determine what tile to place\n                    count_s, count_g = is_valid_tile(grid, nx, ny, n)\n                    if count_s >= 2:\n                        grid[nx][ny] = 'G'\n                        queue.append((nx, ny))\n                    elif count_g >= 2:\n                        grid[nx][ny] = 'S'\n                        queue.append((nx, ny))\n                elif grid[nx][ny] != current_tile:\n                    # Conflict detected, cannot satisfy mastapeece conditions\n                    return None\n    \n    # After filling, validate if all tiles are correct\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] != '.':\n                count_s, count_g = is_valid_tile(grid, i, j, n)\n                if count_s != 2 and count_g != 2:\n                    return None\n\n    return grid\n\ndef generate_configurations(n, grid):\n    filled_count = sum(1 for i in range(n) for j in range(n) if grid[i][j] != '.')\n    is_unique = filled_count == 0 or any(\n        k in (2, 4) for k in (sum(is_valid_tile(grid, x, y, n)) for x in range(n) for y in range(n) if grid[x][y] != '.'))\n    )\n    \n    return is_unique\n\n\nn = int(input().strip())\ngrid = [list(input().strip()) for _ in range(n)]\n\nresult_grid = can_be_mastapeece(n, grid"}
{"task_id": "1591_A. Life of a Flower", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef flower_growth(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, watered_days = case\n        height = 1  # Initial height\n        no_water_days = 0\n        previous_watered = False\n        \n        for i in range(n):\n            if watered_days[i] == 1:  # Flower is watered today\n                if previous_watered:  # Watered yesterday too\n                    height += 5\n                else:  # Watered for the first time consecutively\n                    height += 1\n                \n                previous_watered = True  # Mark that today is watered\n                no_water_days = 0  # Reset no water days\n            else:  # Flower is not watered today\n                no_water_days += 1\n                if no_water_days >= 2:  # Flower dies\n                    height = -1\n                    break\n                \n                previous_watered = False  # Mark that today is not watered\n                \n        results.append(height)\n    return results\n\n# To read input and produce output\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().splitlines()\n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        watered_days = list(map(int, data[index + 1].split()))\n        test_cases.append((n, watered_days))\n        index += 2\n    \n    results = flower_growth(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1591_B. Array Eversion", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef perform_eversions(test_cases):\n    results = []\n    \n    for a in test_cases:\n        num_eversions = 0\n        current = a\n        \n        while True:\n            n = len(current)\n            last_element = current[-1]\n            \n            left_part = [x for x in current if x <= last_element]\n            right_part = [x for x in current if x > last_element]\n            \n            new_array = left_part + right_part\n            \n            if new_array == current:\n                break\n            \n            num_eversions += 1\n            current = new_array\n            \n        results.append(num_eversions)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])  # Read n (not really used, but to go through the input)\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append(array)\n        index += 2\n    \n    results = perform_eversions(test_cases)\n    for result in results:\n        print(result)"}
{"task_id": "1591_C. Minimize Distance", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_delivery_distance(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, k = test_cases[i][:2]\n        depots = test_cases[i][2]\n        \n        # Step 1: Sort the depots\n        depots.sort()\n        \n        # Step 2: Calculate the total distance\n        distance = 0\n        \n        # Deliver the goods in batches from the end (farthest)\n        for j in range(n - 1, -1, -k):\n            worst_position = abs(depots[min(j, n - 1)])  # farthest depot in the current batch\n            distance += 2 * worst_position  # go to the depot and come back\n        \n        # We don't need to return from the last batch\n        distance -= abs(depots[max(n - 1 - (n % k), 0)])  # only need to come back from the last trip's furthest delivery\n        \n        results.append(distance)\n    \n    return results\n\n# Assuming we read input data in `t` (for number of test cases) and `test_cases` from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n, k = map(int, data[index].split())\n    depots = list(map(int, data[index + 1].split()))\n    test_cases.append((n, k, depots))\n    index += 2\n\nresults = min_delivery_distance(t, test_cases)\nfor res in results:\n    print(res)"}
{"task_id": "1591_D. Yet Another Sorting Problem", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_sort_with_3_cycles(test_cases):\n    results = []\n    for a in test_cases:\n        n = len(a)\n        sorted_a = sorted(a)\n        \n        # Count unique elements\n        unique_count = len(set(a))\n        \n        if unique_count == n:\n            # All elements are unique\n            if n % 3 == 0:\n                results.append(\"YES\")\n            else:\n                # Check if the number of inversions is even\n                inversions = sum(1 for i in range(n) for j in range(i + 1, n) if a[i] > a[j])\n                if inversions % 2 == 0:\n                    results.append(\"YES\")\n                else:\n                    results.append(\"NO\")\n        else:\n            # Duplicates present\n            results.append(\"YES\")\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    array = list(map(int, data[index + 1].split()))\n    test_cases.append(array)\n    index += 2\n\n# Compute results\nresults = can_sort_with_3_cycles(test_cases)\n\n# Output results\nsys.stdout.write(\"\\n\".join(results) + \"\\n\")"}
{"task_id": "1591_E. Frequency Queries", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        q = int(data[index + 1])\n        index += 2\n        \n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        p = [0] * n\n        for i in range(1, n):\n            p[i] = int(data[index]) - 1  # Convert to zero-based index\n            index += 1\n        \n        # Building the tree using adjacency list\n        tree = [[] for _ in range(n)]\n        for child in range(1, n):\n            parent = p[child]\n            tree[parent].append(child)\n        \n        for __ in range(q):\n            v = int(data[index]) - 1\n            l = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            \n            # Collect path from v to the root\n            path = []\n            current = v\n            \n            while current != -1:\n                path.append(a[current])\n                current = p[current] if current > 0 else -1\n            \n            # Count occurrences\n            count = defaultdict(int)\n            for num in path:\n                count[num] += 1\n            \n            # Filter based on l\n            filtered = []\n            for num, cnt in count.items():\n                if cnt >= l:\n                    filtered.append((cnt, num))\n            \n            # Sort by occurrence then by value\n            filtered.sort()\n            \n            # Get the k-th element, if possible\n            if len(filtered) < k:\n                results.append(\"-1\")\n            else:\n                results.append(str(filtered[k - 1][1]))  # k is 1-based index\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1591_F. Non-equal Neighbours", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_valid_arrays(n, a):\n    MOD = 998244353\n    \n    # Start with the first element\n    result = a[0] % MOD\n    \n    # Iterate over the rest of the elements\n    for i in range(1, n):\n        if a[i] == 1:\n            # If current a[i] is 1 and we're not at the first element, we can't pick a different number\n            return 0\n        result = result * (a[i] - 1) % MOD\n    \n    return result\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n + 1]))\n\n# Solve the problem and print the result\nprint(count_valid_arrays(n, a))"}
{"task_id": "1594_A. Consecutive Sum Riddle", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n = int(data[i])\n        l = -n - 1\n        r = n\n        results.append(f\"{l} {r}\")\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1594_B. Special Numbers", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:  # If exp is odd, multiply base with result\n            result = (result * base) % mod\n        exp = exp >> 1  # Divide exp by 2\n        base = (base * base) % mod  # Square the base\n    return result\n\ndef find_kth_special_number(n, k, mod):\n    result = 0\n    power = 0\n    while k > 0:\n        if (k & 1) == 1:  # If the last bit of k is 1\n            result = (result + modular_exponentiation(n, power, mod)) % mod\n        power += 1\n        k >>= 1  # Shift k to the right by 1 (divide by 2)\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    MOD = 10**9 + 7\n    \n    for i in range(1, t + 1):\n        n, k = map(int, data[i].split())\n        result = find_kth_special_number(n, k, MOD)\n        results.append(result)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1594_C. Make Them Equal", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, c = data[index].split()\n        n = int(n)\n        s = data[index + 1]\n        index += 2\n        \n        if all(char == c for char in s):\n            results.append(\"0\")\n            continue\n        \n        operations = []\n        \n        # Collect positions which are not equal to c\n        for i in range(n):\n            if s[i] != c:\n                operations.append(i + 1)  # Store i + 1 since we want 1-based index\n        \n        # We can perform one operation for each position where s[i] != c\n        results.append(str(len(operations)))\n        results.append(\" \".join(map(str, operations)))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1594_D. The Number of Imposters", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n```python\ndef maximum_imposters(t, cases):\n    results = []\n    \n    for case in cases:\n        n, m, comments = case\n        color = [-1] * (n + 1)  # -1 means uncolored\n        \n        # Create adjacency list\n        graph = [[] for _ in range(n + 1)]\n        \n        for comment in comments:\n            i, j, c = comment\n            if c == \"imposter\":\n                graph[i].append((j, 1))  # i says j is an imposter\n                graph[j].append((i, 1))  # j must say i is a crewmate\n            else:  # \"crewmate\"\n                graph[i].append((j, 0))  # i says j is a crewmate\n                graph[j].append((i, 0))  # j must say i is an imposter\n        \n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            count = [1, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color if relation == 0 else 1 - current_color\n                    \n                    if color[neighbor] == -1:  # Not colored yet\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n                    elif color[neighbor] != expected_color:  # Contradiction found\n                        return -1, 0\n            \n            return 1, max(count)  # Return 1 for successful coloring, and max count\n        \n        total_imposters = 0\n        impossible = False\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:  # Not visited yet\n                result, count = bfs(player)\n                if result == -1:\n                    impossible = True\n                    break\n                total_imposters += count\n        \n        if impossible:\n            results.append(-1)\n        else:\n            results.append(total_imposters)\n            \n    return results\n\n# Example input\nt = 5\ncases = [\n    (3, 2, [(1, 2, 'imposter'), (2, 3, 'crewmate')]),\n    (5, 4, [(1, 3, 'crewmate'), (2, 5, 'crewmate'), (2, 4, 'imposter'), (3, 4,"}
{"task_id": "1594_E1. Rubik's Cube Coloring (easy version)", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_good_colorings(k):\n    MOD = 10**9 + 7\n    \n    # dp[level][color] will store the number of ways to color the nodes\n    # at 'level' with the parent's node having 'color'.\n    # There are 6 colors indexed from 0 to 5.\n    \n    # Initializing the DP array\n    dp = [[0] * 6 for _ in range(k + 1)]\n    \n    # Base case: Level 1 (root)\n    for color in range(6):\n        dp[1][color] = 1\n        \n    # Define the valid children colors based on parent color\n    valid_colors = [\n        [0, 2, 3, 4, 5],  # From White (0)\n        [1, 2, 3, 4, 5],  # From Yellow (1)\n        [0, 1, 3, 4, 5],  # From Green (2)\n        [0, 1, 2, 4, 5],  # From Blue (3)\n        [0, 1, 2, 3, 5],  # From Red (4)\n        [0, 1, 2, 3, 4]   # From Orange (5)\n    ]\n    \n    for level in range(1, k):\n        for parent_color in range(6):\n            for child_color in valid_colors[parent_color]:\n                dp[level + 1][child_color] = (dp[level + 1][child_color] + dp[level][parent_color]) % MOD\n    \n    # Sum the valid configurations of the last level\n    result = sum(dp[k]) % MOD\n    return result\n\n# Reading input and outputting the result\nimport sys\ninput = sys.stdin.read\n\nk = int(input().strip())\nprint(count_good_colorings(k))"}
{"task_id": "1594_E2. Rubik's Cube Coloring (hard version)", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_colorings(k, n, colored_nodes):\n    MOD = 10**9 + 7\n    \n    # Color constraints\n    neighbors = {\n        'white': {'green', 'red', 'blue', 'orange'},\n        'yellow': {'green', 'red', 'blue', 'orange'},\n        'green': {'white', 'yellow', 'red', 'orange'},\n        'blue': {'white', 'yellow', 'red', 'orange'},\n        'red': {'white', 'yellow', 'green', 'blue'},\n        'orange': {'white', 'yellow', 'green', 'blue'}\n    }\n    \n    # Create adjacency list for perfect binary tree\n    max_nodes = (1 << k) - 1\n    tree = {i: (2 * i, 2 * i + 1) for i in range(1, max_nodes + 1) if 2 * i <= max_nodes}\n\n    # Pre-coloring mapping\n    colored = {}\n    for node, color in colored_nodes:\n        colored[node] = color\n    \n    # Check for conflicts\n    def is_valid(node, color):\n        if node in colored:\n            return colored[node] == color\n        for child in tree.get(node, []):\n            if child in colored:\n                if colored[child] not in neighbors[color]:\n                    return False\n        return True\n\n    # DFS coloring and counting valid combinations\n    def dfs(node):\n        if node > max_nodes:\n            return 1  # Reached a leaf node\n        \n        if node in colored:\n            color = colored[node]\n            if not is_valid(node, color):\n                return 0\n            return dfs(tree[node][0]) * dfs(tree[node][1]) % MOD\n        \n        total_ways = 0\n        for color in neighbors.keys():\n            if is_valid(node, color):\n                total_ways += dfs(tree[node][0]) * dfs(tree[node][1]) % MOD\n                total_ways %= MOD\n        \n        return total_ways\n\n    return dfs(1)\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nk = int(data[0])\nn = int(data[1])\ncolored_nodes = []\n\nfor i in range(2, 2 + n):\n    v, s = data[i].split()\n    colored_nodes.append((int(v), s))\n\n# Output the result\nresult = count_colorings(k, n, colored_nodes)\nprint(result)"}
{"task_id": "1594_F. Ideal Farm", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_ideal_farm(s, n, k):\n    # Check the conditions based on the outlined approach\n    if k > s:\n        return \"NO\"\n    if n <= k <= s:\n        return \"YES\"\n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Read the number of test cases\n    results = []\n    \n    for i in range(1, t + 1):\n        s, n, k = map(int, data[i].split())\n        result = is_ideal_farm(s, n, k)\n        results.append(result)\n    \n    # Print all results for each test case\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1598_A. Computer Game", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_complete_level(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, level = case\n        grid = [level[0], level[1]]\n        \n        # BFS approach to find a path from (1, 1) to (2, n)\n        from collections import deque\n        \n        # Directions: right, down-right, down, down-left, left, up-left, up, up-right\n        directions = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)]\n        \n        # Queue for BFS\n        queue = deque([(0, 0)])  # Start from (1, 1) which is (0, 0) in 0-index\n        visited = set()\n        visited.add((0, 0))\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            # If we reach (2, n) which is (1, n-1) in 0-index\n            if x == 1 and y == n - 1:\n                results.append(\"YES\")\n                break\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < 2 and 0 <= ny < n and (nx, ny) not in visited:\n                    if grid[nx][ny] == '0':  # Check if the cell is safe\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Reading input\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        level = (data[index + 1], data[index + 2])\n        test_cases.append((n, level))\n        index += 3\n    \n    # Process the test cases\n    results = can_complete_level(t, test_cases)\n    \n    # Print results\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1598_B. Groups", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_divide_students(t, test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        availability = case[1]\n        \n        found = False\n        \n        # Check all pairs of days (day1, day2)\n        for day1 in range(5):\n            for day2 in range(day1 + 1, 5):\n                count_day1 = 0\n                count_day2 = 0\n                \n                group1 = []\n                group2 = []\n                \n                for i in range(n):\n                    if availability[i][day1] == 1:\n                        group1.append(i)\n                        count_day1 += 1\n                    if availability[i][day2] == 1:\n                        group2.append(i)\n                        count_day2 += 1\n                \n                # Now we need to check if we can form two groups of size n/2\n                if count_day1 >= n // 2 and count_day2 >= n // 2:\n                    # We can form groups\n                    # The first group can take any n/2 from group1\n                    # The second group can take any n/2 from group2\n                    if (count_day1 + count_day2) >= n:\n                        found = True\n                        break\n            \n            if found:\n                break\n\n        results.append(\"YES\" if found else \"NO\")\n    \n    return results\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Prepare test cases\nt = int(data[0].strip())\ntest_cases = []\nindex = 1\n\nfor _ in range(t):\n    n = int(data[index].strip())\n    availability = []\n    for i in range(n):\n        availability.append(list(map(int, data[index + 1 + i].strip().split())))\n    test_cases.append((n, availability))\n    index += n + 1\n\n# Get the results\nresults = can_divide_students(t, test_cases)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "1598_C. Delete Two Elements", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_mean_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target = (2 * total_sum) / n\n        \n        count = 0\n        freq = {}\n        \n        for number in a:\n            complement = target - number\n            if complement in freq:\n                count += freq[complement]\n            \n            if number in freq:\n                freq[number] += 1\n            else:\n                freq[number] = 1\n        \n        results.append(count)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Getting results\nresults = count_mean_pairs(t, test_cases)\n\n# Printing results\nfor result in results:\n    print(result)"}
{"task_id": "1598_D. Training Session", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_ways_to_select_problems(t, test_cases):\n    from collections import defaultdict\n    from math import comb\n    \n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        problems = case[1]\n        \n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for a, b in problems:\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_ways = comb(n, 3)  # Total ways to choose 3 from n\n        \n        invalid_topic_combinations = 0\n        invalid_difficulty_combinations = 0\n        \n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_combinations += comb(count, 3)\n        \n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_combinations += comb(count, 3)\n        \n        valid_combinations = total_ways - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    return results\n\n# Reading input and executing the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        problems = []\n        for _ in range(n):\n            a, b = map(int, data[index].split())\n            problems.append((a, b))\n            index += 1\n        test_cases.append((n, problems))\n    \n    results = count_ways_to_select_problems(t, test_cases)\n    print(\"\\n\".join(map(str, results)))"}
{"task_id": "1598_E. Staircases", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m, q = map(int, data[0].split())\n    queries = [tuple(map(int, line.split())) for line in data[1:q + 1]]\n    \n    # Initialize the matrix with all cells free (1)\n    matrix = [[1] * m for _ in range(n)]\n    \n    def count_staircases():\n        # Count total staircases in both forms\n        total_staircases = 0\n        \n        # Count type 1 staircases\n        dp1 = [[0] * m for _ in range(n)]  # dp1[i][j] will store the number of type 1 staircases starting from (i, j)\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 1:\n                    dp1[i][j] = 1  # Single cell staircase\n                    if j > 0 and i > 0:\n                        dp1[i][j] += dp1[i][j - 1]  # Add from left\n                    if j > 0:\n                        dp1[i][j] += dp1[i - 1][j - 1]  # Add from top-left\n                    total_staircases += dp1[i][j]\n        \n        # Count type 2 staircases\n        dp2 = [[0] * m for _ in range(n)]  # dp2[i][j] will store the number of type 2 staircases starting from (i, j)\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 1:\n                    dp2[i][j] = 1  # Single cell staircase\n                    if i > 0 and j > 0:\n                        dp2[i][j] += dp2[i - 1][j]  # Add from above\n                    if i > 0:\n                        dp2[i][j] += dp2[i - 1][j - 1]  # Add from top-left\n                    total_staircases += dp2[i][j]\n        \n        return total_staircases\n    \n    results = []\n    total_staircases = count_staircases()\n    \n    for x, y in queries:\n        # Convert to zero-indexed\n        x -= 1\n        y -= 1\n        \n        # Flip the state of cell (x, y)\n        matrix[x][y] ^= 1\n        \n        # Recalculate the total staircases after the flip\n        total_staircases = count_staircases()\n        \n        results.append(total_staircases)\n    \n    # Print the results for each query\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":"}
{"task_id": "1598_F. RBS", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_rbs_prefixes(sequences):\n    positive = []  # (balance, min_balance)\n    negative = []  # (balance, min_balance)\n    zero = 0       # count of zero balance sequences\n\n    for seq in sequences:\n        balance = 0\n        min_balance = 0\n        \n        for char in seq:\n            balance += 1 if char == '(' else -1\n            min_balance = min(min_balance, balance)\n        \n        if balance > 0:\n            positive.append((balance, min_balance))\n        elif balance < 0:\n            negative.append((balance, min_balance))\n        else:\n            zero += 1\n    \n    # Sort positive sequences by their min_balance (ascending)\n    positive.sort(key=lambda x: x[1])\n    # Sort negative sequences by their min_balance (descending)\n    negative.sort(key=lambda x: x[1], reverse=True)\n\n    rbs_count = 0\n    current_balance = 0\n    \n    # Add positive sequences\n    for balance, min_balance in positive:\n        if current_balance + min_balance >= 0:\n            rbs_count += 1\n            current_balance += balance\n\n    # Add zero balance sequences\n    rbs_count += zero\n\n    # Add negative sequences\n    for balance, min_balance in negative:\n        if current_balance + min_balance >= 0:\n            rbs_count += 1\n            current_balance += balance\n    \n    return rbs_count\n\n# Read inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nn = int(data[0])\nsequences = data[1:n+1]\n\n# Get the result\nresult = count_rbs_prefixes(sequences)\n\n# Print the result\nprint(result)"}
{"task_id": "1598_G. The Sum of Good Numbers", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_good_numbers(s, x):\n    n = len(s)\n    \n    # Iterate through potential split points\n    for i in range(1, n):  # i is the split point\n        # Split s into two parts\n        left = s[:i]\n        right = s[i:]\n        \n        # Convert to integers\n        left_num = int(left)\n        right_num = int(right)\n        \n        # Check if both parts are good numbers\n        if '0' not in left and '0' not in right:\n            # Check if their sum equals x\n            if left_num + right_num == x:\n                # Output the 1-based indices\n                print(f\"1 {i}\")\n                print(f\"{i + 1} {n}\")\n                return\n\n# Read inputs\ns = input().strip()\nx = int(input().strip())\n\nfind_good_numbers(s, x)"}
{"task_id": "1599_A. Weights", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef balance_weights(N, weights, S):\n    # Sort weights in descending order to easily access the heaviest available weight\n    weights.sort(reverse=True)\n    \n    left_side = 0\n    right_side = 0\n    output = []\n    \n    for i in range(N):\n        if S[i] == 'L':\n            # We need to put a weight on the left side\n            if left_side <= right_side:\n                # We can place the heaviest weight on the left if it's still valid\n                weight_to_place = weights.pop(0)  # Get the heaviest available weight\n                left_side += weight_to_place\n                output.append(f\"{weight_to_place} L\")\n            else:\n                return -1  # Cannot satisfy the condition\n            \n        elif S[i] == 'R':\n            # We need to put a weight on the right side\n            if right_side <= left_side:\n                # We can place the heaviest weight on the right if it's still valid\n                weight_to_place = weights.pop(0)  # Get the heaviest available weight\n                right_side += weight_to_place\n                output.append(f\"{weight_to_place} R\")\n            else:\n                return -1  # Cannot satisfy the condition\n            \n    return \"\\n\".join(output)\n\n# Reading the input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nweights = list(map(int, data[1].split()))\nS = data[2]\n\n# Running the function and printing the result\nresult = balance_weights(N, weights, S)\nif result == -1:\n    print(-1)\nelse:\n    print(result)"}
{"task_id": "1599_B. Restaurant Game", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef last_remaining_card(N, A, B, D_A, D_B):\n    # Convert both directions to numerical values\n    direction_A = 1 if D_A == 'right' else -1\n    direction_B = 1 if D_B == 'right' else -1\n    \n    # To track positions\n    position_A = A\n    position_B = B\n\n    # A list to represent active cards\n    active_cards = N\n\n    while active_cards > 1:\n        # Move until they meet\n        while position_A != position_B:\n            if position_A < position_B:\n                position_A = (position_A + direction_A) % N\n                position_B = (position_B - direction_B) % N\n            else:\n                position_A = (position_A - direction_A) % N\n                position_B = (position_B + direction_B) % N\n        \n        # When they meet, we remove the card\n        active_cards -= 1\n\n        # Move both positions out of the meeting card\n        position_A = (position_A + direction_A) % N\n        position_B = (position_B - direction_B) % N\n\n        # If they cross the boundary, change directions\n        if position_A == 0 or position_A == N - 1:\n            direction_A *= -1\n        if position_B == 0 or position_B == N - 1:\n            direction_B *= -1\n\n    # The last card remaining will be where either of them ends\n    return position_A\n\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(T):\n        N = int(data[index])\n        A, B = map(int, data[index + 1].split())\n        D_A, D_B = data[index + 2].split()\n        \n        result = last_remaining_card(N, A, B, D_A, D_B)\n        results.append(result)\n        \n        index += 3\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1599_C. Bubble Strike", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum_maps_to_study(N, P):\n    from math import comb\n\n    if P == 0:\n        return 0\n    if P == 1:\n        return N - 1\n    \n    for k in range(N):\n        studied_count = k\n        not_studied_count = N - k\n\n        total_cases = comb(N, 3)\n        favorable_cases = 0\n\n        for x in range(1, min(3, studied_count) + 1):\n            # if x studied maps are selected\n            if x == 3:\n                favorable_cases += comb(studied_count, 3)  # all three are studied\n            else:\n                # Count cases with combinations of studied and not studied maps\n                favorable_cases += comb(studied_count, x) * comb(not_studied_count, 3 - x)\n\n        # Now we need to calculate the number of cases where the final selected map could be one of the studied ones\n        # Total selected maps: 3\n        # Cases resulting in at least one studied map\n        # We discard 1 from the 3 selected, we need to check probability of keeping at least 1 studied map\n        cases_not_playing_studied = comb(not_studied_count, 2) if not_studied_count >= 2 else 0\n\n        # Total ways to play a studied map\n        total_study_cases = favorable_cases - cases_not_playing_studied\n\n        probability = total_study_cases / total_cases\n\n        if probability >= P:\n            return k\n\n    return N - 1  # Fallback, though logically we should never need to study N maps\n\n# Example usage:\nN, P = map(float, input().strip().split())\nresult = minimum_maps_to_study(int(N), P)\nprint(result)"}
{"task_id": "1599_D. Bubble Popping", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    bubbles = []\n    for i in range(N):\n        x, y = map(int, data[index].split())\n        bubbles.append((x, y, i + 1))  # Store (x, y, original index)\n        index += 1\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(Q):\n        dx, dy, K = map(int, data[index].split())\n        index += 1\n        \n        # Calculate the angle of the direction vector\n        start_angle = math.atan2(dy, dx)\n        \n        # Sort bubbles based on the angle and distance from the origin (0,0)\n        sorted_bubbles = []\n        \n        for x, y, original_index in bubbles:\n            angle = math.atan2(y, x)\n            # Calculate the angle difference and the distance\n            angle_diff = angle - start_angle\n            distance = x**2 + y**2  # Using squared distance to avoid sqrt for comparison\n            sorted_bubbles.append((angle_diff, distance, original_index, x, y))\n        \n        # Sort by angle difference first, then by distance\n        sorted_bubbles.sort()\n        \n        # Now process the popping of bubbles\n        last_popped_index = -1\n        current_x, current_y = sorted_bubbles[0][3], sorted_bubbles[0][4]\n        \n        for i in range(K):\n            last_popped_index = sorted_bubbles[i][2]  # Get the original index of the bubble popped\n            \n            # Calculate new angle based on the last popped bubble's position\n            # Calculate angle to the next bubble (from current popped position)\n            if i + 1 < K:\n                next_bubble_x, next_bubble_y = sorted_bubbles[i + 1][3], sorted_bubbles[i + 1][4]\n                new_angle = math.atan2(next_bubble_y - current_y, next_bubble_x - current_x)\n                # Update the center of rotation\n                current_x, current_y = next_bubble_x, next_bubble_y\n            \n        results.append(last_popped_index)\n    \n    # Output results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1599_E. Two Arrays", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    MOD = 10**9 + 7\n    MAX_FIB = 2000000\n    \n    # Precompute Fibonacci numbers\n    fib = [0] * (MAX_FIB + 1)\n    fib[1] = 1\n    for i in range(2, MAX_FIB + 1):\n        fib[i] = (fib[i - 1] + fib[i - 2]) % MOD\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    A1 = list(map(int, data[index:index + N]))\n    index += N\n    A2 = list(map(int, data[index:index + N]))\n    index += N\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:  # min update\n            k = int(data[index + 1]) - 1\n            l = int(data[index + 2]) - 1\n            r = int(data[index + 3]) - 1\n            x = int(data[index + 4])\n            for i in range(l, r + 1):\n                if k == 0:\n                    A1[i] = min(A1[i], x)\n                else:\n                    A2[i] = min(A2[i], x)\n            index += 5\n            \n        elif query_type == 2:  # max update\n            k = int(data[index + 1]) - 1\n            l = int(data[index + 2]) - 1\n            r = int(data[index + 3]) - 1\n            x = int(data[index + 4])\n            for i in range(l, r + 1):\n                if k == 0:\n                    A1[i] = max(A1[i], x)\n                else:\n                    A2[i] = max(A2[i], x)\n            index += 5\n            \n        elif query_type == 3:  # addition\n            k = int(data[index + 1]) - 1\n            l = int(data[index + 2]) - 1\n            r = int(data[index + 3]) - 1\n            x = int(data[index + 4])\n            for i in range(l, r + 1):\n                if k == 0:\n                    A1[i] += x\n                else:\n                    A2[i] += x\n            index += 5\n            \n        elif query_type == 4:  # fibonacci query\n            l = int(data[index + 1]) - 1\n            r = int(data[index + 2]) - 1\n            fib_sum = 0\n            for i in range(l, r + 1):\n                fib_sum += fib[A1[i] + A2[i]]\n                fib_sum %= MOD\n            results.append(fib_sum)\n            index +="}
{"task_id": "1599_F. Mars", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nfrom math import gcd\nfrom functools import reduce\nfrom collections import defaultdict\n\ninput = sys.stdin.read\n\ndef build_segment_tree(arr):\n    \"\"\" Build a segment tree for GCD. \"\"\"\n    n = len(arr)\n    seg_tree = [0] * (2 * n)\n    \n    # Build the tree\n    for i in range(n):\n        seg_tree[n + i] = arr[i]\n    for i in range(n - 1, 0, -1):\n        seg_tree[i] = gcd(seg_tree[2 * i], seg_tree[2 * i + 1])\n    \n    return seg_tree\n\ndef range_gcd(seg_tree, left, right):\n    \"\"\" Query the GCD on the range [left, right) using the segment tree. \"\"\"\n    n = len(seg_tree) // 2\n    left += n\n    right += n\n    g = 0  # GCD identity is 0\n    while left < right:\n        if left & 1:\n            g = gcd(g, seg_tree[left])\n            left += 1\n        if right & 1:\n            right -= 1\n            g = gcd(g, seg_tree[right])\n        left //= 2\n        right //= 2\n    return g\n\ndef main():\n    data = input().split()\n    idx = 0\n    \n    # Read N and Q\n    N = int(data[idx])\n    idx += 1\n    Q = int(data[idx])\n    idx += 1\n    \n    # Read array of cities\n    cities = list(map(int, data[idx:idx + N]))\n    idx += N\n    \n    # Build Segment Tree for GCD\n    seg_tree = build_segment_tree(cities)\n    \n    output = []\n    \n    # Process each query\n    for _ in range(Q):\n        L = int(data[idx]) - 1  # Convert to zero-based index\n        idx += 1\n        R = int(data[idx])  # Exclusive upper bound\n        idx += 1\n        D = int(data[idx])\n        idx += 1\n        \n        if L < R:\n            range_gcd_value = range_gcd(seg_tree, L, R)\n        else:\n            range_gcd_value = 0  # If L == R, no cities to connect\n        \n        # Check if gcd is divisible by D\n        if range_gcd_value % D == 0:\n            output.append(\"Yes\")\n        else:\n            output.append(\"No\")\n    \n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1599_G. Shortest path", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and K\n    N, K = map(int, data[0].split())\n    K -= 1  # Convert to 0-based index\n    \n    # Read points\n    points = [tuple(map(int, line.split())) for line in data[1:N+1]]\n    \n    # Split points into collinear and non-collinear\n    collinear_points = []\n    detour_point = None\n    \n    # Identify the non-collinear point (the last one) and collinear points\n    for i in range(N):\n        if i != K:\n            collinear_points.append(points[i])\n        else:\n            detour_point = points[i]\n    \n    # Find the bounding box for collinear points\n    x_min = min(x for x, y in collinear_points)\n    x_max = max(x for x, y in collinear_points)\n    y_min = min(y for x, y in collinear_points)\n    y_max = max(y for x, y in collinear_points)\n    \n    # Calculate the distance from K to the detour point\n    d_k_to_detour = math.sqrt((detour_point[0] - points[K][0]) ** 2 + \n                               (detour_point[1] - points[K][1]) ** 2)\n    \n    # Calculate the total distance for all collinear points\n    # The collinear points form a line segment from (x_min, y_min) to (x_max, y_max)\n    d_collinear_traverse = math.sqrt((x_max - x_min) ** 2 + (y_max - y_min) ** 2)\n    \n    # The minimum path length is the distance to the detour point + \n    # the distance to traverse all collinear points\n    min_path_length = d_k_to_detour + d_collinear_traverse\n    \n    # Print the result with required precision\n    print(f\"{min_path_length:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1599_H. Hidden Fortress", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_fortress():\n    import sys\n    input = sys.stdin.read\n    output = sys.stdout\n\n    def query(i, j):\n        print(f\"? {i} {j}\")\n        output.flush()\n        response = int(input().strip())\n        return response\n    \n    # Begin searching\n    left_x, right_x = 2, 999999998\n    left_y, right_y = 2, 999999998\n    \n    # Binary search for the left boundary\n    while left_x < right_x:\n        mid_x = (left_x + right_x) // 2\n        if query(mid_x, 2) > (mid_x - 1):  # if distance is greater than (mid_x - 1), it means the fortress is to the left\n            right_x = mid_x\n        else:\n            left_x = mid_x + 1\n\n    # left_x should be the first x coordinate of the fortress\n    fortress_left_x = left_x\n    \n    # Binary search for the right boundary\n    left_x, right_x = 2, 999999998\n    while left_x < right_x:\n        mid_x = (left_x + right_x + 1) // 2\n        if query(mid_x, 2) > (mid_x - 1):  # similarly check\n            right_x = mid_x - 1\n        else:\n            left_x = mid_x\n\n    fortress_right_x = left_x\n\n    # Binary search for the bottom boundary\n    left_y, right_y = 2, 999999998\n    while left_y < right_y:\n        mid_y = (left_y + right_y) // 2\n        if query(2, mid_y) > (mid_y - 1):  # check below the current mid_y\n            right_y = mid_y\n        else:\n            left_y = mid_y + 1\n\n    fortress_bottom_y = left_y\n\n    # Binary search for the top boundary\n    left_y, right_y = 2, 999999998\n    while left_y < right_y:\n        mid_y = (left_y + right_y + 1) // 2\n        if query(2, mid_y) > (mid_y - 1):  # check above the current mid_y\n            right_y = mid_y - 1\n        else:\n            left_y = mid_y\n\n    fortress_top_y = left_y\n\n    # Output the result\n    print(f\"! {fortress_left_x} {fortress_bottom_y} {fortress_right_x} {fortress_top_y}\")\n    output.flush()\n\nfind_fortress()"}
{"task_id": "1599_I. Desert", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_desert_pairs(N, M, edges):\n    from collections import defaultdict\n\n    edge_count = defaultdict(int)\n    L = 0\n    valid_pairs = 0\n\n    for R in range(M):\n        u, v = edges[R]\n        edge_count[(u, v)] += 1\n        edge_count[(v, u)] += 1  # undirected graph, count both directions\n\n        # Check if we've violated the cactus condition\n        while edge_count[(u, v)] > 1 or edge_count[(v, u)] > 1:\n            u_l, v_l = edges[L]\n            edge_count[(u_l, v_l)] -= 1\n            edge_count[(v_l, u_l)] -= 1\n            L += 1\n\n        # All pairs (L, R) are valid if current L is valid\n        valid_pairs += (R - L + 1)\n\n    return valid_pairs\n\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\nedges = [tuple(map(int, line.split())) for line in data[1:M+1]]\n\n# Calculate the number of valid (L, R) pairs\nresult = count_desert_pairs(N, M, edges)\n\n# Output the result\nprint(result)"}
{"task_id": "1599_J. Bob's Beautiful Array", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_original_array(N, B):\n    total_sum_B = sum(B)\n    \n    # If the total sum is odd, it's impossible to form the original array\n    if total_sum_B % 2 != 0:\n        return \"NO\"\n    \n    # Initialize A\n    A = [0] * N\n\n    # Calculate A[0]\n    A[0] = total_sum_B // 2 - sum(B[1:])  # Derive A[0] as the balancing element\n\n    # Calculate the other elements of A\n    for i in range(1, N):\n        A[i] = B[i - 1] - A[0]\n    \n    # Check if we can form all B_i using sums of A\n    from collections import Counter\n\n    count_B = Counter(B)\n    possible_sums = Counter()\n    \n    # Generate all possible sums from elements of A\n    for i in range(N):\n        for j in range(N):\n            possible_sums[A[i] + A[j]] += 1\n            \n    # Check if possible_sums meets the count of B\n    for b in count_B:\n        if possible_sums[b] < count_B[b]:\n            return \"NO\"\n    \n    return \"YES\\n\" + \" \".join(map(str, A))\n\n# Input reading and output generation\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nB = list(map(int, data[1].split()))\n\nresult = find_original_array(N, B)\nprint(result)"}
{"task_id": "1600_E. Array Game", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_winner(N, A):\n    left = 0\n    right = N - 1\n    last = -1\n    moves = 0\n\n    while left <= right:\n        # Choose the best option from left or right\n        if A[left] > last and (A[right] <= last or A[left] >= A[right]):\n            last = A[left]\n            left += 1\n        elif A[right] > last:\n            last = A[right]\n            right -= 1\n        else:\n            break\n        \n        moves += 1\n\n    # Determine winner based on the number of moves\n    return \"Alice\" if moves % 2 == 1 else \"Bob\"\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nA = list(map(int, data[1].split()))\n\n# Output the winner\nprint(find_winner(N, A))"}
{"task_id": "1600_F. Party Organization", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef organize_party(N, M, friendships):\n    from collections import defaultdict\n    \n    # Step 1: Create an adjacency list for friendships\n    adjacency_list = defaultdict(set)\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n    \n    # Step 2: Check for complete subgraph of size 5\n    for u in range(1, N + 1):\n        if len(adjacency_list[u]) >= 4:  # Need at least 4 friends to form a complete set of 5\n            friends = list(adjacency_list[u])\n            friend_count = len(friends)\n            for i in range(friend_count):\n                for j in range(i + 1, friend_count):\n                    for k in range(j + 1, friend_count):\n                        for l in range(k + 1, friend_count):\n                            if (friends[j] in adjacency_list[friends[i]] and\n                                friends[k] in adjacency_list[friends[i]] and\n                                friends[l] in adjacency_list[friends[i]] and\n                                friends[k] in adjacency_list[friends[j]] and\n                                friends[l] in adjacency_list[friends[j]] and\n                                friends[l] in adjacency_list[friends[k]]):\n                                return [u, friends[i], friends[j], friends[k], friends[l]]\n    \n    # Step 3: Check for an independent set of size 5\n    independent_candidates = [i for i in range(1, N + 1) if len(adjacency_list[i]) < 4]\n\n    if len(independent_candidates) >= 5:\n        return independent_candidates[:5]\n\n    # If we reach here, no valid party can be organized\n    return -1\n\n# Read input and output the result\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().splitlines()\n    first_line = data[0].split()\n    N = int(first_line[0])\n    M = int(first_line[1])\n    \n    friendships = []\n    for i in range(1, M + 1):\n        u, v = map(int, data[i].split())\n        friendships.append((u, v))\n    \n    result = organize_party(N, M, friendships)\n    if result == -1:\n        print(result)\n    else:\n        print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1600_J. Robot Factory", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_rooms(n, m, grid):\n    # Directions: North, East, South, West represented as (dx, dy)\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Wall presence representation\n    walls = [[0] * m for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    \n    # Create wall presence grid\n    for i in range(n):\n        for j in range(m):\n            walls[i][j] = grid[i][j]\n    \n    def has_wall(x, y, dir):\n        # Check the wall presence in the direction\n        return (walls[x][y] & (1 << dir)) != 0\n\n    def dfs(x, y):\n        stack = [(x, y)]\n        size = 0\n        \n        while stack:\n            cx, cy = stack.pop()\n            if visited[cx][cy]:\n                continue\n            \n            visited[cx][cy] = True\n            size += 1\n            \n            # Explore neighbors\n            for d in range(4):\n                nx, ny = cx + directions[d][0], cy + directions[d][1]\n                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                    if not has_wall(cx, cy, d):  # No wall in this direction\n                        stack.append((nx, ny))\n        \n        return size\n    \n    room_sizes = []\n    \n    for i in range(n):\n        for j in range(m):\n            if not visited[i][j]:\n                room_size = dfs(i, j)\n                room_sizes.append(room_size)\n    \n    # Sort room sizes in descending order\n    room_sizes.sort(reverse=True)\n    return room_sizes\n\nimport sys\n\ndef main():\n    input_data = sys.stdin.read().strip().splitlines()\n    n, m = map(int, input_data[0].split())\n    \n    # Parse the grid\n    grid = [list(map(int, line.split())) for line in input_data[1:n+1]]\n    \n    # Get room sizes\n    room_sizes = find_rooms(n, m, grid)\n    \n    # Print the result\n    print(\" \".join(map(str, room_sizes)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1601_A. Array Elimination", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_valid_k(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        valid_k = set()\n        \n        valid_k.add(1)  # k = 1 is always valid\n        \n        # For k = n\n        if n > 1 and (len(set(a)) == 1 and 0 not in a):\n            valid_k.add(n)  # If all elements are the same and non-zero\n        \n        # Determine the maximum number of bits (0 to 29 since 0 <= a[i] < 2^30)\n        for k in range(2, n + 1):\n            # Check if we can reduce the array to zero using pairs of k elements\n            count = [0] * 30  # Count how many numbers have each bit set\n            for num in a:\n                for bit in range(30):  # Up to 29 bits\n                    if num & (1 << bit):\n                        count[bit] += 1\n            \n            # Check if there's at least one bit that can be eliminated by a group of size k\n            can_make_zero = any(c >= k for c in count)\n            if can_make_zero:\n                valid_k.add(k)\n        \n        results.append(\" \".join(map(str, sorted(valid_k))))\n    \n    return results\n\n# Read input and solve the problem\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    results = find_valid_k(t, test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "1601_B. Frog Traveler", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nfrom collections import deque\n\ndef min_jumps(n, a, b):\n    # BFS initialization\n    queue = deque([n])  # Start from the bottom of the well\n    jumps = [float('inf')] * (n + 1)  # To track min jumps to reach each depth\n    jumps[n] = 0  # Starting point\n    parent = [-1] * (n + 1)  # To reconstruct the path\n\n    while queue:\n        current_depth = queue.popleft()\n        \n        # Determine maximum jump possible from current depth\n        max_jump = a[current_depth - 1]\n        \n        # Explore all reachable positions\n        for jump in range(max_jump + 1):\n            new_depth = current_depth - jump\n            if new_depth < 0:\n                continue  # Can't go above ground level\n            \n            # Calculate the depth after slipping\n            slipped_depth = new_depth + b[new_depth - 1] if new_depth > 0 else 0\n            \n            # If we found a shorter way to reach slipped_depth\n            if jumps[slipped_depth] > jumps[current_depth] + 1:\n                jumps[slipped_depth] = jumps[current_depth] + 1\n                parent[slipped_depth] = current_depth\n                queue.append(slipped_depth)\n\n    # If we can't reach ground level\n    if jumps[0] == float('inf'):\n        return -1, []\n    \n    # Backtrack to find the sequence of jumps\n    path = []\n    pos = 0\n    while pos != n:\n        path.append(pos)\n        pos = parent[pos]\n    \n    path.reverse()  # Reverse to get the correct order\n    return jumps[0], path\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\n\n# Process and output\nresult = min_jumps(n, a, b)\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(\" \".join(map(str, result[1])))"}
{"task_id": "1601_C. Optimal Insertion", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_inversions(t, test_cases):\n    from bisect import bisect_right\n    \n    results = []\n    \n    for n, m, a, b in test_cases:\n        # Sort array b\n        b.sort()\n        \n        inversions = 0\n        \n        for a_elem in a:\n            # Count how many elements in b are greater than a_elem\n            count_greater = len(b) - bisect_right(b, a_elem)\n            inversions += count_greater\n        \n        results.append(inversions)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Processing input\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n, m = map(int, data[index].split())\n    a = list(map(int, data[index + 1].split()))\n    b = list(map(int, data[index + 2].split()))\n    test_cases.append((n, m, a, b))\n    index += 3\n\n# Getting results\nresults = min_inversions(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1601_D. Difficult Mountain", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef max_alpinists(n, d, alpinists):\n    # Sort the alpinists based on skill (s) first and on neatness (a) secondarily\n    alpinists.sort(key=lambda x: (x[0], -x[1]))\n    \n    current_difficulty = d\n    count = 0\n    \n    for skill, neatness in alpinists:\n        if skill >= current_difficulty:\n            count += 1\n            current_difficulty = max(current_difficulty, neatness)\n    \n    return count\n\n# Read the inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, d = map(int, data[0].split())\nalpinists = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n\n# Call the function and print the answer\nresult = max_alpinists(n, d, alpinists)\nprint(result)"}
{"task_id": "1601_E. Phys Ed Online", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_gym_cost(n, q, k, costs, queries):\n    # Array to store minimum costs for each day\n    min_cost = [0] * (n + 1)\n    \n    # Initialize the minimum cost for the first day\n    min_cost[1] = costs[0]\n    \n    # Calculate minimum costs cumulatively\n    for i in range(1, n):\n        min_cost[i + 1] = min(min_cost[i] + costs[i], costs[i])\n        \n        # Check the previous k days to find the best cost\n        if i >= k:\n            min_cost[i + 1] = min(min_cost[i + 1], min_cost[i - k + 1] + costs[i])\n    \n    results = []\n    \n    # Process each query\n    for l, r in queries:\n        total_cost = min_cost[r] - (min_cost[l - 1] if l > 1 else 0)\n        results.append(total_cost)\n    \n    return results\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# First line of input\nn, q, k = map(int, data[0].split())\n# Second line of input\ncosts = list(map(int, data[1].split()))\n# Queries\nqueries = [tuple(map(int, data[i + 2].split())) for i in range(q)]\n\n# Get results\nresults = min_gym_cost(n, q, k, costs, queries)\n\n# Print all results\nfor result in results:\n    print(result)"}
{"task_id": "1601_F. Two Sorts", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef lexicographical_count(n):\n    # Counts numbers <= n that have the same prefix as given prefix\n    s = str(n)\n    length = len(s)\n    count = 0\n    \n    # Count numbers with fewer digits than n\n    for d in range(1, length):\n        count += 9 * (10 ** (d - 1))  # 1, 2, ..., 9 followed by (d-1) digits (0-9)\n\n    # Count numbers with the same number of digits but less than or equal to n\n    prefix = \"\"\n    for i in range(length):\n        current_digit = s[i]\n        # Count how many numbers can be formed with the prefix so far\n        for digit in range(0 if i > 0 else 1, int(current_digit)):\n            count += 10 ** (length - i - 1)\n        \n        prefix += current_digit\n        # If the prefix itself exceeds n, stop counting\n        if prefix > s:\n            break\n    return count\n\ndef calculate_sum(n):\n    MOD1 = 998244353\n    MOD2 = 10**9 + 7\n    total_sum = 0\n    \n    for i in range(1, n + 1):\n        lex_index = lexicographical_count(i) + 1  # +1 for the current number itself\n        difference = (i - lex_index) % MOD1\n        total_sum = (total_sum + difference) % MOD2\n    \n    return total_sum\n\n# Reading input and output\nn = int(input().strip())\nresult = calculate_sum(n)\nprint(result)"}
{"task_id": "1603_D. Artistic Partition", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef precompute_c(max_n):\n    c = [[0] * (max_n + 1) for _ in range(max_n + 1)]\n    \n    for d in range(1, max_n + 1):\n        for multiple in range(d, max_n + 1, d):\n            # Count pairs (i, j) in range [d, r] where gcd(i, j) = d\n            count = (multiple // d) * (multiple // d + 1) // 2\n            for start in range(multiple, max_n + 1):\n                c[d][start] += count\n            \n            if multiple + d <= max_n:\n                c[d][multiple + d] -= count\n\n    for d in range(1, max_n + 1):\n        for j in range(1, max_n + 1):\n            c[d][j] += c[d][j - 1]\n    \n    return c\n\ndef solve(n, k, c):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0  # Base case\n    \n    for j in range(1, n + 1):\n        for i in range(j):\n            dp[j] = min(dp[j], dp[i] + c[i + 1][j])\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    t = int(data[0])\n    queries = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(t)]\n    \n    max_n = max(n for n, k in queries)\n    c = precompute_c(max_n)\n    \n    results = []\n    for n, k in queries:\n        result = solve(n, k, c)\n        results.append(result)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1603_E. A Perfect Problem", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_perfect_sequences(n, M):\n    # Calculate the number of perfect sequences\n    result = (n + 1) % M\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    n, M = map(int, input().strip().split())\n    print(count_perfect_sequences(n, M))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1603_F. October 18, 2017", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    MOD = 998244353\n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n, k, x = map(int, data[i].split())\n        \n        # Total sequences: 2^(kn)\n        total_sequences = mod_exp(2, k * n, MOD)\n        \n        if x == 0:\n            # If x is 0, the invalid subsequences are those that contain 0 at least once\n            # Total sequences without 0: (2^k - 1)^n\n            valid_without_zero = mod_exp(2, (k - 1) * n, MOD)\n            invalid_sequences = (total_sequences - valid_without_zero + MOD) % MOD\n        else:\n            # For x > 0, we need to count invalid sequences that can form XOR x\n            # This requires determining how many elements can be chosen to avoid forming x\n            # If x is valid in the space of 0 to 2^k, we can only choose from (2^k - 1)\n            invalid_sequences = 0\n            if x < (1 << k):\n                # The number of ways we can form sequences that have XOR x\n                # This is more complex and requires an appropriate counting mechanism.\n                # For now, we will assume all sequences are valid as a baseline.\n                invalid_sequences = 0\n\n        # Valid sequences = total_sequences - invalid_sequences\n        valid_sequences = (total_sequences - invalid_sequences + MOD) % MOD\n        results.append(valid_sequences)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1604_A. Era", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_operations_to_satisfy_condition(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        operations = 0\n        current_position = 1\n        \n        for ai in a:\n            if ai > current_position:\n                operations += ai - current_position\n                current_position = ai + 1\n            else:\n                current_position += 1\n        \n        results.append(operations)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nfor i in range(t):\n    n = int(data[2 * i + 1])\n    a = list(map(int, data[2 * i + 2].split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = min_operations_to_satisfy_condition(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res)"}
{"task_id": "1604_B. XOR Specia-LIS-t", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_split_sequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        # Use a set to track if we have any duplicates\n        seen = set()\n        possible = False\n        for num in a:\n            if num in seen:\n                possible = True\n                break\n            seen.add(num)\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Read inputs from stdin and handle the function\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Get results and print them\nresults = can_split_sequence(t, test_cases)\nprint(\"\\n\".join(results))"}
{"task_id": "1604_C. Di-visible Confusion", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_erase_sequence(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        possible = True\n        for j in range(n):\n            if a[j] % (j + 1) == 0:\n                possible = False\n                break\n        results.append(\"YES\" if possible else \"NO\")\n    return results\n\n# Reading input for multiple test cases\nimport sys\n\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\nresults = can_erase_sequence(t, test_cases)\nprint(\"\\n\".join(results))"}
{"task_id": "1604_D. Moderate Modular Mode", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        x, y = map(int, data[i].split())\n        results.append(y)  # Choose n as y\n    \n    print('\\n'.join(map(str, results)))"}
{"task_id": "1604_E. Extreme Extension", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef extreme_value_sum(t, test_cases):\n    MOD = 998244353\n    result = []\n    \n    for case in test_cases:\n        n, a = case\n        total_sum = 0\n        \n        # To store the length of the last decreasing segment\n        last_decrease_length = 0\n        \n        # Traverse the array and calculate extreme values\n        for j in range(n):\n            if j == 0 or a[j] >= a[j - 1]:\n                last_decrease_length = 0  # Reset if not decreasing\n            else:\n                last_decrease_length += 1  # Increment decreasing length\n            \n            total_sum = (total_sum + last_decrease_length) % MOD\n        \n        result.append(total_sum)\n    \n    return result\n\n# Read input and call the function\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    results = extreme_value_sum(t, test_cases)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1606_A. AB Balance", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_steps_to_equal_AB_BA(t, strings):\n    results = []\n    \n    for s in strings:\n        ab_count = sum(1 for i in range(len(s) - 1) if s[i:i + 2] == 'ab')\n        ba_count = sum(1 for i in range(len(s) - 1) if s[i:i + 2] == 'ba')\n        \n        if ab_count == ba_count:\n            results.append(s)\n            continue\n        \n        # If we need to make AB == BA, we can either convert all to 'a' or all to 'b'\n        if ab_count > ba_count:\n            # Convert to all 'b's\n            results.append('b' * len(s))\n        else:\n            # Convert to all 'a's\n            results.append('a' * len(s))\n    \n    return results\n\n# Reading input\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    strings = data[1:t + 1]  # the strings\n    results = min_steps_to_equal_AB_BA(t, strings)\n    \n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "1606_B. Update Files", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum_hours(t, test_cases):\n    results = []\n    for n, k in test_cases:\n        if n == 1:\n            results.append(0)\n            continue\n        \n        if k >= n:\n            results.append(1)\n            continue\n        \n        hours = 0\n        updated_computers = 1  # Initially only computer 1 has the update\n        \n        while updated_computers < n:\n            hours += 1\n            updated_computers += min(k * (k ** hours - 1) // (k - 1), n - updated_computers)\n        \n        results.append(hours)\n\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n\n# Calculate and print results\nresults = minimum_hours(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1606_C. Banknotes", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_min_non_representable(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, k, a = case\n        max_value = 0\n        remaining_k = k\n        \n        for i in range(n):\n            denomination = 10 ** a[i]\n            # Use as many of this denomination as we can\n            if remaining_k > 0:\n                max_using_this = min(remaining_k, 10**9)  # We can't use more than k\n                max_value += max_using_this * denomination\n                remaining_k -= max_using_this\n            \n        # The first number we can't represent\n        min_non_representable = max_value + 1\n        results.append(min_non_representable)\n    \n    return results\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nt = int(data[0])  # number of test cases\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n, k = map(int, data[index].split())\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, k, a))\n    index += 2\n\nresults = find_min_non_representable(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1606_D. Red-Blue Matrix", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        matrix = []\n        for i in range(n):\n            row = list(map(int, data[index].split()))\n            matrix.append(row)\n            index += 1\n        \n        # Start with two colors\n        color = [''] * n\n        color[0] = 'R'  # First row red\n        color[1] = 'B'  # Second row blue\n        \n        red_max = [0] * (m - 1)\n        blue_min = [0] * (m - 1)\n        valid = False\n        \n        for k in range(1, m):\n            # Prepare to find the maximum of reds and minimum of blues for left matrix\n            left_red_max = float('-inf')\n            left_blue_min = float('inf')\n            for i in range(n):\n                if color[i] == 'R':\n                    left_red_max = max(left_red_max, max(matrix[i][:k]))\n                else:\n                    left_blue_min = min(left_blue_min, min(matrix[i][:k]))\n            \n            # If condition is violated\n            if left_red_max <= left_blue_min:\n                continue\n            \n            # Prepare to find the minimum of reds and maximum of blues for right matrix\n            right_red_min = float('inf')\n            right_blue_max = float('-inf')\n            for i in range(n):\n                if color[i] == 'R':\n                    right_red_min = min(right_red_min, min(matrix[i][k:]))\n                else:\n                    right_blue_max = max(right_blue_max, max(matrix[i][k:]))\n            \n            # If condition is violated\n            if right_blue_max <= right_red_min:\n                continue\n            \n            # If we reach here, we have a valid configuration\n            valid = True\n            results.append(\"YES\")\n            results.append(''.join(color))\n            results.append(str(k))\n            break\n        \n        if not valid:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1606_E. Arena", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_no_winner(n, x):\n    MOD = 998244353\n    \n    if n > x:\n        return 0\n    \n    choices_per_hero = x - n + 1\n    total_combinations = pow(choices_per_hero, n, MOD)\n    \n    return total_combinations\n\n# Reading inputs\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, x = map(int, input().strip().split())\n    \n    result = count_no_winner(n, x)\n    print(result)"}
{"task_id": "1606_F. Tree Queries", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef main():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for i in range(1, n):\n        x, y = map(int, data[i].split())\n        tree[x].append(y)\n        tree[y].append(x)\n    \n    # Prepare to store the children counts\n    c = [0] * (n + 1)\n    \n    # A visited array to track visited nodes during DFS\n    visited = [False] * (n + 1)\n    \n    def dfs(node):\n        visited[node] = True\n        count = 0\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                count += 1 + dfs(neighbor)\n        c[node] = count\n        return count\n    \n    # Start DFS from the root (1)\n    dfs(1)\n    \n    # Read number of queries\n    q = int(data[n])\n    \n    results = []\n    \n    # Process each query\n    for i in range(n + 1, n + 1 + q):\n        v, k = map(int, data[i].split())\n        \n        if k == 0:\n            # If k is 0, we want the full count of children\n            results.append(c[v])\n        else:\n            # We need to decide which nodes to delete\n            max_score = -float('inf')\n            \n            # If we keep all children, we have c[v] children and m = 0\n            max_score = c[v]\n            \n            # Try deleting each child and see the effect\n            for child in tree[v]:\n                if c[child] > 0:  # Only consider if child has children\n                    # Calculate the score if we delete this child\n                    current_children = c[v] - 1  # We would lose one child\n                    score_if_deleted = current_children - 1 * k\n                    max_score = max(max_score, score_if_deleted)\n            \n            results.append(max_score)\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "1607_A. Linear Keyboard", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef typing_time_on_keyboard(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        keyboard = test_cases[i][0]\n        word = test_cases[i][1]\n        \n        # Create a mapping of each character to its position\n        position_map = {char: idx for idx, char in enumerate(keyboard)}\n        \n        # Calculate total typing time\n        total_time = 0\n        current_position = position_map[word[0]]  # Start with the first character\n        \n        for char in word[1:]:\n            next_position = position_map[char]\n            total_time += abs(next_position - current_position)\n            current_position = next_position\n        \n        results.append(total_time)\n    \n    return results\n\n# Input handling and output\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nt = int(data[0])\ntest_cases = [(data[2*i + 1], data[2*i + 2]) for i in range(t)]\n\nresults = typing_time_on_keyboard(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1607_B. Odd Grasshopper", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef final_position(x0, n):\n    if n == 0:\n        return x0\n\n    total_jumps = n * (n + 1) // 2\n\n    if x0 % 2 == 0:  # x0 is even\n        if n % 2 == 0:  # n is even\n            return x0 - total_jumps\n        else:  # n is odd\n            return x0 + total_jumps + 1\n    else:  # x0 is odd\n        if n % 2 == 0:  # n is even\n            return x0 + total_jumps\n        else:  # n is odd\n            return x0 - total_jumps - 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        x0, n = map(int, data[i].split())\n        results.append(final_position(x0, n))\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1607_C. Minimum Extraction", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_minimum(t, cases):\n    results = []\n    for case in cases:\n        n = case[0]\n        a = case[1]\n        \n        if n == 1:\n            results.append(a[0])\n        else:\n            a.sort()\n            results.append(a[-1])  # The maximum possible minimum after all operations\n    \n    return results\n\n# Reading input and running the function\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ncases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    cases.append((n, a))\n    index += 2\n\nresults = maximize_minimum(t, cases)\nfor result in results:\n    print(result)"}
{"task_id": "1607_D. Blue-Red Permutation", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_form_permutation(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i][0]\n        a = test_cases[i][1]\n        colors = test_cases[i][2]\n        \n        # Count occurrences of each number\n        count = [0] * (n + 1)\n        for num in a:\n            if 1 <= num <= n:\n                count[num] += 1\n        \n        # Check how many blues and reds we can use\n        excess_b = 0\n        excess_r = 0\n        \n        for j in range(1, n + 1):\n            if count[j] == 0:  # number j is missing\n                # Check what can fill this gap\n                if j - 1 >= 1:  # Can we decrease a blue to fill this?\n                    excess_b += sum(1 for k in range(n) if a[k] >= j and colors[k] == 'B')\n                if j + 1 <= n:  # Can we increase a red to fill this?\n                    excess_r += sum(1 for k in range(n) if a[k] <= j and colors[k] == 'R')\n        \n        # Check the total excess possible\n        # We need at least as many operations as there are missing numbers\n        if excess_b + excess_r >= n - sum(1 for c in count[1:] if c > 0):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Use the function\nt = 8\ntest_cases = [\n    (4, [1, 2, 5, 2], \"BRBR\"),\n    (2, [1, 1], \"BB\"),\n    (5, [3, 1, 4, 2, 5], \"RBRRB\"),\n    (5, [3, 1, 3, 1, 3], \"RBRRB\"),\n    (5, [5, 1, 5, 1, 5], \"RBRRB\"),\n    (4, [2, 2, 2, 2], \"BRBR\"),\n    (2, [1, -2], \"BR\"),\n    (4, [-2, -1, 4, 0], \"RRRR\"),\n]\n\nresult = can_form_permutation(t, test_cases)\nfor res in result:\n    print(res)"}
{"task_id": "1607_E. Robot on the Board 1", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_start_positions(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, s = case\n        \n        # Initialize boundaries\n        min_row = 0\n        max_row = 0\n        min_col = 0\n        max_col = 0\n        \n        # Current position simulation\n        current_row = 0\n        current_col = 0\n        \n        for command in s:\n            if command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            elif command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            \n            # Update max/min boundaries\n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Calculate valid starting position\n        start_row = max(1, 1 - min_row)\n        start_col = max(1, 1 - min_col)\n        \n        # Ensure within bounds of the board\n        if start_row + max_row > n:\n            start_row = n - max_row\n        if start_col + max_col > m:\n            start_col = m - max_col\n        \n        results.append((start_row, start_col))\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nfor i in range(t):\n    n, m = map(int, data[2 * i + 1].split())\n    s = data[2 * i + 2]\n    test_cases.append((n, m, s))\n\n# Get results\nresults = find_start_positions(t, test_cases)\n\n# Print results\nfor row, col in results:\n    print(row, col)"}
{"task_id": "1607_F. Robot on the Board 2", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef robot_moves(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, board = case\n        \n        # Directions mapping\n        direction = {\n            'L': (0, -1),\n            'R': (0, 1),\n            'U': (-1, 0),\n            'D': (1, 0)\n        }\n        \n        # To store the maximum number of steps from each cell\n        max_steps = [[-1] * m for _ in range(n)]\n        \n        def dfs(start_row, start_col):\n            visited = set()\n            current_row, current_col = start_row, start_col\n            steps = 0\n            \n            while True:\n                if (current_row, current_col) in visited:\n                    break\n                if current_row < 0 or current_row >= n or current_col < 0 or current_col >= m:\n                    break\n                \n                visited.add((current_row, current_col))\n                next_direction = board[current_row][current_col]\n                dr, dc = direction[next_direction]\n                current_row += dr\n                current_col += dc\n                steps += 1\n            \n            return steps\n        \n        max_moves = 0\n        best_position = (1, 1)  # Default to (1, 1) for later output\n        \n        for r in range(n):\n            for c in range(m):\n                if max_steps[r][c] == -1:  # Not computed yet\n                    steps = dfs(r, c)\n                    max_steps[r][c] = steps\n                    if steps > max_moves:\n                        max_moves = steps\n                        best_position = (r + 1, c + 1)  # Convert to 1-based index\n        \n        results.append(f\"{best_position[0]} {best_position[1]} {max_moves}\")\n    \n    return results\n\n# Read input format\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split(\"\\n\")\n    t = int(data[0].strip())\n    test_cases = []\n    idx = 1\n\n    for _ in range(t):\n        while data[idx].strip() == \"\":\n            idx += 1\n        n, m = map(int, data[idx].strip().split())\n        idx += 1\n        board = [data[idx + i].strip() for i in range(n)]\n        test_cases.append((n, m, board))\n        idx += n\n\n    results = robot_moves(t, test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1607_G. Banquet Preparations 1", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimize_balance(t, test_cases):\n    results = []\n    \n    for n, m, dishes in test_cases:\n        total_fish = sum(a for a, b in dishes)\n        total_meat = sum(b for a, b in dishes)\n        \n        # Initial balance\n        initial_balance = abs(total_fish - total_meat)\n        current_balance = initial_balance\n        \n        allocation = []\n        \n        # Based on the initial balance, we decide how much to eat\n        if total_fish > total_meat:\n            # We need to eat more meat\n            for a, b in dishes:\n                # Eat as much meat as possible, but must eat m total\n                y = min(b, m)\n                x = m - y\n                allocation.append((min(x, a), y))\n        else:\n            # We need to eat more fish\n            for a, b in dishes:\n                # Eat as much fish as possible, but must eat m total\n                x = min(a, m)\n                y = m - x\n                allocation.append((x, min(y, b)))\n\n        # Calculate new totals\n        total_fish_eaten = sum(x for x, y in allocation)\n        total_meat_eaten = sum(y for x, y in allocation)\n        \n        final_balance = abs(total_fish - total_fish_eaten - (total_meat - total_meat_eaten))\n        \n        results.append(f\"{final_balance}\")\n        for x, y in allocation:\n            results.append(f\"{x} {y}\")\n\n    return results\n\n# Reading the input in the specified format\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    index += 1  # Skip the blank line\n    n, m = map(int, data[index].split())\n    index += 1\n    dishes = []\n    \n    for __ in range(n):\n        a, b = map(int, data[index].split())\n        dishes.append((a, b))\n        index += 1\n\n    test_cases.append((n, m, dishes))\n\n# Solve the test cases\nresults = minimize_balance(t, test_cases)\n\n# Output the results\nprint('\\n'.join(results))"}
{"task_id": "1607_H. Banquet Preparations 2", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n```python\ndef minimize_variety(test_cases):\n    results = []\n    \n    for n, dishes in test_cases:\n        from collections import defaultdict\n        \n        groups = defaultdict(list)\n        \n        # Group dishes by (a_i, b_i)\n        for index, (a_i, b_i, m_i) in enumerate(dishes):\n            groups[(a_i, b_i)].append((m_i, index))\n        \n        # Prepare the answer structure\n        consumption = [(0, 0)] * n\n        \n        # Process each group\n        total_variety = 0\n        \n        for (a_i, b_i), dishes_list in groups.items():\n            total_variety += 1  # Each unique (a_i, b_i) adds one to the variety\n            total_m = sum(m_i for m_i, _ in dishes_list)  # total m_i for the group\n            count = len(dishes_list)\n            # Distributing the m_i evenly across dishes in this group\n            m_per_dish = total_m // count\n            \n            remaining = total_m % count\n            \n            for (m_i, index) in dishes_list:\n                if m_i <= m_per_dish:\n                    x_i = min(a_i, m_i)\n                    y_i = m_i - x_i\n                else:\n                    x_i = min(a_i, m_per_dish)\n                    y_i = m_per_dish - x_i\n                    \n                # We might need to adjust based on remaining 'm_i' we couldn't distribute\n                if remaining > 0 and x_i < a_i:\n                    x_i += 1\n                    remaining -= 1\n                elif remaining > 0 and y_i < b_i:\n                    y_i += 1\n                    remaining -= 1\n                \n                consumption[index] = (x_i, y_i)\n        \n        # Prepare output\n        results.append(f\"{total_variety}\")\n        for x_i, y_i in consumption:\n            results.append(f\"{x_i} {y_i}\")\n    \n    return \"\\n\".join(results)\n\n# Example usage\ninput_data = [\n    (3, [(10, 10, 2), (9, 9, 0), (10, 9, 1)]),\n    (2, [(3, 4, 1), (5, 1, 2)]),\n    (3, [(7, 2, 5), (6, 5, 4), (5, 5, 6)]),\n    (1, [(13, 42, 50)]),\n    (5, [(5, 7, 12), (3, 1, 4), (7, 3, 7), (0, 0, 0), (4, 1, 5)])\n]\n\nprint(minimize_variety(input"}
{"task_id": "1608_A. Find Array", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef generate_arrays(test_cases):\n    results = []\n    for n in test_cases:\n        # Generate a list of n consecutive integers starting from 2\n        results.append(\" \".join(str(2 + i) for i in range(n)))\n    return results\n\n# Main function to read input and print output\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    t = int(data[0])  # number of test cases\n    test_cases = [int(data[i]) for i in range(1, t + 1)]\n    \n    results = generate_arrays(test_cases)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1608_B. Build the Permutation", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_permutation(n, a, b):\n    if a + b > n - 2 or (a > (n - 1) // 2) or (b > (n - 1) // 2):\n        return -1\n    \n    p = list(range(1, n + 1))  # Start with the permutation [1, 2, ..., n]\n\n    # Create local maxima\n    for i in range(1, a + 1):\n        p[2 * i - 1], p[2 * i] = p[2 * i], p[2 * i - 1]\n\n    # Create local minima\n    for i in range(1, b + 1):\n        if 2 * a + 2 * i < n:\n            p[2 * a + 2 * i - 1], p[2 * a + 2 * i] = p[2 * a + 2 * i], p[2 * a + 2 * i - 1]\n    \n    return p\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Number of test cases\n    results = []\n    \n    for i in range(1, t + 1):\n        n, a, b = map(int, data[i].split())\n        result = find_permutation(n, a, b)\n        if result == -1:\n            results.append(\"-1\")\n        else:\n            results.append(\" \".join(map(str, result)))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1608_C. Game Master", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_win_tournament():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index].split()))\n        index += 1\n        b = list(map(int, data[index].split()))\n        index += 1\n        \n        max_a = max(a)\n        max_b = max(b)\n        \n        result = []\n        for i in range(n):\n            if a[i] == max_a or b[i] == max_b:\n                result.append(\"1\")\n            else:\n                result.append(\"0\")\n        \n        results.append(\"\".join(result))\n    \n    print(\"\\n\".join(results))\n\n# Note: The function `can_win_tournament()` is designed to read from standard input\n# and will handle multiple test cases as described in the prompt."}
{"task_id": "1608_D. Dominoes", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_valid_colorings(n, dominoes):\n    MOD = 998244353\n    \n    # Determine the valid colorings\n    valid_count = 1  # Initialize with one valid way\n    \n    # To handle edge cases for color checks\n    colors = []\n    for left, right in dominoes:\n        colors.append((left, right))\n    \n    # Handle the coloring\n    for i in range(n):\n        left, right = colors[i]\n        next_left, _ = colors[(i + 1) % n]  # Next domino's left color\n        \n        if left == '?' and right == '?':\n            # Both sides are '?'\n            valid_count *= 2\n            valid_count %= MOD\n        elif left == '?':\n            # Left is '?', right is known\n            if right == 'B':\n                # Right is 'B', left must be 'W'\n                colors[i] = ('W', right)\n            else:  # right == 'W'\n                # Right is 'W', left must be 'B'\n                colors[i] = ('B', right)\n        elif right == '?':\n            # Right is '?', left is known\n            if left == 'B':\n                # Left is 'B', right must be 'W'\n                colors[i] = (left, 'W')\n            else:  # left == 'W'\n                # Left is 'W', right must be 'B'\n                colors[i] = (left, 'B')\n        else:\n            # Both sides are known\n            if left == right:\n                return 0  # Invalid configuration\n    \n    return valid_count\n\n# Reading input from stdin and printing the output\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    n = int(data[0])\n    dominoes = [tuple(line.strip()) for line in data[1:n+1]]\n    \n    answer = count_valid_colorings(n, dominoes)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1608_E. The Cells on the Paper", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_form_rectangles(cells, k):\n    # Group cells by color\n    color_cells = {1: [], 2: [], 3: []}\n    for (x, y, c) in cells:\n        color_cells[c].append((x, y))\n    \n    # Get the bounds for each color\n    bounds = {}\n    for color in range(1, 4):\n        xs = [cell[0] for cell in color_cells[color]]\n        ys = [cell[1] for cell in color_cells[color]]\n        bounds[color] = (min(xs), max(xs), min(ys), max(ys))\n    \n    # Check for non-intersecting rectangles\n    for color1 in range(1, 4):\n        for color2 in range(color1 + 1, 4):\n            b1 = bounds[color1]\n            b2 = bounds[color2]\n            # Check if rectangles intersect\n            if not (b1[1] < b2[0] or b2[1] < b1[0] or b1[3] < b2[2] or b2[3] < b1[2]):\n                return False\n    return True\n\ndef max_cells(n, cells):\n    left, right = 0, n // 3\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_form_rectangles(cells[:3 * mid], mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left * 3\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    n = int(data[0])\n    cells = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    result = max_cells(n, cells)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1608_F. MEX counting", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_valid_arrays(n, k, b):\n    MOD = 998244353\n\n    # Initialize a DP table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: For an empty array, MEX is 0\n    dp[0][0] = 1  # One way to have a MEX of 0 with an empty array\n    \n    for i in range(1, n + 1):\n        mex_min = max(0, b[i - 1] - k)\n        mex_max = min(n, b[i - 1] + k)\n        \n        # Cumulative sums to efficiently calculate the ranges\n        cum_sum = [0] * (n + 2)\n        \n        for m in range(n + 1):\n            cum_sum[m + 1] = (cum_sum[m] + dp[i - 1][m]) % MOD\n        \n        for m in range(n + 1):\n            if mex_min <= m <= mex_max:\n                # Valid MEX is within the range\n                # We can take all values from [0, m-1] plus m itself\n                dp[i][m] = cum_sum[m + 1]  # All ways to have MEX <= m\n            else:\n                # If m < mex_min or m > mex_max, no valid arrays\n                dp[i][m] = 0\n    \n    # Sum all valid MEX counts for full arrays\n    result = sum(dp[n]) % MOD\n    return result\n\n# Read input and call the function\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn, k = int(data[0]), int(data[1])\nb = list(map(int, data[2:n + 2]))\n\n# Execute and print the output\nprint(count_valid_arrays(n, k, b))"}
{"task_id": "1608_G. Alphabetic Tree", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nfrom sys import stdin, stdout\nfrom collections import defaultdict, deque\n\ndef dfs(node, parent):\n    depth[node] = depth[parent] + 1 if parent else 0\n    parent_map[node] = parent\n    for neighbor, char in tree[node]:\n        if neighbor != parent:\n            edge_char[neighbor] = char\n            dfs(neighbor, node)\n\ndef find_lca(u, v):\n    # Bring both nodes to the same depth\n    if depth[u] < depth[v]:\n        u, v = v, u\n    # Bring u and v to the same level\n    while depth[u] > depth[v]:\n        u = parent_map[u]\n    while u != v:\n        u = parent_map[u]\n        v = parent_map[v]\n    return u\n\ndef get_path_string(u, v):\n    lca = find_lca(u, v)\n    path = []\n    # From u to lca\n    while u != lca:\n        path.append(edge_char[u])\n        u = parent_map[u]\n    # From lca to v\n    path_from_lca_to_v = []\n    while v != lca:\n        path_from_lca_to_v.append(edge_char[v])\n        v = parent_map[v]\n    # Combine both parts\n    path.extend(reversed(path_from_lca_to_v))\n    return ''.join(path)\n\ndef count_occurrences(substr, strings):\n    count = 0\n    for s in strings:\n        count += s.count(substr)\n    return count\n\ndef main():\n    input = stdin.read\n    data = input().splitlines()\n    \n    n, m, q = map(int, data[0].split())\n    \n    global tree, depth, parent_map, edge_char\n    tree = defaultdict(list)\n    depth = {}\n    parent_map = {}\n    edge_char = {}\n    \n    idx = 1\n    for _ in range(n - 1):\n        u, v, c = data[idx].split()\n        u, v = int(u), int(v)\n        tree[u].append((v, c))\n        tree[v].append((u, c))\n        idx += 1\n    \n    # Prepare depth and parent arrays\n    depth = {}\n    parent_map = {}\n    edge_char = {}\n    dfs(1, None)  # Start DFS from node 1 (assuming 1-based indexing)\n\n    strings = [data[i] for i in range(idx, idx + m)]\n    idx += m\n    \n    results = []\n    for _ in range(q):\n        u, v, l, r = map(int, data[idx].split())\n        l -= 1  # Convert to 0 index\n        r -= 1  # Convert to 0 index\n        \n        path_string = get_path_string(u, v)\n        occurrences = count_occurrences(path_string, strings[l:r + 1])\n        results.append(str(occurrences))\n        idx += 1\n    \n    stdout.write(\"\\n\".join(results) + \"\\n\")"}
{"task_id": "1613_A. Long Comparison", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef compare_numbers(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        x1, p1 = test_cases[i][0]\n        x2, p2 = test_cases[i][1]\n        \n        # Normalize the comparison on powers of ten\n        if p1 < p2:\n            # Compare x1 * 10^(p1) with x2 * 10^(p2)\n            # This is equivalent to comparing x1 with x2 * 10^(p2 - p1)\n            x1_adjusted = x1\n            x2_adjusted = x2 * (10 ** (p2 - p1))\n        elif p1 > p2:\n            # Compare x1 * 10^(p1) with x2 * 10^(p2)\n            # This is equivalent to comparing x1 * 10^(p1 - p2) with x2\n            x1_adjusted = x1 * (10 ** (p1 - p2))\n            x2_adjusted = x2\n        else:\n            # p1 == p2, direct comparison of x1 and x2\n            x1_adjusted = x1\n            x2_adjusted = x2\n            \n        # Perform the comparison\n        if x1_adjusted < x2_adjusted:\n            results.append('<')\n        elif x1_adjusted > x2_adjusted:\n            results.append('>')\n        else:\n            results.append('=')\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nfor i in range(t):\n    x1, p1 = map(int, data[2 * i + 1].split())\n    x2, p2 = map(int, data[2 * i + 2].split())\n    test_cases.append(((x1, p1), (x2, p2)))\n\n# Get the results\nresults = compare_numbers(t, test_cases)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "1613_B. Absent Remainder", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, arr = case\n        seen = set(arr)\n        pairs = []\n        \n        for i in range(n):\n            x = arr[i]\n            for j in range(n):\n                if i != j:\n                    y = arr[j]\n                    if x % y not in seen:  # Check the condition for valid pair\n                        pairs.append((x, y))\n                        if len(pairs) == n // 2:\n                            break\n            if len(pairs) == n // 2:\n                break\n        \n        results.append(pairs)\n    \n    return results\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nline_index = 1\nfor _ in range(t):\n    n = int(data[line_index])\n    arr = list(map(int, data[line_index + 1].split()))\n    test_cases.append((n, arr))\n    line_index += 2\n\n# Get results\nresults = find_pairs(t, test_cases)\n\n# Print output in the required format\nfor pairs in results:\n    for x, y in pairs:\n        print(x, y)"}
{"task_id": "1613_C. Poisoned Dagger", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum_k_damage(test_cases):\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            \n            # Calculate damage with current mid as k\n            damage = 0\n            last_time = 0\n            \n            for i in range(n):\n                attack_time = attacks[i]\n                \n                if i == 0:\n                    # First attack always contributes full k seconds\n                    damage += mid\n                else:\n                    # Calculate the overlap\n                    overlap = max(0, attack_time - last_time)\n                    effective_damage = mid - overlap\n                    damage += max(0, effective_damage)\n                \n                # Update last_time to the end of this attack's poison effect\n                last_time = attack_time + mid - 1\n            \n            if damage >= h:\n                high = mid  # We might find a smaller k\n            else:\n                low = mid + 1  # Need a larger k\n            \n        results.append(low)\n    \n    return results\n\n# Read input and run the function\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nt = int(data[0])\ntest_cases = []\n\nfor i in range(t):\n    n, h = map(int, data[2 * i + 1].split())\n    attacks = list(map(int, data[2 * i + 2].split()))\n    test_cases.append((n, h, attacks))\n\nresults = minimum_k_damage(test_cases)\n\nfor res in results:\n    print(res)"}
{"task_id": "1613_D. MEX Sequences", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_mex_correct_subsequences(test_cases):\n    MOD = 998244353\n    results = []\n    \n    for n, a in test_cases:\n        count = [0] * (n + 1)\n        \n        # Count occurrences of each integer in the array\n        for number in a:\n            if number <= n:\n                count[number] += 1\n        \n        # Determine the largest k where 0 to k are all present\n        k = 0\n        while k <= n and count[k] > 0:\n            k += 1\n        k -= 1  # k is the largest number such that 0 to k is present\n        \n        # Special case for the number of excess numbers\n        excess_count = sum(count[k + 1:n + 1])\n        \n        # Calculate number of valid subsequences\n        result = 1\n        for i in range(k + 1):\n            if count[i] > 0:\n                result = result * (pow(2, count[i], MOD) - 1) % MOD\n        \n        # Multiply by the number of non-empty subsets of excess numbers\n        if excess_count > 0:\n            result = result * pow(2, excess_count, MOD) % MOD\n        \n        results.append(result)\n    \n    return results\n\n# Read input\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\nt = int(data[index])\nindex += 1\n\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    test_cases.append((n, a))\n\n# Solve the problem\nresults = count_mex_correct_subsequences(test_cases)\n\n# Output results\nfor res in results:\n    print(res)"}
{"task_id": "1613_E. Crazy Robot", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_force_reach_lab(n, m, grid, lab_position):\n    from collections import deque\n    \n    # Directions correspond to [up, down, left, right]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS from lab_position\n    queue = deque([lab_position])\n    reachable = set()\n    reachable.add(lab_position)\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.':\n                if (nx, ny) not in reachable:\n                    reachable.add((nx, ny))\n                    queue.append((nx, ny))\n    \n    # Create a new grid with required modifications\n    result_grid = []\n    for i in range(n):\n        new_row = []\n        for j in range(m):\n            if grid[i][j] == 'L':\n                new_row.append('L')\n            elif grid[i][j] == '#':\n                new_row.append('#')\n            elif (i, j) in reachable:\n                new_row.append('+')\n            else:\n                new_row.append('.')\n        result_grid.append(''.join(new_row))\n    \n    return result_grid\n\ndef process_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = []\n        lab_position = None\n        \n        for i in range(n):\n            row = data[index]\n            grid.append(row)\n            if 'L' in row:\n                lab_position = (i, row.index('L'))\n            index += 1\n        \n        modified_grid = can_force_reach_lab(n, m, grid, lab_position)\n        results.append('\\n'.join(modified_grid))\n    \n    print('\\n\\n'.join(results))\n\n# The function process_input() will read from stdin and execute the solution."}
{"task_id": "1613_F. Tree Coloring", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_beautiful_colorings(n, edges):\n    from sys import setrecursionlimit\n    from collections import defaultdict\n    \n    MOD = 998244353\n    setrecursionlimit(300000)\n\n    # Build the tree using adjacency list\n    tree = defaultdict(list)\n    for x, y in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n\n    # Caching factorial and inverse factorial\n    fact = [1] * (n + 1)\n    ifact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    ifact[n] = pow(fact[n], MOD - 2, MOD)  # Fermat's little theorem\n    for i in range(n - 1, 0, -1):\n        ifact[i] = ifact[i + 1] * (i + 1) % MOD\n\n    # DFS to calculate the number of colorings\n    def dfs(node, parent):\n        total_subtree_size = 1\n        total_ways = 1\n        child_count = 0\n        \n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            child_count += 1\n            subtree_size, subtree_ways = dfs(neighbor, node)\n            total_subtree_size += subtree_size\n            total_ways = total_ways * subtree_ways % MOD\n        \n        # Number of ways to arrange the current node's children with given constraints\n        if child_count > 0:\n            total_ways = total_ways * fact[total_subtree_size - 1] % MOD\n            total_ways = total_ways * ifact[child_count - 1] % MOD\n        \n        return total_subtree_size, total_ways\n\n    # Start DFS from the root node 1\n    _, result = dfs(1, -1)\n    \n    # The result is multiplied by n (the number of ways to choose the color of the root)\n    result = result * n % MOD\n    \n    return result\n\n# Input handling\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nn = int(data[0])\nedges = [tuple(map(int, line.split())) for line in data[1:n]]\n\n# Get the result and print it\nprint(count_beautiful_colorings(n, edges))"}
{"task_id": "1615_A. Closing The Gap", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum_ugliness(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, heights = case\n        total_blocks = sum(heights)\n        \n        # Check if total_blocks is divisible by n\n        if total_blocks % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\n# Reading inputs and executing the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        heights = list(map(int, data[index + 1].split()))\n        test_cases.append((n, heights))\n        index += 2\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)"}
{"task_id": "1615_B. And It's Non-Zero", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum_deletions(t, test_cases):\n    results = []\n    for l, r in test_cases:\n        if l == r:\n            results.append(0)\n            continue\n        \n        # Find the first bit position where l and r differ\n        diff = l ^ r  # XOR to find differing bits\n        highest_bit = 0\n        \n        while diff:\n            highest_bit += 1\n            diff >>= 1\n        \n        # The number of integers in the range l to r\n        total_count = r - l + 1\n        \n        # The number of elements that can be kept is 1 << (highest_bit - 1)\n        # The maximum count of non-zero AND possible is the highest power of two\n        # that can fit within the range defined by the highest differing bit\n        max_keep = total_count - (1 << (highest_bit - 1))\n        \n        # To find how many need to be deleted\n        to_delete = total_count - max_keep\n        \n        results.append(to_delete)\n\n    return results\n\n# Reading input format and invoking function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n    \n    results = minimum_deletions(t, test_cases)\n    \n    for result in results:\n        print(result)"}
{"task_id": "1615_C. Menorah", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_operations_to_match_candles(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, b = case\n        count01 = 0  # Count of positions where we want to light a candle\n        count10 = 0  # Count of positions where we want to extinguish a candle\n        \n        # Evaluate the differences\n        for i in range(n):\n            if a[i] == '0' and b[i] == '1':\n                count01 += 1\n            elif a[i] == '1' and b[i] == '0':\n                count10 += 1\n        \n        # Check if the operation is impossible\n        if count01 > 0 and '1' not in a:\n            results.append(-1)\n        else:\n            results.append(max(count01, count10))\n\n    return results\n\n# Reading input and calling the function\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split(\"\\n\")\n\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = data[index + 1].strip()\n    b = data[index + 2].strip()\n    test_cases.append((n, a, b))\n    index += 3\n\n# Get the results\nresults = min_operations_to_match_candles(t, test_cases)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "1615_D. X(or)-mas Tree", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n```python\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.parity = [0] * n  # Track the parity of the path to root\n    \n    def find(self, a):\n        if self.parent[a] != a:\n            original_parent = self.parent[a]\n            self.parent[a] = self.find(self.parent[a])\n            self.parity[a] ^= self.parity[original_parent]\n        return self.parent[a]\n    \n    def union(self, a, b, val):\n        rootA = self.find(a)\n        rootB = self.find(b)\n        \n        if rootA != rootB:\n            if self.rank[rootA] > self.rank[rootB]:\n                self.parent[rootB] = rootA\n                self.parity[rootB] = self.parity[a] ^ self.parity[b] ^ val\n            elif self.rank[rootA] < self.rank[rootB]:\n                self.parent[rootA] = rootB\n                self.parity[rootA] = self.parity[a] ^ self.parity[b] ^ val\n            else:\n                self.parent[rootB] = rootA\n                self.parity[rootB] = self.parity[a] ^ self.parity[b] ^ val\n                self.rank[rootA] += 1\n\n    def set_parity(self, a, p):\n        rootA = self.find(a)\n        self.parity[rootA] = p\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[idx].split())\n        idx += 1\n        \n        edges = []\n        uf = UnionFind(n + 1)\n        unknown_edges = []\n        \n        for __ in range(n - 1):\n            x, y, v = map(int, data[idx].split())\n            edges.append((x, y, v))\n            if v != -1:\n                uf.union(x, y, v)\n            else:\n                unknown_edges.append((x, y))\n            idx += 1\n\n        queries = []\n        for __ in range(m):\n            a, b, p = map(int, data[idx].split())\n            queries.append((a, b, p))\n            idx += 1\n\n        consistent = True\n        for a, b, p in queries:\n            rootA = uf.find(a)\n            rootB = uf.find(b)\n            \n            if rootA == rootB:\n                if (uf.parity[a] ^ uf.parity[b]) % 2 != p:\n                    consistent = False\n                    break\n            else:\n                uf.union(a, b, p)\n\n        if not consistent:\n            results.append(\"NO\")\n            continue\n\n        final_edges = []\n        for x, y, v in edges:\n            if v"}
{"task_id": "1615_E. Purple Crayon", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef optimal_score(n, k, edges):\n    from collections import defaultdict\n    \n    # Build the tree as an adjacency list\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # To store the size of subtrees\n    subtree_sizes = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    # DFS to compute the size of each subtree\n    def dfs(node):\n        visited[node] = True\n        size = 1\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                size += dfs(neighbor)\n        subtree_sizes[node] = size\n        return size\n    \n    # Start DFS from the root node which is 1\n    dfs(1)\n    \n    # Collect sizes of all the nodes' subtrees, except the root node\n    subtree_sizes[0] = 0  # Placeholder for the 0 index (not used)\n    subtree_sizes = subtree_sizes[1:]  # Use only 1 to n indices\n    \n    # Sort the subtree sizes in descending order\n    sorted_sizes = sorted(subtree_sizes, reverse=True)\n    \n    # Red's optimal strategy: Color k largest subtrees (or as many as he can)\n    r = sum(sorted_sizes[i] for i in range(min(k, len(sorted_sizes))))\n    \n    # Total nodes minus red nodes gives us the remaining white nodes\n    w = n - r\n    \n    # Blue can color all other nodes except those colored by Red\n    # The maximum number of blue nodes Blue can color are those not part of Red's subtrees\n    b = 0\n    if k < n:  # If Red colored all nodes, Blue cannot color any\n        b = n - (r + (n - r))  # All remaining nodes can be colored by Blue\n    \n    # Calculate the score w * (r - b)\n    score = w * (r - b)\n    \n    return score\n\n# Read from stdin and process\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nedges = [tuple(map(int, line.split())) for line in data[1:n]]\n\nresult = optimal_score(n, k, edges)\nprint(result)"}
{"task_id": "1615_F. LEGOndary Grandmaster", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_operations(start, end):\n    \"\"\"\n    Count the number of operations needed to transform start to end.\n    This counts pairs of '11' that need to be removed and pairs of '00' that need to be added.\n    \"\"\"\n    remove_count, add_count = 0, 0\n    for i in range(len(start) - 1):\n        if start[i] == '1' and start[i + 1] == '1':\n            remove_count += 1\n        if end[i] == '0' and end[i + 1] == '0':\n            add_count += 1\n            \n    return remove_count, add_count\n\ndef total_time(n, s, t):\n    MOD = 1000000007\n    total_operations = 0\n    \n    # Generate all possible states for '?' in s and t\n    for mask in range(1 << s.count('?')):\n        # Build the candidate start state\n        candidate_start = list(s)\n        for i, char in enumerate(candidate_start):\n            if char == '?':\n                candidate_start[i] = '1' if (mask & (1 << (i - candidate_start.count('?') + s.count('?')))) else '0'\n        candidate_start = ''.join(candidate_start)\n\n        # Generate all possible states for '?' in t\n        for mask_t in range(1 << t.count('?')):\n            candidate_end = list(t)\n            for i, char in enumerate(candidate_end):\n                if char == '?':\n                    candidate_end[i] = '1' if (mask_t & (1 << (i - candidate_end.count('?') + t.count('?')))) else '0'\n            candidate_end = ''.join(candidate_end)\n\n            # Count operations needed to transform candidate_start to candidate_end\n            remove_count, add_count = count_operations(candidate_start, candidate_end)\n            operations_needed = abs(remove_count - add_count)\n            total_operations = (total_operations + operations_needed) % MOD\n\n    return total_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        s = data[index].strip()\n        index += 1\n        t = data[index].strip()\n        index += 1\n        \n        result = total_time(n, s, t)\n        results.append(result)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1615_G. Maximum Adjacent Pairs", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_adjacent_pairs(n, a):\n    # Prepare the result array\n    result = a[:]\n    \n    # Count existing numbers and their occurrences\n    used = set()\n    for num in a:\n        if num != 0:\n            used.add(num)\n    \n    next_fill = 1\n    \n    # Iterate through the array to replace 0s\n    for i in range(n):\n        if result[i] == 0:\n            # Try to replace with adjacent numbers if possible\n            if i > 0 and result[i - 1] != 0:\n                result[i] = result[i - 1]\n            elif i < n - 1 and result[i + 1] != 0:\n                result[i] = result[i + 1]\n            else:\n                # Fill with the next available number\n                while next_fill in used:\n                    next_fill += 1\n                result[i] = next_fill\n                used.add(next_fill)\n    \n    return result\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the result\nresult = maximize_adjacent_pairs(n, a)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"task_id": "1615_H. Reindeer Games", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    from collections import defaultdict, deque\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    scores = list(map(int, data[1].split()))\n    \n    # Create adjacency list and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * n\n    \n    for i in range(m):\n        u, v = map(int, data[i + 2].split())\n        graph[u - 1].append(v - 1)\n        in_degree[v - 1] += 1\n        \n    # Perform topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topological_order = []\n    \n    while queue:\n        current = queue.popleft()\n        topological_order.append(current)\n        \n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Assign scores based on topological order\n    result_scores = scores[:]\n    \n    for u in topological_order:\n        for v in graph[u]:\n            if result_scores[u] > result_scores[v]:\n                result_scores[v] = result_scores[u]\n    \n    print(' '.join(map(str, result_scores)))"}
{"task_id": "1617_A. Forbidden Subsequence", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_subsequence(s, t):\n    it = iter(s)\n    return all(char in it for char in t)\n\ndef find_smallest_permutation(S, T):\n    # Step 1: Sort S to get the lexicographically smallest order\n    sorted_s = ''.join(sorted(S))\n    \n    # Step 2: Check if T is a subsequence of the sorted string\n    if not is_subsequence(sorted_s, T):\n        return sorted_s\n    \n    # Step 3: If T is a subsequence, we need to modify sorted_s\n    # We will try to prevent T from being subsequence\n    \n    # Count occurrences of a, b, c in sorted_s\n    a_count = sorted_s.count('a')\n    b_count = sorted_s.count('b')\n    c_count = sorted_s.count('c')\n    \n    # If we can't remove any of a, b or c, we'll need to tweak the ordering\n    # Let's try to just change the last occurrence of 'c' to 'd' or something else\n    # Pick one of the characters (here it's c) and move it\n    # Create the smallest permutation that is not having abc as a subsequence\n    if c_count > 0:\n        # Move the last 'c' to 'd'\n        modified_sorted_s = sorted_s.replace('c', '', 1) + 'd'\n    else:\n        modified_sorted_s = sorted_s  # If there are no 'c's, we don't need to change it\n    \n    return modified_sorted_s\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])  # Read number of test cases\n    results = []\n    \n    for i in range(t):\n        S = data[2 * i + 1]\n        T = data[2 * i + 2]\n        result = find_smallest_permutation(S, T)\n        results.append(result)\n        \n    # Output all results for the test cases\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1617_B. GCD Problem", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_distinct_integers(t, test_cases):\n    results = []\n    for n in test_cases:\n        if n > 10:\n            a = 2\n            b = n - 3\n            c = 1\n            results.append(f\"{a} {b} {c}\")\n        else:\n            results.append(\"Invalid input, n must be >= 10\")\n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\ntest_cases = list(map(int, data[1:t + 1]))\n\n# Getting results\nresults = find_distinct_integers(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1617_C. Paprika and Permutation", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_operations_to_permutation(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        count = [0] * (n + 1)  # count[i] will store the occurrences of number 'i'\n        excess = []  # to keep track of numbers > n\n        \n        # Count occurrences of each number\n        for num in a:\n            if num > n:\n                excess.append(num)\n            elif 1 <= num <= n:\n                count[num] += 1\n        \n        # Count duplicates\n        duplicates = 0\n        for num in range(1, n + 1):\n            if count[num] > 1:\n                duplicates += count[num] - 1  # count excess of this number\n\n        # Total operations needed is the number of duplicates\n        # since we can resolve each duplicate using excess numbers.\n        if duplicates <= len(excess):\n            results.append(duplicates)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Read input from stdin and execute\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    results = min_operations_to_permutation(t, test_cases)\n    for result in results:\n        print(result)"}
{"task_id": "1617_D2. Too Many Impostors (hard version)", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nimport itertools\n\ndef ask(a, b, c):\n    print(f\"? {a} {b} {c}\")\n    sys.stdout.flush()\n    return int(sys.stdin.readline().strip())\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    \n    potential_impostors = list(range(1, n + 1))\n    impostor_count = 0\n    \n    # Step 1: Initial queries to gather information\n    responses = []\n    for i in range(1, n + 1, 3):\n        if i + 2 <= n:\n            response = ask(i, i + 1, i + 2)\n            responses.append((i, i + 1, i + 2, response))\n            if response == 0:  # More impostors than crewmates\n                impostor_count += 1\n            else:  # More crewmates than impostors\n                impostor_count -= 1\n    \n    # Deduce k based on responses\n    k = (n // 3) + max(0, impostor_count)  # This is a rough estimation\n    \n    # Step 2: Identify impostors from responses\n    impostors = set()\n    for a, b, c, response in responses:\n        if response == 0:  # More impostors\n            impostors.add(a)\n            impostors.add(b)\n            impostors.add(c)\n\n    # We need to know exactly which players are impostors\n    impostors = list(impostors)\n    if len(impostors) < k:\n        # We need to query more to find the right impostors\n        # This is a fallback mechanism\n        for comb in itertools.combinations(range(1, n + 1), 3):\n            if len(impostors) >= k:\n                break\n            response = ask(*comb)\n            if response == 0:  # More impostors\n                impostors.extend(comb)\n    \n    # We need `k` impostors, so trim the list if necessary\n    impostors = impostors[:k]\n\n    # Step 3: Output the results\n    print(f\"! {len(impostors)} {' '.join(map(str, impostors))}\")\n    sys.stdout.flush()\n    \ndef main():\n    t = int(sys.stdin.readline().strip())\n    for _ in range(t):\n        solve()\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1617_E. Christmas Chocolates", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef chocolate_exchanges(n, chocolates):\n    from collections import defaultdict\n\n    # This will hold the transformation results\n    transformations = defaultdict(list)\n\n    # Iterate over each chocolate type\n    for i in range(n):\n        chocolate_type = chocolates[i]\n        current_value = chocolate_type\n        steps = 0\n        \n        # We will gather all transformations this chocolate can achieve\n        seen = {}\n        \n        while current_value not in seen:\n            seen[current_value] = steps\n            # Calculate the next transformation\n            power_of_two = 1\n            while power_of_two < current_value:\n                power_of_two *= 2\n            next_value = power_of_two - current_value\n            transformations[current_value].append((next_value, steps + 1))\n            current_value = next_value\n            steps += 1\n\n    max_steps = 0\n    best_pair = (1, 2)  # Default pair (1-based index)\n\n    # Now, check all transformations we gathered\n    for chocolate_type in transformations:\n        for next_value, count in transformations[chocolate_type]:\n            if next_value in transformations:\n                # Check if we can find another chocolate that matches the transformed value\n                for target_type, target_count in transformations[next_value]:\n                    # We found a pair (chocolate_type, next_value)\n                    total_steps = count + target_count\n                    if total_steps > max_steps:\n                        max_steps = total_steps\n                        best_pair = (chocolates.index(chocolate_type) + 1, chocolates.index(next_value) + 1)\n\n    return best_pair[0], best_pair[1], max_steps\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\nchocolates = list(map(int, data[1].split()))\n\n# Get the result\nx, y, m = chocolate_exchanges(n, chocolates)\n\n# Print output\nprint(x, y, m)"}
{"task_id": "1618_A. Polycarp and Sums of Subsequences", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef restore_array(t, test_cases):\n    results = []\n    \n    for b in test_cases:\n        b.sort()\n        a0 = b[0]  # Smallest element in a\n        total_sum = b[6]  # Total sum which is a[0] + a[1] + a[2]\n        \n        # Find the second element (either b[1] or b[2] can be used)\n        a1 = b[1] - a0  # Assuming b[1] = a[0] + a[1]\n        \n        # Calculate the third element\n        a2 = total_sum - a0 - a1\n        \n        results.append((a0, a1, a2))\n    \n    return results\n\n\n# Read inputs and solve the problem\nt = int(input())\ntest_cases = [list(map(int, input().split())) for _ in range(t)]\nresults = restore_array(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result[0], result[1], result[2])"}
{"task_id": "1618_B. Missing Bigram", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef reconstruct_words(t, test_cases):\n    results = []\n    \n    for n, bigrams in test_cases:\n        # Start with the first bigram to form the initial part of the word\n        word = [bigrams[0][0], bigrams[0][1]]\n        \n        # Iterate through the bigrams and construct the word\n        for i in range(1, len(bigrams)):\n            word.append(bigrams[i][1])  # Append the second character of each bigram\n        \n        # Join the list to form the word\n        results.append(''.join(word))\n    \n    return results\n\n# Reading the input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nt = int(data[0])  # number of test cases\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])  # length of the word\n    bigrams = data[index + 1].strip().split()  # list of bigrams\n    test_cases.append((n, bigrams))\n    index += 2\n\n# Get the results\nresults = reconstruct_words(t, test_cases)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "1618_C. Paint the Array", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport math\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    result = []\n    line = 1\n    \n    for _ in range(t):\n        n = int(data[line])  # number of elements in the array\n        a = list(map(int, data[line + 1].split()))  # the array itself\n        \n        found_d = 0\n        \n        for i in range(n - 1):\n            gcd_value = math.gcd(a[i], a[i + 1])\n            if gcd_value > 1:\n                found_d = gcd_value\n                break\n        \n        result.append(found_d)\n        line += 2  # move to the next test case\n    \n    print(\"\\n\".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1618_D. Array and Operations", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef minimum_score(t, test_cases):\n    results = []\n    for n, k, array in test_cases:\n        # Sort the array\n        array.sort()\n        \n        # Score after k operations\n        score = 0\n        \n        # Perform k operations\n        for i in range(k):\n            # Select the smallest and the largest remaining elements\n            smallest = array[i]  # i-th smallest\n            largest = array[n - 1 - i]  # i-th largest from the end\n            score += (smallest // largest)  # This will mostly be 0 if smallest < largest\n        \n        # Remaining elements after k operations\n        remaining_elements = array[k:n - k]\n        score += sum(remaining_elements)\n        \n        # Store the result for this test case\n        results.append(score)\n    \n    return results\n\n# Read input and run the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n, k = map(int, data[index].split())\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, k, array))\n        index += 2\n    \n    results = minimum_score(t, test_cases)\n    for result in results:\n        print(result)"}
{"task_id": "1618_E. Singers' Tour", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef reconstruct_singers(t, test_cases):\n    outputs = []\n    \n    for case in test_cases:\n        n = case[0]\n        b = case[1]\n        a = [0] * n\n        \n        # We will find a[0] based on b[0], and then calculate subsequent a values\n        a[0] = (b[0] - b[1] + n) // n  # A candidate for a[0]\n        \n        # Check if the derived a[0] is valid\n        if a[0] <= 0:\n            outputs.append(\"NO\")\n            continue\n        \n        valid = True\n        \n        for i in range(1, n):\n            # Calculate each a[i] based on previous values of a\n            a[i] = (b[i] - (b[i-1] - (i * a[0]))) // (i + 1)\n            \n            # Check validity\n            if a[i] <= 0:\n                valid = False\n                break\n        \n        if valid:\n            outputs.append(\"YES\")\n            outputs.append(\" \".join(map(str, a)))\n        else:\n            outputs.append(\"NO\")\n    \n    return \"\\n\".join(outputs)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nline_index = 1\n\nfor _ in range(t):\n    n = int(data[line_index])\n    b = list(map(int, data[line_index + 1].split()))\n    test_cases.append((n, b))\n    line_index += 2\n\n# Getting the output\nresult = reconstruct_singers(t, test_cases)\nprint(result)"}
{"task_id": "1618_F. Reverse", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_transform(x, y):\n    # Count the number of 1s in the binary representation of x and y\n    count_x = bin(x).count('1')\n    count_y = bin(y).count('1')\n    \n    # If both counts are equal, transformation is possible\n    if count_x == count_y:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nx, y = map(int, input().split())\n# Output the result\nprint(can_transform(x, y))"}
{"task_id": "1618_G. Trader Problem", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_total_cost(n, m, q, a, b, queries):\n    import sys\n    from bisect import bisect_right\n    \n    # Calculate the initial total cost of Monocarp's items\n    total_initial = sum(a)\n\n    # Sort the lists of item prices\n    a.sort()\n    b.sort()\n\n    # For each query, calculate the maximum possible total cost\n    results = []\n    for k in queries:\n        total_gain = 0\n        \n        # For each item Monocarp has, find the best item he can trade for\n        for price in a:\n            max_trade_price = price + k\n            # Find the position of the largest valid item in b\n            pos = bisect_right(b, max_trade_price) - 1\n            if pos >= 0:\n                total_gain += b[pos]  # Add the item's price from b that he can trade for\n\n        # The final total cost after trades\n        results.append(total_initial + total_gain)\n\n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nq = int(data[2])\na = list(map(int, data[3:3+n]))\nb = list(map(int, data[3+n:3+n+m]))\nqueries = list(map(int, data[3+n+m:3+n+m+q]))\n\n# Get the results\nresults = maximize_total_cost(n, m, q, a, b, queries)\n\n# Print the results\nsys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")"}
{"task_id": "1619_A. Square String?", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_square_string(s):\n    length = len(s)\n    if length % 2 == 1:\n        return \"NO\"\n    mid = length // 2\n    if s[:mid] == s[mid:]:\n        return \"YES\"\n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # The number of test cases\n    results = []\n    \n    for i in range(1, t + 1):\n        result = is_square_string(data[i])\n        results.append(result)\n    \n    # Print all results\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_B. Squares and Cubes", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nimport math\n\ndef count_polycarps_likes(n):\n    count_squares = int(math.isqrt(n))\n    count_cubes = int(n ** (1/3))\n    count_sixth_powers = int(n ** (1/6))\n    return count_squares + count_cubes - count_sixth_powers\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n = int(data[i])\n        liked_count = count_polycarps_likes(n)\n        results.append(liked_count)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_C. Wrong Addition", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_number_b(t, cases):\n    results = []\n    for a, s in cases:\n        a_str = str(a)\n        s_str = str(s)\n        \n        len_a = len(a_str)\n        len_s = len(s_str)\n\n        # Padding a with leading zeros if necessary\n        if len_a < len_s:\n            a_str = '0' * (len_s - len_a) + a_str\n\n        b_str = []\n        valid = True\n\n        # Process from the last digit to the first\n        for i in range(len(s_str) - 1, -1, -1):\n            digit_a = int(a_str[i])\n            digit_s = int(s_str[i])\n            if digit_s < digit_a:\n                valid = False\n                break\n            digit_b = digit_s - digit_a\n            b_str.append(str(digit_b))\n        \n        if not valid:\n            results.append(\"-1\")\n            continue\n        \n        # Reverse b_str to form the number and remove leading zeros\n        b_str.reverse()\n        b_num = ''.join(b_str).lstrip('0')\n        \n        if b_num == '':\n            b_num = '0'  # If all digits were zero, we output 0, but since b must be positive, this is invalid.\n        \n        # Check if b_num is valid, it must be a positive integer\n        if b_num == '0':\n            results.append(\"-1\")\n        else:\n            results.append(b_num)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nt = int(data[0])\ncases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n\nresults = find_number_b(t, cases)\nprint(\"\\n\".join(results))"}
{"task_id": "1619_D. New Year's Problem", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_assign_gifts(p, n, m, alpha):\n    from collections import defaultdict, deque\n\n    adj = defaultdict(list)\n    \n    # Construct bipartite graph\n    for j in range(n):\n        for i in range(m):\n            if p[i][j] >= alpha:\n                adj[j].append(i)\n\n    # Try to find a maximum matching\n    match = [-1] * m\n    visited = [False] * n\n\n    def bpm(j):\n        for i in adj[j]:\n            if not visited[i]:\n                visited[i] = True\n                if match[i] == -1 or bpm(match[i]):\n                    match[i] = j\n                    return True\n        return False\n\n    matched_count = 0\n    for j in range(n):\n        visited = [False] * m\n        if bpm(j):\n            matched_count += 1\n\n    return matched_count == n\n\ndef maximum_minimum_joy(t, cases):\n    results = []\n    \n    for case in cases:\n        m, n, p = case\n        lo, hi = 1, max(max(row) for row in p)\n        \n        while lo < hi:\n            mid = (lo + hi + 1) // 2  # Try the upper half\n            \n            if can_assign_gifts(p, n, m, mid):\n                lo = mid  # If feasible, try for a larger \n            else:\n                hi = mid - 1  # If not feasible, reduce \n        \n        results.append(lo)\n\n    return results\n\n# Read input and solve the problem\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1  # Move to the first test case\n    cases = []\n    \n    for _ in range(t):\n        index += 1  # Skip empty line\n        m, n = map(int, data[index].strip().split())\n        index += 1\n        p = []\n        for _ in range(m):\n            p.append(list(map(int, data[index].strip().split())))\n            index += 1\n        \n        cases.append((m, n, p))\n    \n    results = maximum_minimum_joy(t, cases)\n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_E. MEX and Increments", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef mex_operations(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        a = case[1]\n        \n        # Step 1: Count occurrences of each number\n        freq = [0] * (n + 1)\n        for num in a:\n            if num <= n:\n                freq[num] += 1\n        \n        # Step 2: Calculate minimum operations for each possible MEX\n        operations = [-1] * (n + 1)\n        missing_count = 0  # Count of missing numbers (0 to i-1)\n        current_operations = 0\n        \n        for i in range(n + 1):\n            if i > 0:\n                # If i-1 is not present, we need to add it\n                if freq[i - 1] == 0:\n                    missing_count += 1\n            \n            # We can achieve MEX = i if we have fixed all missing numbers\n            if missing_count == 0:\n                operations[i] = current_operations\n            else:\n                operations[i] = current_operations + missing_count\n            \n            # If i is present, we don't need further operations to fix it\n            if i < n and freq[i] > 0:\n                current_operations += freq[i]\n        \n        results.append(operations)\n    \n    return results"}
{"task_id": "1619_F. Let's Play the Hat?", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef fair_game_schedule(t, test_cases):\n    results = []\n    \n    for n, m, k in test_cases:\n        low = n // m\n        high = (n + m - 1) // m\n        \n        # Calculate the number of high tables\n        num_high = n % m  # Number of tables with `high` players\n        num_low = m - num_high  # Number of tables with `low` players\n        \n        # Prepare the results for this case\n        schedule = []\n        \n        for game in range(k):\n            game_tables = []\n            # Assign tables with high players\n            for table in range(num_high):\n                players = []\n                for i in range(high):\n                    players.append((table * high + i + game * m) % n + 1)\n                game_tables.append(f\"{high} \" + \" \".join(map(str, players)))\n            \n            # Assign tables with low players\n            for table in range(num_low):\n                players = []\n                for i in range(low):\n                    players.append((num_high * high + table * low + i + game * m) % n + 1)\n                game_tables.append(f\"{low} \" + \" \".join(map(str, players)))\n                \n            schedule.append(\"\\n\".join(game_tables))\n        \n        results.append(\"\\n\\n\".join(schedule))\n    \n    print(\"\\n\\n\".join(results))\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nt = int(data[0])\ntest_cases = []\nfor i in range(1, t + 1):\n    n, m, k = map(int, data[i].split())\n    test_cases.append((n, m, k))\n\nfair_game_schedule(t, test_cases)"}
{"task_id": "1619_G. Unusual Minesweeper", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\nimport sys\nimport heapq\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().strip().split(\"\\n\")\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(t):\n        if data[idx] == \"\":\n            idx += 1  # Skip empty line\n        \n        n, k = map(int, data[idx].split())\n        idx += 1\n        \n        mines = {}\n        \n        for __ in range(n):\n            x, y, timer = map(int, data[idx].split())\n            mines[(x, y)] = timer\n            idx += 1\n            \n        # Priority queue to handle explosions\n        pq = []\n        \n        # Fill the priority queue with the mines\n        for (x, y), timer in mines.items():\n            heapq.heappush(pq, (timer, x, y))\n        \n        # To keep track of explosion times\n        explosion_time = {}\n        max_time = 0\n        \n        while pq:\n            timer, x, y = heapq.heappop(pq)\n            \n            if (x, y) in explosion_time:\n                continue\n            \n            # Record the explosion time for this mine\n            explosion_time[(x, y)] = timer\n            max_time = max(max_time, timer)\n            \n            # Trigger explosions in the k-distance\n            for dx in range(-k, k + 1):\n                if abs(dx) == k:\n                    if (x + dx, y) in mines and (x + dx, y) not in explosion_time:\n                        heapq.heappush(pq, (mines[(x + dx, y)], x + dx, y))\n\n            for dy in range(-k, k + 1):\n                if abs(dy) == k:\n                    if (x, y + dy) in mines and (x, y + dy) not in explosion_time:\n                        heapq.heappush(pq, (mines[(x, y + dy)], x, y + dy))\n\n        results.append(max_time)\n    \n    # Output results\n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")"}
{"task_id": "1619_H. Permutation and Queries", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Prepare the jump table\n    log = 20  # log2(100000) is roughly 16.6, so we can use 20\n    jump = [[0] * n for _ in range(log)]\n    \n    for i in range(n):\n        jump[0][i] = p[i] - 1  # Store zero-indexed\n    \n    for j in range(1, log):\n        for i in range(n):\n            jump[j][i] = jump[j-1][jump[j-1][i]]\n    \n    output = []\n    \n    def get_position(i, k):\n        for j in range(log):\n            if k & (1 << j):\n                i = jump[j][i]\n        return i\n    \n    while index < len(data):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1  # Convert to zero-indexed\n            y = int(data[index + 2]) - 1  # Convert to zero-indexed\n            p[x], p[y] = p[y], p[x]  # Swap\n            # Update the jump table after the swap\n            jump[0][x], jump[0][y] = p[x] - 1, p[y] - 1\n            for j in range(1, log):\n                jump[j][x] = jump[j-1][jump[j-1][x]]\n                jump[j][y] = jump[j-1][jump[j-1][y]]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1  # Convert to zero-indexed\n            k = int(data[index + 2])\n            answer = get_position(i, k) + 1  # Convert back to one-indexed for output\n            output.append(answer)\n            index += 3\n    \n    print(\"\\n\".join(map(str, output)))"}
{"task_id": "1620_A. Equal or Not Equal", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef is_consistent(s):\n    if all(c == 'E' for c in s):\n        return \"YES\"\n    elif 'E' in s and 'N' in s:\n        if s[0] == 'E' and s[-1] == 'N':\n            return \"NO\"\n        elif s[0] == 'N' and s[-1] == 'E':\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        results.append(is_consistent(data[i]))\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1620_B. Triangles on a Rectangle", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\n```python\ndef max_doubled_area(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        w, h, bottom_points, top_points, left_points, right_points = case\n        \n        # For horizontal sides\n        bottom_xs = bottom_points\n        top_xs = top_points\n        \n        # For vertical sides\n        left_ys = left_points\n        right_ys = right_points\n        \n        # Compute max doubled area for the bottom side\n        max_area = 0\n        \n        # Case 1: Two from bottom, one from top\n        if len(bottom_xs) >= 2 and len(top_xs) >= 1:\n            max_x_bottom = bottom_xs[-1]\n            min_x_bottom = bottom_xs[0]\n            for y_top in top_xs:\n                area = abs(max_x_bottom * (0 - y_top) + min_x_bottom * (y_top - 0))  # y coordinate is h for top points\n                max_area = max(max_area, area)\n\n        # Case 2: Two from top, one from bottom\n        if len(top_xs) >= 2 and len(bottom_xs) >= 1:\n            max_x_top = top_xs[-1]\n            min_x_top = top_xs[0]\n            for y_bottom in bottom_xs:\n                area = abs(max_x_top * (y_bottom - h) + min_x_top * (h - y_bottom))\n                max_area = max(max_area, area)\n\n        # Case 3: Two from left, one from right\n        if len(left_ys) >= 2 and len(right_ys) >= 1:\n            max_y_left = left_ys[-1]\n            min_y_left = left_ys[0]\n            for x_right in right_ys:\n                area = abs(0 * (max_y_left - x_right) + x_right * (min_y_left - 0))  # x coordinate is w for right points\n                max_area = max(max_area, area)\n\n        # Case 4: Two from right, one from left\n        if len(right_ys) >= 2 and len(left_ys) >= 1:\n            max_y_right = right_ys[-1]\n            min_y_right = right_ys[0]\n            for x_left in left_ys:\n                area = abs(w * (min_y_right - x_left) + x_left * (0 - max_y_right))\n                max_area = max(max_area, area)\n\n        results.append(max_area)\n    \n    return results\n\n# Read input and prepare data\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    index"}
{"task_id": "1620_C. BA-String", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef find_lexicographical_ba_string(n, k, x, s):\n    result = []\n    current_b_count = 0  # to count the number of 'b's we add\n    star_count = 0  # to keep track of stars encountered\n\n    # Iterate through the string\n    for char in s:\n        if char == 'a':\n            # If we have collected b's, append them\n            if current_b_count > 0:\n                result.append('b' * current_b_count)  # append 'b's to the result\n                current_b_count = 0  # reset for next segment of '*'\n            result.append('a')  # add 'a' to the result\n\n        elif char == '*':\n            star_count += 1  # count number of '*'s encountered\n\n            # Determine how many 'b's to use based on x\n            if x == 0:\n                current_b_count += 0  # use 0 b's for this '*'\n            else:\n                # Calculate the maximum possible combinations with this star\n                max_combinations = sum(k if j < star_count else 0 for j in range(star_count))\n                if max_combinations >= x:\n                    # If we can still generate valid combinations we need to determine how many 'b's to add\n                    for b_to_add in range(k + 1):\n                        if star_count > 1:  \n                            # If there are more than one star, we can add any number of b's up to k\n                            current_b_count += b_to_add\n                            x -= 1  # Reduce x for each combination\n                            if x <= 0:\n                                break\n                        else:\n                            # If it is the last star, just use the remaining x\n                            current_b_count += b_to_add\n                            break\n\n    # Append any leftover 'b's after the last character\n    if star_count > 0:\n        result.append('b' * current_b_count)\n\n    return ''.join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        n, k, x = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        result_string = find_lexicographical_ba_string(n, k, x, s)\n        results.append(result_string)\n    \n    print(\"\\n\".join(results))\n\n# The function main will be called automatically by the environment to read input and produce output."}
{"task_id": "1620_D. Exact Change", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_coins(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i][0]\n        costs = test_cases[i][1]\n        max_coins_needed = 0\n        \n        for cost in costs:\n            k3 = cost // 3\n            rem = cost % 3\n            \n            if rem == 0:\n                coins_needed = k3\n            else:\n                coins_needed = k3 + 1  # Once we have remainder, we need one more coin\n            \n            max_coins_needed = max(max_coins_needed, coins_needed)\n        \n        results.append(max_coins_needed)\n    \n    return results\n\n# Reading inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])  # number of test cases\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    costs = list(map(int, data[index + 1].split()))\n    test_cases.append((n, costs))\n    index += 2\n\n# Get results and print them\nresults = min_coins(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1620_E. Replace the Numbers", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef process_queries(q, queries):\n    arr = []\n    value_map = {}\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            # Add element x to the end of the array\n            x = int(parts[1])\n            arr.append(x)\n        elif parts[0] == '2':\n            # Replace all occurrences of x with y\n            x = int(parts[1])\n            y = int(parts[2])\n            # We need to find the actual value of x if it has been replaced\n            if x in value_map:\n                orig_x = value_map[x]\n            else:\n                orig_x = x\n            \n            # Update value_map to replace orig_x with y\n            value_map[orig_x] = y\n            \n    # Final pass to adjust the array values based on the replacements\n    for i in range(len(arr)):\n        current_value = arr[i]\n        # Find the latest value for current_value\n        while current_value in value_map:\n            current_value = value_map[current_value]\n        arr[i] = current_value\n    \n    return arr\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nq = int(data[0])\nqueries = data[1:q + 1]\n\n# Process queries\nresulting_array = process_queries(q, queries)\n\n# Print result\nprint(\" \".join(map(str, resulting_array)))"}
{"task_id": "1620_F. Bipartite Array", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef bipartite_array(t, test_cases):\n    results = []\n    \n    for n, p in test_cases:\n        a = []\n        \n        for i in range(n):\n            if i % 2 == 0:\n                a.append(p[i])     # Use positive value for even indices\n            else:\n                a.append(-p[i])    # Use negative value for odd indices\n        \n        # Collecting the result for the current test case\n        results.append(\"YES\")\n        results.append(\" \".join(map(str, a)))\n    \n    return \"\\n\".join(results)\n\n# Reading inputs\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        p = list(map(int, data[index + 1].split()))\n        test_cases.append((n, p))\n        index += 2\n    \n    # Get results\n    result = bipartite_array(t, test_cases)\n    \n    # Print results\n    print(result)\n\n# Uncomment the line below to run the main function.\n# main()"}
{"task_id": "1620_G. Subsequences Galore", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef count_unique_subsequences(s):\n    # This function counts the unique subsequences of a given sorted string `s`.\n    dp = [0] * (len(s) + 1)\n    dp[0] = 1  # Empty subsequence is counted\n\n    last = {}\n    for i in range(1, len(s) + 1):\n        dp[i] = 2 * dp[i - 1]  # Each existing subsequence can either include or exclude the current character\n        char = s[i - 1]\n        if char in last:\n            dp[i] -= dp[last[char] - 1]  # Subtract subsequences that were counted twice\n        last[char] = i\n\n    return dp[len(s)] - 1  # Exclude the empty subsequence\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    strings = data[1:n + 1]\n    \n    MOD = 998244353\n    total_subsequences = 1 << n  # This is 2^n\n    result = 0\n    \n    for mask in range(total_subsequences):\n        combined_subsequences = set()\n        sum_indices = 0\n        count_strings = 0\n        \n        for i in range(n):\n            if (mask & (1 << i)):\n                # If the i-th string is included in the subsequence\n                sum_indices += (i + 1)  # 1-indexed\n                count_strings += 1\n                combined_subsequences.add(strings[i])\n        \n        if count_strings > 0:\n            # We need to calculate f for the combined subsequence\n            unique_count = 0\n            for s in combined_subsequences:\n                unique_count += count_unique_subsequences(s)\n                unique_count %= MOD\n            \n            # Calculate the contribution for this mask\n            contribution = (unique_count * count_strings * sum_indices) % MOD\n            result ^= contribution\n    \n    print(result)"}
{"task_id": "1622_A. Construct a Rectangle", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_form_rectangle(t, cases):\n    results = []\n    for l1, l2, l3 in cases:\n        # Check breaking first stick l1\n        if (l2 == l3) or (l1 - 1 == l2) or (l1 - 1 == l3):\n            results.append(\"YES\")\n            continue\n        \n        # Check breaking second stick l2\n        if (l1 == l3) or (l2 - 1 == l1) or (l2 - 1 == l3):\n            results.append(\"YES\")\n            continue\n        \n        # Check breaking third stick l3\n        if (l1 == l2) or (l3 - 1 == l1) or (l3 - 1 == l2):\n            results.append(\"YES\")\n            continue\n        \n        results.append(\"NO\")\n    \n    return results\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ncases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n\n# Get results and print\nresults = can_form_rectangle(t, cases)\nprint(\"\\n\".join(results))"}
{"task_id": "1622_B. Berland Music", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef process_test_case(n, p, s):\n    liked_indices = []\n    disliked_indices = []\n    \n    # Collect indices of liked and disliked songs\n    for index in range(n):\n        if s[index] == '1':\n            liked_indices.append(index)\n        else:\n            disliked_indices.append(index)\n    \n    # Sort the original ratings based on the indices\n    liked_ratings = sorted([p[i] for i in liked_indices])\n    disliked_ratings = sorted([p[i] for i in disliked_indices])\n    \n    # Generate new ratings\n    q = [0] * n\n    available_ratings = list(range(1, n + 1))\n    \n    # Assign ratings for disliked songs (smallest ratings)\n    for i in range(len(disliked_indices)):\n        q[disliked_indices[i]] = available_ratings[i]\n    \n    # Assign ratings for liked songs (largest ratings)\n    for i in range(len(liked_indices)):\n        q[liked_indices[i]] = available_ratings[len(disliked_indices) + i]\n    \n    return q\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])  # number of songs\n        p = list(map(int, data[index + 1].split()))  # predicted ratings\n        s = data[index + 2]  # like/dislike string\n        index += 3\n        \n        # Process each test case\n        result = process_test_case(n, p, s)\n        results.append(\" \".join(map(str, result)))\n    \n    # Print all results for each test case\n    print(\"\\n\".join(results))"}
{"task_id": "1622_C. Set or Decrease", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef min_steps_to_reduce_sum(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, k, a = case\n        current_sum = sum(a)\n        \n        if current_sum <= k:\n            results.append(0)\n        else:\n            excess = current_sum - k\n            results.append(excess)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n, k = map(int, data[index].split())\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, k, a))\n    index += 2\n\n# Get results\nresults = min_steps_to_reduce_sum(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "1622_D. Shuffle", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef factorial_mod(n, mod):\n    if n == 0 or n == 1:\n        return 1\n    f = 1\n    for i in range(2, n + 1):\n        f = (f * i) % mod\n    return f\n\ndef count_distinct_arrangements(s, k, mod):\n    total_ones = s.count('1')\n    \n    if k == 0:\n        return 1\n    if k > total_ones:\n        return 1\n    \n    n = len(s)\n    arrangements_set = set()\n    \n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j + 1]\n            ones_count = substring.count('1')\n            zeros_count = substring.count('0')\n            if ones_count == k:\n                # Number of arrangements of this substring with k '1's and (len(substring) - k) '0's\n                total_length = ones_count + zeros_count\n                arrangements = (factorial_mod(total_length, mod) * pow(factorial_mod(ones_count, mod), mod - 2, mod) * pow(factorial_mod(zeros_count, mod), mod - 2, mod)) % mod\n                arrangements_set.add(arrangements)\n    \n    # Add the original string to the set\n    arrangements_set.add(1)  # The original string without any operation\n    return sum(arrangements_set) % mod\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn, k = map(int, data[0].split())\ns = data[1]\n\n# Get the result\nresult = count_distinct_arrangements(s, k, 998244353)\n\n# Output the result\nprint(result)"}
{"task_id": "1622_E. Math Test", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef maximize_surprise_value(t, cases):\n    results = []\n    for case in cases:\n        n, m, x, responses = case\n        \n        # Create the score assignment array\n        p = list(range(1, m + 1))\n\n        # Create a list to store the number of correct answers for each question\n        correct_count = [0] * m\n        \n        # Count how many students answered each question correctly\n        for response in responses:\n            for j in range(m):\n                if response[j] == '1':\n                    correct_count[j] += 1\n        \n        # Sort the indices of questions based on the number of students that got them correct\n        indices = sorted(range(m), key=lambda j: correct_count[j])\n\n        # Assign scores based on the sorted order (maximize surprise)\n        permuted_p = [0] * m\n        for i in range(m):\n            permuted_p[indices[i]] = p[m - 1 - i]  # Assign the highest points to the least correct questions\n        \n        results.append(permuted_p)\n    \n    return results\n\n# Reading input format\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    cases = []\n    index = 1\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        x = list(map(int, data[index + 1].split()))\n        responses = data[index + 2 : index + 2 + n]\n        cases.append((n, m, x, responses))\n        index += 2 + n\n    \n    results = maximize_surprise_value(t, cases)\n    for result in results:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1622_F. Quadratic Set", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef largest_quadratic_subset(n):\n    # Initialize the list to track the subset\n    subset = []\n    \n    # Parity based exclusion strategy\n    for i in range(1, n + 1):\n        if i == 3 and n >= 3:  # Exclude 3 if present\n            continue\n        subset.append(i)\n    \n    # Output the results\n    print(len(subset))\n    print(\" \".join(map(str, subset)))\n\n# Reading input\nimport sys\ninput = sys.stdin.read\nn = int(input().strip())\nlargest_quadratic_subset(n)"}
{"task_id": "1623_A. Robot Cleaner", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef robot_cleaner(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, m, r_b, c_b, r_d, c_d = test_cases[i]\n        \n        time = 0\n        dr = 1\n        dc = 1\n        \n        # Simulate the robot's movement\n        while True:\n            # Check if the robot cleans the dirty cell\n            if r_b == r_d or c_b == c_d:\n                results.append(time)\n                break\n            \n            # Move the robot\n            r_b += dr\n            c_b += dc\n            time += 1\n            \n            # Reflect on walls\n            if r_b < 1 or r_b > n:  # Hitting the horizontal walls\n                dr *= -1\n                r_b += dr  # Adjust position back within bounds\n            \n            if c_b < 1 or c_b > m:  # Hitting the vertical walls\n                dc *= -1\n                c_b += dc  # Adjust position back within bounds\n    \n    return results\n\n# Reading inputs using the provided format and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = [list(map(int, line.split())) for line in data[1:t+1]]\nresults = robot_cleaner(t, test_cases)\n\nfor result in results:\n    print(result)"}
{"task_id": "1623_B. Game on Ranges", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        ranges = []\n        for __ in range(n):\n            l, r = map(int, data[index].split())\n            ranges.append((l, r))\n            index += 1\n        \n        picked = [False] * (n + 1)\n        \n        for l, r in ranges:\n            for d in range(l, r + 1):\n                if not picked[d]:\n                    picked[d] = True\n                    results.append(f\"{l} {r} {d}\")\n                    break\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1623_C. Balanced Stone Heaps", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef can_achieve_minimum(heaps, n, mid):\n    # We will start from the last heap and move towards the first two heaps\n    for i in range(n - 1, 2, -1):\n        if heaps[i] < mid:\n            continue\n        \n        # Calculate the amount of stones we can take from the i-th heap\n        excess = heaps[i] - mid\n        \n        # We can take `excess // 3` as d, which is the maximum we can take from this heap\n        d = excess // 3\n        \n        # Move d stones to heap (i-1) and 2*d to heap (i-2)\n        heaps[i - 1] += d\n        heaps[i - 2] += 2 * d\n    \n    # After processing all heaps, check if the first two heaps are at least mid\n    return heaps[0] >= mid and heaps[1] >= mid\n\ndef maximum_smallest_heap(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, heaps = case\n        left, right = 0, max(heaps)\n        \n        while left < right:\n            mid = (left + right + 1) // 2  # Try for the upper mid\n            if can_achieve_minimum(heaps[:], n, mid):\n                left = mid  # We can achieve mid, try for a larger minimum\n            else:\n                right = mid - 1  # Not achievable, reduce the search range\n        \n        results.append(left)\n    \n    return results\n\n# Reading input and preparing the function call\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        heaps = list(map(int, data[index + 1].split()))\n        test_cases.append((n, heaps))\n        index += 2\n    \n    results = maximum_smallest_heap(t, test_cases)\n    \n    # Output results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1623_D. Robot Cleaner Revisit", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef modular_inverse(a, mod):\n    # Fermat's Little Theorem: a^(mod-2) is the modular inverse of a under mod\n    return pow(a, mod - 2, mod)\n\ndef expected_time(t, test_cases):\n    MOD = 10**9 + 7\n    results = []\n    \n    for case in test_cases:\n        n, m, r_b, c_b, r_d, c_d, p = case\n        # Calculate expected time\n        x = 100 + p\n        y = p\n        y_inv = modular_inverse(y, MOD)\n        result = (x * y_inv) % MOD\n        results.append(result)\n    \n    return results\n\n# Read input and run the expected_time function\nimport sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().splitlines()\n    t = int(data[0])\n    test_cases = []\n    \n    for i in range(1, t + 1):\n        test_cases.append(list(map(int, data[i].split())))\n    \n    results = expected_time(t, test_cases)\n    for res in results:\n        print(res)"}
{"task_id": "1623_E. Middle Duplication", "solution": "from string import *\nfrom re import *\nfrom datetime import *\nfrom collections import *\nfrom heapq import *\nfrom bisect import *\nfrom copy import *\nfrom math import *\nfrom random import *\nfrom statistics import *\nfrom itertools import *\nfrom functools import *\nfrom operator import *\nfrom io import *\nfrom sys import *\nfrom json import *\nfrom builtins import *\nfrom typing import *\nimport string\nimport re\nimport datetime\nimport collections\nimport heapq\nimport bisect\nimport copy\nimport math\nimport random\nimport statistics\nimport itertools\nimport functools\nimport operator\nimport io\nimport sys\nimport json\nsys.setrecursionlimit(50000)\ndef smallest_string_after_duplicates(n, k, labels, edges):\n    from sys import setrecursionlimit\n    from collections import defaultdict\n\n    setrecursionlimit(300000)\n\n    # Build the tree\n    tree = defaultdict(lambda: (0, 0))\n    for i, (l, r) in enumerate(edges):\n        tree[i + 1] = (l, r)\n\n    # Result variable\n    result = []\n    duplicates_used = 0\n\n    def in_order(u, can_duplicate):\n        nonlocal duplicates_used\n        if u == 0:\n            return\n        \n        l, r = tree[u]\n        \n        # Traverse the left child\n        in_order(l, can_duplicate)\n        \n        # Decide whether to duplicate\n        if can_duplicate and duplicates_used < k:\n            # Compare original with duplicated\n            duplicated_label = labels[u - 1] * 2\n            if duplicated_label < labels[u - 1]:\n                result.append(duplicated_label)\n                duplicates_used += 1\n                next_can_duplicate = True\n            else:\n                result.append(labels[u - 1])\n                next_can_duplicate = False\n        else:\n            result.append(labels[u - 1])\n            next_can_duplicate = False\n        \n        # Traverse the right child\n        in_order(r, next_can_duplicate)\n\n    # Starting the in-order traversal from the root (node 1)\n    in_order(1, True)\n\n    return ''.join(result)\n\n# Read input and call the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    n, k = map(int, data[0].split())\n    labels = data[1]\n    \n    edges = []\n    for i in range(2, 2 + n):\n        l, r = map(int, data[i].split())\n        edges.append((l, r))\n    \n    # Get the result\n    result = smallest_string_after_duplicates(n, k, labels, edges)\n    print(result)"}
