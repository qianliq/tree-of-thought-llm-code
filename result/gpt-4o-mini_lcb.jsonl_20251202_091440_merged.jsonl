{"task_id": "1873_A", "solution": "def can_form_abc(arrangements):\n    results = []\n    target = \"abc\"\n    \n    for arrangement in arrangements:\n        if arrangement == target:\n            results.append(\"YES\")\n            continue\n        \n        mismatches = [i for i in range(3) if arrangement[i] != target[i]]\n        \n        if len(mismatches) == 2:\n            # Check if swapping the two would result in \"abc\"\n            if arrangement[mismatches[0]] == target[mismatches[1]] and arrangement[mismatches[1]] == target[mismatches[0]]:\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\narrangements = data[1:t + 1]\nresults = can_form_abc(arrangements)\n\n# Output each result in a new line\nfor result in results:\n    print(result)"}
{"task_id": "1873_B", "solution": "def max_product_with_one_increment(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, digits = case\n        max_product = 0\n        \n        for i in range(n):\n            # Copy the digits and increment the current digit by 1\n            modified_digits = digits.copy()\n            modified_digits[i] += 1\n            \n            # Calculate the product of the modified digits\n            product = 1\n            for digit in modified_digits:\n                product *= digit\n            \n            # Update the maximum product found\n            max_product = max(max_product, product)\n        \n        results.append(max_product)\n    \n    return results\n\n# Read input and execute the function\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    digits = list(map(int, data[index + 1].split()))\n    test_cases.append((n, digits))\n    index += 2\n\nresults = max_product_with_one_increment(test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1873_D", "solution": "def min_operations_to_white(test_cases):\n    results = []\n    for n, k, s in test_cases:\n        operations = 0\n        i = 0\n        while i < n:\n            if s[i] == 'B':\n                operations += 1\n                # Perform the operation by skipping the next k cells.\n                i += k\n            else:\n                # Just move to the next cell if it's already white.\n                i += 1\n        results.append(operations)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, k = map(int, data[index].split())\n        s = data[index + 1].strip()\n        test_cases.append((n, k, s))\n        index += 2\n        \n    results = min_operations_to_white(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1883_B", "solution": "def can_form_palindrome_after_removals(test_cases):\n    results = []\n    for n, k, s in test_cases:\n        from collections import Counter\n        \n        # Count frequencies of each character\n        freq = Counter(s)\n        \n        # Count how many characters have an odd frequency\n        odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n        \n        # Calculate the remaining length after removing k characters\n        remaining_count = n - k\n        \n        # Determine how many odd frequencies are allowed\n        max_odds_allowed = 1 if remaining_count % 2 != 0 else 0\n        \n        # Check if we can form a palindrome after the removals\n        if odd_count <= max_odds_allowed:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Reading the input and outputting the results\nimport sys\ninput = sys.stdin.read\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n, k = map(int, data[index].split())\n        s = data[index + 1]\n        test_cases.append((n, k, s))\n        index += 2\n    \n    results = can_form_palindrome_after_removals(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1883_C", "solution": "def min_operations_to_make_product_divisible(t, test_cases):\n    results = []\n    \n    for n, k, a in test_cases:\n        # Count occurrences of each number in array 'a'\n        count = [0] * 11  # Count for numbers 1 to 10\n        for num in a:\n            count[num] += 1\n        \n        # Determine the required factors based on k\n        required = {}\n        if k == 2:\n            required[2] = 1\n        elif k == 3:\n            required[3] = 1\n        elif k == 4:\n            required[2] = 2  # 4 = 2^2\n        elif k == 5:\n            required[5] = 1\n        \n        # Count the available factors\n        available = {2: 0, 3: 0, 5: 0}\n        \n        for num in range(1, 11):\n            if num % 2 == 0:\n                available[2] += count[num] * (num // 2)\n            if num % 3 == 0:\n                available[3] += count[num] * (num // 3)\n            if num % 5 == 0:\n                available[5] += count[num] * (num // 5)\n\n        # Calculate how many more factors are needed\n        operations = 0\n        for prime, req in required.items():\n            if available[prime] < req:\n                operations += req - available[prime]\n        \n        results.append(operations)\n    \n    return results\n\n# Reading input and output\nimport sys\n\ndef main():\n    input_data = sys.stdin.read().strip().split('\\n')\n    t = int(input_data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n, k = map(int, input_data[index].split())\n        a = list(map(int, input_data[index + 1].split()))\n        test_cases.append((n, k, a))\n        index += 2\n    \n    results = min_operations_to_make_product_divisible(t, test_cases)\n    \n    # Printing results\n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1899_A", "solution": "def determine_winner(t, cases):\n    results = []\n    for n in cases:\n        if n % 3 == 0:\n            results.append(\"First\")\n        elif n % 3 == 1:\n            results.append(\"First\")\n        else:  # n % 3 == 2\n            results.append(\"Second\")\n    return results\n\n# Read input\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    cases = list(map(int, data[1:t+1]))\n    \n    winners = determine_winner(t, cases)\n    \n    for winner in winners:\n        print(winner)"}
{"task_id": "1899_B", "solution": "def max_difference(t, cases):\n    results = []\n    \n    for case in cases:\n        n, weights = case\n        # Step 1: Calculate prefix sums\n        prefix_sums = [0] * (n + 1)\n        for i in range(n):\n            prefix_sums[i + 1] = prefix_sums[i] + weights[i]\n        \n        max_diff = 0\n        \n        # Step 2: Find all divisors of n\n        for k in range(1, n + 1):\n            if n % k == 0:\n                # We can form n / k trucks\n                truck_weights = []\n                for j in range(0, n, k):\n                    truck_weights.append(prefix_sums[j + k] - prefix_sums[j])\n                \n                # Step 3: Calculate max and min weights\n                max_weight = max(truck_weights)\n                min_weight = min(truck_weights)\n                max_diff = max(max_diff, max_weight - min_weight)\n        \n        results.append(max_diff)\n    \n    return results\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    cases = []\n    idx = 1\n    for _ in range(t):\n        n = int(data[idx])\n        weights = list(map(int, data[idx + 1].split()))\n        cases.append((n, weights))\n        idx += 2\n    \n    results = max_difference(t, cases)\n    for result in results:\n        print(result)"}
{"task_id": "1899_C", "solution": "def max_alternating_sum(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n = test_cases[i][0]  # length of the array\n        a = test_cases[i][1]  # the array itself\n        \n        if n == 1:\n            results.append(a[0])\n            continue\n        \n        max_sum = float('-inf')\n        current_sum = a[0]\n        \n        for j in range(1, n):\n            if (a[j] % 2) != (a[j-1] % 2):\n                current_sum += a[j]\n            else:\n                max_sum = max(max_sum, current_sum)\n                current_sum = a[j]  # Start a new current sum from this element\n        \n        max_sum = max(max_sum, current_sum)  # Final check for the last subarray\n        results.append(max_sum)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Getting results\nresults = max_alternating_sum(t, test_cases)\n\n# Printing output\nfor result in results:\n    print(result)"}
{"task_id": "1899_D", "solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.read\n\ndef count_pairs(test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        freq = defaultdict(int)\n\n        # Count frequencies of each note a_i\n        for value in a:\n            freq[value] += 1\n\n        # Calculate the number of pairs\n        count = 0\n        for f in freq.values():\n            if f > 1:\n                count += f * (f - 1) // 2\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    \n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    results = count_pairs(test_cases)\n    print('\\n'.join(map(str, results)))\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "2727", "solution": "class Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        senior_count = 0\n        \n        for detail in details:\n            age = int(detail[12:14])  # Extract and convert age from string\n            if age > 60:\n                senior_count += 1  # Increment counter if age is greater than 60\n        \n        return senior_count  # Return the total count of seniors"}
{"task_id": "2728", "solution": "from typing import List\n\nclass Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        score = 0\n        \n        while nums:  # Continue until nums is empty\n            max_removed = []  # To keep track of max values removed from each row\n            \n            for row in nums:\n                if row:  # Ensure the row is not empty\n                    max_value = max(row)  # Find the max value in the current row\n                    max_removed.append(max_value)  # Store it\n                    row.remove(max_value)  # Remove the max value from the row\n            \n            if max_removed:  # If we have removed any max values\n                score += max(max_removed)  # Add the maximum of the removed values to the score\n            \n            # Remove any empty rows from nums\n            nums = [row for row in nums if row]  # Keep only non-empty rows\n            \n        return score"}
{"task_id": "2730", "solution": "from typing import List\n\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        max_or = 0\n        \n        # Calculate the base OR of the original array\n        base_or = 0\n        for num in nums:\n            base_or |= num\n        \n        # Try to apply the doubling operation to each element\n        for i in range(n):\n            # Calculate the potential value after doubling\n            current_value = nums[i]\n            for j in range(k + 1):  # From 0 to k times\n                if j > 0:  # Multiply by 2, but only if j > 0\n                    current_value *= 2\n                \n                # Calculate the OR with the rest of the array\n                potential_or = base_or | current_value\n                max_or = max(max_or, potential_or)\n        \n        return max_or"}
{"task_id": "2754", "solution": "from typing import List\nfrom functools import reduce\nfrom operator import mul\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        # Filter out zeros\n        nums = [num for num in nums if num != 0]\n        \n        if not nums:\n            return 0  # All numbers were zero\n        \n        # Sort numbers to easily deal with negatives\n        nums.sort()\n        \n        # Count negatives\n        negative_count = sum(1 for num in nums if num < 0)\n        \n        # If there's an odd number of negative numbers, we should exclude the largest (least negative)\n        if negative_count % 2 != 0:\n            nums.pop(0)  # Remove the largest negative number (smallest in sorted order)\n        \n        # Calculate product of the remaining numbers\n        return reduce(mul, nums, 1)  # Start with 1 for multiplication"}
{"task_id": "2755", "solution": "from typing import List\n\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        n = len(s)\n        dp = [0] + [n] * n  # Initialize dp array\n        \n        word_set = set(dictionary)  # Convert list to set for O(1) lookups\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[j:i] in word_set:\n                    dp[i] = min(dp[i], dp[j])  # Use the previous dp value\n                else:\n                    dp[i] = min(dp[i], dp[j] + (i - j))  # Add extra characters\n                \n        return dp[n]"}
{"task_id": "2756", "solution": "from typing import List\n\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        # Sort the prices to find the two cheapest chocolates\n        prices.sort()\n        \n        # Check if we can buy the two cheapest chocolates\n        if len(prices) < 2:\n            return money  # Not enough chocolates to buy\n        \n        # Calculate the sum of the two cheapest chocolates\n        total_cost = prices[0] + prices[1]\n        \n        # Check if we can buy them without going into debt\n        if total_cost <= money:\n            # Calculate leftover money\n            return money - total_cost\n        \n        # If we can't buy them, return the original money\n        return money"}
{"task_id": "2757", "solution": "class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Helper function to calculate digit sum\n        def digit_sum(n):\n            return sum(int(d) for d in str(n))\n        \n        # Memoization dictionary\n        memo = {}\n        \n        # Recursive function to count numbers with conditions\n        def count_good_numbers(pos, tight_start, tight_end, current_sum, leading_zero):\n            # If we reach end of the digits\n            if pos == len(num2):\n                return 1 if min_sum <= current_sum <= max_sum else 0\n            \n            # Memoization key\n            key = (pos, tight_start, tight_end, current_sum, leading_zero)\n            if key in memo:\n                return memo[key]\n\n            limit_start = int(num1[pos]) if tight_start else 0\n            limit_end = int(num2[pos]) if tight_end else 9\n            count = 0\n            \n            for digit in range(limit_start, limit_end + 1):\n                # Skip leading zeros\n                if leading_zero and digit == 0:\n                    count += count_good_numbers(pos + 1, tight_start and (digit == limit_start), tight_end and (digit == limit_end), current_sum, True)\n                else:\n                    count += count_good_numbers(pos + 1, tight_start and (digit == limit_start), tight_end and (digit == limit_end), current_sum + digit, False)\n                \n                count %= MOD\n\n            memo[key] = count\n            return count\n        \n        # Start recursive counting from position 0\n        result_num2 = count_good_numbers(0, True, True, 0, True)\n        result_num1 = count_good_numbers(0, True, True, 0, True) - count_good_numbers(0, True, True, 0, True)  # Count for num1-1\n        return (result_num2 - result_num1 + MOD) % MOD"}
{"task_id": "2777", "solution": "class Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        diff = []\n        prefix_set = set()\n        \n        n = len(nums)\n        \n        for i in range(n):\n            # Update prefix set\n            prefix_set.add(nums[i])\n            count_prefix = len(prefix_set)\n            \n            # Calculate suffix distinct elements\n            suffix_set = set(nums[i + 1:])  # Elements from nums[i+1] to nums[n-1]\n            count_suffix = len(suffix_set)\n            \n            # Calculate difference and append to result\n            diff.append(count_prefix - count_suffix)\n        \n        return diff"}
{"task_id": "2779", "solution": "from typing import List\n\nclass Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [0] * n  # Initialize the nums array with zeros\n        adjacent_count = 0  # To count adjacent same color elements\n        answer = []  # List to store the result after each query\n        \n        for index, color in queries:\n            left_neighbor_same = (index > 0 and nums[index] == nums[index - 1])\n            right_neighbor_same = (index < n - 1 and nums[index] == nums[index + 1])\n            \n            # Before coloring, check the neighbors\n            if left_neighbor_same:\n                adjacent_count -= 1\n            if right_neighbor_same:\n                adjacent_count -= 1\n            \n            # Color the element\n            nums[index] = color\n            \n            # After coloring, check the neighbors again\n            left_neighbor_new_same = (index > 0 and nums[index] == nums[index - 1])\n            right_neighbor_new_same = (index < n - 1 and nums[index] == nums[index + 1])\n            \n            if left_neighbor_new_same:\n                adjacent_count += 1\n            if right_neighbor_new_same:\n                adjacent_count += 1\n            \n            answer.append(adjacent_count)  # Store the result for this query\n        \n        return answer"}
{"task_id": "2784", "solution": "class Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        n = len(nums)\n        \n        # Precompute powers of two up to n\n        power_of_two = [1] * (n + 1)\n        for i in range(1, n + 1):\n            power_of_two[i] = (power_of_two[i - 1] * 2) % MOD\n        \n        total_power = 0\n        \n        for i in range(n):\n            max_elem = nums[i]\n            min_elem = nums[i]\n            # The number of elements that can be used to the left\n            count = i\n            \n            # Contribution when nums[i] is the max element\n            contribution = (max_elem * max_elem % MOD) * min_elem % MOD * (power_of_two[count] - 1) % MOD\n            total_power = (total_power + contribution) % MOD\n        \n        return total_power"}
{"task_id": "2785", "solution": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        # Step 1: Identify positions of 1 and n\n        position_of_1 = nums.index(1)\n        position_of_n = nums.index(len(nums))\n        \n        # Step 2: Calculate swaps needed to move 1 to the front\n        swaps_for_1 = position_of_1\n        \n        # Step 3: Calculate swaps needed to move n to the end\n        swaps_for_n = len(nums) - 1 - position_of_n\n        \n        # Step 4: Adjust for overlap if 1 is to the right of n\n        if position_of_1 > position_of_n:\n            return swaps_for_1 + swaps_for_n - 1\n        \n        # Step 5: Return the total swaps needed\n        return swaps_for_1 + swaps_for_n"}
{"task_id": "2786", "solution": "class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        start = 0\n        count = 0\n        max_length = 0\n        \n        for end in range(len(s)):\n            if end > 0 and s[end] == s[end - 1]:\n                count += 1\n            \n            while count > 1:\n                if s[start] == s[start + 1]:\n                    count -= 1\n                start += 1\n            \n            max_length = max(max_length, end - start + 1)\n        \n        return max_length"}
{"task_id": "2791", "solution": "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        received = set()  # Set to keep track of friends who received the ball\n        current_friend = 1  # Start with the 1st friend\n        turn = 1  # Turn counter\n        \n        while current_friend not in received:\n            received.add(current_friend)  # Mark the current friend as having received the ball\n            # Calculate the next friend using the formula\n            current_friend = (current_friend + turn * k - 1) % n + 1\n            turn += 1  # Increment the turn\n        \n        # Determine the losers by checking who did not receive the ball\n        losers = [i for i in range(1, n + 1) if i not in received]\n        \n        return sorted(losers)  # Return the losers in ascending order"}
{"task_id": "2792", "solution": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        # Calculate the XOR of all elements in `derived`\n        total_xor = 0\n        for value in derived:\n            total_xor ^= value\n        \n        # Check the conditions based on the parity of the length of derived\n        if len(derived) % 2 == 0:\n            return total_xor == 0\n        else:\n            return total_xor == 1"}
{"task_id": "2800", "solution": "class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        \n        for char in s:\n            if stack:  # Check if stack is not empty\n                # Check for \"AB\" or \"CD\" combinations\n                if (stack[-1] == 'A' and char == 'B') or (stack[-1] == 'C' and char == 'D'):\n                    stack.pop()  # Remove the last character as well as the current character\n                    continue  # Skip to the next character\n            stack.append(char)  # Add current character to the stack\n        \n        return len(stack)  # The length of the remaining characters in the stack"}
{"task_id": "2802", "solution": "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def can_partition(s: str, target: int) -> bool:\n            # Backtracking function to check if we can partition s to sum to target\n            def backtrack(start: int, current_sum: int) -> bool:\n                if current_sum > target:\n                    return False\n                if start == len(s):\n                    return current_sum == target\n                for end in range(start + 1, len(s) + 1):\n                    # Take substring s[start:end]\n                    num = int(s[start:end])\n                    if backtrack(end, current_sum + num):\n                        return True\n                return False\n            \n            return backtrack(0, 0)\n\n        punishment_sum = 0\n        for i in range(1, n + 1):\n            square = i * i\n            square_str = str(square)\n            if can_partition(square_str, i):\n                punishment_sum += square\n        \n        return punishment_sum"}
{"task_id": "2808", "solution": "from typing import List\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        dp = [float('inf')] * n\n        \n        # Base case\n        dp[0] = cost[0]\n        \n        for i in range(1, n):\n            # Option 1: Using the paid painter for wall i\n            dp[i] = dp[i-1] + cost[i]\n            \n            # Option 2: Using the free painter for wall i while the paid painter is busy\n            total_time = 0\n            \n            for j in range(i, -1, -1):  # Check backwards from wall i to wall 0\n                if j == i:\n                    total_time += time[i]  # Paid painter paints wall i\n                else:\n                    if total_time < time[j]:  # If the paid painter hasn't finished painting wall j\n                        # We can use the free painter for wall j and any wall before it\n                        dp[i] = min(dp[i], (dp[j-1] if j > 0 else 0))  # Only use dp[j-1] if j > 0\n                        break  \n                total_time += 1  # Free painter would take 1 time unit to paint wall j\n        \n        return dp[n-1]"}
{"task_id": "2810", "solution": "class Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        # Initial cost without any operations\n        min_cost = sum(nums)\n\n        # Iterate over possible operations\n        for k in range(n):\n            # Calculate the cost with k operations\n            current_cost = k * x\n            \n            # Add the cost of collecting chocolates after k shifts\n            for i in range(n):\n                current_cost += nums[(i + k) % n]\n\n            # Update the minimum cost if the current is less\n            min_cost = min(min_cost, current_cost)\n\n        return min_cost"}
{"task_id": "2811", "solution": "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        selected = []\n        selected_set = set()\n        i = 1\n        \n        while len(selected) < n:\n            if (k - i) not in selected_set:\n                selected.append(i)\n                selected_set.add(i)\n            i += 1\n        \n        return sum(selected)"}
{"task_id": "2812", "solution": "class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + 2 * t"}
{"task_id": "2816", "solution": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        result = [''] * n  # Initialize a list to build the result\n        \n        for i in range((n + 1) // 2):  # Loop through the first half\n            left_char = s[i]\n            right_char = s[n - 1 - i]\n            # Choose the lexicographically smaller character\n            smallest_char = min(left_char, right_char)\n            result[i] = smallest_char  # Set the character for the left half\n            result[n - 1 - i] = smallest_char  # Set the character for the right half\n        \n        return ''.join(result)  # Join the list into a string and return it"}
{"task_id": "2817", "solution": "class Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        \n        # Costs to make all '0's\n        cost_to_zero = [0] * n\n        # Costs to make all '1's\n        cost_to_one = [0] * n\n        \n        # Calculate cost to make all '0's\n        current_cost = 0\n        for i in range(n):\n            if s[i] == '1':\n                current_cost += 1  # We'll need to flip this to '0'\n            cost_to_zero[i] = current_cost + (i + 1)  # Cost if we flip at this index\n        \n        current_cost = 0\n        for i in range(n-1, -1, -1):\n            if s[i] == '0':\n                current_cost += 1  # We'll need to flip this to '1'\n            cost_to_one[i] = current_cost + (n - i)  # Cost if we flip at this index\n        \n        # Find the minimum cost for making all characters the same\n        min_cost = float('inf')\n        \n        for i in range(n):\n            total_cost_for_zeros = cost_to_zero[i] + (cost_to_one[i] if i < n else 0)\n            total_cost_for_ones = cost_to_one[i] + (cost_to_zero[i] if i >= 0 else 0)\n            min_cost = min(min_cost, total_cost_for_zeros, total_cost_for_ones)\n        \n        return min_cost"}
{"task_id": "2819", "solution": "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        return num.rstrip('0')"}
{"task_id": "2824", "solution": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Step 1: Calculate the concatenation\n        concatenated_number = str(n) + str(2 * n) + str(3 * n)\n        \n        # Step 2: Check the digits\n        # Check if the length is 9 and contains all digits from 1 to 9\n        if len(concatenated_number) != 9:\n            return False\n        \n        # Create a set of digits in the concatenated string\n        digit_set = set(concatenated_number)\n        \n        # Check if the digit set contains exactly the digits from '1' to '9'\n        return digit_set == {'1', '2', '3', '4', '5', '6', '7', '8', '9'}"}
{"task_id": "2825", "solution": "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        # Use a set to store the unique characters in the string\n        unique_characters = set(s)\n        # The minimized length is the number of unique characters\n        return len(unique_characters)"}
{"task_id": "2827", "solution": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        parent = list(range(len(nums)))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootY] = rootX\n        \n        # Map prime factors to their respective indices\n        factor_map = {}\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            # Find all factors of num\n            for j in range(1, int(num**0.5) + 1):\n                if num % j == 0:\n                    if j not in factor_map:\n                        factor_map[j] = []\n                    factor_map[j].append(i)\n                    \n                    if j != num // j:  # Avoid adding the square root twice\n                        if num // j not in factor_map:\n                            factor_map[num // j] = []\n                        factor_map[num // j].append(i)\n        \n        # Union indices based on their factors\n        for indices in factor_map.values():\n            for k in range(1, len(indices)):\n                union(indices[0], indices[k])\n        \n        # Check if all indices have the same root\n        root = find(0)\n        for i in range(1, len(nums)):\n            if find(i) != root:\n                return False\n        \n        return True"}
{"task_id": "2828", "solution": "class Solution:\n    def smallestString(self, s: str) -> str:\n        result = list(s)  # Convert string to list for mutability\n        n = len(result)\n\n        # Find the point to start replacing\n        for i in range(n):\n            if result[i] > 'a':\n                # Start replacing from here to the end\n                for j in range(i, n):\n                    if result[j] == 'a':\n                        break  # Stop when we hit 'a'\n                    result[j] = chr(ord(result[j]) - 1)  # Replace with previous character\n                break  # We only need to do this once\n\n        return ''.join(result)  # Convert list back to string"}
{"task_id": "2831", "solution": "from typing import List\nfrom math import gcd\n\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        beautiful_pairs_count = 0\n        \n        # Extracting first and last digits\n        first_digits = []\n        last_digits = []\n        \n        for num in nums:\n            first_digit = int(str(num)[0])  # First digit\n            last_digit = num % 10            # Last digit\n            first_digits.append(first_digit)\n            last_digits.append(last_digit)\n        \n        # Counting beautiful pairs\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if gcd(first_digits[i], last_digits[j]) == 1:\n                    beautiful_pairs_count += 1\n        \n        return beautiful_pairs_count"}
{"task_id": "2832", "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        left = 0\n        max_freq = 0\n        count = defaultdict(int)\n        max_length = 0\n        \n        for right in range(len(nums)):\n            count[nums[right]] += 1\n            max_freq = max(max_freq, count[nums[right]])\n            \n            # Check if we need to shrink the window\n            while (right - left + 1) - max_freq > k:\n                count[nums[left]] -= 1\n                left += 1\n                \n            max_length = max(max_length, right - left + 1)\n            \n        return max_length"}
{"task_id": "2833", "solution": "from typing import List\nfrom collections import defaultdict\nimport bisect\n\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Step 1: Prepare data structure to track requests for each server\n        server_requests = defaultdict(list)\n        \n        # Step 2: Log requests for each server\n        for server_id, time in logs:\n            server_requests[server_id].append(time)\n        \n        # Step 3: Sort request times for each server for binary search\n        for server_id in server_requests:\n            server_requests[server_id].sort()\n        \n        # Step 4: Prepare to answer each query\n        result = []\n        \n        for query in queries:\n            lower_bound = query - x\n            upper_bound = query\n            \n            total_servers = n\n            busy_servers = 0\n            \n            # Check each server to see if it received requests in the interval\n            for server_id in range(1, n + 1):\n                if server_id in server_requests:\n                    # Get the list of times for the current server\n                    times = server_requests[server_id]\n                    # Use binary search to find the number of requests in the range\n                    left_index = bisect.bisect_left(times, lower_bound)\n                    right_index = bisect.bisect_right(times, upper_bound)\n                    \n                    if left_index < right_index:  # Means there are requests in the interval\n                        busy_servers += 1\n            \n            # Step 5: Calculate idle servers\n            idle_servers = total_servers - busy_servers\n            result.append(idle_servers)\n        \n        return result"}
{"task_id": "2834", "solution": "from typing import List\n\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        # Step 1: Initialize a set with the initial positions of the marbles\n        occupied_positions = set(nums)\n        \n        # Step 2: Process each move\n        for from_pos, to_pos in zip(moveFrom, moveTo):\n            if from_pos in occupied_positions:\n                occupied_positions.remove(from_pos)  # Remove the marbles from the moveFrom position\n            occupied_positions.add(to_pos)  # Add the marbles to the moveTo position\n        \n        # Step 3: Sort the final occupied positions and return\n        return sorted(occupied_positions)"}
{"task_id": "2837", "solution": "class Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        if num1 < num2:\n            return -1  # Immediate impossibility if num2 is greater than num1\n        \n        min_operations = float('inf')\n        \n        for i in range(61):  # i from 0 to 60\n            power_of_two = 1 << i  # This is 2^i\n            current_subtraction = power_of_two + num2\n            \n            if current_subtraction <= 0:\n                continue  # Invalid case, we can't use this\n            \n            # Check if we can make num1 zero by using this current_subtraction\n            if (num1 - num2) % current_subtraction == 0:\n                k = (num1 - num2) // current_subtraction\n                if k >= 0:\n                    min_operations = min(min_operations, k)\n        \n        return min_operations if min_operations != float('inf') else -1"}
{"task_id": "2839", "solution": "from typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        \n        # Step 1: Combine and sort the nums1, nums2 with their sums\n        indexed_data = [(nums1[i], nums2[i], nums1[i] + nums2[i]) for i in range(n)]\n        indexed_data.sort()  # Sort by nums1 first, and then by nums2\n        \n        # Step 2: Prepare max_sum array based on sorted order\n        max_sum = [0] * n\n        max_sum[0] = indexed_data[0][2]  # The sum is the third element in the tuple\n        \n        for i in range(1, n):\n            max_sum[i] = max(max_sum[i - 1], indexed_data[i][2])\n        \n        # Step 3: Process each query\n        answer = []\n        for x_i, y_i in queries:\n            # Binary search to find the first index where nums1 >= x_i\n            index = bisect.bisect_left(indexed_data, (x_i, float('-inf'), float('-inf')))\n            if index < n:\n                # Now we need to find the maximum sum where nums2 >= y_i\n                # We will find the maximum sum from index onwards\n                max_valid_sum = -1\n                for j in range(index, n):\n                    if indexed_data[j][1] >= y_i:  # Check nums2 condition\n                        max_valid_sum = max(max_valid_sum, max_sum[j])\n                answer.append(max_valid_sum)\n            else:\n                answer.append(-1)  # No valid index found\n        \n        return answer"}
{"task_id": "2844", "solution": "class Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum_squares = 0\n        \n        for i in range(1, n + 1):\n            if n % i == 0:\n                sum_squares += nums[i - 1] ** 2\n        \n        return sum_squares"}
{"task_id": "2845", "solution": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        # Step 1: Sort the array\n        nums.sort()\n        \n        # Step 2: Initialize min partition value as a large number\n        min_partition_value = float('inf')\n        \n        # Step 3: Calculate partition values\n        for i in range(1, len(nums)):\n            partition_value = abs(nums[i] - nums[i - 1])\n            min_partition_value = min(min_partition_value, partition_value)\n        \n        # Step 4: Return the minimum partition value found\n        return min_partition_value"}
{"task_id": "2847", "solution": "from typing import List\n\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        word_set = set(words)  # Store all words in a set for fast lookup\n        pairs_count = 0\n        \n        for word in words:\n            reversed_word = word[::-1]  # Get the reversed string\n            if reversed_word in word_set:  # Check if the reversed word exists in the set\n                pairs_count += 1  # We can form a pair\n                word_set.remove(word)  # Remove the original word from the set\n                word_set.remove(reversed_word)  # Remove the reversed word from the set\n        \n        return pairs_count"}
{"task_id": "2848", "solution": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Precompute the adjacency matrix for valid pairs\n        valid_pairs = [[False] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                        valid_pairs[i][j] = True\n        \n        # Memoization dictionary\n        memo = {}\n        \n        def backtrack(mask, last):\n            if mask == (1 << n) - 1:  # All numbers used\n                return 1\n            \n            if (mask, last) in memo:  # Return already computed result\n                return memo[(mask, last)]\n            \n            total_permutations = 0\n            \n            for next_num in range(n):\n                if mask & (1 << next_num) == 0 and valid_pairs[last][next_num]:  # not used and valid\n                    total_permutations += backtrack(mask | (1 << next_num), next_num)\n                    total_permutations %= MOD\n            \n            memo[(mask, last)] = total_permutations\n            return total_permutations\n        \n        # Starting the backtrack with each number\n        total_special_permutations = 0\n        for start in range(n):\n            total_special_permutations += backtrack(1 << start, start)  # start with each number\n            total_special_permutations %= MOD\n        \n        return total_special_permutations"}
{"task_id": "2849", "solution": "from typing import List\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        n = len(nums)\n        total_imbalance = 0\n        \n        # Iterate over all possible starting points of subarrays\n        for start in range(n):\n            # Iterate over all possible ending points of subarrays\n            for end in range(start + 1, n + 1):\n                # Extract the subarray\n                subarray = nums[start:end]\n                # Sort the subarray\n                subarray.sort()\n                \n                # Count the imbalance numbers\n                imbalance_count = 0\n                for i in range(len(subarray) - 1):\n                    if subarray[i + 1] - subarray[i] > 1:\n                        imbalance_count += 1\n                \n                # Add to the total imbalance\n                total_imbalance += imbalance_count\n        \n        return total_imbalance"}
{"task_id": "2850", "solution": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # Use 'AB' strings fully, each contributes 2\n        length_from_AB = z * 2\n        \n        # Determine how many 'AA' and 'BB' we can use\n        if x > y:\n            length_from_AA = (y + 1) * 2  # Can use (y + 1) 'AA's if more 'AA's than 'BB's\n            length_from_BB = y * 2\n        else:\n            length_from_AA = x * 2\n            length_from_BB = (x + 1) * 2  # Can use (x + 1) 'BB's if more 'BB's than 'AA's\n        \n        # Total length\n        total_length = length_from_AB + length_from_AA + length_from_BB\n        \n        return total_length"}
{"task_id": "2854", "solution": "class Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        # Initialize with the first word's length\n        current_length = len(words[0])\n        last_char = words[0][-1]  # Last character of the current concatenation\n        \n        # Iterate through the remaining words\n        for i in range(1, len(words)):\n            new_word = words[i]\n            new_length = len(new_word)\n            \n            # Calculate lengths for both situations\n            # Case 1: current + new_word\n            length1 = current_length + new_length\n            if last_char == new_word[0]:  # If last char of current matches first char of new\n                length1 -= 1  # Reduce by 1\n            \n            # Case 2: new_word + current\n            length2 = current_length + new_length\n            if new_word[-1] == last_char:  # If last char of new matches first char of current\n                length2 -= 1  # Reduce by 1\n            \n            # Update current_length to the minimum found\n            current_length = min(length1, length2)\n            # Update the last_char to the last character of the new word\n            last_char = new_word[-1]\n        \n        return current_length"}
{"task_id": "2855", "solution": "from typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [-1] * n\n        dp[0] = 0  # Starting point has 0 jumps\n        \n        for i in range(n):\n            if dp[i] == -1:  # If the current index is unreachable, skip it\n                continue\n            for j in range(i + 1, n):\n                if -target <= nums[j] - nums[i] <= target:\n                    dp[j] = max(dp[j], dp[i] + 1)\n\n        return dp[n - 1]"}
{"task_id": "2856", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        # Step 1: Identify the number of distinct elements in the entire array.\n        distinct_count = len(set(nums))\n        \n        left = 0\n        right = 0\n        current_count = 0\n        subarray_counts = defaultdict(int)\n        complete_subarray_count = 0\n        \n        # Step 2: Sliding window to find complete subarrays\n        while right < len(nums):\n            # Add the right element to the window\n            if subarray_counts[nums[right]] == 0:\n                current_count += 1\n            subarray_counts[nums[right]] += 1\n            \n            # Step 3: Check if the current window is complete\n            while current_count >= distinct_count:\n                # Count this subarray and all valid right extensions\n                complete_subarray_count += len(nums) - right\n                \n                # Move the left pointer to shrink the window\n                subarray_counts[nums[left]] -= 1\n                if subarray_counts[nums[left]] == 0:\n                    current_count -= 1\n                left += 1\n            \n            right += 1\n            \n        return complete_subarray_count"}
{"task_id": "2857", "solution": "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        distance = 0\n        while mainTank > 0:\n            # Determine how much fuel we can use in this cycle\n            if mainTank >= 5:\n                # Use 5 liters, which allows for a possible transfer from additional tank\n                distance += 5 * 10  # 10 km per liter\n                mainTank -= 5\n                if additionalTank > 0:  # Check if we can transfer fuel\n                    mainTank += 1  # Transfer 1 liter from additional tank to main tank\n                    additionalTank -= 1  # Decrease the additional tank fuel\n            else:\n                # Use the remaining fuel in main tank\n                distance += mainTank * 10\n                mainTank = 0  # Main tank is empty\n        return distance"}
{"task_id": "2866", "solution": "from typing import List\n\nclass Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        max_length = 0\n        n = len(nums)\n        \n        for l in range(n):\n            if nums[l] % 2 == 0 and nums[l] <= threshold:\n                current_length = 1\n                for r in range(l + 1, n):\n                    if nums[r] <= threshold and nums[r] % 2 != nums[r - 1] % 2:\n                        current_length += 1\n                    else:\n                        break\n                \n                max_length = max(max_length, current_length)\n        \n        return max_length"}
{"task_id": "2867", "solution": "from typing import List\n\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Step 1: Find all the indices of 1s\n        ones_indices = [i for i in range(n) if nums[i] == 1]\n        \n        # If there are no 1s, there are no good subarrays\n        if not ones_indices:\n            return 0\n        \n        # Total ways to split\n        total_ways = 1\n        \n        # Step 2: Calculate the gaps between 1s\n        for i in range(1, len(ones_indices)):\n            gap = ones_indices[i] - ones_indices[i - 1] - 1  # Count zeros between\n            total_ways = (total_ways * (gap + 1)) % MOD\n        \n        # Return the result\n        return total_ways"}
{"task_id": "2868", "solution": "class Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        left = 0\n        total_count = 0\n        \n        for right in range(len(nums)):\n            # Expand the window\n            while max(nums[left:right + 1]) - min(nums[left:right + 1]) > 2:\n                left += 1\n            # Count valid subarrays that end with `right`\n            total_count += (right - left + 1)\n        \n        return total_count"}
{"task_id": "2869", "solution": "from typing import List\n\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        max_length = 1\n        current_length = 1\n        \n        # Initialize the last chosen value\n        last_chosen = min(nums1[0], nums2[0])\n        \n        for i in range(1, n):\n            # Get the potential choices\n            option1 = nums1[i]\n            option2 = nums2[i]\n            \n            # Check if we can extend the current non-decreasing subarray\n            if last_chosen <= option1 and last_chosen <= option2:\n                # Both choices are valid\n                current_length += 1\n                last_chosen = max(option1, option2)  # Take the larger to maximize future options\n            elif last_chosen <= option1:\n                # Only option1 is valid\n                current_length += 1\n                last_chosen = option1\n            elif last_chosen <= option2:\n                # Only option2 is valid\n                current_length += 1\n                last_chosen = option2\n            else:\n                # Neither option is valid\n                current_length = 1  # Reset the current length\n                last_chosen = min(option1, option2)  # Reset the last chosen to the minimum\n                \n            max_length = max(max_length, current_length)\n        \n        return max_length"}
{"task_id": "2870", "solution": "class Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        max_length = -1\n        current_length = 0\n\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1] + 1:  # Incrementing step\n                if current_length == 0:\n                    current_length = 2  # Start a new alternating subarray\n                else:\n                    current_length += 1  # Continue the current alternating subarray\n            elif nums[i] == nums[i - 1] - 1:  # Decrementing step\n                if current_length > 0:\n                    current_length += 1  # Continue alternating\n                else:\n                    current_length = 0  # Reset if there is no valid pair to start\n            else:\n                current_length = 0  # Reset if no alternating pattern\n\n            if current_length > max_length:\n                max_length = current_length\n\n        return max_length if max_length > 1 else -1"}
{"task_id": "2872", "solution": "class Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        # Start from the end of the array\n        max_value = nums[-1]\n        \n        # Iterate backwards through the array\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] <= max_value:\n                # If the current number can be merged with max_value\n                max_value += nums[i]\n        \n        return max_value"}
{"task_id": "2873", "solution": "from typing import List\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        if n < 2:\n            return []\n        \n        # Step 1: Sieve of Eratosthenes to find all primes up to n\n        is_prime = [True] * (n + 1)\n        is_prime[0] = is_prime[1] = False\n        \n        for i in range(2, int(n**0.5) + 1):\n            if is_prime[i]:\n                for j in range(i * i, n + 1, i):\n                    is_prime[j] = False\n        \n        # Step 2: Collect all primes\n        primes = [i for i in range(n + 1) if is_prime[i]]\n        \n        # Step 3: Finding pairs\n        result = []\n        for x in primes:\n            y = n - x\n            if y < x:  # Ensure x <= y\n                break\n            if y <= n and is_prime[y]:\n                result.append([x, y])\n        \n        return result"}
{"task_id": "2876", "solution": "from typing import List\n\nclass Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        count = 0\n        for hour in hours:\n            if hour >= target:\n                count += 1\n        return count"}
{"task_id": "2877", "solution": "class Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        \n        def overlap(s1, s2):\n            max_overlap = 0\n            # Check for maximum overlap where s1 ends and s2 starts\n            for i in range(1, min(len(s1), len(s2)) + 1):\n                if s1[-i:] == s2[:i]:\n                    max_overlap = i\n            return max_overlap\n        \n        def combine(s1, s2):\n            ov = overlap(s1, s2)\n            return s1 + s2[ov:]\n        \n        from itertools import permutations\n        \n        candidates = []\n        for perm in permutations([a, b, c]):\n            combined = combine(combine(perm[0], perm[1]), perm[2])\n            candidates.append(combined)\n        \n        # Find the shortest length, then the lexicographically smallest\n        min_length = float('inf')\n        result = \"\"\n        \n        for candidate in candidates:\n            if len(candidate) < min_length:\n                min_length = len(candidate)\n                result = candidate\n            elif len(candidate) == min_length:\n                result = min(result, candidate)\n        \n        return result"}
{"task_id": "2878", "solution": "class Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        current_decrement = 0\n        operations = [0] * (n + 1)  # To track operations\n        \n        for i in range(n):\n            current_decrement += operations[i]  # Update current decrement due to previous operations\n            \n            # If the adjusted value of nums[i] is greater than 0, we need to apply more operations\n            if nums[i] > current_decrement:\n                needed_operations = nums[i] - current_decrement\n                current_decrement += needed_operations  # Apply needed operations\n                if i + k <= n:  # Check if we are within bounds for the next k elements\n                    operations[i + k] -= needed_operations  # Cancel the effect after k elements\n            \n            # If at any point we have too much current decrement, we cannot make nums[i] equal to 0\n            if current_decrement > nums[i]:\n                return False\n        \n        return True"}
{"task_id": "2879", "solution": "class Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        \n        # Precompute the minimum changes needed to make each substring semi-palindromic\n        def changes_to_semi_palindrome(start, end):\n            length = end - start + 1\n            min_changes = float('inf')\n            \n            # Check for all possible divisors d\n            for d in range(1, length):\n                if length % d == 0:\n                    # Count frequency of characters in groups\n                    freq = [0] * 26\n                    for i in range(start, end + 1):\n                        freq[ord(s[i]) - ord('a')] += 1\n            \n                    changes = 0\n                    for m in range(d):\n                        group = []\n                        for i in range(m, length, d):\n                            group.append(s[start + i])\n                        \n                        # Count changes needed to make this group palindromic\n                        count = [0] * 26\n                        for char in group:\n                            count[ord(char) - ord('a')] += 1\n                        changes += len(group) - max(count)\n                    \n                    min_changes = min(min_changes, changes)\n            \n            return min_changes\n        \n        # DP table\n        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        # Filling the DP table\n        for j in range(1, k + 1):\n            for i in range(1, n + 1):\n                for p in range(i):\n                    dp[i][j] = min(dp[i][j], dp[p][j - 1] + changes_to_semi_palindrome(p, i - 1))\n        \n        return dp[n][k]"}
{"task_id": "2881", "solution": "from typing import List\n\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            # Split the word by the separator and filter out empty strings\n            split_words = word.split(separator)\n            # Extend the result list with non-empty strings\n            result.extend([w for w in split_words if w])\n        return result"}
{"task_id": "2882", "solution": "class Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7  # Define the modulo\n        \n        # Memoization dictionary\n        memo = {}\n        \n        def countWays(n, current):\n            # If already computed, return the stored result\n            if (n, current) in memo:\n                return memo[(n, current)]\n            \n            # Base case: if n is 0, we've found a valid combination\n            if n == 0:\n                return 1\n            # Base case: if n is negative or if current exceeds n, no valid combination\n            if n < 0 or current > n:\n                return 0\n            \n            # Calculate the power of the current integer\n            power = current ** x\n            \n            # Recursively count ways including current and excluding current\n            include_current = countWays(n - power, current + 1)\n            exclude_current = countWays(n, current + 1)\n            \n            # Store the result in memoization dictionary\n            memo[(n, current)] = (include_current + exclude_current) % MOD\n            \n            return memo[(n, current)]\n        \n        # Start the recursion with n and the first integer 1\n        return countWays(n, 1)"}
{"task_id": "2883", "solution": "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        # List of beautiful substrings in binary form corresponding to powers of 5\n        beautiful_numbers = [\"1\", \"101\", \"11001\", \"1111101\", \"1001110001\", \"110000110101\", \"1111001001010001\"]\n        \n        # Initialize DP array\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0  # Base case: no substrings needed for empty string\n        \n        # Check all substrings\n        for i in range(1, n + 1):\n            for b in beautiful_numbers:\n                b_len = len(b)\n                if i - b_len >= 0 and s[i - b_len:i] == b:\n                    dp[i] = min(dp[i], dp[i - b_len] + 1)\n\n        # Result is dp[n] if it's not inf, otherwise return -1\n        return dp[n] if dp[n] != float('inf') else -1"}
{"task_id": "2884", "solution": "from typing import List\n\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        max_length = 0\n        start = 0\n        \n        for end in range(len(word)):\n            # Check the current substring from word[start:end+1]\n            while any(word[start:end+1].find(f) != -1 for f in forbidden_set):\n                start += 1  # Shrink the window until it's valid\n            \n            max_length = max(max_length, end - start + 1)  # Update max_length\n            \n        return max_length"}
{"task_id": "2886", "solution": "class Solution:\n    def finalString(self, s: str) -> str:\n        result = []\n        for char in s:\n            if char == 'i':\n                result.reverse()\n            else:\n                result.append(char)\n        return ''.join(result)"}
{"task_id": "2887", "solution": "class Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = 'aeiouAEIOU'\n        vowel_list = []\n        \n        # Step 1: Extract the vowels\n        for char in s:\n            if char in vowels:\n                vowel_list.append(char)\n        \n        # Step 2: Sort the vowels\n        vowel_list.sort()\n        \n        # Step 3: Reconstruct the string\n        result = []\n        vowel_index = 0\n        \n        for char in s:\n            if char in vowels:\n                result.append(vowel_list[vowel_index])\n                vowel_index += 1\n            else:\n                result.append(char)\n        \n        # Step 4: Convert list back to string\n        return ''.join(result)"}
{"task_id": "2888", "solution": "class Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        # Step 1: Determine the dominant element and its frequency in the entire array\n        total_freq = Counter(nums)\n        dominant_element = max(total_freq.keys(), key=lambda x: total_freq[x])\n        dominant_count = total_freq[dominant_element]\n        \n        n = len(nums)\n        left_count = 0\n        \n        # Step 2: Iterate through the array to find the minimum valid split index\n        for i in range(n - 1):  # We skip the last index since we can't split there\n            if nums[i] == dominant_element:\n                left_count += 1\n            \n            right_count = dominant_count - left_count\n            \n            # Check if both sides are valid\n            if (left_count * 2 > (i + 1)) and (right_count * 2 > (n - (i + 1))):\n                return i\n        \n        return -1"}
{"task_id": "2891", "solution": "class Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        from collections import defaultdict\n        \n        count = defaultdict(int)\n        \n        for num in nums:\n            min_val = num - k\n            max_val = num + k\n            count[(min_val, max_val)] += 1\n            \n        max_beauty = 0\n        \n        # We can leverage a sorted approach to find the maximum overlaps\n        events = []\n        \n        for (start, end), cnt in count.items():\n            events.append((start, cnt))   # start of an interval\n            events.append((end + 1, -cnt)) # end of an interval (end + 1 to mark the exit)\n        \n        events.sort()\n        \n        current_beauty = 0\n        for event in events:\n            current_beauty += event[1]\n            max_beauty = max(max_beauty, current_beauty)\n        \n        return max_beauty"}
{"task_id": "2892", "solution": "class Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        max_num = max(nums)  # Step 1: Identify the maximum element\n        expected_length = max_num + 1  # Step 2: Calculate expected length\n        \n        if len(nums) != expected_length:  # Check if lengths match\n            return False\n        \n        # Step 3: Count frequencies\n        from collections import Counter\n        frequency = Counter(nums)\n        \n        # Step 4: Validate the counts\n        for i in range(1, max_num):\n            if frequency[i] != 1:  # Each number from 1 to n-1 should appear exactly once\n                return False\n        \n        if frequency[max_num] != 2:  # The number n should appear exactly twice\n            return False\n        \n        return True  # If all checks pass, return true"}
{"task_id": "2893", "solution": "from typing import List\n\nclass Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        max_score_same_parity = nums[0]\n        max_score_different_parity = float('-inf')  # Invalid initial score for different parity\n        \n        for j in range(1, n):\n            if nums[j] % 2 == nums[0] % 2:  # Same parity\n                max_score_same_parity = max(max_score_same_parity + nums[j], max_score_different_parity + nums[j])\n                max_score_different_parity = float('-inf')  # Reset because we cannot have a valid transition from different parity\n            else:  # Different parity\n                new_score_same = max_score_same_parity + nums[j] - x\n                new_score_different = max_score_different_parity + nums[j] if max_score_different_parity != float('-inf') else float('-inf')\n                max_score_same_parity = new_score_same\n                max_score_different_parity = max(new_score_different, float('-inf'))  # Keep track of valid different parity score\n            \n        return max(max_score_same_parity, max_score_different_parity)"}
{"task_id": "2902", "solution": "class Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Helper function to find the maximum digit in a number\n        def max_digit(n):\n            return max(int(d) for d in str(n))\n        \n        # Group numbers by their maximum digit\n        max_digit_groups = defaultdict(list)\n        for num in nums:\n            md = max_digit(num)\n            max_digit_groups[md].append(num)\n        \n        # Find the maximum sum of pairs with the same maximum digit\n        max_sum = -1\n        for numbers in max_digit_groups.values():\n            if len(numbers) > 1:\n                # Sort the numbers to find the two largest\n                numbers.sort()\n                candidate_sum = numbers[-1] + numbers[-2]\n                max_sum = max(max_sum, candidate_sum)\n        \n        return max_sum"}
{"task_id": "2915", "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        count = 0\n        cnt = 0\n        remainder_count = defaultdict(int)\n        \n        # Initialize the remainder_count with 0 remainder seen once\n        remainder_count[0] = 1\n        \n        for num in nums:\n            if num % modulo == k:\n                cnt += 1\n            \n            # Calculate effective count modulo\n            effective_count = cnt % modulo\n            \n            # Increment count by the number of times this effective count has been seen\n            count += remainder_count[effective_count]\n            \n            # Update the remainder_count for the current effective count\n            remainder_count[effective_count] += 1\n        \n        return count"}
{"task_id": "2916", "solution": "class Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        n = len(nums)\n        \n        # If there's only one element, we can consider it already split\n        if n == 1:\n            return True\n            \n        # Calculate total sum of the array\n        total_sum = sum(nums)\n        \n        # If the total sum is less than n * m, it's impossible to split\n        if total_sum < n * m:\n            return False\n        \n        current_sum = 0\n        valid_parts = 0\n        \n        # Traverse through the array to find valid parts\n        for num in nums:\n            current_sum += num\n            \n            # If the current sum reaches or exceeds m, we can make a valid split\n            if current_sum >= m:\n                valid_parts += 1\n                current_sum = 0  # Reset for the next subarray\n        \n        # Check if we found enough valid parts\n        return valid_parts >= n"}
{"task_id": "2917", "solution": "class Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] < target:\n                    count += 1\n        \n        return count"}
{"task_id": "2919", "solution": "from typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        total_usage = sum(usageLimits)\n        \n        # Binary search to find the maximum number of groups\n        low, high = 0, total_usage\n        \n        while low < high:\n            mid = (low + high + 1) // 2\n            needed = mid * (mid + 1) // 2\n            \n            if needed <= total_usage:\n                low = mid  # mid is a valid number of groups\n            else:\n                high = mid - 1  # mid is too high\n        \n        return low"}
{"task_id": "2920", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0  # Only one element, already equal\n        \n        # Step 1: Create a mapping of unique values to their indices\n        value_to_indices = defaultdict(list)\n        for index, value in enumerate(nums):\n            value_to_indices[value].append(index)\n        \n        min_seconds = float('inf')\n        \n        # Step 2: For each unique value, determine the number of segments\n        for value, indices in value_to_indices.items():\n            segments = 0\n            last_index = -2  # Start with an invalid index\n            \n            # Count segments of the current value\n            for index in indices:\n                if last_index + 1 != index:\n                    segments += 1\n                last_index = index\n            \n            # Check the circular condition\n            if indices[0] == 0 and indices[-1] == n - 1:\n                segments -= 1\n            \n            # The number of seconds required to make all equal to this value\n            min_seconds = min(min_seconds, segments)\n\n        return min_seconds"}
{"task_id": "2921", "solution": "class Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        \n        low_int = int(low)\n        high_int = int(high)\n        count = 0\n        \n        from collections import deque\n        \n        # BFS initialization\n        queue = deque(range(10))  # Initialize with the digits 0-9\n        \n        while queue:\n            num = queue.popleft()\n            \n            if num > high_int:\n                continue\n            \n            if num >= low_int and num <= high_int:\n                count = (count + 1) % MOD\n            \n            if num == 0 or num > high_int:\n                continue\n            \n            last_digit = num % 10\n            \n            # Next stepping numbers\n            if last_digit > 0:  # can append last_digit - 1\n                next_num = num * 10 + (last_digit - 1)\n                queue.append(next_num)\n            if last_digit < 9:  # can append last_digit + 1\n                next_num = num * 10 + (last_digit + 1)\n                queue.append(next_num)\n\n        return count"}
{"task_id": "2952", "solution": "class Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        total_initial_sum = sum(nums1)\n        sum_nums2 = sum(nums2)\n        \n        # If the initial sum is already less than or equal to x\n        if total_initial_sum <= x:\n            return 0\n        \n        n = len(nums1)\n        left, right = 0, 10**6  # Set upper limit for binary search\n        \n        def canAchieve(t):\n            # Calculate the potential sum after t seconds\n            potential_sum = total_initial_sum + t * sum_nums2\n            for i in range(n):\n                adjusted_sum = potential_sum - nums2[i] * t  # Reset nums1[i] to 0\n                if adjusted_sum <= x:\n                    return True\n            return False\n        \n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if canAchieve(mid):\n                result = mid\n                right = mid - 1  # Try to find a smaller time\n            else:\n                left = mid + 1  # Need more time\n        \n        return result"}
{"task_id": "2953", "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        count_map = defaultdict(int)\n        \n        # Count occurrences of each coordinate\n        for x, y in coordinates:\n            count_map[(x, y)] += 1\n            \n        count = 0\n        unique_coordinates = list(count_map.keys())\n        \n        # Compare each pair of unique coordinates\n        for i in range(len(unique_coordinates)):\n            x1, y1 = unique_coordinates[i]\n            for j in range(i + 1, len(unique_coordinates)):\n                x2, y2 = unique_coordinates[j]\n                distance = (x1 ^ x2) + (y1 ^ y2)\n                \n                if distance == k:\n                    count += count_map[(x1, y1)] * count_map[(x2, y2)]\n        \n        # Handle pairs within the same coordinate if k == 0\n        if k == 0:\n            for x, y in count_map:\n                n = count_map[(x, y)]\n                count += (n * (n - 1)) // 2\n        \n        return count"}
{"task_id": "2954", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        n = len(nums)\n        if n < k:\n            return 0\n        \n        max_sum = 0\n        current_sum = 0\n        count = defaultdict(int)\n        distinct_count = 0\n        \n        for i in range(n):\n            current_sum += nums[i]\n            count[nums[i]] += 1\n            \n            if count[nums[i]] == 1:\n                distinct_count += 1\n            \n            # Once we hit k size, we will check if we need to slide the window\n            if i >= k:\n                left_elem = nums[i - k]\n                current_sum -= left_elem\n                count[left_elem] -= 1\n                \n                if count[left_elem] == 0:\n                    distinct_count -= 1\n            \n            # Check if we have a valid window of size k\n            if i >= k - 1:\n                if distinct_count >= m:\n                    max_sum = max(max_sum, current_sum)\n        \n        return max_sum if max_sum > 0 else 0"}
{"task_id": "2955", "solution": "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        # Initial balance\n        initial_balance = 100\n        \n        # Calculate lower and upper multiples of 10\n        lower_multiple = (purchaseAmount // 10) * 10\n        upper_multiple = lower_multiple + 10\n        \n        # Determine the rounded amount\n        if abs(lower_multiple - purchaseAmount) < abs(upper_multiple - purchaseAmount):\n            roundedAmount = lower_multiple\n        else:\n            roundedAmount = upper_multiple\n        \n        # Update balance\n        new_balance = initial_balance - roundedAmount\n        \n        return new_balance"}
{"task_id": "2977", "solution": "class Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        # Concatenate the first characters of each word\n        acronym = ''.join(word[0] for word in words)\n        # Compare the generated acronym with the given string s\n        return acronym == s"}
{"task_id": "2979", "solution": "from typing import List\n\nclass Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        # Step 1: Initialize the DP array\n        dp = [0] * (n + 1)  # dp[i] = max gold for houses up to index i - 1\n        \n        # Step 2: Sort the offers by the end index\n        offers.sort(key=lambda x: x[1])\n        \n        # Step 3: Iterate through the offers to fill the DP array\n        for start_i, end_i, gold_i in offers:\n            # Calculate the max we can get if we take this offer\n            # The next available index after end_i for the next house\n            next_house = end_i + 1\n            \n            # Determine the gold earned by accepting this offer\n            new_gold = dp[start_i] + gold_i\n            \n            # Update dp[next_house] for the maximum we can have\n            dp[next_house] = max(dp[next_house], new_gold)\n        \n        # Step 4: Fill dp with the values considering previous houses\n        for i in range(1, n + 1):\n            dp[i] = max(dp[i], dp[i - 1])  # Carry forward the maximum\n        \n        # Step 5: The answer will be in dp[n]\n        return dp[n]"}
{"task_id": "2998", "solution": "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        count = 0\n        \n        for num in range(low, high + 1):\n            str_num = str(num)\n            length = len(str_num)\n            \n            # Skip if the number of digits is odd\n            if length % 2 != 0:\n                continue\n            \n            mid = length // 2\n            # Split the number into two halves\n            left_half = str_num[:mid]\n            right_half = str_num[mid:]\n            \n            # Calculate the sum of both halves\n            sum_left = sum(int(digit) for digit in left_half)\n            sum_right = sum(int(digit) for digit in right_half)\n            \n            # Check if the sums are equal\n            if sum_left == sum_right:\n                count += 1\n        \n        return count"}
{"task_id": "2999", "solution": "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        # Extract characters at even indices and odd indices\n        even_indices_s1 = sorted([s1[0], s1[2]])\n        odd_indices_s1 = sorted([s1[1], s1[3]])\n        \n        even_indices_s2 = sorted([s2[0], s2[2]])\n        odd_indices_s2 = sorted([s2[1], s2[3]])\n        \n        # Compare sorted groups\n        return even_indices_s1 == even_indices_s2 and odd_indices_s1 == odd_indices_s2"}
{"task_id": "3000", "solution": "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        min_diff = float('inf')\n        sorted_list = SortedList()\n        \n        for i in range(n):\n            # Ensure we only consider elements that are at least x indices apart\n            if i >= x:\n                # Get the current number\n                current_num = nums[i]\n                \n                # Check the closest numbers in the sorted list\n                pos = sorted_list.bisect_left(current_num)\n                \n                # Check the number just before the position\n                if pos > 0:\n                    min_diff = min(min_diff, abs(current_num - sorted_list[pos - 1]))\n                \n                # Check the number at the position (if exists)\n                if pos < len(sorted_list):\n                    min_diff = min(min_diff, abs(current_num - sorted_list[pos]))\n                \n                # Add the number that is now at least x indices away\n                sorted_list.add(nums[i - x])\n            \n            # Always add the current number to the sorted list for future comparisons\n            sorted_list.add(current_num)\n        \n        return min_diff"}
{"task_id": "3017", "solution": "class Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        def count_even_odd_digits(n: int) -> (int, int):\n            even_count = 0\n            odd_count = 0\n            for digit in str(n):\n                if int(digit) % 2 == 0:\n                    even_count += 1\n                else:\n                    odd_count += 1\n            return even_count, odd_count\n        \n        beautiful_count = 0\n        \n        for num in range(low, high + 1):\n            even_count, odd_count = count_even_odd_digits(num)\n            if even_count == odd_count and num % k == 0:\n                beautiful_count += 1\n        \n        return beautiful_count"}
{"task_id": "3018", "solution": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        n, m = len(str1), len(str2)\n        \n        # If str2 is longer than str1, it's impossible to find a subsequence\n        if m > n:\n            return False\n        \n        i, j = 0, 0  # Pointers for str1 and str2\n        \n        while i < n and j < m:\n            if str1[i] == str2[j]:\n                # Characters match, move both pointers\n                i += 1\n                j += 1\n            else:\n                # Check if we can increment str1[i] to match str2[j]\n                next_char = chr((ord(str1[i]) - ord('a') + 1) % 26 + ord('a'))\n                if next_char == str2[j]:\n                    # Increment str1[i] to match str2[j]\n                    i += 1\n                else:\n                    # Cannot match, return false\n                    return False\n        \n        # If we've matched all characters in str2\n        return j == m"}
{"task_id": "3019", "solution": "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        count_L = moves.count('L')\n        count_R = moves.count('R')\n        count_Underscore = moves.count('_')\n        \n        # Furthest left position (using all Ls and treating all _s as Ls)\n        furthest_left = -(count_L + count_Underscore)\n        \n        # Furthest right position (using all Rs and treating all _s as Rs)\n        furthest_right = count_R + count_Underscore\n        \n        # The maximum distance from origin we can achieve\n        return max(abs(furthest_left), abs(furthest_right))"}
{"task_id": "3024", "solution": "class Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        \n        # If s equals t, we only need to check how many times we can rotate it to stay the same\n        if s == t:\n            # Any suffix can be moved to the front in k operations, which results in the same string.\n            return n % MOD\n        \n        # Prepare to count valid rotations of s that match t\n        valid_rotations = 0\n        \n        # We can form a double string to easily manage rotations\n        double_s = s + s\n        \n        # Check for all possible rotations\n        for i in range(n):\n            if double_s[i:i+n] == t:\n                valid_rotations += 1\n        \n        # Calculate the number of valid initial positions\n        # We need to solve (i + k) % n = j for each valid j\n        result = 0\n        \n        # For each valid starting point of t, count how many i can be valid\n        for j in range(n):\n            if (j - k) % n < 0:\n                start_index = (j - k + n) % n\n            else:\n                start_index = (j - k) % n\n            \n            if start_index < n:\n                result += valid_rotations\n        \n        return result % MOD"}
{"task_id": "3025", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        freq = Counter(nums)\n        operations = 0\n        \n        # Iterate from the largest power of 2 down to 1\n        for power in sorted(freq.keys(), reverse=True):\n            while target >= power and freq[power] > 0:\n                # Use the power to reduce the target\n                num_used = min(freq[power], target // power)\n                target -= num_used * power\n                freq[power] -= num_used\n            \n            # If we still need to reduce the target and we have no more of this power\n            if target > 0 and power > 1:\n                # We can split this power into two of half its value\n                # This counts as one operation\n                operations += freq[power]\n                # Each frequency count gives us two of the next lower power\n                freq[power // 2] += freq[power] * 2\n                freq[power] = 0\n        \n        # If after all operations we still have a target left, it's impossible\n        if target > 0:\n            return -1\n        \n        return operations"}
{"task_id": "3031", "solution": "class Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        mod = 12345\n        n = len(grid)\n        m = len(grid[0])\n        \n        total_product = 1\n        zero_count = 0\n        non_zero_product = 1\n        \n        # Calculate total product and count zeros\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    total_product *= grid[i][j]\n                    total_product %= mod  # Keep it within bounds\n                    non_zero_product *= grid[i][j]\n                    non_zero_product %= mod\n                else:\n                    zero_count += 1\n        \n        # Create result matrix\n        product_matrix = [[0] * m for _ in range(n)]\n        \n        if zero_count > 1:\n            # More than one zero means all products are zero\n            return product_matrix\n        elif zero_count == 1:\n            # One zero means only one position can have a non-zero value\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == 0:\n                        product_matrix[i][j] = non_zero_product\n                        break  # We can break since we only need to set one\n        else:\n            # No zeros, calculate product for each position\n            for i in range(n):\n                for j in range(m):\n                    product_matrix[i][j] = total_product * pow(grid[i][j], mod - 2, mod) % mod\n        \n        return product_matrix"}
{"task_id": "3032", "solution": "from typing import List\n\nclass Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n = len(receiver)\n        max_value = 0\n        \n        # Iterate over each player\n        for start in range(n):\n            visited = {}\n            current = start\n            total_sum = 0\n            passes = 0\n            \n            # Simulate passing until we either reach a cycle or k passes\n            while passes < k and current not in visited:\n                visited[current] = passes\n                total_sum += current\n                current = receiver[current]\n                passes += 1\n            \n            if passes < k:\n                # Cycle detected\n                cycle_start = current\n                cycle_sum = 0\n                cycle_length = 0\n                \n                # Calculate cycle properties\n                while True:\n                    cycle_sum += cycle_start\n                    cycle_start = receiver[cycle_start]\n                    cycle_length += 1\n                    if cycle_start in visited:\n                        break\n                \n                # Calculate the number of passes in the cycle\n                total_passes_in_cycle = k - passes\n                total_cycle_contribution = (total_passes_in_cycle // cycle_length) * cycle_sum\n                remainder_passes = total_passes_in_cycle % cycle_length\n                \n                # Add the rest of the contributions from the cycle to total_sum\n                total_sum += total_cycle_contribution\n                \n                # Add the remaining passes in the cycle\n                cycle_start = current\n                for _ in range(remainder_passes):\n                    total_sum += cycle_start\n                    cycle_start = receiver[cycle_start]\n                \n            else:\n                # No cycle, just finished passing k times\n                total_sum += sum(receiver[i] for i in visited)\n\n            max_value = max(max_value, total_sum)\n        \n        return max_value"}
{"task_id": "3033", "solution": "class Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        count1 = count2 = 0\n        \n        # Identify mismatches\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                if s1[i] == '1':\n                    count1 += 1  # Type 1 mismatch\n                else:\n                    count2 += 1  # Type 2 mismatch\n        \n        # Check feasibility\n        if (count1 + count2) % 2 != 0:\n            return -1\n        \n        # Calculate cost\n        pairs = min(count1, count2)\n        remaining_one = abs(count1 - count2)\n        \n        # Cost calculation\n        total_cost = pairs * x + (remaining_one // 2)\n        \n        return total_cost"}
{"task_id": "3034", "solution": "class Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        # A set to store all unique points covered by the cars\n        covered_points = set()\n        \n        # Iterate through each car's range\n        for start, end in nums:\n            # Add each point in the range [start, end] to the set\n            for point in range(start, end + 1):\n                covered_points.add(point)\n        \n        # Return the number of unique points covered\n        return len(covered_points)"}
{"task_id": "3044", "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        collected = set()\n        operations = 0\n        \n        # Iterate from the last element to the first\n        for num in reversed(nums):\n            operations += 1\n            if num <= k:\n                collected.add(num)\n            # Check if we have collected all required elements from 1 to k\n            if len(collected) == k:\n                break\n        \n        return operations"}
{"task_id": "3045", "solution": "from typing import List\n\nclass Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        sorted_nums = sorted(nums)\n        # Check if already sorted\n        if nums == sorted_nums:\n            return 0\n        \n        # Finding the rotation point\n        rotation_index = -1\n        for i in range(n):\n            if nums[i] > nums[(i + 1) % n]:\n                if rotation_index != -1:  # Found more than one rotation point\n                    return -1\n                rotation_index = (i + 1) % n\n        \n        # If there's a rotation point, check if it can be sorted\n        if rotation_index == -1:  # This means the array is fully sorted\n            return 0\n        \n        # Check if the rotation point leads to a sorted array\n        for i in range(1, n):\n            if nums[(rotation_index + i) % n] != sorted_nums[i - 1]:\n                return -1\n        \n        return rotation_index"}
{"task_id": "3046", "solution": "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        target_endings = [\"00\", \"25\", \"50\", \"75\"]\n        min_deletions = float('inf')  # Initialize to infinity for comparison\n        \n        # Iterate through each valid ending\n        for ending in target_endings:\n            second_digit = ending[1]  # The second digit we want to find first\n            first_digit = ending[0]   # The first digit we want to find after\n                \n            # Find the index of the second digit from the end\n            second_index = -1\n            for i in range(len(num) - 1, -1, -1):\n                if num[i] == second_digit:\n                    second_index = i\n                    break\n            \n            if second_index == -1:\n                continue  # If we can't find the second digit, skip this ending\n            \n            # Now find the first digit before the found second digit\n            first_index = -1\n            for i in range(second_index - 1, -1, -1):\n                if num[i] == first_digit:\n                    first_index = i\n                    break\n            \n            if first_index == -1:\n                continue  # If we can't find the first digit, skip this ending\n            \n            # Calculate how many deletions are needed\n            deletions = (len(num) - 1 - second_index) + (second_index - 1 - first_index)\n            min_deletions = min(min_deletions, deletions)\n        \n        return min_deletions if min_deletions != float('inf') else len(num)  # If no valid number, return the length of num"}
{"task_id": "3047", "solution": "from typing import List\nfrom collections import defaultdict\nfrom math import isqrt\n\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def prime_factorization(n):\n            factors = defaultdict(int)\n            for i in range(2, isqrt(n) + 1):\n                while n % i == 0:\n                    factors[i] += 1\n                    n //= i\n            if n > 1:\n                factors[n] += 1\n            return tuple((p, exp % 2) for p, exp in factors.items() if exp % 2 != 0)\n\n        groups = defaultdict(int)\n        \n        for num in nums:\n            key = prime_factorization(num)\n            groups[key] += num\n        \n        return max(groups.values(), default=0)"}
{"task_id": "3055", "solution": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        count_ones = s.count('1')\n        count_zeros = s.count('0')\n        \n        # Construct the maximum odd binary number\n        # Place all '1's first, then all '0's, and end with one '1'\n        if count_ones > 0:\n            return '1' * (count_ones - 1) + '0' * count_zeros + '1'\n        return \"\""}
{"task_id": "3080", "solution": "class Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        zero_count = sum(1 for num in nums if num == 0)\n        return zero_count + 1"}
{"task_id": "3081", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        # Count occurrences of each number\n        count = Counter(nums)\n        \n        # Find the maximum frequency of any single number\n        max_count = max(count.values())\n        \n        # The minimum length achievable is the maximum count of any number\n        return max_count"}
{"task_id": "3091", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        MOD = 10**9 + 7\n        max_sum = sum(nums)\n        \n        # Create a frequency dictionary\n        count = Counter(nums)\n        \n        # Initialize dp array\n        dp = [0] * (max_sum + 1)\n        dp[0] = 1  # there's one way to get sum 0, using the empty set\n        \n        # Process each unique number and its occurrences\n        for number, freq in count.items():\n            # Temporary array to hold current state\n            current_dp = dp[:]\n            # Update dp for the current number\n            for j in range(max_sum + 1):\n                for k in range(1, freq + 1):\n                    if j + k * number <= max_sum:\n                        current_dp[j + k * number] = (current_dp[j + k * number] + dp[j]) % MOD\n                    else:\n                        break\n            dp = current_dp\n        \n        # Count sums in the range [l, r]\n        result = sum(dp[l:r + 1]) % MOD\n        return result"}
{"task_id": "3093", "solution": "class Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        def count_set_bits(n: int) -> int:\n            return bin(n).count('1')  # Count the number of '1's in the binary representation\n        \n        total_sum = 0\n        for index in range(len(nums)):\n            if count_set_bits(index) == k:\n                total_sum += nums[index]\n        \n        return total_sum"}
{"task_id": "3094", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        total_operations = 0\n        pairs = 0\n        \n        for freq in count.values():\n            # Count how many operations we can do using groups of 3\n            ops_three = freq // 3\n            total_operations += ops_three\n            freq -= ops_three * 3\n            \n            # Count how many operations we can do using pairs of 2\n            if freq == 2:\n                total_operations += 1\n            elif freq == 1:\n                pairs += 1\n        \n        # Check if we can pair any leftover singles\n        if pairs % 2 != 0:\n            return -1\n        \n        total_operations += pairs // 2\n        return total_operations"}
{"task_id": "3104", "solution": "class Solution:\n    def countWays(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        \n        count = 0\n        \n        # Check for the case when no students are selected\n        if all(x > 0 for x in nums):\n            count += 1\n        \n        # Check for the case when all students are selected\n        if all(x < n for x in nums):\n            count += 1\n        \n        # Check for selections between 1 and n-1\n        for k in range(n):\n            if k > 0 and nums[k-1] < k and (k == n or nums[k] > k):\n                count += 1\n        \n        return count"}
{"task_id": "3106", "solution": "class Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        # Step 1: Initialize the DP array\n        dp = [-float('inf')] * (target + 1)\n        dp[0] = 0  # We can always make the sum of 0 with an empty subsequence\n        \n        # Step 2: Process each number in nums\n        for num in nums:\n            # Iterate backward to avoid using the same element more than once\n            for s in range(target, num - 1, -1):\n                if dp[s - num] != -float('inf'):\n                    dp[s] = max(dp[s], dp[s - num] + 1)\n        \n        # Step 5: Get the result\n        return dp[target] if dp[target] != -float('inf') else -1"}
{"task_id": "3114", "solution": "class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        max_sum = 0\n        \n        # Iterate over each possible peak\n        for peak in range(n):\n            # Build the left side heights\n            left_heights = [0] * (peak + 1)\n            left_heights[0] = maxHeights[0]\n            for i in range(1, peak + 1):\n                left_heights[i] = min(maxHeights[i], left_heights[i - 1] + 1)\n            \n            # Build the right side heights\n            right_heights = [0] * (n - peak)\n            right_heights[0] = maxHeights[peak]\n            for i in range(1, n - peak):\n                right_heights[i] = min(maxHeights[peak + i], right_heights[i - 1] + 1)\n            \n            # Combine heights and calculate the total sum\n            total_heights = left_heights + right_heights[1:]\n            current_sum = sum(total_heights)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum"}
{"task_id": "3141", "solution": "class Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        from collections import deque\n        \n        n = len(nums)\n        prefix_sum = [0] * (n * 2 + 1)  # Create a prefix sum for 2 repetitions of nums\n        for i in range(1, n * 2 + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n        min_length = float('inf')\n        q = deque()\n        \n        for i in range(n * 2 + 1):\n            while q and prefix_sum[i] - prefix_sum[q[0]] >= target:\n                min_length = min(min_length, i - q.popleft())\n\n            while q and prefix_sum[i] <= prefix_sum[q[-1]]:\n                q.pop()\n\n            q.append(i)\n\n        return min_length if min_length != float('inf') else -1"}
{"task_id": "3150", "solution": "class Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        left = 0\n        count_ones = 0\n        min_length = float('inf')\n        result = \"\"\n        \n        for right in range(n):\n            # Expand the window by including the character at right\n            if s[right] == '1':\n                count_ones += 1\n            \n            # Check if we have exactly k 1's\n            while count_ones > k:\n                if s[left] == '1':\n                    count_ones -= 1\n                left += 1\n            \n            # If we have exactly k 1's, check substring\n            if count_ones == k:\n                current_length = right - left + 1\n                current_substring = s[left:right + 1]\n                \n                # Update the result if we found a smaller substring\n                if current_length < min_length:\n                    min_length = current_length\n                    result = current_substring\n                elif current_length == min_length:\n                    result = min(result, current_substring)\n        \n        return result"}
{"task_id": "3151", "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        # Sort the processor times and tasks\n        processorTime.sort()\n        tasks.sort(reverse=True)\n        \n        # Create a min-heap to manage the finish times of the processors\n        finish_times = []\n        \n        # Initialize the heap with the initial availability of each processor\n        for pt in processorTime:\n            heapq.heappush(finish_times, pt)\n        \n        # Assign tasks to processors\n        for task in tasks:\n            # Get the earliest available processor\n            earliest_available = heapq.heappop(finish_times)\n            # Calculate the new finish time after processing the task\n            new_finish_time = earliest_available + task\n            # Push the updated finish time back into the heap\n            heapq.heappush(finish_times, new_finish_time)\n        \n        # The result is the maximum finish time in the heap\n        return max(finish_times)"}
{"task_id": "3153", "solution": "class Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Sort the array in descending order\n        nums.sort(reverse=True)\n        \n        # Select the top k elements\n        max_elements = nums[:k]\n        \n        # Calculate the sum of squares\n        sum_of_squares = sum(x * x for x in max_elements) % MOD\n        \n        return sum_of_squares"}
{"task_id": "3154", "solution": "from typing import List\n\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        max_value = float('-inf')  # Start with the smallest possible value\n        \n        n = len(nums)\n        # Iterate through indices for j\n        for j in range(1, n - 1):\n            # For each j, find possible i and k\n            for i in range(j):\n                for k in range(j + 1, n):\n                    triplet_value = (nums[i] - nums[j]) * nums[k]\n                    max_value = max(max_value, triplet_value)\n        \n        return max(max_value, 0)  # If max_value is negative, return 0."}
{"task_id": "3163", "solution": "class Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        total_sum = 0\n        \n        for i in range(n):\n            distinct_elements = set()\n            for j in range(i, n):\n                distinct_elements.add(nums[j])\n                distinct_count = len(distinct_elements)\n                total_sum += distinct_count ** 2\n        \n        return total_sum"}
{"task_id": "3164", "solution": "class Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        nums = []\n        result = []\n        prev_count = 0  # To count consecutive 'prev'\n        \n        for word in words:\n            if word == \"prev\":\n                prev_count += 1\n                # Calculate the index for last visited integer\n                if prev_count <= len(nums):\n                    last_visited = nums[-prev_count]  # Get the (prev_count)-th last element\n                else:\n                    last_visited = -1\n                result.append(last_visited)\n            else:\n                # Convert the word to an integer and append to nums\n                nums.append(int(word))\n                prev_count = 0  # Reset prev_count since we encountered a number\n        \n        return result"}
{"task_id": "3166", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        # Step 1: Count the frequency of each number\n        frequency_count = Counter(nums)\n        \n        # Step 2: Find the maximum frequency\n        max_freq = max(frequency_count.values())\n        \n        # Step 3: Return the maximum frequency as the minimum number of groups needed\n        return max_freq"}
{"task_id": "3171", "solution": "from typing import List\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1 = sum(nums1)\n        sum2 = sum(nums2)\n        zeros1 = nums1.count(0)\n        zeros2 = nums2.count(0)\n        \n        # Calculate the difference and the total number of zeros\n        diff = abs(sum1 - sum2)\n        total_zeros = zeros1 + zeros2\n        \n        # Check if it's possible to equalize the sums\n        if diff > total_zeros:\n            return -1\n        \n        # Calculate the minimum equal sum\n        return max(sum1, sum2) + diff"}
{"task_id": "3172", "solution": "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        # Step 1: Calculate total sum of integers from 1 to n\n        total_sum = n * (n + 1) // 2\n        \n        # Step 2: Calculate num2 (sum of integers divisible by m)\n        k = n // m  # number of multiples of m in the range\n        num2 = k * m * (k + 1) // 2  # sum of multiples of m\n        \n        # Step 3: Calculate num1 (sum of integers not divisible by m)\n        num1 = total_sum - num2\n        \n        # Step 4: Return the difference\n        return num1 - num2"}
{"task_id": "3174", "solution": "class Solution:\n    def minChanges(self, s: str) -> int:\n        n = len(s)\n        changes = 0\n        \n        for i in range(0, n, 2):\n            # Take the pair of characters\n            pair = s[i:i+2]\n            count_0_to_00 = 0\n            count_1_to_11 = 0\n            \n            # Count changes needed to make this pair \"00\"\n            if pair[0] == '1':\n                count_0_to_00 += 1\n            if pair[1] == '1':\n                count_0_to_00 += 1\n            \n            # Count changes needed to make this pair \"11\"\n            if pair[0] == '0':\n                count_1_to_11 += 1\n            if pair[1] == '0':\n                count_1_to_11 += 1\n            \n            # Choose the minimum of the two options\n            changes += min(count_0_to_00, count_1_to_11)\n        \n        return changes"}
{"task_id": "3176", "solution": "from typing import List\n\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n\n        for j in range(1, n - 1):\n            if nums[j] <= 1:  # nums[j] must be greater than both nums[i] and nums[k]\n                continue\n            \n            # Find valid i < j\n            valid_i = [nums[i] for i in range(j) if nums[i] < nums[j]]\n            # Find valid k > j\n            valid_k = [nums[k] for k in range(j + 1, n) if nums[k] < nums[j]]\n\n            if valid_i and valid_k:\n                # We have valid i's and k's for this j, calculate the minimum sum\n                min_i = min(valid_i)\n                min_k = min(valid_k)\n                current_sum = min_i + nums[j] + min_k\n                min_sum = min(min_sum, current_sum)\n\n        return min_sum if min_sum != float('inf') else -1"}
{"task_id": "3183", "solution": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        result = 0\n        \n        # Check each bit position from 0 to 30\n        for bit in range(31):\n            count = 0\n            \n            # Count how many numbers have the current bit set\n            for num in nums:\n                if num & (1 << bit):\n                    count += 1\n            \n            # If at least k numbers have this bit set, set it in the result\n            if count >= k:\n                result |= (1 << bit)\n        \n        return result"}
{"task_id": "3184", "solution": "from typing import List\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        max_sum = float('-inf')\n\n        for i in range(n):\n            dp[i] = nums[i]  # Each element can at least form a subsequence by itself\n            for j in range(i):\n                if nums[i] - nums[j] >= i - j:  # Check for balanced condition\n                    dp[i] = max(dp[i], dp[j] + nums[i])  # Update dp[i]\n\n            max_sum = max(max_sum, dp[i])  # Keep track of the maximum sum\n\n        return max_sum"}
{"task_id": "3188", "solution": "from typing import List\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        champion = 0\n        \n        # First find a candidate for the champion\n        for i in range(1, n):\n            if grid[i][champion] == 1:\n                champion = i\n        \n        # The candidate is in `champion`, now we need to check if it is indeed the champion\n        for j in range(n):\n            if j != champion and grid[champion][j] == 0:\n                # If there is any team j that is stronger than the champion, then champion is not the true champion\n                return -1  # This case shouldn't happen based on the problem statement\n        \n        return champion"}
{"task_id": "3190", "solution": "class Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        max1 = max(nums1)\n        max2 = max(nums2)\n\n        # Check current values\n        need_swap1 = (nums1[n-1] != max1)\n        need_swap2 = (nums2[n-1] != max2)\n\n        # If no swaps are needed for both\n        if not need_swap1 and not need_swap2:\n            return 0\n\n        # Indices where we can swap\n        pos_max1 = -1\n        pos_max2 = -1\n        \n        # Find positions for possible swaps\n        for i in range(n - 1):\n            if nums2[i] == max1:\n                pos_max1 = i\n            if nums1[i] == max2:\n                pos_max2 = i\n        \n        operations = 0\n\n        # Check what we need to swap\n        if need_swap1 and pos_max1 == -1:\n            return -1  # Cannot bring max1 to the end of nums1\n        if need_swap2 and pos_max2 == -1:\n            return -1  # Cannot bring max2 to the end of nums2\n\n        # Count the necessary swaps\n        if need_swap1:\n            operations += 1  # One swap for max1\n        if need_swap2:\n            operations += 1  # One swap for max2\n\n        return operations"}
{"task_id": "3192", "solution": "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        MOD = 10**9 + 7\n        max_product = 0\n        \n        # We compute the limit for the values of x\n        limit = (1 << n)  # This is 2^n\n        \n        # Iterate through all values of x from 0 to 2^n - 1\n        for x in range(limit):\n            # Calculate the products (a XOR x) and (b XOR x)\n            a_xor = a ^ x\n            b_xor = b ^ x\n            product = (a_xor * b_xor) % MOD\n            \n            # Update the maximum product found\n            max_product = max(max_product, product)\n        \n        return max_product"}
{"task_id": "3193", "solution": "from typing import List\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        max_xor = 0\n        \n        # Iterate through all pairs (x, y)\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                x = nums[i]\n                y = nums[j]\n                \n                # Check if (x, y) is a strong pair\n                if abs(x - y) <= min(x, y):\n                    # Calculate XOR\n                    current_xor = x ^ y\n                    # Update maximum XOR\n                    max_xor = max(max_xor, current_xor)\n        \n        return max_xor"}
{"task_id": "3194", "solution": "from typing import List\n\nclass Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        indices = []  # Step 1: Initialize an empty list\n        for index, word in enumerate(words):  # Step 2: Iterate over the words\n            if x in word:  # Step 3: Check for character presence\n                indices.append(index)  # Step 4: Store the index\n        return indices  # Step 5: Return the result"}
{"task_id": "3195", "solution": "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        # Step 1: Identify the positions of '1's (black balls)\n        black_positions = [i for i, char in enumerate(s) if char == '1']\n        \n        # Count of black balls\n        count_of_black_balls = len(black_positions)\n        \n        # Step 2: Calculate the total moves needed\n        total_moves = 0\n        \n        # Ideal position for the j-th black ball\n        for j in range(count_of_black_balls):\n            ideal_position = len(s) - count_of_black_balls + j\n            total_moves += black_positions[j] - ideal_position\n        \n        return total_moves"}
{"task_id": "3196", "solution": "from typing import List\n\nclass Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()  # Step 1: Sort the array\n        left = 0\n        total_operations = 0\n        max_freq = 0\n        \n        # Step 2: Use sliding window to find maximum frequency\n        for right in range(len(nums)):\n            # Calculate the number of operations needed to make all elements \n            # in the window equal to nums[right]\n            total_operations += nums[right]\n            \n            # The number of elements in the current window is (right - left + 1)\n            # We need to calculate the cost to convert all elements in the window\n            # to nums[right], which is:\n            # (current total - target value * count) <= k\n            while (right - left + 1) * nums[right] - total_operations > k:\n                total_operations -= nums[left]\n                left += 1\n            \n            # Update max frequency (current size of the window)\n            max_freq = max(max_freq, right - left + 1)\n        \n        return max_freq"}
{"task_id": "3199", "solution": "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        count = 0\n        for x1 in range(min(limit, n) + 1):\n            for x2 in range(min(limit, n - x1) + 1):\n                x3 = n - x1 - x2\n                if 0 <= x3 <= limit:\n                    count += 1\n        return count"}
{"task_id": "3200", "solution": "class Solution:\n    def stringCount(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        if n < 4:\n            return 0\n        \n        # Precompute factorials and inverse factorials\n        fact = [1] * (n + 1)\n        for i in range(2, n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n            \n        def mod_inv(x):\n            return pow(x, MOD - 2, MOD)\n        \n        inv_fact = [1] * (n + 1)\n        for i in range(2, n + 1):\n            inv_fact[i] = mod_inv(fact[i])\n        \n        # Total letters for \"leet\" => l, e, e, t\n        total = 1  # 1 'l'\n        total += 2  # 2 'e's\n        total += 1  # 1 't'\n        \n        # Total ways to arrange \"leet\" + extra letters\n        remaining = n - total\n        good_strings = (fact[n] * inv_fact[1] % MOD * inv_fact[2] % MOD * inv_fact[1] % MOD) * pow(26, remaining, MOD) % MOD\n        \n        return good_strings"}
{"task_id": "3203", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        half_n = n // 2\n        \n        # Count frequency of characters in the whole string\n        total_count = Counter(s)\n        \n        # Prepare to store results\n        results = []\n        \n        for a, b, c, d in queries:\n            # Count frequencies in the first substring\n            first_substr_count = Counter(s[a:b + 1])\n            # Count frequencies in the second substring\n            second_substr_count = Counter(s[c:d + 1])\n            \n            # Calculate combined character counts after rearrangement\n            combined_count = total_count.copy()\n            for char in first_substr_count:\n                combined_count[char] -= first_substr_count[char]\n            for char in second_substr_count:\n                combined_count[char] -= second_substr_count[char]\n                \n            # Check if we can form a palindrome\n            odd_count = sum(1 for count in combined_count.values() if count % 2 != 0)\n            \n            # For even length string, there should be no odd counts\n            results.append(odd_count == 0)\n        \n        return results"}
{"task_id": "3206", "solution": "from typing import List\n\nclass Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Convert lists to sets to get unique elements\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # Count the number of unique elements in nums1 present in nums2\n        count1 = len(set1.intersection(set2))\n        \n        # Count the number of unique elements in nums2 present in nums1\n        count2 = len(set2.intersection(set1))\n        \n        # Return the results as a list\n        return [count1, count2]"}
{"task_id": "3207", "solution": "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        # Step 1: Find the lengths of the strings\n        len1, len2, len3 = len(s1), len(s2), len(s3)\n\n        # Step 2: Identify the longest common suffix\n        common_suffix_length = 0\n        while (len1 - common_suffix_length - 1 >= 0 and\n               len2 - common_suffix_length - 1 >= 0 and\n               len3 - common_suffix_length - 1 >= 0 and\n               s1[len1 - common_suffix_length - 1] == s2[len2 - common_suffix_length - 1] == s3[len3 - common_suffix_length - 1]):\n            common_suffix_length += 1\n        \n        # Step 3: Calculate the required operations\n        operations = (len1 - common_suffix_length) + (len2 - common_suffix_length) + (len3 - common_suffix_length)\n        \n        # Step 4: If there is no common suffix and the strings are not equal, return -1\n        if common_suffix_length == 0 and (s1 != s2 or s2 != s3 or s1 != s3):\n            return -1\n        \n        return operations"}
{"task_id": "3209", "solution": "from typing import List\n\nclass Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        total_cost = 0\n        i = 0\n        n = len(prices)\n\n        while i < n:\n            total_cost += prices[i]  # Purchase the i-th fruit\n            i += (i + 1)  # Move to the next fruit after taking i fruits for free\n            \n        return total_cost"}
{"task_id": "3210", "solution": "class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        vowels_set = {'a', 'e', 'i', 'o', 'u'}\n        n = len(s)\n        beautiful_count = 0\n        \n        for start in range(n):\n            vowels_count = 0\n            consonants_count = 0\n            \n            for end in range(start, n):\n                if s[end] in vowels_set:\n                    vowels_count += 1\n                else:\n                    consonants_count += 1\n                \n                if vowels_count == consonants_count:\n                    if (vowels_count * consonants_count) % k == 0:\n                        beautiful_count += 1\n        \n        return beautiful_count"}
{"task_id": "3211", "solution": "class Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        \n        max_length = 1\n        current_length = 1\n\n        for i in range(1, n):\n            if nums[i] >= nums[i - 1]:\n                current_length += 1\n            else:\n                # Update max length with the current non-decreasing segment\n                max_length = max(max_length, current_length)\n                # Check if we can merge the current segment with the next\n                if i < n - 1 and nums[i - 1] + nums[i] >= nums[i + 1]:\n                    current_length = i - (i - current_length) + 1  # Reset the length from the last non-decreasing\n                else:\n                    current_length = 1  # Reset to 1 as current element starts a new segment\n        \n        # Final check for the last segment\n        max_length = max(max_length, current_length)\n        \n        return max_length"}
{"task_id": "3212", "solution": "class Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Dynamic programming array\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case: 1 way to partition an empty array\n        \n        # Last occurrence of each number\n        last_occurrence = {}\n        \n        for i in range(1, n + 1):\n            num = nums[i - 1]\n            dp[i] = (2 * dp[i - 1]) % MOD  # Start with 2 times the previous\n            \n            if num in last_occurrence:\n                j = last_occurrence[num]\n                dp[i] = (dp[i] - dp[j - 1]) % MOD  # Exclude invalid partitions\n            \n            last_occurrence[num] = i  # Update last occurrence of the number\n        \n        return dp[n]"}
{"task_id": "3213", "solution": "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        max_num = max(nums)\n        indices = [i for i, num in enumerate(nums) if num == max_num]\n        count = 0\n        \n        # If there are fewer than k occurrences, directly return 0\n        if len(indices) < k:\n            return 0\n        \n        # Traverse through the indices to find the valid subarrays\n        for i in range(len(indices) - k + 1):\n            left = indices[i] - (indices[i - 1] if i > 0 else -1)  # elements to the left of the current window\n            right = (indices[i + k - 1] + 1) - indices[i + k - 2]  # elements to the right of the current window\n            count += left * right\n        \n        return count"}
{"task_id": "3219", "solution": "class Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        from collections import defaultdict\n        \n        n = len(nums)\n        \n        # Union-Find (Disjoint Set Union) implementation\n        parent = list(range(n))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootY] = rootX\n        \n        # Create connections based on the limit\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) <= limit:\n                    union(i, j)\n        \n        # Group indices by their root parent\n        groups = defaultdict(list)\n        for i in range(n):\n            root = find(i)\n            groups[root].append(i)\n        \n        # Create the result array\n        result = nums[:]\n        \n        # For each group, sort the values and assign them back\n        for indices in groups.values():\n            # Extract values and sort them\n            values = [nums[i] for i in indices]\n            values.sort()\n            # Place them back in sorted order\n            for idx, value in zip(sorted(indices), values):\n                result[idx] = value\n        \n        return result"}
{"task_id": "3220", "solution": "class Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        tested_count = 0  # Initialize the counter for tested devices\n        n = len(batteryPercentages)  # Get the number of devices\n        \n        for i in range(n):\n            if batteryPercentages[i] > 0:  # Check if the current device can be tested\n                tested_count += 1  # Increment the count of tested devices\n                # Update the battery percentages of subsequent devices\n                for j in range(i + 1, n):\n                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)\n        \n        return tested_count  # Return the total count of tested devices"}
{"task_id": "3221", "solution": "from typing import List\n\nclass Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        peaks = []\n        n = len(mountain)\n        \n        # Iterate from the second element to the second to last element\n        for i in range(1, n - 1):\n            # Check if the current element is greater than its neighbors\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n                peaks.append(i)\n        \n        return peaks"}
{"task_id": "3223", "solution": "class Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        from collections import defaultdict\n        \n        n = len(word)\n        left = 0\n        count_complete_substrings = 0\n        frequency = defaultdict(int)\n        \n        for right in range(n):\n            frequency[word[right]] += 1\n\n            # Check if the current window is valid\n            while left <= right:\n                # Check if every character in the frequency dict has exactly 'k' occurrences\n                if all(freq == k for freq in frequency.values()) and self.is_valid(word[left:right + 1]):\n                    # Count all complete substrings from current left to right\n                    count_complete_substrings += 1\n                    break\n                else:\n                    frequency[word[left]] -= 1\n                    if frequency[word[left]] == 0:\n                        del frequency[word[left]]\n                    left += 1\n                \n        return count_complete_substrings\n    \n    def is_valid(self, substring: str) -> bool:\n        for i in range(len(substring) - 1):\n            if abs(ord(substring[i]) - ord(substring[i + 1])) > 2:\n                return False\n        return True"}
{"task_id": "3224", "solution": "from typing import List\n\nclass Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Precompute factorials up to n\n        factorial = [1] * (n + 1)\n        for i in range(2, n + 1):\n            factorial[i] = factorial[i - 1] * i % MOD\n        \n        # Determine the gaps of non-infected children\n        total_ways = 1\n        last_sick_pos = -1\n        \n        for sick_pos in sick:\n            # Count the number of non-infected children in the current gap\n            non_infected_count = sick_pos - last_sick_pos - 1  # Children between last sick and current sick\n            if non_infected_count > 0:\n                total_ways = total_ways * factorial[non_infected_count] % MOD\n            \n            last_sick_pos = sick_pos\n        \n        # Handle the gap after the last infected child\n        non_infected_count = n - last_sick_pos - 1\n        if non_infected_count > 0:\n            total_ways = total_ways * factorial[non_infected_count] % MOD\n        \n        return total_ways"}
{"task_id": "3225", "solution": "class Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        frequency = {}\n        max_length = 0\n        start = 0\n        \n        for end in range(len(nums)):\n            # Include the current element in the window\n            frequency[nums[end]] = frequency.get(nums[end], 0) + 1\n            \n            # Check if the current window is valid\n            while frequency[nums[end]] > k:\n                frequency[nums[start]] -= 1\n                if frequency[nums[start]] == 0:\n                    del frequency[nums[start]]\n                start += 1\n            \n            # Update the maximum length of the good subarray\n            max_length = max(max_length, end - start + 1)\n        \n        return max_length"}
{"task_id": "3226", "solution": "from typing import List\n\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        # Step 1: Sort the array\n        nums.sort()\n        arr = []\n        \n        # Step 2: Iterate through the sorted array in pairs\n        for i in range(0, len(nums), 2):\n            # Alice removes the smaller element\n            alice_removed = nums[i]\n            # Bob removes the next smaller element\n            bob_removed = nums[i + 1]\n            # Step 3: Append Bob's removed element first, then Alice's\n            arr.append(bob_removed)\n            arr.append(alice_removed)\n        \n        # Step 4: Return the resulting array\n        return arr"}
{"task_id": "3227", "solution": "from typing import List\n\nclass Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        total_sum = n * n * (n * n + 1) // 2  # Expected sum of numbers from 1 to n^2\n        seen_numbers = set()\n        current_sum = 0\n        repeating_number = -1\n\n        for row in grid:\n            for number in row:\n                if number in seen_numbers:\n                    repeating_number = number\n                else:\n                    seen_numbers.add(number)\n                    current_sum += number\n        \n        missing_number = total_sum - current_sum\n        \n        return [repeating_number, missing_number]"}
{"task_id": "3228", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        # Count frequencies of each number in nums1 and nums2\n        counter1 = Counter(nums1)\n        counter2 = Counter(nums2)\n        \n        # Get unique elements from both counters\n        unique_nums1 = set(counter1.keys())\n        unique_nums2 = set(counter2.keys())\n        \n        # Calculate the total unique elements\n        total_unique = len(unique_nums1 | unique_nums2)  # Union of both sets\n        \n        # The maximum size of the set s we can achieve\n        n = len(nums1)  # or len(nums2), since they are equal\n        max_possible_size = n  # We can have at most n unique elements after removals\n        \n        # The result is the minimum of total unique elements and max possible size\n        return min(total_unique, max_possible_size)"}
{"task_id": "3229", "solution": "class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        def generate_palindromes(limit):\n            palindromes = []\n            # Generate palindromes by iterating through numbers and creating their mirror\n            for i in range(1, 10**5):\n                s = str(i)\n                # Create palindromes of odd and even lengths\n                palindromes.append(int(s + s[-2::-1]))  # Odd length\n                palindromes.append(int(s + s[::-1]))    # Even length\n            return [p for p in palindromes if p < limit]\n\n        # Step 1: Generate all palindromic numbers less than 10^9\n        palindromic_numbers = generate_palindromes(10**9)\n        \n        # Step 2: Calculate minimum cost\n        min_cost = float('inf')\n        \n        for p in palindromic_numbers:\n            total_cost = sum(abs(num - p) for num in nums)\n            min_cost = min(min_cost, total_cost)\n        \n        return min_cost"}
{"task_id": "3230", "solution": "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        n = len(word)\n        if n == 0:\n            return 0\n        \n        operations = 0\n        new_word = list(word)  # Convert string to list for mutability\n        \n        for i in range(n - 1):\n            if self.isAlmostEqual(new_word[i], new_word[i + 1]):\n                # We need to change new_word[i + 1]\n                operations += 1\n                new_word[i + 1] = self.getReplacementCharacter(new_word[i], new_word[i + 1])\n\n        return operations\n    \n    def isAlmostEqual(self, a: str, b: str) -> bool:\n        return a == b or abs(ord(a) - ord(b)) == 1\n    \n    def getReplacementCharacter(self, c1: str, c2: str) -> str:\n        excluded = {c1, c2}\n        for ch in range(ord('a'), ord('z') + 1):\n            candidate = chr(ch)\n            if candidate not in excluded and not self.isAlmostEqual(candidate, c1) and not self.isAlmostEqual(candidate, c2):\n                return candidate\n        return c1  # Fallback, shouldn't reach here in normal cases"}
{"task_id": "3231", "solution": "class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        # Sort the coins to handle smaller denominations first\n        coins.sort()\n        \n        curr = 0  # This will track the maximum obtainable amount\n        added_coins = 0  # This will count the number of added coins\n        index = 0  # To iterate through the coins array\n        \n        while curr < target:\n            if index < len(coins) and coins[index] <= curr + 1:\n                # If the current coin can help us reach curr + 1\n                curr += coins[index]\n                index += 1\n            else:\n                # We need to add coin of value curr + 1\n                added_coins += 1\n                curr += (curr + 1)  # Now curr can reach curr + 1\n        \n        return added_coins"}
{"task_id": "3233", "solution": "class Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        \n        def count_partitions(s, k):\n            distinct_count = 0\n            char_count = {}\n            partitions = 0\n            \n            for char in s:\n                if char not in char_count:\n                    char_count[char] = 0\n                    distinct_count += 1\n                char_count[char] += 1\n                \n                if distinct_count > k:\n                    partitions += 1\n                    # Reset for new partition\n                    char_count.clear()\n                    char_count[char] = 1\n                    distinct_count = 1\n            \n            # Count the last partition if there are any remaining characters\n            if char_count:\n                partitions += 1\n            \n            return partitions\n        \n        # Start with partitions from the original string\n        max_partitions = count_partitions(s, k)\n        \n        n = len(s)\n        \n        # Try changing each character and count partitions\n        for i in range(n):\n            original_char = s[i]\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == original_char:\n                    continue\n                \n                # Create a new string with the change\n                new_str = s[:i] + c + s[i+1:]\n                max_partitions = max(max_partitions, count_partitions(new_str, k))\n        \n        return max_partitions"}
{"task_id": "3234", "solution": "from typing import List\n\nclass Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        good_indices = []\n        \n        for i in range(len(variables)):\n            a_i, b_i, c_i, m_i = variables[i]\n            last_digit = pow(a_i, b_i, 10)  # Step 2: Calculate a_i^b_i % 10\n            result = pow(last_digit, c_i, m_i)  # Step 3: Calculate (last_digit)^c_i % m_i\n            \n            if result == target:  # Step 5: Compare with target\n                good_indices.append(i)  # Step 6: Collect good index\n        \n        return good_indices  # Return the list of good indices"}
{"task_id": "3235", "solution": "class Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        from collections import defaultdict\n        import sys\n        \n        # Step 1: Track character differences\n        n = len(source)\n        if n != len(target):\n            return -1\n        \n        # Cost map to track transformations\n        cost_map = defaultdict(list)\n        for o, c, z in zip(original, changed, cost):\n            cost_map[o].append((c, z))  # original character -> list of (changed character, cost)\n\n        # Step 2: Determine changes needed\n        total_cost = 0\n        for i in range(n):\n            src_char = source[i]\n            tgt_char = target[i]\n            if src_char != tgt_char:\n                # Step 3: Check if transformation is possible\n                if src_char not in cost_map:\n                    return -1  # Can't transform src_char to anything\n                \n                # Find the minimum cost to change src_char to tgt_char\n                min_cost = sys.maxsize\n                for changed_char, trans_cost in cost_map[src_char]:\n                    if changed_char == tgt_char:\n                        min_cost = min(min_cost, trans_cost)\n                    # Consider chaining transformations if needed\n                    if changed_char in cost_map:\n                        for next_changed_char, next_cost in cost_map[changed_char]:\n                            if next_changed_char == tgt_char:\n                                min_cost = min(min_cost, trans_cost + next_cost)\n                \n                if min_cost == sys.maxsize:\n                    return -1  # No valid transformation found\n                \n                total_cost += min_cost\n        \n        return total_cost"}
{"task_id": "3236", "solution": "class Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        n = len(nums)\n        \n        # Step 1: Find the longest sequential prefix and its sum\n        longest_sum = 0\n        current_sum = 0\n        current_length = 0\n        \n        for i in range(n):\n            if i == 0 or nums[i] == nums[i - 1] + 1:\n                current_sum += nums[i]\n                current_length += 1\n            else:\n                if current_length > 0:\n                    longest_sum = max(longest_sum, current_sum)\n                current_sum = nums[i]\n                current_length = 1\n        \n        # To account for the last sequential prefix if it was the longest\n        longest_sum = max(longest_sum, current_sum)\n        \n        # Step 2: Create a set of nums for fast lookup\n        nums_set = set(nums)\n        \n        # Step 3: Find the smallest integer >= longest_sum that is missing\n        x = longest_sum\n        while x in nums_set:\n            x += 1\n        \n        return x"}
{"task_id": "3239", "solution": "class Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        from collections import deque\n        \n        # If x is already equal to y, return 0\n        if x == y:\n            return 0\n        \n        # Initialize the queue for BFS and the visited set\n        queue = deque([(x, 0)])  # (current value of x, operations count)\n        visited = set([x])\n        \n        while queue:\n            current, operations = queue.popleft()\n            \n            # Generate possible next states\n            next_states = [current - 1, current + 1]\n            if current % 5 == 0:\n                next_states.append(current // 5)\n            if current % 11 == 0:\n                next_states.append(current // 11)\n            \n            for next_x in next_states:\n                # Check if we reached the target\n                if next_x == y:\n                    return operations + 1\n                \n                # If the next x is within the valid range and not visited\n                if 1 <= next_x <= 10000 and next_x not in visited:\n                    visited.add(next_x)\n                    queue.append((next_x, operations + 1))\n        \n        return -1  # Just a fallback; should never reach here as we will find y."}
{"task_id": "3240", "solution": "class Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        \n        def price(num: int) -> int:\n            # Count set bits at positions that are multiples of x\n            p = 0\n            pos = 1\n            while num > 0:\n                if num % 2 == 1 and pos % x == 0:\n                    p += 1\n                num //= 2\n                pos += 1\n            return p\n        \n        left, right = 1, k + 1\n        while left < right:\n            mid = (left + right) // 2\n            total_price = sum(price(i) for i in range(1, mid + 1))\n            \n            if total_price <= k:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left - 1"}
{"task_id": "3242", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        # Step 1: Count frequencies of each element\n        frequency_counts = Counter(nums)\n        \n        # Step 2: Determine maximum frequency\n        max_freq = max(frequency_counts.values())\n        \n        # Step 3: Calculate total frequencies of elements with maximum frequency\n        total_max_freq_elements = sum(count for count in frequency_counts.values() if count == max_freq)\n        \n        # Step 4: Return the result\n        return total_max_freq_elements"}
{"task_id": "3243", "solution": "class Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        suffix = int(s)\n        len_s = len(s)\n        power_of_ten = 10 ** len_s\n        \n        k_min = (start - suffix + power_of_ten - 1) // power_of_ten  # Ceiling division\n        k_max = (finish - suffix) // power_of_ten  # Floor division\n        \n        count = 0\n        \n        for k in range(k_min, k_max + 1):\n            powerful_int = k * power_of_ten + suffix\n            if powerful_int > finish:\n                break  # No need to check further if we've exceeded finish\n            \n            # Check if all digits of powerful_int are <= limit\n            if all(int(digit) <= limit for digit in str(powerful_int)):\n                count += 1\n        \n        return count"}
{"task_id": "3244", "solution": "from typing import List\nfrom math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        # Calculate the GCD of the entire array\n        overall_gcd = reduce(gcd, nums)\n        \n        # Count how many numbers are equal to the GCD\n        gcd_count = nums.count(overall_gcd)\n        \n        # If the GCD count is greater than 1, we can reduce it to 2\n        # If it is 1, we can reduce it to 1\n        return max(1, gcd_count)"}
{"task_id": "3245", "solution": "from typing import List\n\nclass Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        a_length = len(a)\n        b_length = len(b)\n        \n        # Step 1: Find all indices of 'a' in 's'\n        a_indices = []\n        for i in range(len(s) - a_length + 1):\n            if s[i:i + a_length] == a:\n                a_indices.append(i)\n        \n        # Step 2: Find all indices of 'b' in 's'\n        b_indices = []\n        for j in range(len(s) - b_length + 1):\n            if s[j:j + b_length] == b:\n                b_indices.append(j)\n        \n        # Step 3: Check for beautiful indices\n        beautiful_indices = set()\n        for i in a_indices:\n            for j in b_indices:\n                if abs(j - i) <= k:\n                    beautiful_indices.add(i)\n                    break  # No need to check more b_indices for this a index\n        \n        # Step 4: Return the sorted list of beautiful indices\n        return sorted(beautiful_indices)"}
{"task_id": "3246", "solution": "class Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        even_count = 0\n        \n        for num in nums:\n            if num % 2 == 0:\n                even_count += 1\n            \n            # Early exit if we already found two even numbers\n            if even_count >= 2:\n                return True\n        \n        return False"}
{"task_id": "3249", "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Step 1: Calculate the initial XOR of all elements in nums\n        current_xor = 0\n        for num in nums:\n            current_xor ^= num\n        \n        # Step 2: Calculate the difference with the target k\n        diff = current_xor ^ k\n        \n        # Step 3: Count the number of set bits in diff\n        count_set_bits = 0\n        while diff > 0:\n            count_set_bits += diff & 1\n            diff >>= 1\n        \n        # The number of set bits is the minimum required operations\n        return count_set_bits"}
{"task_id": "3251", "solution": "from typing import List\n\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        max_diagonal_squared = -1\n        max_area = 0\n\n        for length, width in dimensions:\n            diagonal_squared = length * length + width * width\n            area = length * width\n            \n            if (diagonal_squared > max_diagonal_squared) or (diagonal_squared == max_diagonal_squared and area > max_area):\n                max_diagonal_squared = diagonal_squared\n                max_area = area\n\n        return max_area"}
{"task_id": "3252", "solution": "class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        \n        # Function to check if an array is strictly increasing\n        def is_strictly_increasing(arr):\n            for i in range(len(arr) - 1):\n                if arr[i] >= arr[i + 1]:  # Not strictly increasing\n                    return False\n            return True\n        \n        # Iterate through all possible subarrays\n        for start in range(n):\n            for end in range(start, n):  # end is inclusive\n                # Create a new array with the subarray removed\n                new_array = nums[:start] + nums[end + 1:]\n                \n                # Check if the new array is strictly increasing\n                if is_strictly_increasing(new_array):\n                    count += 1\n        \n        return count"}
{"task_id": "3261", "solution": "class Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        # Step 1: Calculate the initial OR\n        initial_or = 0\n        for num in nums:\n            initial_or |= num\n        \n        # Step 2: Store potential reductions\n        potential_reductions = []\n        for i in range(len(nums) - 1):\n            and_val = nums[i] & nums[i + 1]\n            potential_reductions.append((and_val, i))\n        \n        # Step 3: Sort based on potential reduction values\n        potential_reductions.sort()  # Sort by AND result, in ascending order\n        \n        # Step 4: Apply up to k operations\n        for i in range(min(k, len(potential_reductions))):\n            and_val, index = potential_reductions[i]\n            # Replace nums[index] and nums[index + 1] with their AND result\n            nums[index] = and_val\n            # Remove the next element\n            nums.pop(index + 1)\n            \n            # Recalculate potential reductions\n            if index > 0:  # There's a previous element\n                and_val = nums[index - 1] & nums[index]\n                potential_reductions.append((and_val, index - 1))\n            if index < len(nums) - 1:  # There's a next element\n                and_val = nums[index] & nums[index + 1]\n                potential_reductions.append((and_val, index))\n            \n            # Resort the potential reductions after each operation\n            potential_reductions.sort()\n        \n        # Step 5: Calculate final OR\n        final_or = 0\n        for num in nums:\n            final_or |= num\n        \n        return final_or"}
{"task_id": "3262", "solution": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        # Step 1: Sort the array\n        nums.sort()\n        \n        # Step 2: Iterate from the largest sides\n        for i in range(len(nums) - 1, 1, -1):\n            # Get the three largest sides\n            a, b, c = nums[i-2], nums[i-1], nums[i]\n            # Step 3: Check the polygon condition\n            if a + b > c:\n                return a + b + c  # Return the perimeter\n        \n        # Step 4: If no valid polygon is found, return -1\n        return -1"}
{"task_id": "3263", "solution": "class Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        # Initialize the DP table with infinity\n        dp = [[float('inf')] * 4 for _ in range(n)]\n        \n        # Base case: Cost for 1 subarray\n        for i in range(n):\n            dp[i][1] = nums[0]  # Only the first element contributes to cost\n        \n        # Fill the DP table\n        for j in range(2, 4):  # For j = 2 and 3 subarrays\n            for i in range(j - 1, n):  # We need at least j-1 elements before index i\n                for k in range(j - 2, i):  # k is the start of the last subarray\n                    dp[i][j] = min(dp[i][j], dp[k][j - 1] + nums[k + 1])\n        \n        # The answer is the minimum cost with 3 subarrays\n        return dp[n - 1][3]"}
{"task_id": "3265", "solution": "class Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        index_map = {}\n        max_sum = float('-inf')\n        n = len(nums)\n\n        # Iterate through the array and store indices\n        for i in range(n):\n            index_map[nums[i]] = i\n\n        # Find the maximum sum of good subarrays\n        for i in range(n):\n            start_value = nums[i]\n            # Check for potential endpoints\n            for end_value in (start_value + k, start_value - k):\n                if end_value in index_map:\n                    j = index_map[end_value]\n                    if j >= i:  # Ensure that j is greater than or equal to i\n                        max_sum = max(max_sum, sum(nums[i:j + 1]))\n\n        return max_sum if max_sum != float('-inf') else 0"}
{"task_id": "3267", "solution": "class Solution:\n    def maximumLength(self, s: str) -> int:\n        from collections import defaultdict\n        \n        # Dictionary to store counts of special substrings\n        count_dict = defaultdict(int)\n        \n        n = len(s)\n        i = 0\n        \n        # Iterate through the string to find contiguous segments of the same character\n        while i < n:\n            char = s[i]\n            start = i\n            \n            # Move i forward to find the end of the segment\n            while i < n and s[i] == char:\n                i += 1\n            \n            # Length of the current segment of the same character\n            length = i - start\n            \n            # Generate all special substrings of this character segment\n            for l in range(1, length + 1):\n                count_dict[char * l] += 1\n        \n        # Find the maximum length of special substrings that occur at least thrice\n        max_length = -1\n        for substr, count in count_dict.items():\n            if count >= 3:\n                max_length = max(max_length, len(substr))\n        \n        return max_length"}
{"task_id": "3269", "solution": "class Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        count = 0\n        m = len(pattern)\n        n = len(nums)\n\n        # Iterate over each possible starting index for subarrays of size m + 1\n        for i in range(n - m):\n            match = True\n            for k in range(m):\n                if pattern[k] == 1:\n                    if not (nums[i + k + 1] > nums[i + k]):\n                        match = False\n                        break\n                elif pattern[k] == 0:\n                    if not (nums[i + k + 1] == nums[i + k]):\n                        match = False\n                        break\n                elif pattern[k] == -1:\n                    if not (nums[i + k + 1] < nums[i + k]):\n                        match = False\n                        break\n            if match:\n                count += 1\n\n        return count"}
{"task_id": "3279", "solution": "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        count_odds = (m + 1) // 2  # Count of odd y values from 1 to m\n        count_evens = m // 2       # Count of even y values from 1 to m\n        total_pairs = 0\n        \n        for x in range(1, n + 1):\n            if x % 2 == 1:  # x is odd\n                total_pairs += count_evens  # We can pair with even y's\n            else:           # x is even\n                total_pairs += count_odds     # We can pair with odd y's\n        \n        return total_pairs"}
{"task_id": "3291", "solution": "from typing import List\nclass Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        # Step 1: Count set bits and group numbers\n        groups = {}\n        for num in nums:\n            count = bin(num).count('1')  # Count set bits\n            if count not in groups:\n                groups[count] = []\n            groups[count].append(num)\n\n        # Step 2: Sort each group\n        for count in groups:\n            groups[count].sort()\n\n        # Step 3: Reconstruct the array\n        reconstructed = []\n        for num in nums:\n            count = bin(num).count('1')\n            reconstructed.append(groups[count].pop(0))  # Take the smallest from the group\n\n        # Step 4: Compare with sorted array\n        return reconstructed == sorted(nums)"}
{"task_id": "3292", "solution": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n = len(nums)\n        m = len(changeIndices)\n\n        marked = [False] * n  # Track marked indices\n        remaining = nums[:]   # Remaining decrements for each index\n        marked_count = 0      # Count of marked indices\n\n        for second in range(1, m + 1):\n            idx = changeIndices[second - 1] - 1  # Convert to 0-indexed\n\n            # If this index is already marked, continue\n            if marked[idx]:\n                continue\n            \n            # If we can mark it now, do it\n            if remaining[idx] == 0:\n                marked[idx] = True\n                marked_count += 1\n                continue\n            \n            # If we can't mark it, we need to decrement it\n            # Decrementing logic\n            for i in range(second - 1, -1, -1):\n                if marked_count == n:  # All marked, no need to do more\n                    break\n                change_idx = changeIndices[i] - 1  # Convert to 0-indexed\n                # Decrement only if it's not already marked\n                if not marked[change_idx] and remaining[change_idx] > 0:\n                    remaining[change_idx] -= 1\n            \n            # After attempting to decrement, check again if we can mark\n            if remaining[idx] == 0:\n                marked[idx] = True\n                marked_count += 1\n\n            # If all indices are marked, return the current second\n            if marked_count == n:\n                return second\n        \n        return -1 if marked_count < n else m"}
{"task_id": "3297", "solution": "import math\n\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        n = len(word)\n        \n        # Calculate LCM of n and k\n        lcm = (n * k) // math.gcd(n, k)\n        \n        # The minimum time is LCM(n, k) / k\n        return lcm // k"}
{"task_id": "3298", "solution": "class Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        # Create a frequency dictionary\n        freq = defaultdict(int)\n\n        # Count frequencies\n        for num in nums:\n            freq[num] += 1\n            freq[num + 1] += 1  # Count the possibility of increasing the number\n\n        max_consecutive = 0\n\n        # Iterate through the sorted unique keys of the frequency dictionary\n        for k in sorted(freq.keys()):\n            # Calculate the number of selectable elements for current `k`\n            count = freq[k]  # count of k\n            if k - 1 in freq:\n                count += freq[k - 1]  # count of k-1\n            if k + 1 in freq:\n                count += freq[k + 1]  # count of k+1\n            \n            # Update the maximum consecutive count\n            max_consecutive = max(max_consecutive, count)\n\n        return max_consecutive"}
{"task_id": "3299", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        # Step 1: Count occurrences of each number\n        count = Counter(nums)\n        max_length = 0\n        \n        # Step 2: Iterate through each unique number in the count\n        for x in count:\n            length = 0\n            power = 1\n            \n            # Step 3: Generate powers of x\n            while power <= 10**9:  # Until the power exceeds 10^9\n                if power in count:\n                    length += count[power]  # Add the count of this power\n                if power * x > 10**9:\n                    break  # Avoid overflow in the next multiplication\n                power *= x  # Move to the next power\n            \n            max_length = max(max_length, length)  # Step 5: Update max length\n        \n        return max_length"}
{"task_id": "3308", "solution": "class Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        positions = [-1] * 26  # Tracks last occurrence of each letter\n        \n        # Record last occurrences of each character\n        for i, char in enumerate(s):\n            positions[ord(char) - ord('a')] = i\n        \n        # This will keep track of the next string state\n        current_string = s\n        while True:\n            new_string = []\n            removed = [False] * 26\n            \n            # Build the new string based on current_string\n            for char in current_string:\n                idx = ord(char) - ord('a')\n                if not removed[idx]:  # If we haven't removed this character yet\n                    removed[idx] = True  # Mark it as removed for next iteration\n                else:\n                    new_string.append(char)  # Keep it if we've already removed it\n            \n            if not new_string:  # If the new string is empty, we stop\n                break\n            \n            current_string = ''.join(new_string)  # Update current_string\n        \n        return current_string  # This will be the last non-empty string"}
{"task_id": "3309", "solution": "class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        def isPrefixAndSuffix(str1, str2):\n            return str2.startswith(str1) and str2.endswith(str1)\n        \n        count = 0\n        n = len(words)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if isPrefixAndSuffix(words[i], words[j]):\n                    count += 1\n        \n        return count"}
{"task_id": "3311", "solution": "class Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        position = 0\n        boundary_count = 0\n\n        for num in nums:\n            move = num  # This is the amount to move\n            new_position = position + move\n            \n            # Check if the ant returns to the boundary after the move\n            if (position <= 0 < new_position) or (position >= 0 > new_position):\n                # If it crosses the boundary, we do not count this step\n                pass\n            else:\n                # Update the position\n                position = new_position\n            \n            # Check if the ant is back at the boundary\n            if position == 0:\n                boundary_count += 1\n\n        return boundary_count"}
{"task_id": "3312", "solution": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        changes = 0\n        for i in range(1, len(s)):\n            if s[i].lower() != s[i - 1].lower():\n                changes += 1\n        return changes"}
{"task_id": "3317", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        def is_palindrome(s: str) -> bool:\n            return s == s[::-1]\n        \n        # Count existing palindromes\n        palindrome_count = sum(is_palindrome(word) for word in words)\n        \n        # To check for potential new palindromes\n        non_palindrome_count = 0\n        character_frequency = Counter()\n        \n        for word in words:\n            if not is_palindrome(word):\n                non_palindrome_count += 1\n                character_frequency.update(word)\n        \n        # We can form new palindromes from non-palindromic words\n        # For a string to be a palindrome, at most one character can have an odd count\n        odd_count = sum(1 for count in character_frequency.values() if count % 2 == 1)\n        \n        # Each pair of odd frequency characters can potentially help form a new palindrome\n        # but we can only create palindromes based on the number of odd counts we have\n        additional_palindromes = non_palindrome_count // 2  # Each pair of non-palindromes can form a palindrome\n        if odd_count > 0:  # If there's an odd character count, we can form one additional palindrome\n            additional_palindromes += 1\n        \n        return palindrome_count + additional_palindromes"}
{"task_id": "3320", "solution": "class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        from collections import defaultdict\n\n        # Frequency dictionary to count occurrences of each score\n        score_count = defaultdict(int)\n        \n        # While we can perform operations\n        while len(nums) >= 2:\n            # Calculate the score of the first two elements\n            score = nums[0] + nums[1]\n            # Increment the count for this score\n            score_count[score] += 1\n            # Simulate deleting the first two elements\n            nums = nums[2:]\n        \n        # Return the maximum count of operations for any score\n        return max(score_count.values(), default=0)"}
{"task_id": "3324", "solution": "class Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        distinct_elements = set(nums)  # Step 1: Get unique elements\n        num_distinct = len(distinct_elements)  # Count of unique elements\n        half_length = len(nums) // 2  # Step 2: Calculate n/2\n        \n        # Step 3 and 4: Check if we can split\n        return num_distinct >= half_length"}
{"task_id": "3329", "solution": "from typing import List\n\nclass Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        def common_prefix_length(x: int, y: int) -> int:\n            str_x, str_y = str(x), str(y)\n            max_length = min(len(str_x), len(str_y))\n            length = 0\n            \n            for i in range(max_length):\n                if str_x[i] == str_y[i]:\n                    length += 1\n                else:\n                    break\n            \n            return length\n        \n        max_common_length = 0\n        \n        for num1 in arr1:\n            for num2 in arr2:\n                max_common_length = max(max_common_length, common_prefix_length(num1, num2))\n        \n        return max_common_length"}
{"task_id": "3331", "solution": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Step 1: Sort the array\n        nums.sort()\n        \n        # Step 2: Count how many elements are less than k\n        count = 0\n        for num in nums:\n            if num < k:\n                count += 1\n            else:\n                break  # No need to check further as the array is sorted\n        \n        # Step 3: Return the count of operations needed\n        return count"}
{"task_id": "3347", "solution": "from typing import List\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1 = []\n        arr2 = []\n        \n        # Step 2: Append the first two elements to arr1 and arr2\n        arr1.append(nums[0])\n        arr2.append(nums[1])\n        \n        # Step 3: Iterate through the rest of the nums starting from index 2\n        for i in range(2, len(nums)):\n            if arr1[-1] > arr2[-1]:\n                arr1.append(nums[i])\n            else:\n                arr2.append(nums[i])\n        \n        # Step 4: Concatenate arr1 and arr2\n        result = arr1 + arr2\n        \n        # Step 5: Return the result\n        return result"}
{"task_id": "abc301_a", "solution": "def determine_winner(N, S):\n    T_count = 0\n    A_count = 0\n\n    # Count wins for each player\n    for char in S:\n        if char == 'T':\n            T_count += 1\n        elif char == 'A':\n            A_count += 1\n\n    # Determine the overall winner\n    if T_count > A_count:\n        return 'T'\n    elif A_count > T_count:\n        return 'A'\n    else:\n        # If wins are equal, check who reached the count first\n        T_current = 0\n        A_current = 0\n        for char in S:\n            if char == 'T':\n                T_current += 1\n            elif char == 'A':\n                A_current += 1\n            \n            if T_current == T_count:\n                return 'T'\n            if A_current == A_count:\n                return 'A'\n\n# Reading input\nimport sys\ninput_data = sys.stdin.read().strip().split()\nN = int(input_data[0])\nS = input_data[1]\n\n# Output the result\nresult = determine_winner(N, S)\nprint(result)"}
{"task_id": "abc301_b", "solution": "def process_sequence(N, A):\n    while True:\n        modified = False\n        for i in range(N - 1):\n            if abs(A[i] - A[i + 1]) > 1:\n                if A[i] < A[i + 1]:\n                    # Insert numbers from A[i]+1 to A[i+1]-1\n                    A = A[:i + 1] + list(range(A[i] + 1, A[i + 1])) + A[i + 1:]\n                else:\n                    # Insert numbers from A[i]-1 to A[i+1]+1 in reverse\n                    A = A[:i + 1] + list(range(A[i] - 1, A[i + 1], -1)) + A[i + 1:]\n                modified = True\n                N = len(A)\n                break  # restart from the beginning after modification\n        if not modified:\n            break\n    \n    return ' '.join(map(str, A))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nA = list(map(int, data[1].split()))\n\n# Output the processed sequence\nprint(process_sequence(N, A))"}
{"task_id": "abc301_c", "solution": "def can_win(S, T):\n    from collections import Counter\n    \n    # Count characters in S and T\n    count_S = Counter(S)\n    count_T = Counter(T)\n    \n    # Count the @ characters\n    at_count_S = count_S.get('@', 0)\n    at_count_T = count_T.get('@', 0)\n    \n    # Calculate needed '@' to make S and T match\n    needed_at = 0\n    \n    # Iterate through each character in the alphabet\n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        needed_in_T = count_T.get(char, 0)\n        available_in_S = count_S.get(char, 0)\n        \n        # If T needs more of a character than S has, calculate how many more are needed\n        if needed_in_T > available_in_S:\n            needed_at += needed_in_T - available_in_S\n    \n    # Total '@' available from both strings\n    total_at_available = at_count_S + at_count_T\n    \n    # If we can fulfill the needed '@' with the available ones\n    if needed_at <= total_at_available:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read the inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split(\"\\n\")\nS = data[0]\nT = data[1]\n\n# Get the result\nresult = can_win(S, T)\n\n# Write the answer to stdout\nprint(result)"}
{"task_id": "abc301_d", "solution": "def max_binary_value(S, N):\n    from itertools import product\n    \n    # Identify positions of '?'\n    question_marks = [i for i, char in enumerate(S) if char == '?']\n    count_questions = len(question_marks)\n    \n    # If no '?', directly convert S to integer and check\n    if count_questions == 0:\n        result = int(S, 2)\n        return result if result <= N else -1\n    \n    max_value = -1\n    \n    # Generate all combinations of 0s and 1s for '?'\n    for combination in product('01', repeat=count_questions):\n        # Create a mutable list from S\n        current_string = list(S)\n        \n        # Replace '?' with the current combination values\n        for idx, replacement in zip(question_marks, combination):\n            current_string[idx] = replacement\n            \n        # Convert the current string to a binary integer\n        current_value = int(''.join(current_string), 2)\n        \n        # Update the maximum value if applicable\n        if current_value <= N:\n            max_value = max(max_value, current_value)\n    \n    return max_value\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nS = data[0]\nN = int(data[1])\n\n# Get the result\nresult = max_binary_value(S, N)\n\n# Print the result\nprint(result)"}
{"task_id": "abc301_e", "solution": "from collections import deque\n\ndef bfs(start, grid, H, W):\n    distances = [[float('inf')] * W for _ in range(H)]\n    distances[start[0]][start[1]] = 0\n    queue = deque([start])\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '#':\n                if distances[nx][ny] == float('inf'):\n                    distances[nx][ny] = distances[x][y] + 1\n                    queue.append((nx, ny))\n    \n    return distances\n\ndef can_visit_candies_and_reach_goal(candy_distances, goal_distance, T):\n    # Use bitmasking to check all subsets of candy\n    max_candies = len(candy_distances)\n    max_visited = 0\n    \n    for mask in range(1 << max_candies):\n        total_moves = 0\n        candies_visited = 0\n        \n        for i in range(max_candies):\n            if mask & (1 << i):\n                total_moves += candy_distances[i][0]  # Move to the i-th candy\n                candies_visited += 1\n        \n        total_moves += goal_distance  # Move from the last candy to the goal\n        \n        if total_moves <= T:\n            max_visited = max(max_visited, candies_visited)\n    \n    return max_visited\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    H, W, T = map(int, data[0].split())\n    grid = [list(data[i + 1]) for i in range(H)]\n    \n    start = None\n    goal = None\n    candies = []\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] == 'o':\n                candies.append((i, j))\n                \n    # BFS from start to find distances to all candies and to goal\n    start_distances = bfs(start, grid, H, W)\n    goal_distance = start_distances[goal[0]][goal[1]]\n    \n    if goal_distance > T:\n        print(-1)\n        return\n    \n    candy_distances = []\n    for candy in candies:\n        candy_distances.append((bfs(candy, grid, H, W)[start[0]][start[1]], start_distances[candy[0]][candy[1]]))\n    \n    max_candies = can_visit_candies_and_reach_goal(candy_distances, goal_distance, T)\n    print(max_candies)\n\nmain()"}
{"task_id": "abc301_f", "solution": "def count_ddos_free_strings(S):\n    MOD = 998244353\n    n = len(S)\n    \n    # Count of \"DDoS\" types found\n    total_count = pow(52, S.count('?'), MOD)\n    \n    # We will track the number of DDoS subsequences in the string\n    for i in range(n - 3):\n        first = S[i]\n        second = S[i + 1]\n        third = S[i + 2]\n        fourth = S[i + 3]\n\n        # Check if the current substring can form \"DDoS\"\n        if first == second and first.isupper() and third.islower() and fourth.isupper():\n            total_count = (total_count - 1 + MOD) % MOD\n\n        # Handle '?'\n        if first == '?':\n            if second == '?':\n                if third == '?':\n                    if fourth == '?':\n                        # all '?'\n                        total_count = (total_count - (52 * 52 * 52) % MOD + MOD) % MOD\n                    else:\n                        # fourth is known\n                        total_count = (total_count - 52 * 52 + MOD) % MOD\n                else:\n                    # third is known\n                    total_count = (total_count - 52 + MOD) % MOD\n            else:\n                if third == '?':\n                    if fourth == '?':\n                        total_count = (total_count - 52 + MOD) % MOD\n                    else:\n                        total_count = (total_count - 1 + MOD) % MOD\n\n    return total_count\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read().strip()\n    result = count_ddos_free_strings(input_data)\n    print(result)"}
{"task_id": "abc302_a", "solution": "def minimum_attacks():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Calculate the minimum number of attacks needed\n    # Using the formula (A + B - 1) // B to achieve ceiling division\n    n = (A + B - 1) // B\n    \n    # Print the result\n    print(n)"}
{"task_id": "abc302_b", "solution": "def find_sequence(H, W, grid):\n    # Define the directions: (delta_row, delta_col)\n    directions = [\n        (0, 1),    # right\n        (1, 0),    # down\n        (1, 1),    # down-right diagonal\n        (1, -1)    # down-left diagonal\n    ]\n    \n    # Target sequence\n    target = 'snuke'\n    \n    # Iterate through every cell in the grid\n    for i in range(H):\n        for j in range(W):\n            # Check if the current cell contains 's'\n            if grid[i][j] == 's':\n                # Check all directions\n                for dr, dc in directions:\n                    # Collect positions\n                    positions = []\n                    valid = True\n                    for k in range(5):\n                        ni = i + dr * k\n                        nj = j + dc * k\n                        if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == target[k]:\n                            positions.append((ni + 1, nj + 1))  # Store 1-based indices\n                        else:\n                            valid = False\n                            break\n                    \n                    if valid:\n                        return positions  # Return the found positions\n    \n    return []  # In case of no valid sequence, but the problem guarantees one\n\n# Read input\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\nH, W = map(int, data[0].split())\ngrid = data[1:H + 1]\n\n# Find the sequence\npositions = find_sequence(H, W, grid)\n\n# Output the positions\nfor pos in positions:\n    print(pos[0], pos[1])"}
{"task_id": "abc302_c", "solution": "import sys\nfrom itertools import permutations\n\ndef can_change_one_char(s1, s2):\n    # Check if s1 can be changed to s2 by changing exactly one character\n    differences = sum(1 for a, b in zip(s1, s2) if a != b)\n    return differences == 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, M = map(int, data[0].split())\n    strings = data[1:N + 1]\n\n    # Generate all permutations of the strings\n    for perm in permutations(strings):\n        valid = True\n        for i in range(N - 1):\n            if not can_change_one_char(perm[i], perm[i + 1]):\n                valid = False\n                break\n        if valid:\n            print(\"Yes\")\n            return\n        \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc302_d", "solution": "def max_gift_sum(N, M, D, A, B):\n    A.sort()\n    B.sort()\n\n    i, j = 0, 0\n    max_sum = -1\n    \n    while i < N and j < M:\n        # Check if current pair (A[i], B[j]) is valid\n        if abs(A[i] - B[j]) <= D:\n            curr_sum = A[i] + B[j]\n            max_sum = max(max_sum, curr_sum)\n            # Move both pointers to explore other potential pairs\n            i += 1\n            j += 1\n        elif B[j] < A[i] - D:\n            # B[j] is too low, move j to a larger value\n            j += 1\n        else:\n            # A[i] is too low, move i to a larger value\n            i += 1\n\n    return max_sum\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    D = int(data[2])\n    \n    A = list(map(int, data[3:3+N]))\n    B = list(map(int, data[3+N:]))\n    \n    result = max_gift_sum(N, M, D, A, B)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc302_e", "solution": "def process_queries(N, Q, queries):\n    # Initialize degree array and isolated count\n    degree = [0] * (N + 1)\n    isolated_count = N  # Initially, all vertices are isolated\n\n    results = []\n    \n    for query in queries:\n        q_type = query[0]\n        \n        if q_type == 1:  # connect vertex u and vertex v\n            u, v = query[1], query[2]\n            degree[u] += 1\n            degree[v] += 1\n            \n            # Check if we need to update isolated count\n            if degree[u] == 1:  # u becomes connected\n                isolated_count -= 1\n            if degree[v] == 1:  # v becomes connected\n                isolated_count -= 1\n\n        elif q_type == 2:  # remove all edges connected to vertex v\n            v = query[1]\n            \n            if degree[v] > 0:\n                # Reduce the isolated count as we are about to isolate v\n                isolated_count += 1\n            \n            # Set degree of v to 0 effectively isolating it\n            degree[v] = 0\n        \n        # Record the current number of isolated vertices\n        results.append(isolated_count)\n    \n    return results\n\n# Read input and call the function to process queries\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\n# Parse input\nfirst_line = list(map(int, data[0].split()))\nN, Q = first_line[0], first_line[1]\n\nqueries = []\nfor line in data[1:]:\n    queries.append(list(map(int, line.split())))\n\n# Process the queries and get results\noutput = process_queries(N, Q, queries)\n\n# Print result\nprint('\\n'.join(map(str, output)))"}
{"task_id": "abc302_f", "solution": "def solve():\n    import sys\n    from collections import defaultdict, deque\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    first_line = data[0].split()\n    N = int(first_line[0])\n    M = int(first_line[1])\n    \n    sets = []\n    elements_to_sets = defaultdict(set)\n    \n    index = 1\n    for i in range(N):\n        A_i = int(data[index])\n        elements = list(map(int, data[index + 1].split()))\n        sets.append(set(elements))\n        for element in elements:\n            elements_to_sets[element].add(i)\n        index += 2\n    \n    # If we can't find both 1 and M in any set, return -1\n    if not elements_to_sets[1] or not elements_to_sets[M]:\n        print(-1)\n        return\n    \n    # Build a graph where each set is a node and edges exist if they share elements\n    graph = defaultdict(set)\n    for element, set_indices in elements_to_sets.items():\n        set_indices = list(set_indices)\n        for i in range(len(set_indices)):\n            for j in range(i + 1, len(set_indices)):\n                graph[set_indices[i]].add(set_indices[j])\n                graph[set_indices[j]].add(set_indices[i])\n    \n    # BFS to find the minimum number of operations to connect the sets containing 1 and M\n    start_sets = list(elements_to_sets[1])\n    target_sets = set(elements_to_sets[M])\n    \n    queue = deque([(s, 0) for s in start_sets])\n    visited = set(start_sets)\n    \n    while queue:\n        current_set_index, operations = queue.popleft()\n        \n        # Check if we can reach any set containing M\n        if current_set_index in target_sets:\n            print(operations)\n            return\n        \n        # Explore neighbors\n        for neighbor in graph[current_set_index]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, operations + 1))\n    \n    # If we exit the loop, it means we cannot connect sets containing 1 and M\n    print(-1)"}
{"task_id": "abc303_a", "solution": "def are_similar_chars(x, y):\n    if x == y:\n        return True\n    if (x == '1' and y == 'l') or (x == 'l' and y == '1'):\n        return True\n    if (x == '0' and y == 'o') or (x == 'o' and y == '0'):\n        return True\n    return False\n\ndef are_similar_strings(N, S, T):\n    for i in range(N):\n        if not are_similar_chars(S[i], T[i]):\n            return \"No\"\n    return \"Yes\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nS = data[1]\nT = data[2]\n\n# Get the result and print it\nresult = are_similar_strings(N, S, T)\nprint(result)"}
{"task_id": "abc303_b", "solution": "def count_bad_mood_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and M\n    N, M = map(int, data[0].split())\n    \n    # To track the pairs of individuals that stood next to each other\n    adjacent_pairs = set()\n    \n    # Process each photo\n    for i in range(1, M + 1):\n        photo = list(map(int, data[i].split()))\n        \n        # Check pairs in this photo\n        for j in range(N - 1):\n            person1 = photo[j]\n            person2 = photo[j + 1]\n            # Add both orders to ensure uniqueness\n            adjacent_pairs.add((min(person1, person2), max(person1, person2)))\n\n    # Calculate total pairs (N choose 2)\n    total_pairs = N * (N - 1) // 2\n    \n    # Calculate number of pairs that are NOT adjacent\n    non_adjacent_pairs = total_pairs - len(adjacent_pairs)\n\n    # Print the result\n    print(non_adjacent_pairs)\n\n# Note: The function count_bad_mood_pairs is designed to be called in an environment where\n# input is piped to stdin. It reads from stdin, processes the input, and prints the output."}
{"task_id": "abc303_c", "solution": "def can_complete_moves(N, M, H, K, S, item_positions):\n    # Current position and health\n    current_x, current_y = 0, 0\n    current_health = H\n    \n    # Store item positions in a set\n    item_set = set(item_positions)\n    \n    # Direction mapping\n    direction_map = {\n        'R': (1, 0),\n        'L': (-1, 0),\n        'U': (0, 1),\n        'D': (0, -1),\n    }\n    \n    # Process each move\n    for move in S:\n        # Update position based on move\n        dx, dy = direction_map[move]\n        current_x += dx\n        current_y += dy\n        \n        # Health decreases by 1\n        current_health -= 1\n        \n        # Check if Takahashi collapses\n        if current_health < 0:\n            return \"No\"\n        \n        # Check if there is an item at the new position\n        if (current_x, current_y) in item_set:\n            if current_health < K:\n                current_health = K  # Restore health to K from the item\n    \n    return \"Yes\"\n\n# Input reading and function execution\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Parse the input\nN, M, H, K = map(int, data[0].split())\nS = data[1]\nitem_positions = [tuple(map(int, line.split())) for line in data[2:M+2]]\n\n# Call the function and print the result\nresult = can_complete_moves(N, M, H, K, S, item_positions)\nprint(result)"}
{"task_id": "abc303_d", "solution": "def min_time_to_type(S, X, Y, Z):\n    total_time = 0\n    caps_lock_on = False  # Start with Caps Lock off\n\n    for char in S:\n        if char == 'A':\n            if not caps_lock_on:\n                # Costs if Caps Lock is off\n                press_a_cost = X + Z  # Press 'a' then toggle Caps Lock\n                press_shift_a_cost = Y  # Press Shift + 'a'\n                # Choose the minimum cost action\n                if press_a_cost < press_shift_a_cost:\n                    total_time += press_a_cost\n                    caps_lock_on = True  # After pressing 'a' we turn Caps Lock on\n                else:\n                    total_time += press_shift_a_cost\n            else:\n                # Caps Lock is on\n                total_time += X  # Just press 'a' to get 'A'\n        else:  # char == 'a'\n            if not caps_lock_on:\n                # Caps Lock is off\n                total_time += X  # Just press 'a'\n            else:\n                # Caps Lock is on\n                press_a_cost = Y + Z  # Press Shift + 'a' then toggle Caps Lock\n                press_a_cost_direct = Y  # Press Shift + 'a' directly\n                # Choose the minimum cost action\n                if press_a_cost < press_a_cost_direct:\n                    total_time += press_a_cost\n                else:\n                    total_time += press_a_cost_direct\n                    # Caps Lock is still on after this operation\n\n    return total_time\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nX, Y, Z = map(int, data[0].split())\nS = data[1]\n\n# Solve the problem and output the result\nresult = min_time_to_type(S, X, Y, Z)\nprint(result)"}
{"task_id": "abc303_e", "solution": "def reconstruct_star_levels(N, edges):\n    # Step 1: Initialize degree count\n    degree = [0] * (N + 1)  # Degree array from 1 to N (1-indexed)\n    \n    # Step 2: Count degrees from the edges\n    for u, v in edges:\n        degree[u] += 1\n        degree[v] += 1\n    \n    # Step 3: Collect the star levels\n    star_levels = []\n    for i in range(1, N + 1):\n        if degree[i] > 1:  # If the degree is more than 1, it can form stars\n            star_levels.append(degree[i] - 1)  # Level is degree - 1\n    \n    # Step 4: Sort the levels\n    star_levels.sort()\n    \n    # Return the result as a space-separated string\n    return ' '.join(map(str, star_levels))\n\n# Read the inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nedges = [tuple(map(int, line.split())) for line in data[1:]]\n\n# Output the result\nprint(reconstruct_star_levels(N, edges))"}
{"task_id": "abc304_a", "solution": "# Read the number of people\nN = int(input().strip())\npeople = []\n\n# Read the names and ages\nfor _ in range(N):\n    line = input().strip().split()\n    name = line[0]\n    age = int(line[1])\n    people.append((name, age))\n\n# Find the index of the youngest person\nyoungest_index = 0\nfor i in range(1, N):\n    if people[i][1] < people[youngest_index][1]:\n        youngest_index = i\n\n# Create the order of names starting from the youngest person\nresult = []\nfor i in range(N):\n    result.append(people[(youngest_index + i) % N][0])\n\n# Print the result\nfor name in result:\n    print(name)"}
{"task_id": "abc304_b", "solution": "N = int(input().strip())\n\nif N <= 999:\n    print(N)\nelif N <= 9999:\n    print((N // 10) * 10)\nelif N <= 99999:\n    print((N // 100) * 100)\nelif N <= 999999:\n    print((N // 1000) * 1000)\nelif N <= 9999999:\n    print((N // 10000) * 10000)\nelif N <= 99999999:\n    print((N // 100000) * 100000)\nelif N <= 999999999:\n    print((N // 1000000) * 1000000)"}
{"task_id": "abc304_c", "solution": "def main():\n    import sys\n    from collections import deque\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and D\n    N, D = map(int, data[0].split())\n    D_squared = D * D  # We will compare squared distances\n\n    # Read the coordinates\n    people = []\n    for i in range(1, N + 1):\n        x, y = map(int, data[i].split())\n        people.append((x, y))\n\n    # To track infected status\n    infected = [False] * N\n    infected[0] = True  # The first person is infected\n    \n    # BFS initialization\n    queue = deque([0])\n\n    while queue:\n        current = queue.popleft()\n        cx, cy = people[current]\n\n        # Check the distance to other people\n        for i in range(N):\n            if not infected[i]:  # If not already infected\n                x, y = people[i]\n                # Calculate squared distance\n                squared_distance = (cx - x) ** 2 + (cy - y) ** 2\n                if squared_distance <= D_squared:\n                    infected[i] = True\n                    queue.append(i)  # Add to the queue for BFS\n\n    # Output results\n    for i in range(N):\n        if infected[i]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc304_d", "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read W and H\n    W, H = map(int, data[0].split())\n    \n    # Read N and strawberries positions\n    N = int(data[1])\n    strawberries = [tuple(map(int, data[i+2].split())) for i in range(N)]\n    \n    # Read A and vertical cuts\n    A = int(data[N + 2])\n    vertical_cuts = list(map(int, data[N + 3].split()))\n    \n    # Read B and horizontal cuts\n    B = int(data[N + 4])\n    horizontal_cuts = list(map(int, data[N + 5].split()))\n    \n    # Store the count of strawberries in each segment defined by the cuts\n    strawberry_count = defaultdict(int)\n    \n    # Count strawberries in the segments\n    for p, q in strawberries:\n        # Determine the vertical segment\n        vertical_segment = 0\n        while vertical_segment < A and vertical_cuts[vertical_segment] < p:\n            vertical_segment += 1\n        \n        # Determine the horizontal segment\n        horizontal_segment = 0\n        while horizontal_segment < B and horizontal_cuts[horizontal_segment] < q:\n            horizontal_segment += 1\n        \n        # Increment the count for the found segment\n        strawberry_count[(vertical_segment, horizontal_segment)] += 1\n    \n    # Determine min and max strawberries in any piece\n    min_strawberries = 0  # there can be a segment with no strawberries\n    max_strawberries = max(strawberry_count.values(), default=0)  # find the maximum count\n    \n    # Print the result\n    print(min_strawberries, max_strawberries)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc304_e", "solution": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # Path compression\n        return self.parent[u]\n\n    def union(self, u, v):\n        rootU = self.find(u)\n        rootV = self.find(v)\n        if rootU != rootV:\n            # Union by rank\n            if self.rank[rootU] > self.rank[rootV]:\n                self.parent[rootV] = rootU\n            elif self.rank[rootU] < self.rank[rootV]:\n                self.parent[rootU] = rootV\n            else:\n                self.parent[rootV] = rootU\n                self.rank[rootU] += 1\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    index = 0\n    \n    N, M = map(int, data[index].split())\n    index += 1\n    \n    uf = UnionFind(N + 1)  # Using 1-based index for vertices\n    \n    for _ in range(M):\n        u, v = map(int, data[index].split())\n        uf.union(u, v)\n        index += 1\n    \n    K = int(data[index])\n    index += 1\n    \n    disconnected_pairs = []\n    for _ in range(K):\n        x, y = map(int, data[index].split())\n        disconnected_pairs.append((x, y))\n        index += 1\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        p, q = map(int, data[index].split())\n        index += 1\n        \n        if uf.find(p) == uf.find(q):\n            # They are already connected, adding this edge would violate \"good\" condition\n            results.append(\"No\")\n        else:\n            # Check if adding this edge would connect any previously marked pairs\n            connected = False\n            for x, y in disconnected_pairs:\n                if uf.find(x) == uf.find(p) and uf.find(y) == uf.find(q):\n                    connected = True\n                    break\n                if uf.find(x) == uf.find(q) and uf.find(y) == uf.find(p):\n                    connected = True\n                    break\n            \n            if connected:\n                results.append(\"No\")\n            else:\n                results.append(\"Yes\")\n    \n    print(\"\\n\".join(results))"}
{"task_id": "abc305_a", "solution": "def nearest_water_station(N):\n    # Nearest water station behind (or at)\n    if N % 5 == 0:\n        nearest_behind = N\n    else:\n        nearest_behind = N - (N % 5)\n    \n    # Nearest water station in front\n    nearest_front = nearest_behind + 5\n    \n    # Calculate distances\n    distance_to_behind = N - nearest_behind\n    distance_to_front = nearest_front - N\n    \n    # Determine the nearest station\n    if distance_to_behind < distance_to_front:\n        return nearest_behind\n    else:\n        return nearest_front\n\n# Read input\nimport sys\ninput = sys.stdin.read\nN = int(input().strip())\n\n# Print output\nprint(nearest_water_station(N))"}
{"task_id": "abc305_b", "solution": "def calculate_distance(p, q):\n    # Distances between points\n    distances = {\n        'A': 0,  # Starting point\n        'B': 3,  # A to B\n        'C': 4,  # B to C (3 + 1)\n        'D': 8,  # C to D (4 + 4)\n        'E': 9,  # D to E (8 + 1)\n        'F': 14, # E to F (9 + 5)\n        'G': 23  # F to G (14 + 9)\n    }\n    \n    # Get positions of points p and q\n    pos_p = distances[p]\n    pos_q = distances[q]\n    \n    # Calculate the distance between points p and q\n    distance = abs(pos_p - pos_q)\n    \n    return distance\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\np, q = data[0], data[1]\n\n# Calculate the distance and print the result\nresult = calculate_distance(p, q)\nprint(result)"}
{"task_id": "abc305_c", "solution": "def find_missing_cookie():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    H, W = map(int, data[0].split())\n    grid = data[1:H + 1]\n    \n    min_row, max_row = H + 1, -1\n    min_col, max_col = W + 1, -1\n    \n    # Determine the bounds of the rectangle that contained cookies\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                if i + 1 < min_row:\n                    min_row = i + 1\n                if i + 1 > max_row:\n                    max_row = i + 1\n                if j + 1 < min_col:\n                    min_col = j + 1\n                if j + 1 > max_col:\n                    max_col = j + 1\n\n    # Now find the empty square within the identified rectangle\n    for i in range(min_row - 1, max_row):\n        for j in range(min_col - 1, max_col):\n            if grid[i][j] == '.':\n                print(i + 1, j + 1)\n                return"}
{"task_id": "abc305_d", "solution": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    \n    A = list(map(int, data[idx:idx + N]))\n    idx += N\n    \n    Q = int(data[idx])\n    idx += 1\n    \n    queries = []\n    for _ in range(Q):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        queries.append((l, r))\n        idx += 2\n    \n    # Prepare sleep intervals and their durations\n    sleep_intervals = []\n    sleep_durations = []\n    \n    for i in range(1, N // 2 + 1):\n        start = A[2 * i - 1]\n        end = A[2 * i]\n        sleep_intervals.append((start, end))\n        sleep_durations.append(end - start)\n    \n    # Now process each query\n    results = []\n    \n    for l, r in queries:\n        # Use bisect to find the relevant sleep intervals\n        start_index = bisect_left(sleep_intervals, (l, -1))  # find the first interval that starts >= l\n        end_index = bisect_right(sleep_intervals, (r, float('inf')))  # find the first interval that starts > r\n        \n        total_sleep = 0\n        \n        # Check each interval in the found range\n        for i in range(start_index, end_index):\n            sleep_start, sleep_end = sleep_intervals[i]\n            # Calculate the overlap\n            overlap_start = max(sleep_start, l)\n            overlap_end = min(sleep_end, r)\n            if overlap_end > overlap_start:\n                total_sleep += (overlap_end - overlap_start)\n        \n        results.append(total_sleep)\n    \n    # Output results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc305_e", "solution": "from collections import deque, defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read number of vertices, edges, and guards\n    N, M, K = map(int, data[0].split())\n    \n    # Read edges and build the graph\n    graph = defaultdict(list)\n    for i in range(1, M + 1):\n        a, b = map(int, data[i].split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Read guards information\n    guards = []\n    for i in range(M + 1, M + 1 + K):\n        p, h = map(int, data[i].split())\n        guards.append((p, h))\n    \n    # Set to store all guarded vertices\n    guarded = set()\n\n    # Perform BFS for each guard\n    for p, h in guards:\n        queue = deque([p])\n        visited = set([p])  # Track visited vertices in this BFS\n        distance = 0\n        \n        while queue and distance < h:\n            distance += 1\n            for _ in range(len(queue)):\n                current = queue.popleft()\n                # Explore neighbors\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n        \n        # All visited vertices are guarded\n        guarded.update(visited)\n    \n    # Prepare the result\n    guarded_list = sorted(guarded)\n    print(len(guarded_list))\n    print(' '.join(map(str, guarded_list)))\n\n# This function would be called when this script is executed\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_a", "solution": "# Read inputs from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nS = data[1]\n\n# Create the result by concatenating each character twice\nresult = ''.join(char * 2 for char in S)\n\n# Print the final result\nprint(result)"}
{"task_id": "abc306_b", "solution": "def main():\n    import sys\n    input_data = sys.stdin.read().strip()\n    # Split the input string into a list of strings and then convert to integers\n    A = list(map(int, input_data.split()))\n    \n    total_sum = 0\n    for i in range(64):\n        total_sum += A[i] * (2 ** i)\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Step 2: Track occurrences\n    occurrences = {}\n    \n    for index, value in enumerate(A):\n        if value in occurrences:\n            occurrences[value].append(index)\n        else:\n            occurrences[value] = [index]\n    \n    # Step 3: Calculate middle occurrences\n    middle_occurrences = []\n    \n    for i in range(1, N+1):\n        middle_index = occurrences[i][1]  # f(i) is the second occurrence\n        middle_occurrences.append((middle_index, i))\n    \n    # Step 4: Sort by middle occurrences\n    middle_occurrences.sort()  # sorts by first element of the tuple by default\n    \n    # Step 5: Output the result\n    sorted_numbers = [str(num) for _, num in middle_occurrences]\n    print(\" \".join(sorted_numbers))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_d", "solution": "def max_tastiness(N, courses):\n    healthy_dp = 0\n    upset_dp = float('-inf')  # Max tastiness with upset stomach; initially very low\n    \n    for X, Y in courses:\n        if X == 0:  # Antidotal course\n            if upset_dp != float('-inf'):\n                # If in upset state, we can recover\n                upset_dp = max(upset_dp, healthy_dp)\n                healthy_dp += Y  # Recover and eat\n            else:\n                healthy_dp += Y  # Just eat as healthy\n        else:  # Poisonous course\n            if upset_dp != float('-inf'):\n                # If in upset state, we can't eat anymore\n                continue\n            else:\n                # If healthy, transition to upset\n                upset_dp = healthy_dp  # Eat this poisonous course causes upset stomach\n                healthy_dp = 0  # Reset healthy as he becomes upset\n\n    # The maximum tastiness he can have while still alive\n    return max(healthy_dp, upset_dp)\n\n# Reading input and calling the function\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    courses = []\n    \n    for i in range(1, N + 1):\n        X, Y = map(int, data[i].split())\n        courses.append((X, Y))\n    \n    result = max_tastiness(N, courses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_e", "solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, K, Q = map(int, data[0].split())\n    A = [0] * N\n    updates = [tuple(map(int, line.split())) for line in data[1:]]\n    \n    # Min-heap for the top K elements\n    min_heap = []\n    current_sum = 0\n    \n    def add_to_heap(value):\n        nonlocal current_sum\n        if len(min_heap) < K:\n            heapq.heappush(min_heap, value)\n            current_sum += value\n        elif len(min_heap) == K and value > min_heap[0]:\n            current_sum += value - heapq.heappop(min_heap)\n            heapq.heappush(min_heap, value)\n    \n    def remove_from_heap(value):\n        nonlocal current_sum\n        if value in min_heap:\n            min_heap.remove(value)\n            heapq.heapify(min_heap)\n            current_sum = sum(min_heap)\n    \n    # Initialize the min_heap with the first K elements (initially all are 0)\n    for i in range(K):\n        heapq.heappush(min_heap, 0)\n    \n    # Output results after each update\n    results = []\n    \n    for x, y in updates:\n        idx = x - 1\n        \n        # Remove old value from heap\n        if A[idx] > 0:\n            remove_from_heap(A[idx])\n        \n        # Apply update\n        A[idx] = y\n        \n        # Add new value to heap\n        add_to_heap(y)\n        \n        # Append the result of f(A)\n        results.append(current_sum)\n    \n    # Print all results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc307_a", "solution": "def calculate_weekly_steps():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])  # number of weeks\n    A = list(map(int, data[1:]))  # list of steps for 7N days\n    \n    weekly_totals = []\n    \n    for i in range(N):\n        start_index = i * 7\n        end_index = start_index + 7\n        weekly_sum = sum(A[start_index:end_index])\n        weekly_totals.append(weekly_sum)\n    \n    print(\" \".join(map(str, weekly_totals)))"}
{"task_id": "abc307_b", "solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef can_form_palindrome(n, strings):\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                concatenated = strings[i] + strings[j]\n                if is_palindrome(concatenated):\n                    return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nstrings = data[1:N+1]\n\n# Output the result\nprint(can_form_palindrome(N, strings))"}
{"task_id": "abc307_c", "solution": "def can_achieve_goal(A, B, X):\n    # Parse the dimensions and contents\n    H_A, W_A = len(A), len(A[0])\n    H_B, W_B = len(B), len(B[0])\n    H_X, W_X = len(X), len(X[0])\n    \n    # Collect all black squares from A and B\n    black_squares_A = [(i, j) for i in range(H_A) for j in range(W_A) if A[i][j] == '#']\n    black_squares_B = [(i, j) for i in range(H_B) for j in range(W_B) if B[i][j] == '#']\n    \n    # Check all possible placements of A and B on an imaginary C\n    for offset_A_row in range(H_X + 1):  # A can be placed from row 0 to H_X\n        for offset_A_col in range(W_X + 1):  # A can be placed from col 0 to W_X\n            for offset_B_row in range(H_X + 1):  # B can be placed from row 0 to H_X\n                for offset_B_col in range(W_X + 1):  # B can be placed from col 0 to W_X\n                    \n                    # Create a blank sheet of size H_X x W_X\n                    combined_sheet = [['.' for _ in range(W_X)] for _ in range(H_X)]\n                    \n                    # Overlay sheet A\n                    for i in range(H_A):\n                        for j in range(W_A):\n                            if A[i][j] == '#' and 0 <= i + offset_A_row < H_X and 0 <= j + offset_A_col < W_X:\n                                combined_sheet[i + offset_A_row][j + offset_A_col] = '#'\n                    \n                    # Overlay sheet B\n                    for i in range(H_B):\n                        for j in range(W_B):\n                            if B[i][j] == '#' and 0 <= i + offset_B_row < H_X and 0 <= j + offset_B_col < W_X:\n                                combined_sheet[i + offset_B_row][j + offset_B_col] = '#'\n                    \n                    # Check for all possible cutouts of size H_X x W_X\n                    for cutout_row in range(H_X - H_X + 1):  # only one possible cutout start\n                        for cutout_col in range(W_X - W_X + 1):  # only one possible cutout start\n                            # Check if this cutout matches X and includes all black squares\n                            matches_X = True\n                            for i in range(H_X):\n                                for j in range(W_X):\n                                    if (0 <= cutout_row + i < H_X and 0 <= cutout_col + j < W_X):\n                                        if combined_sheet[cutout_row + i][cutout_col + j] != X[i][j]:\n                                            matches_X = False\n                                            break\n                                if not matches_X:\n                                    break\n                            \n                            if matches_X:\n                                # Now check if all black squares from A and B are included\n                                all_black_included = True\n                                for (i, j) in black_squares_A + black_squares_B:\n                                    if not (0 <= cutout_row + i < H_X and 0 <= cutout_col + j < W_X and \n                                            combined_sheet[cutout_row + i][cutout_col + j] == '#'):\n                                        all_black_included = False\n                                        break\n                                \n                                if all_black_included:\n                                    return \"Yes\"\n\n    return \"No\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nH_A, W_A = map(int, data[0].split())\nA = data[1:H_A + 1]\nH_B, W_B = map(int, data[H_A + 1].split())\nB = data[H_A + 2:H_A + 2 + H_B]\nH_X, W_X = map(int, data[H_A + H_B + 2].split())\nX = data[H_A + H_B + 3:H_A + H_B + 3 + H_X]\n\n# Get the result\nresult = can_achieve_goal(A, B, X)\n\n# Print the result\nprint(result)"}
{"task_id": "abc307_d", "solution": "def remove_substrings(N, S):\n    stack = []\n    result = []\n\n    for char in S:\n        if char.isalpha():  # if it's a lowercase letter\n            # Only add to result if we are not inside a removable segment\n            if not stack:\n                result.append(char)\n        elif char == '(':\n            stack.append(char)  # push '(' onto the stack\n        elif char == ')':\n            if stack and stack[-1] == '(':  # found a matching '(' for this ')'\n                stack.pop()  # pop the matching '('\n                # We don't add anything to result for the section (something)\n\n    # Join the result list into a string and return it\n    return ''.join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nS = data[1]\n\n# Get the result and print it\noutput = remove_substrings(N, S)\nprint(output)"}
{"task_id": "abc307_e", "solution": "def modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\ndef solve(N, M):\n    MOD = 998244353\n    \n    if M == 1:\n        return 0  # No valid arrangements if M = 1 and N >= 2\n    \n    total_arrangements = (M * modular_exponentiation(M - 1, N - 1, MOD)) % MOD\n    invalid_arrangements = (M - 1) * modular_exponentiation(M - 2, N - 2, MOD) % MOD\n    \n    result = (total_arrangements - invalid_arrangements + MOD) % MOD\n    return result\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip()\n    N, M = map(int, data.split())\n    print(solve(N, M))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc308_a", "solution": "def check_conditions(S):\n    # Check for monotonicity\n    for i in range(7):\n        if S[i] > S[i + 1]:\n            return \"No\"\n    \n    # Check for range and multiples of 25\n    for s in S:\n        if s < 100 or s > 675 or s % 25 != 0:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read the input\nimport sys\ninput_data = sys.stdin.read()\nS = list(map(int, input_data.split()))\n\n# Check conditions and print result\nresult = check_conditions(S)\nprint(result)"}
{"task_id": "abc308_b", "solution": "def calculate_sushi_price():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and M\n    N, M = map(int, data[0].split())\n    \n    # Read C_i (colors of plates)\n    C = data[1].split()\n    \n    # Read D_i (distinct colors) and P (prices)\n    D = data[2].split()\n    P = list(map(int, data[3].split()))\n    \n    # Create a price mapping for the distinct colors\n    price_map = {D[i]: P[i + 1] for i in range(M)}  # D_1 to D_M map to P_1 to P_M\n    price_map['default'] = P[0]  # Price for colors not in D\n    \n    # Calculate the total price\n    total_price = 0\n    for color in C:\n        total_price += price_map.get(color, price_map['default'])\n    \n    print(total_price)"}
{"task_id": "abc308_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    people = []\n    \n    for i in range(1, N + 1):\n        A, B = map(int, data[i].split())\n        success_rate = (A, A + B)  # Representing as (A_i, A_i + B_i)\n        people.append((success_rate, i))  # Store success rate and original index\n    \n    # Sort by success rate (desc) and by index (asc) in case of ties\n    people.sort(key=lambda x: (-x[0][0] / x[0][1], x[1]))\n    \n    # Extract sorted indices\n    result = [str(person[1]) for person in people]\n    \n    # Print result\n    print(\" \".join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc308_d", "solution": "from collections import deque\n\ndef bfs_snukes_path(H, W, grid):\n    # Define the character sequence\n    snukes = \"snukes\"\n    target_length = len(snukes)\n    \n    # Directions for adjacent cells\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS initialization\n    queue = deque([(0, 0, 0)])  # (row, column, step in the sequence)\n    visited = set((0, 0))\n    \n    while queue:\n        x, y, step = queue.popleft()\n        \n        # If we reached the bottom-right corner\n        if x == H - 1 and y == W - 1:\n            return \"Yes\"\n        \n        # Calculate the expected character\n        expected_char = snukes[step % target_length]\n        \n        # Explore all adjacent cells\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check boundaries\n            if 0 <= nx < H and 0 <= ny < W:\n                # Check if the cell has the expected character and not visited yet\n                if grid[nx][ny] == expected_char and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, step + 1))\n    \n    return \"No\"\n\n# Read input and run the algorithm\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    H, W = map(int, data[0].split())\n    grid = data[1:H + 1]\n    \n    result = bfs_snukes_path(H, W, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc308_e", "solution": "def mex(a, b, c):\n    return {0, 1, 2}.difference({a, b, c}).pop() if {a, b, c} != {0, 1, 2} else 3\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    A = list(map(int, data[1].split()))\n    S = data[2]\n    \n    # Collect indices of 'M', 'E', 'X'\n    M_indices = []\n    E_indices = []\n    X_indices = []\n    \n    for i in range(N):\n        if S[i] == 'M':\n            M_indices.append(i)\n        elif S[i] == 'E':\n            E_indices.append(i)\n        elif S[i] == 'X':\n            X_indices.append(i)\n    \n    total_mex_sum = 0\n    # Let's iterate over the indices of 'M'\n    for m_index in M_indices:\n        # For every 'M', we need to find 'E's and 'X's after this index\n        e_start = 0\n        x_start = 0\n        # for every 'E' find 'X's that come after it\n        while e_start < len(E_indices) and E_indices[e_start] <= m_index:\n            e_start += 1\n        # e_start is now the first valid 'E' index after 'M'\n        \n        for e_index in E_indices[e_start:]:\n            while x_start < len(X_indices) and X_indices[x_start] <= e_index:\n                x_start += 1\n            # x_start is now the first valid 'X' index after 'E'\n            for x_index in X_indices[x_start:]:\n                # Calculate mex for (m_index, e_index, x_index)\n                total_mex_sum += mex(A[m_index], A[e_index], A[x_index])\n    \n    print(total_mex_sum)"}
{"task_id": "abc308_f", "solution": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    P = list(map(int, data[2:N + 2]))\n    L = list(map(int, data[N + 2:N + 2 + M]))\n    D = list(map(int, data[N + 2 + M:N + 2 + 2 * M]))\n    \n    # Prepare list of coupons as tuples\n    coupons = [(L[i], D[i]) for i in range(M)]\n    \n    # Sort items and coupons\n    P.sort()\n    coupons.sort()\n    \n    total_cost = 0\n    coupon_index = 0\n    available_coupons = []\n    \n    for price in P:\n        # Push eligible coupons into the max-heap\n        while coupon_index < M and coupons[coupon_index][0] <= price:\n            heapq.heappush(available_coupons, -coupons[coupon_index][1])  # Use negative for max-heap\n            coupon_index += 1\n        \n        # Determine the cost for the current item\n        if available_coupons:\n            max_discount = -heapq.heappop(available_coupons)  # Get the largest discount\n            total_cost += max(0, price - max_discount)  # Avoid negative pricing\n        else:\n            total_cost += price  # No coupon available, pay the regular price\n    \n    print(total_cost)"}
{"task_id": "abc309_a", "solution": "def are_adjacent_horizontally(A, B):\n    # Calculate row and column for A\n    row_A = (A - 1) // 3\n    col_A = (A - 1) % 3\n    \n    # Calculate row and column for B\n    row_B = (B - 1) // 3\n    col_B = (B - 1) % 3\n    \n    # Check if they are in the same row and adjacent (columns differ by 1)\n    if row_A == row_B and abs(col_A - col_B) == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read inputs\nimport sys\ninput_data = sys.stdin.read().strip()\nA, B = map(int, input_data.split())\n\n# Get the result\nresult = are_adjacent_horizontally(A, B)\n\n# Print the result\nprint(result)"}
{"task_id": "abc309_b", "solution": "def shift_outer_layer_clockwise(grid, n):\n    # Extract outer layer\n    outer_layer = []\n    \n    # Top row\n    for j in range(n):\n        outer_layer.append(grid[0][j])\n    \n    # Right column\n    for i in range(1, n - 1):\n        outer_layer.append(grid[i][n - 1])\n    \n    # Bottom row\n    for j in range(n - 1, -1, -1):\n        outer_layer.append(grid[n - 1][j])\n    \n    # Left column\n    for i in range(n - 2, 0, -1):\n        outer_layer.append(grid[i][0])\n    \n    # Shift clockwise\n    outer_layer = [outer_layer[-1]] + outer_layer[:-1]\n    \n    # Create a new grid to populate with shifted values\n    new_grid = [[0] * n for _ in range(n)]\n    \n    index = 0\n    \n    # Fill the new grid with the shifted outer layer\n    # Top row\n    for j in range(n):\n        new_grid[0][j] = outer_layer[index]\n        index += 1\n    \n    # Right column\n    for i in range(1, n - 1):\n        new_grid[i][n - 1] = outer_layer[index]\n        index += 1\n    \n    # Bottom row\n    for j in range(n - 1, -1, -1):\n        new_grid[n - 1][j] = outer_layer[index]\n        index += 1\n    \n    # Left column\n    for i in range(n - 2, 0, -1):\n        new_grid[i][0] = outer_layer[index]\n        index += 1\n    \n    # Fill in the inner values without changes\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            new_grid[i][j] = grid[i][j]\n    \n    return new_grid\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    grid = [list(map(int, list(data[i + 1]))) for i in range(n)]\n    \n    new_grid = shift_outer_layer_clockwise(grid, n)\n    \n    for row in new_grid:\n        print(''.join(map(str, row)))"}
{"task_id": "abc309_c", "solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and K\n    first_line = data[0].split()\n    N = int(first_line[0])\n    K = int(first_line[1])\n    \n    # Read the a_i and b_i values\n    medicines = []\n    for i in range(1, N + 1):\n        a_i, b_i = map(int, data[i].split())\n        medicines.append((a_i, b_i))\n    \n    # Create a min-heap for managing medicine intake days\n    min_heap = []\n    \n    # Total pills calculated for the current day\n    total_pills = 0\n    \n    # Populate the heap with the initial medicines\n    for a_i, b_i in medicines:\n        heapq.heappush(min_heap, (a_i, b_i))\n        total_pills += b_i\n    \n    # We start checking from day 1\n    day = 1\n    \n    while True:\n        # Check if the current total pills is K or less\n        if total_pills <= K:\n            print(day)\n            return\n        \n        # Move to the next day\n        day += 1\n        \n        # Remove medicines that finished their duration\n        while min_heap and min_heap[0][0] < day:\n            end_day, pills_per_day = heapq.heappop(min_heap)\n            total_pills -= pills_per_day\n        \n        # Check if we need to add new medicines for the current day\n        for a_i, b_i in medicines:\n            if (a_i >= day):\n                total_pills += b_i\n                heapq.heappush(min_heap, (day + a_i - 1, b_i))"}
{"task_id": "abc309_d", "solution": "from collections import deque, defaultdict\nimport sys\n\ndef bfs(start, graph, n):\n    dist = [-1] * (n + 1)  # Distance array\n    dist[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:  # Not visited\n                dist[neighbor] = dist[node] + 1\n                queue.append(neighbor)\n    \n    return dist\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N1, N2, M\n    first_line = data[0].split()\n    N1 = int(first_line[0])\n    N2 = int(first_line[1])\n    M = int(first_line[2])\n    \n    graph = defaultdict(list)\n    \n    # Read edges\n    for i in range(1, M + 1):\n        a, b = map(int, data[i].split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Compute distances from vertex 1\n    dist_from_1 = bfs(1, graph, N1 + N2)\n    \n    # Compute distances from vertex N1 + N2\n    dist_from_N1_plus_N2 = bfs(N1 + N2, graph, N1 + N2)\n    \n    # Now we find the maximum possible d\n    max_distance = 0\n    \n    # Go through all u in the first component (1 to N1)\n    for u in range(1, N1 + 1):\n        # Go through all v in the second component (N1 + 1 to N1 + N2)\n        for v in range(N1 + 1, N1 + N2 + 1):\n            if dist_from_1[u] != -1 and dist_from_N1_plus_N2[v] != -1:\n                # d = distance from 1 to u + 1 (the edge we are adding) + distance from N1 + N2 to v\n                d = dist_from_1[u] + 1 + dist_from_N1_plus_N2[v]\n                max_distance = max(max_distance, d)\n    \n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_e", "solution": "def solve():\n    import sys\n    from collections import defaultdict, deque\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and M\n    N, M = map(int, data[0].split())\n    \n    # Read parents and build the tree\n    parents = list(map(int, data[1].split()))\n    tree = defaultdict(list)\n    \n    # Fill the tree with children relationships\n    for child in range(2, N + 1):\n        parent = parents[child - 2]\n        tree[parent].append(child)\n    \n    # Set to track unique covered individuals\n    covered = set()\n    \n    # Process each insurance policy\n    for i in range(2, 2 + M):\n        x, y = map(int, data[i].split())\n        \n        # BFS to find all descendants up to y generations\n        queue = deque([(x, 0)])  # (current_person, current_generation)\n        \n        while queue:\n            person, generation = queue.popleft()\n            if person not in covered:\n                covered.add(person)\n            if generation < y:\n                for child in tree[person]:\n                    queue.append((child, generation + 1))\n    \n    # Output the number of unique covered individuals\n    print(len(covered))"}
{"task_id": "abc310_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])  # number of dishes\n    P = int(data[1])  # price of drink without coupon\n    Q = int(data[2])  # price of drink with coupon\n    D = list(map(int, data[3:3 + N]))  # prices of the dishes\n    \n    # Calculate the minimum cost with the coupon\n    cheapest_dish = min(D)\n    total_with_coupon = Q + cheapest_dish\n    \n    # Calculate the total cost without using the coupon\n    total_without_coupon = P\n    \n    # Determine the minimum total cost\n    minimum_total = min(total_with_coupon, total_without_coupon)\n    \n    print(minimum_total)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N, M = map(int, data[0].split())\n    products = []\n    \n    for i in range(1, N + 1):\n        line = list(map(int, data[i].split()))\n        price = line[0]\n        count = line[1]\n        functions = set(line[2:2 + count])  # Store functions in a set\n        products.append((price, functions))\n    \n    # Compare each pair of products\n    for i in range(N):\n        pi, fi = products[i]\n        for j in range(N):\n            if i != j:\n                pj, fj = products[j]\n                # Check the first condition: P_i >= P_j\n                if pi >= pj:\n                    # Check the second condition: all functions of i are in j\n                    if fi.issubset(fj):\n                        # Condition for strict superiority\n                        if pi > pj or not fi.issubset(fj):  # pj must have extra functions\n                            print(\"Yes\")\n                            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    N = int(data[0])\n    unique_sticks = set()\n\n    for i in range(1, N + 1):\n        stick = data[i]\n        # Normalize the stick by taking the lexicographically smaller of the stick and its reverse\n        normalized = min(stick, stick[::-1])\n        unique_sticks.add(normalized)\n\n    # The number of unique sticks\n    print(len(unique_sticks))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_d", "solution": "def count_teams(N, T, incompatible_pairs):\n    from itertools import combinations\n    from functools import lru_cache\n    \n    MOD = 10**9 + 7\n    \n    incompatible_graph = [[] for _ in range(N)]\n    for a, b in incompatible_pairs:\n        incompatible_graph[a - 1].append(b - 1)\n        incompatible_graph[b - 1].append(a - 1)\n    \n    # We will use a memoization approach to count valid distributions\n    @lru_cache(None)\n    def dp(remaining_players, team_count):\n        if team_count == 0:\n            return 1 if remaining_players == 0 else 0\n        if remaining_players < team_count:\n            return 0\n        \n        # We use the principle of inclusion-exclusion to account for teams\n        total_ways = 0\n        \n        # The maximum number of players we can assign to the current team\n        for first in range(1, remaining_players - team_count + 2):\n            # Calculate ways to assign remaining players to teams\n            ways = dp(remaining_players - first, team_count - 1)\n            total_ways = (total_ways + ways) % MOD\n        \n        return total_ways\n    \n    # Main call to count the ways to assign players to T teams\n    return dp(N, T)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, T, M = map(int, data[0].split())\n    incompatible_pairs = [tuple(map(int, line.split())) for line in data[1:M+1]]\n    \n    # Calculate the result\n    result = count_teams(N, T, incompatible_pairs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc310_e", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N = int(data[0])\n    S = data[1]\n    \n    total_pairs = N * (N + 1) // 2  # Total pairs (i, j)\n    \n    # Count the length of segments of consecutive '1's\n    count_of_pairs_with_zero = 0\n    current_segment_length = 0\n    \n    for i in range(N):\n        if S[i] == '1':\n            current_segment_length += 1\n        else:\n            if current_segment_length > 0:\n                count_of_pairs_with_zero += current_segment_length * (current_segment_length + 1) // 2\n                current_segment_length = 0\n    \n    # Handle the last segment if it ended with '1'\n    if current_segment_length > 0:\n        count_of_pairs_with_zero += current_segment_length * (current_segment_length + 1) // 2\n    \n    # Total pairs minus those producing 0\n    result = total_pairs - count_of_pairs_with_zero\n    print(result)\n\n# The main function will be called when the code is executed.\nmain()"}
{"task_id": "abc310_f", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    MOD = 998244353\n    TARGET_SUM = 10\n    \n    # Initialize DP array for sums from 0 to TARGET_SUM\n    dp = [0] * (TARGET_SUM + 1)\n    dp[0] = 1  # There is one way to achieve sum 0: select no dice.\n    \n    # Total outcomes\n    total_outcomes = 1\n    for a in A:\n        total_outcomes = total_outcomes * a % MOD\n    \n    # Fill the DP array\n    for a in A:\n        for s in range(TARGET_SUM, -1, -1):\n            for k in range(1, a + 1):\n                if s - k >= 0:\n                    dp[s] = (dp[s] + dp[s - k]) % MOD\n    \n    ways_to_achieve_target = dp[TARGET_SUM]\n    \n    # Calculate the final result\n    if ways_to_achieve_target == 0:\n        print(0)\n        return\n    \n    # Compute the modular inverse of total_outcomes\n    def mod_inverse(x, p):\n        return pow(x, p - 2, p)\n    \n    total_outcomes_inv = mod_inverse(total_outcomes, MOD)\n    \n    result = ways_to_achieve_target * total_outcomes_inv % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc311_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N = int(data[0])  # Length of the string\n    S = data[1]       # The string itself\n    \n    seen = set()\n    \n    for i in range(N):\n        seen.add(S[i])\n        if len(seen) == 3:  # We have seen A, B, and C\n            print(i + 1)    # Output the number of characters checked (1-based index)\n            return\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc311_b", "solution": "def max_consecutive_free_days(N, D, schedules):\n    # Step 1: Create a combined availability string\n    combined = ['o'] * D  # Start with all days free\n    for i in range(N):\n        for j in range(D):\n            if schedules[i][j] == 'x':\n                combined[j] = 'x'  # Mark the day as occupied if any person is occupied\n    \n    # Step 2: Find the longest segment of consecutive 'o's\n    max_length = 0\n    current_length = 0\n    \n    for day in combined:\n        if day == 'o':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0  # Reset the count when we encounter 'x'\n    \n    return max_length\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Parse the first line for N and D\nN, D = map(int, data[0].split())\nschedules = data[1:N+1]  # Get the schedules\n\n# Call the function and print the result\nprint(max_consecutive_free_days(N, D, schedules))"}
{"task_id": "abc311_c", "solution": "def find_cycle(N, A):\n    visited = set()\n    path = []\n    current = 1  # Start from vertex 1 (1-indexed)\n\n    # Follow the edges and track the path\n    while current not in visited:\n        visited.add(current)\n        path.append(current)\n        current = A[current - 1]  # Move to the next vertex (A is 0-indexed)\n\n    # Now `current` is a vertex that has already been visited,\n    # indicating the start of the cycle\n    cycle_start = current\n    cycle = []\n    \n    # Rebuild the cycle\n    for node in path:\n        if node == cycle_start:\n            cycle.append(node)\n            break\n        if cycle:\n            cycle.append(node)\n\n    # Continue to add until we complete the cycle\n    while True:\n        current = A[cycle[-1] - 1]\n        cycle.append(current)\n        if current == cycle_start:\n            break\n\n    print(len(cycle))\n    print(' '.join(map(str, cycle)))\n\n# Reading input and invoking the function\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\nfind_cycle(N, A)"}
{"task_id": "abc311_d", "solution": "def count_ice_squares(N, M, grid):\n    # Directions for up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Set to keep track of visited squares\n    visited = set()\n    \n    # BFS stack (using list as stack)\n    stack = [(2, 2)]  # Starting position (2, 2)\n    visited.add((2, 2))\n    \n    while stack:\n        x, y = stack.pop()\n        \n        # Explore in all four directions\n        for dx, dy in directions:\n            nx, ny = x, y\n            \n            # Keep moving in the current direction until hitting a rock or boundary\n            while 1 <= nx + dx < N and 1 <= ny + dy < M and grid[nx + dx][ny + dy] == '.':\n                nx += dx\n                ny += dy\n                \n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    stack.append((nx, ny))\n    \n    return len(visited)\n\n# Read inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\ngrid = data[1:N+1]\n\n# Call the function and output the result\nresult = count_ice_squares(N, M, grid)\nprint(result)"}
{"task_id": "abc311_e", "solution": "def count_holeless_squares(H, W, N, holes):\n    # Create a grid to mark holed cells\n    grid = [[0] * (W + 1) for _ in range(H + 1)]\n    \n    # Mark holed cells\n    for a, b in holes:\n        grid[a][b] = 1  # Mark as holed\n    \n    # Create a dp array\n    dp = [[0] * (W + 1) for _ in range(H + 1)]\n    total_holeless_squares = 0\n    \n    # Fill in the dp array\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if grid[i][j] == 0:  # Not holed\n                # Determine the size of the largest holeless square with (i, j) as top-left corner\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                total_holeless_squares += dp[i][j]\n    \n    return total_holeless_squares\n\n# Read input and run the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nH, W, N = map(int, data[0].split())\nholes = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n\nresult = count_holeless_squares(H, W, N, holes)\nprint(result)"}
{"task_id": "abc312_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    S = input().strip()\n    \n    valid_strings = {\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"}\n    \n    if S in valid_strings:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_b", "solution": "def is_valid_tak_code(grid, i, j):\n    # Check top-left 3x3 block\n    for x in range(3):\n        for y in range(3):\n            if grid[i + x][j + y] != '#':\n                return False\n    \n    # Check bottom-right 3x3 block\n    for x in range(3):\n        for y in range(3):\n            if grid[i + 6 + x][j + 6 + y] != '#':\n                return False\n    \n    # Check adjacent cells\n    adjacent_cells = [\n        (i - 1, j - 1), (i - 1, j), (i - 1, j + 1),\n        (i, j - 1),           (i, j + 1),\n        (i + 1, j - 1), (i + 1, j), (i + 1, j + 1),\n        \n        (i + 6 - 1, j + 6 - 1), (i + 6 - 1, j + 6), (i + 6 - 1, j + 6 + 1),\n        (i + 6, j + 6 - 1),           (i + 6, j + 6 + 1),\n        (i + 6 + 1, j + 6 - 1), (i + 6 + 1, j + 6), (i + 6 + 1, j + 6 + 1)\n    ]\n    \n    for x, y in adjacent_cells:\n        if 0 <= x < len(grid) and 0 <= y < len(grid[0]):\n            if grid[x][y] != '.':\n                return False\n    \n    return True\n\ndef find_tak_codes(N, M, grid):\n    results = []\n    for i in range(N - 8):\n        for j in range(M - 8):\n            if is_valid_tak_code(grid, i, j):\n                results.append((i + 1, j + 1))  # store results in 1-based index\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N, M = map(int, data[0].split())\n    grid = data[1:N+1]\n    \n    results = find_tak_codes(N, M, grid)\n    \n    for res in results:\n        print(res[0], res[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_c", "solution": "def find_minimum_x():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:N + 2]))\n    B = list(map(int, data[N + 2:N + 2 + M]))\n    \n    # Sort the prices\n    A.sort()\n    B.sort()\n    \n    # Two pointers\n    j = 0  # Pointer for buyers\n    for i in range(N):\n        # Current seller price\n        seller_price = A[i]\n        \n        # Move buyer pointer until B[j] > seller_price\n        while j < M and B[j] <= seller_price:\n            j += 1\n        \n        # Number of sellers who can sell for seller_price or more\n        sellers_count = N - i\n        # Number of buyers who can buy for seller_price or less\n        buyers_count = j\n        \n        if sellers_count >= buyers_count:\n            print(seller_price)\n            return\n    \n    # If we complete the loop without finding a valid answer\n    # This situation shouldn't happen given the constraints\n    print(A[-1] + 1)"}
{"task_id": "abc312_d", "solution": "def count_valid_parentheses(S):\n    MOD = 998244353\n    n = len(S)\n    \n    # Maximum balance can be the length of S\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: empty string is a valid parenthesis string\n    \n    for i in range(n):\n        for j in range(n):  # j is the current balance\n            if dp[i][j] == 0:\n                continue\n            \n            if S[i] == '(':\n                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n            elif S[i] == ')':\n                if j > 0:  # We can only reduce balance if it's above 0\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % MOD\n            elif S[i] == '?':\n                # Treat '?' as '('\n                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n                # Treat '?' as ')'\n                if j > 0:\n                    dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % MOD\n                    \n    return dp[n][0]  # The result is the number of valid configurations with balance 0\n\n# Reading input and outputting result\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read().strip()\n    result = count_valid_parentheses(input_data)\n    print(result)"}
{"task_id": "abc312_e", "solution": "def count_shared_faces(cuboids):\n    N = len(cuboids)\n    counts = [0] * N\n\n    # Prepare structures for the three projections\n    xy_planes = []\n    xz_planes = []\n    yz_planes = []\n\n    # Create projections for each cuboid\n    for i in range(N):\n        x1, y1, z1, x2, y2, z2 = cuboids[i]\n        xy_planes.append((x1, y1, x2, y2, z1, z2, i))\n        xz_planes.append((x1, z1, x2, z2, y1, y2, i))\n        yz_planes.append((y1, z1, y2, z2, x1, x2, i))\n\n    # Function to count overlaps\n    def count_overlaps(planes):\n        planes.sort()  # Sort by the first two dimensions\n        active = []\n        for start1, start2, end1, end2, fixed_start, fixed_end, index in planes:\n            # Remove non-overlapping intervals\n            active = [a for a in active if a[2] > start1]\n            for _, _, _, _, fixed1, fixed2, j in active:\n                if fixed_start == fixed1 and not (end1 <= fixed1 or start1 >= fixed2):\n                    counts[index] += 1\n                    counts[j] += 1\n            active.append((start1, start2, end1, end2, fixed_start, fixed_end, index))\n\n    # Count overlaps for each face\n    count_overlaps(xy_planes)\n    count_overlaps(xz_planes)\n    count_overlaps(yz_planes)\n\n    return counts\n\n\n# Read input\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    N = int(data[0])\n    cuboids = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n    \n    result = count_shared_faces(cuboids)\n    print('\\n'.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_f", "solution": "def max_happiness(N, M, items):\n    pull_tab_cans = []\n    regular_cans = []\n    can_openers = []\n\n    # Categorize items into three lists\n    for T, X in items:\n        if T == 0:\n            pull_tab_cans.append(X)\n        elif T == 1:\n            regular_cans.append(X)\n        else:\n            can_openers.append(X)\n\n    # Sort each list in descending order\n    pull_tab_cans.sort(reverse=True)\n    regular_cans.sort(reverse=True)\n    can_openers.sort(reverse=True)\n\n    # Calculate total happiness from pull-tab cans\n    happiness_from_pull_tabs = sum(pull_tab_cans[:min(M, len(pull_tab_cans))])\n    max_happiness = happiness_from_pull_tabs\n\n    # Check combinations of using can openers with regular cans\n    if can_openers:\n        # Prefix sum of regular can happiness\n        regular_cans_prefix_sum = [0] * (len(regular_cans) + 1)\n        for i in range(1, len(regular_cans) + 1):\n            regular_cans_prefix_sum[i] = regular_cans_prefix_sum[i - 1] + regular_cans[i - 1]\n\n        for k in range(1, min(len(can_openers), M) + 1):\n            # Total cans we can open with k can openers\n            cans_to_open = sum(can_openers[:k])\n            cans_opened = min(cans_to_open, len(regular_cans))\n            \n            total_items_used = k + cans_opened\n            if total_items_used > M:\n                continue\n\n            # Happiness from k can openers and the maximum cans we can open\n            happiness_from_regular_cans = regular_cans_prefix_sum[cans_opened]\n            total_happiness = happiness_from_pull_tabs + happiness_from_regular_cans\n            \n            # Check if we can maximize happiness\n            max_happiness = max(max_happiness, total_happiness)\n\n    return max_happiness\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nN, M = map(int, data[0].split())\nitems = [tuple(map(int, line.split())) for line in data[1:]]\n\nresult = max_happiness(N, M, items)\nprint(result)"}
{"task_id": "abc313_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    \n    P1 = P[0]\n    max_other = max(P[1:]) if N > 1 else 0\n    \n    needed_points = max(0, max_other - P1 + 1)  # +1 because we need P1 + x > max_other\n    print(needed_points)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc313_b", "solution": "def find_strongest_programmer(N, M, relations):\n    # Create a list to count how many programmers each programmer is stronger than\n    strength_count = [0] * (N + 1)  # index 0 will be unused\n    \n    # Process relations\n    for A, B in relations:\n        strength_count[A] += 1  # A is stronger than B, increment A's count\n    \n    # Determine if there's a unique strongest programmer\n    strongest_candidate = -1\n    \n    for i in range(1, N + 1):\n        if strength_count[i] == N - 1:\n            if strongest_candidate == -1:\n                strongest_candidate = i  # found a candidate\n            else:\n                return -1  # more than one candidate with N-1 strength\n    \n    return strongest_candidate\n\n# Read inputs and invoke the function\nimport sys\n\ninput_data = sys.stdin.read().strip().splitlines()\nN, M = map(int, input_data[0].split())\nrelations = [tuple(map(int, line.split())) for line in input_data[1:M+1]]\n\n# Get the result\nresult = find_strongest_programmer(N, M, relations)\n\n# Output the result\nprint(result)"}
{"task_id": "abc313_c", "solution": "def min_operations_to_balance(N, A):\n    min_A = min(A)\n    max_A = max(A)\n    \n    if max_A - min_A <= 1:\n        return 0\n    \n    excess = 0\n    deficit = 0\n    \n    for value in A:\n        if value > min_A + 1:\n            excess += value - (min_A + 1)\n        elif value < min_A:\n            deficit += min_A - value\n    \n    return max(excess, deficit)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\nresult = min_operations_to_balance(N, A)\nprint(result)"}
{"task_id": "abc314_a", "solution": "# Pi value stored as a string for easy slicing\npi_value = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\n# Read the input value for N\nN = int(input().strip())\n\n# Truncate the value of pi to N decimal places\n# The format is \"3.\" followed by N decimal places\nresult = pi_value[:2 + N]  # Slice up to 2 + N to include \"3.\" and N decimals\n\n# Print the result\nprint(result)"}
{"task_id": "abc314_b", "solution": "def roulette_bets():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n\n    N = int(data[0])\n    bets = []\n    \n    index = 1\n    for i in range(N):\n        C_i = int(data[index])\n        A_i = list(map(int, data[index + 1].split()))\n        bets.append((C_i, A_i))\n        index += 2\n    \n    X = int(data[index])\n    \n    # List to store indices of players who bet on X\n    players_betting_on_X = []\n    \n    # Find players betting on X\n    for i in range(N):\n        C_i, A_i = bets[i]\n        if X in A_i:\n            players_betting_on_X.append((i + 1, C_i))  # Store (1-indexed player index, C_i)\n    \n    if not players_betting_on_X:\n        # If no one bet on X\n        print(0)\n        return\n    \n    # Find minimal number of bets among those who bet on X\n    min_bets = min(c for _, c in players_betting_on_X)\n    \n    # Collect all players who have the minimum number of bets\n    result_indices = sorted(i for i, c in players_betting_on_X if c == min_bets)\n    \n    # Output the result\n    print(len(result_indices))\n    if result_indices:\n        print(' '.join(map(str, result_indices)))"}
{"task_id": "abc314_c", "solution": "def perform_color_shifts(N, M, S, C):\n    # Convert S to a list for mutability\n    S = list(S)\n    \n    # Create a mapping of color to indices\n    color_indices = {}\n    for index in range(N):\n        color = C[index]\n        if color not in color_indices:\n            color_indices[color] = []\n        color_indices[color].append(index)\n    \n    # Perform right circular shifts for each color\n    for color in range(1, M + 1):\n        if color in color_indices:\n            indices = color_indices[color]\n            k = len(indices)\n            if k > 1:  # Only need to shift if there's more than one index\n                # Right circular shift\n                last_character_index = indices[-1]\n                # Shift each index\n                for i in range(k - 1, 0, -1):\n                    S[indices[i]] = S[indices[i - 1]]\n                S[indices[0]] = S[last_character_index]\n    \n    # Join the list back to string\n    return ''.join(S)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # First line contains N and M\n    N, M = map(int, data[0].split())\n    # Second line contains S\n    S = data[1]\n    # Third line contains the color array\n    C = list(map(int, data[2].split()))\n    \n    # Perform the shifts and get the final string\n    result = perform_color_shifts(N, M, S, C)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc314_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    S = list(data[1])  # Convert to list for mutable string\n    Q = int(data[2])\n    \n    # This will track the current state of the string:\n    # 0 = normal, 1 = lowercase, 2 = uppercase\n    state = 0\n    \n    for i in range(3, 3 + Q):\n        operation = data[i].split()\n        t = int(operation[0])\n        \n        if t == 1:\n            # Change specific character\n            x = int(operation[1]) - 1  # Convert 1-based index to 0-based\n            c = operation[2]\n            if state == 1:  # If in lowercase state\n                c = c.lower()\n            elif state == 2:  # If in uppercase state\n                c = c.upper()\n            S[x] = c  # Modify the list at index x\n            \n        elif t == 2:\n            # Convert all to lowercase\n            state = 1\n            \n        elif t == 3:\n            # Convert all to uppercase\n            state = 2\n            \n    # Apply the final state to the string\n    if state == 1:\n        S = [ch.lower() for ch in S]\n    elif state == 2:\n        S = [ch.upper() for ch in S]\n    \n    # Print the final string\n    print(''.join(S))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc314_e", "solution": "def expected_cost_to_earn_points(N, M, wheels):\n    # Initialize dp array\n    dp = [float('inf')] * (M + 1)\n    dp[0] = 0  # Cost to get 0 points is 0\n    \n    # Process each wheel\n    for cost, P, scores in wheels:\n        # Calculate the expected points from this wheel\n        expected_points = sum(scores) / P\n        \n        # Update dp array from M down to 0\n        for current_points in range(M, -1, -1):\n            if dp[current_points] == float('inf'):\n                continue  # Skip if unreachable\n            \n            # Check the outcomes of playing this wheel\n            for score in scores:\n                new_points = min(M, current_points + score)\n                dp[new_points] = min(dp[new_points], dp[current_points] + cost)\n    \n    return dp[M]\n\n# Read input and prepare data for the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Read N and M\nN, M = map(int, data[0].split())\nwheels = []\n\n# Read each wheel's information\nfor i in range(1, N + 1):\n    line = list(map(int, data[i].split()))\n    C = line[0]  # Cost to play\n    P = line[1]  # Number of points on this wheel\n    scores = line[2:]  # Points on the wheel\n    wheels.append((C, P, scores))\n\n# Get the expected cost and print\nresult = expected_cost_to_earn_points(N, M, wheels)\nprint(result)"}
{"task_id": "abc314_f", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    MOD = 998244353\n    \n    N = int(data[0])\n    matches = [tuple(map(int, line.split())) for line in data[1:N]]\n\n    # Initialize expected wins and sizes\n    expected_wins = [0] * (N + 1)  # E[i] for player i, 1-based index\n    team_size = [1] * (N + 1)       # size[i] for team of player i, 1-based index\n    \n    for p, q in matches:\n        a = team_size[p]\n        b = team_size[q]\n        \n        # Probabilities\n        prob_p_wins = a * pow(a + b, MOD - 2, MOD) % MOD\n        prob_q_wins = b * pow(a + b, MOD - 2, MOD) % MOD\n        \n        # Expected wins before this match\n        expected_wins[p] += prob_p_wins\n        expected_wins[q] += prob_q_wins\n        \n        # Expectation update with merging\n        expected_wins[p] %= MOD\n        expected_wins[q] %= MOD\n        \n        # Merge teams\n        new_team_size = a + b\n        team_size[p] = new_team_size\n        team_size[q] = new_team_size  # Not strictly necessary\n        \n    # Output expected wins modulo MOD\n    print(' '.join(str(expected_wins[i] % MOD) for i in range(1, N + 1)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_a", "solution": "# Read input from standard input\nimport sys\ninput = sys.stdin.read\n\ndef remove_vowels():\n    S = input().strip()  # Read the input string and remove any surrounding whitespace\n    vowels = {'a', 'e', 'i', 'o', 'u'}  # Define the set of vowels\n    result = ''.join([char for char in S if char not in vowels])  # Filter out vowels\n    print(result)  # Output the resulting string\n\nremove_vowels()"}
{"task_id": "abc315_b", "solution": "def find_middle_day():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    M = int(data[0])\n    days_in_months = list(map(int, data[1:M + 1]))\n    \n    total_days = sum(days_in_months)\n    middle_day = (total_days + 1) // 2\n    \n    cumulative_days = 0\n    \n    for month in range(M):\n        cumulative_days += days_in_months[month]\n        if cumulative_days >= middle_day:\n            day_in_month = middle_day - (cumulative_days - days_in_months[month])\n            print(month + 1, day_in_month)\n            return"}
{"task_id": "abc315_c", "solution": "def max_satisfaction(N, ice_cream_cups):\n    from collections import defaultdict\n\n    # Step 1: Group cups by flavor\n    flavor_map = defaultdict(list)\n    for flavor, deliciousness in ice_cream_cups:\n        flavor_map[flavor].append(deliciousness)\n\n    # Step 2: For each flavor, sort the deliciousness values and get the top two\n    max_satisfaction = 0\n    top_deliciousness = []\n\n    for flavors in flavor_map.values():\n        flavors.sort(reverse=True)\n        if len(flavors) > 0:\n            top_deliciousness.append((flavors[0], flavors[1] if len(flavors) > 1 else 0))  # Store top 1 and top 2\n\n    # Step 3: Calculate satisfaction based on different and same flavors\n    # Case 1: Two different flavors (max sum of two largest deliciousness)\n    if len(top_deliciousness) > 1:\n        top_deliciousness.sort(reverse=True, key=lambda x: x[0])  # sort by largest deliciousness\n        max_satisfaction = max(max_satisfaction, top_deliciousness[0][0] + top_deliciousness[1][0])\n\n    # Case 2: Two same flavors (using the top two deliciousness of the same flavor)\n    for d1, d2 in top_deliciousness:\n        max_satisfaction = max(max_satisfaction, d1 + d2 // 2)\n\n    return max_satisfaction\n\n# Input reading\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nN = int(data[0])\nice_cream_cups = [tuple(map(int, line.split())) for line in data[1:N+1]]\n\n# Calculate the result\nresult = max_satisfaction(N, ice_cream_cups)\n\n# Output the result\nprint(result)"}
{"task_id": "abc315_d", "solution": "def remaining_cookies(H, W, grid):\n    marked = [[False] * W for _ in range(H)]\n    \n    while True:\n        marked_this_round = False\n        \n        # Row marking\n        for i in range(H):\n            color_count = {}\n            for j in range(W):\n                if not marked[i][j]:\n                    color = grid[i][j]\n                    if color in color_count:\n                        color_count[color].append(j)\n                    else:\n                        color_count[color] = [j]\n            for indices in color_count.values():\n                if len(indices) > 1:  # found two or more of the same color\n                    marked_this_round = True\n                    for index in indices:\n                        marked[i][index] = True\n        \n        # Column marking\n        for j in range(W):\n            color_count = {}\n            for i in range(H):\n                if not marked[i][j]:\n                    color = grid[i][j]\n                    if color in color_count:\n                        color_count[color].append(i)\n                    else:\n                        color_count[color] = [i]\n            for indices in color_count.values():\n                if len(indices) > 1:  # found two or more of the same color\n                    marked_this_round = True\n                    for index in indices:\n                        marked[index][j] = True\n        \n        # If no cookies were marked this round, we can stop\n        if not marked_this_round:\n            break\n        \n        # Remove marked cookies\n        for i in range(H):\n            for j in range(W):\n                if marked[i][j]:\n                    grid[i][j] = None  # Remove cookie from grid\n    \n    # Count remaining cookies\n    remaining_count = sum(1 for i in range(H) for j in range(W) if grid[i][j] is not None)\n    return remaining_count\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Read H and W\nH, W = map(int, data[0].split())\n# Read the cookie grid\ngrid = [list(data[i + 1]) for i in range(H)]\n\n# Get the result\nresult = remaining_cookies(H, W, grid)\n\n# Print the result\nprint(result)"}
{"task_id": "abc315_e", "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N = int(data[0])\n    prerequisites = defaultdict(list)\n    \n    # Reading the input and constructing the graph\n    for i in range(1, N + 1):\n        line = list(map(int, data[i].split()))\n        C_i = line[0]\n        if C_i > 0:\n            prerequisites[i] = line[1:C_i + 1]\n    \n    # We want to find all prerequisites for book 1\n    visited = set()\n    order = []\n\n    def dfs(book):\n        if book in visited:\n            return\n        visited.add(book)\n        for prereq in prerequisites[book]:\n            dfs(prereq)\n        order.append(book)\n\n    # Start DFS from book 1\n    dfs(1)\n    \n    # Remove book 1 from order and reverse it to get the correct reading order\n    order.remove(1)\n    order.reverse()\n    \n    print(\" \".join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_f", "solution": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    checkpoints = [tuple(map(int, line.split())) for line in data[1:N+1]]\n    \n    dp = [float('inf')] * N\n    dp[0] = 0.0  # Starting at checkpoint 1\n    \n    for i in range(1, N):\n        for j in range(i):\n            # Calculate the distance from checkpoint j to checkpoint i\n            dist = math.sqrt((checkpoints[i][0] - checkpoints[j][0]) ** 2 + \n                             (checkpoints[i][1] - checkpoints[j][1]) ** 2)\n            C = i - j - 1  # Number of skipped checkpoints\n            penalty = 0 if C == 0 else 2 ** (C - 1)  # Calculate penalty\n            \n            # Update dp[i]\n            dp[i] = min(dp[i], dp[j] + dist + penalty)\n    \n    # The answer is the minimum cost to reach checkpoint N (index N-1)\n    print(f\"{dp[N-1]:.20f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc318_a", "solution": "def count_full_moon_days(N, M, P):\n    if M > N:\n        return 0\n    else:\n        # Calculate the maximum k such that M + kP <= N\n        k_max = (N - M) // P\n        return k_max + 1  # +1 to include the first full moon on day M\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nN = int(data[0])\nM = int(data[1])\nP = int(data[2])\n\n# Get the result and print it\nresult = count_full_moon_days(N, M, P)\nprint(result)"}
{"task_id": "abc318_b", "solution": "def calculate_area():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N = int(data[0])\n    grid = [[False] * 101 for _ in range(101)]\n    \n    for i in range(1, N + 1):\n        A, B, C, D = map(int, data[i].split())\n        for x in range(A, B):\n            for y in range(C, D):\n                grid[x][y] = True\n\n    # Calculate total covered area\n    area = sum(1 for i in range(101) for j in range(101) if grid[i][j])\n    \n    # Output the result\n    print(area)\n\ncalculate_area()"}
{"task_id": "abc318_c", "solution": "def minimum_trip_cost():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    D = int(data[1])\n    P = int(data[2])\n    F = list(map(int, data[3:]))\n    \n    # Total cost if we don't use any one-day passes\n    total_regular_cost = sum(F)\n    \n    # Initialize the minimum cost as the total regular cost\n    min_cost = total_regular_cost\n    \n    # Iterate over the number of batches of passes we can buy\n    # max_batches is the maximum number of D-day passes we can consider\n    max_batches = (N + D - 1) // D\n    \n    for k in range(max_batches + 1):\n        # Cost for k batches of one-day passes\n        cost_with_passes = k * P\n        \n        # Days covered by the passes\n        days_covered = k * D\n        \n        # Cost of remaining days\n        remaining_days = N - days_covered\n        \n        # We need to sum the lowest fares from the F array for the remaining days\n        if remaining_days > 0:\n            # Sort F to get the cheapest options\n            remaining_cost = sum(sorted(F)[:remaining_days])\n        else:\n            remaining_cost = 0\n        \n        # Calculate the total cost for this option\n        total_cost = cost_with_passes + remaining_cost\n        \n        # Update the minimum cost found\n        min_cost = min(min_cost, total_cost)\n    \n    # Output the result\n    print(min_cost)"}
{"task_id": "abc318_d", "solution": "def max_weight_edges(N, edge_weights):\n    # Convert edge weights to a full adjacency matrix\n    D = [[0] * N for _ in range(N)]\n    index = 0\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            D[i][j] = edge_weights[index]\n            D[j][i] = edge_weights[index]\n            index += 1\n    \n    # DP array to store the maximum weight with the given mask\n    dp = [0] * (1 << N)\n    \n    # Iterate over all possible masks\n    for mask in range(1 << N):\n        # Try to add an edge (i, j) to the current mask if possible\n        for i in range(N):\n            if (mask & (1 << i)) == 0:  # vertex i is not yet used\n                for j in range(i + 1, N):\n                    if (mask & (1 << j)) == 0:  # vertex j is not yet used\n                        new_mask = mask | (1 << i) | (1 << j)\n                        dp[new_mask] = max(dp[new_mask], dp[mask] + D[i][j])\n    \n    # The answer is the maximum value in the dp array\n    return max(dp)\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().splitlines()\n    N = int(data[0])\n    edge_weights = []\n    \n    for line in data[1:]:\n        edge_weights.extend(map(int, line.split()))\n    \n    result = max_weight_edges(N, edge_weights)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc318_e", "solution": "def count_valid_triples(N, A):\n    from collections import defaultdict\n    \n    # Step 1: Create a map to store indices of each value in A\n    index_map = defaultdict(list)\n    \n    for idx, value in enumerate(A):\n        index_map[value].append(idx)\n    \n    total_triples = 0\n    \n    # Step 2: Count valid triples for each unique value in A\n    for value, indices in index_map.items():\n        m = len(indices)\n        \n        # Step 3: Count occurrences of other numbers\n        count_other = [0] * (N + 1)\n        for num in A:\n            if num != value:\n                count_other[num] += 1\n        \n        # Step 4: Calculate valid triples for this value\n        for j in range(m):  # j is the position of A[i]\n            i = indices[j]\n            \n            # Count how many A[j] are valid (where j is between i and k)\n            for k in range(j + 1, m):  # k is the position of A[k]\n                k_pos = indices[k]\n                \n                # Number of valid j's is simply the count of non-value elements\n                total_triples += count_other[k_pos]\n                \n            # Update count_other to reflect we've \"used\" this index\n            count_other[i] -= 1\n            \n    return total_triples\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_triples(N, A)\n\n# Print the result\nprint(result)"}
{"task_id": "abc319_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n\n    # Step 1: Find divisors of N that are between 1 and 9.\n    valid_divisors = [j for j in range(1, 10) if N % j == 0]\n\n    # Step 2: Construct the output string\n    result = []\n    \n    for i in range(N + 1):\n        smallest_j = None\n        for j in valid_divisors:\n            if i % (N // j) == 0:  # Check if i is a multiple of N/j\n                if smallest_j is None or j < smallest_j:\n                    smallest_j = j\n        \n        # If we found a valid smallest j, append it; otherwise, append '-'.\n        if smallest_j is not None:\n            result.append(str(smallest_j))\n        else:\n            result.append('-')\n\n    # Step 3: Print the result\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc319_c", "solution": "import itertools\nimport math\nfrom collections import Counter\n\ndef probability_no_disappointment(grid):\n    # Flatten the grid to a list of numbers\n    numbers = [num for row in grid for num in row]\n    \n    # Count frequencies of each number\n    count = Counter(numbers)\n    total_permutations = math.factorial(9)  # Total arrangements of the 9 cells\n    \n    # Calculate the denominator for permutations with duplicates\n    for freq in count.values():\n        total_permutations //= math.factorial(freq)\n\n    # Define positions for checking disappointment\n    disappointment_patterns = [\n        [(0, 0), (0, 1), (0, 2)],  # row 1\n        [(1, 0), (1, 1), (1, 2)],  # row 2\n        [(2, 0), (2, 1), (2, 2)],  # row 3\n        [(0, 0), (1, 0), (2, 0)],  # col 1\n        [(0, 1), (1, 1), (2, 1)],  # col 2\n        [(0, 2), (1, 2), (2, 2)],  # col 3\n        [(0, 0), (1, 1), (2, 2)],  # diagonal \\\n        [(2, 0), (1, 1), (0, 2)],  # diagonal /\n    ]\n    \n    # Function to check a single arrangement for disappointment\n    def is_valid(arrangement):\n        for pattern in disappointment_patterns:\n            a, b, c = arrangement[pattern[0][0] * 3 + pattern[0][1]], arrangement[pattern[1][0] * 3 + pattern[1][1]], arrangement[pattern[2][0] * 3 + pattern[2][1]]\n            if a == b and a != c:\n                return False\n        return True\n\n    # Count valid permutations\n    valid_permutations_count = 0\n    for arrangement in itertools.permutations(numbers):\n        if is_valid(arrangement):\n            valid_permutations_count += 1\n\n    # Calculate the probability\n    probability = valid_permutations_count / total_permutations\n    return probability\n\n# Reading input from stdin\nimport sys\n\ngrid = []\nfor _ in range(3):\n    row = list(map(int, sys.stdin.readline().strip().split()))\n    grid.append(row)\n\n# Calculate the probability\nresult = probability_no_disappointment(grid)\n\n# Output the result with the required precision\nprint(f\"{result:.30f}\")"}
{"task_id": "abc319_d", "solution": "def can_fit(words, width, max_lines):\n    current_line_length = 0\n    lines_used = 1  # Start with one line\n\n    for length in words:\n        if current_line_length + (1 if current_line_length > 0 else 0) + length > width:\n            lines_used += 1  # Start a new line\n            current_line_length = length  # This word starts the new line\n            if lines_used > max_lines:\n                return False\n        else:\n            if current_line_length > 0:\n                current_line_length += 1  # Add space for the next word\n            current_line_length += length  # Add the current word length\n\n    return True\n\ndef minimum_window_width(N, M, widths):\n    left = max(widths)  # The longest word\n    right = sum(widths) + N - 1  # All words plus spaces\n\n    while left < right:\n        mid = (left + right) // 2\n        if can_fit(widths, mid, M):\n            right = mid  # Try to find a smaller width\n        else:\n            left = mid + 1  # Increase width\n\n    return left\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\nwidths = list(map(int, data[1].split()))\n\n# Get the answer and print it\nresult = minimum_window_width(N, M, widths)\nprint(result)"}
{"task_id": "abc319_e", "solution": "def earliest_arrival(N, X, Y, P, T, queries):\n    results = []\n    \n    for q in queries:\n        # Start at time q\n        current_time = q + X\n        \n        for i in range(N - 1):\n            # Calculate next bus departure time\n            if current_time % P[i] == 0:\n                # If he arrives at a multiple of P[i], he can take the bus immediately\n                current_time += T[i]\n            else:\n                # Calculate the next bus departure time\n                next_departure = ((current_time // P[i]) + 1) * P[i]\n                current_time = next_departure + T[i]\n        \n        # Finally walk to Aoki's house\n        current_time += Y\n        \n        results.append(current_time)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# First line\nN, X, Y = map(int, data[0].split())\nP = []\nT = []\nfor i in range(1, N):\n    p_i, t_i = map(int, data[i].split())\n    P.append(p_i)\n    T.append(t_i)\n\n# Queries\nQ = int(data[N])\nqueries = [int(data[N + 1 + i]) for i in range(Q)]\n\n# Get results\nresults = earliest_arrival(N, X, Y, P, T, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "abc320_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip()\n    \n    A, B = map(int, data.split())\n    \n    # Calculate A^B and B^A\n    result = (A ** B) + (B ** A)\n    \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc320_b", "solution": "def longest_palindromic_substring_length(S: str) -> int:\n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(S) and S[left] == S[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    max_length = 1\n    for i in range(len(S)):\n        # Check for odd-length palindromes\n        len1 = expand_around_center(i, i)\n        # Check for even-length palindromes\n        len2 = expand_around_center(i, i + 1)\n        max_length = max(max_length, len1, len2)\n    \n    return max_length\n\nif __name__ == \"__main__\":\n    import sys\n    input_string = sys.stdin.read().strip()\n    result = longest_palindromic_substring_length(input_string)\n    print(result)"}
{"task_id": "abc320_c", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    M = int(data[0])\n    S1 = data[1]\n    S2 = data[2]\n    S3 = data[3]\n    \n    # A dictionary to store the earliest time for each character on the three reels\n    character_times = {}\n    \n    # Record the time each character can be displayed for each reel\n    for t in range(M):\n        for reel_index, S in enumerate([S1, S2, S3]):\n            char = S[t]\n            if char not in character_times:\n                character_times[char] = [None, None, None]\n            character_times[char][reel_index] = t if character_times[char][reel_index] is None else min(character_times[char][reel_index], t)\n\n    min_time = float('inf')\n    for times in character_times.values():\n        if None not in times:  # All reels can display this character\n            min_time = min(min_time, max(times))  # We want the maximum of the three times\n    \n    print(min_time if min_time != float('inf') else -1)"}
{"task_id": "abc320_d", "solution": "from collections import defaultdict, deque\n\ndef determine_coordinates(N, M, relationships):\n    # Graph to store relationships\n    graph = defaultdict(list)\n    \n    # Fill the graph with the relationships\n    for A, B, X, Y in relationships:\n        graph[A].append((B, X, Y))\n        graph[B].append((A, -X, -Y))  # Reverse relationship for reverse query\n        \n    # Coordinates array; None means undecided\n    coordinates = [None] * (N + 1)\n    coordinates[1] = (0, 0)  # Person 1 is at (0, 0)\n    \n    # BFS queue\n    queue = deque([1])\n    \n    while queue:\n        current = queue.popleft()\n        current_x, current_y = coordinates[current]\n        \n        for neighbor, dx, dy in graph[current]:\n            new_x = current_x + dx\n            new_y = current_y + dy\n            \n            if coordinates[neighbor] is None:\n                # Assign the coordinate if it's undecided\n                coordinates[neighbor] = (new_x, new_y)\n                queue.append(neighbor)\n            else:\n                # If already set, check for conflicts\n                if coordinates[neighbor] != (new_x, new_y):\n                    coordinates[neighbor] = \"undecidable\"\n    \n    results = []\n    for i in range(1, N + 1):\n        if coordinates[i] == \"undecidable\":\n            results.append(\"undecidable\")\n        else:\n            results.append(f\"{coordinates[i][0]} {coordinates[i][1]}\")\n            \n    return results\n\n# Read input and call the function to output results\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N, M = map(int, data[0].split())\n    relationships = [tuple(map(int, line.split())) for line in data[1:M+1]]\n    \n    results = determine_coordinates(N, M, relationships)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc320_e", "solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    first_line = data[0].split()\n    N = int(first_line[0])\n    M = int(first_line[1])\n    \n    noodles_received = [0] * N\n    queue = list(range(1, N + 1))  # People are numbered from 1 to N\n    heapq.heapify(queue)  # This is actually not necessary since we will manage it manually\n    return_heap = []\n    \n    current_time = 0\n    event_idx = 1  # Start processing from the second line (first line contains N and M)\n    \n    for _ in range(M):\n        T_i, W_i, S_i = map(int, data[event_idx].split())\n        event_idx += 1\n        \n        # Process returns from the return_heap before this event time\n        while return_heap and return_heap[0][0] <= T_i:\n            return_time, person = heapq.heappop(return_heap)\n            heapq.heappush(queue, person)  # Person returns to the queue\n        \n        # Now process the current event at time T_i\n        if queue:\n            front_person = heapq.heappop(queue)  # Get the person at the front\n            noodles_received[front_person - 1] += W_i  # Update the noodles count\n            return_time = T_i + S_i\n            heapq.heappush(return_heap, (return_time, front_person))  # Schedule their return\n        \n    # After processing all events, we need to check for any remaining returns\n    while return_heap:\n        return_time, person = heapq.heappop(return_heap)\n        heapq.heappush(queue, person)  # They can be pushed back to the queue if needed\n    \n    # Output the result for each person\n    for amount in noodles_received:\n        print(amount)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_a", "solution": "def is_321_like_number(N):\n    # Convert the number to a string to access digits\n    str_N = str(N)\n    # Iterate through the digits and check the decreasing condition\n    for i in range(len(str_N) - 1):\n        if str_N[i] <= str_N[i + 1]:  # Check if the current digit is not greater than the next\n            return \"No\"\n    return \"Yes\"\n\n# Read input\nN = int(input().strip())\n# Print the result\nprint(is_321_like_number(N))"}
{"task_id": "abc321_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])  # Number of rounds\n    X = int(data[1])  # Target final grade\n    scores = list(map(int, data[2:2 + N - 1]))  # Scores from the first N-1 rounds\n    \n    # Sort existing scores\n    scores.sort()\n    \n    # Check for the minimum score needed\n    min_score = -1\n    for final_score in range(101):  # A_N can be from 0 to 100\n        # Create a new score list including final_score\n        new_scores = scores + [final_score]\n        new_scores.sort()\n        \n        # Calculate the final grade by summing up the middle scores\n        final_grade = sum(new_scores[1:-1])\n        \n        if final_grade >= X:\n            min_score = final_score\n            break\n    \n    print(min_score)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_c", "solution": "from itertools import combinations\n\ndef find_kth_321_like_number(K):\n    # Possible digits\n    digits = '0123456789'\n    num_list = []\n    \n    # Generate all non-empty subsets of the digits\n    for i in range(1, len(digits) + 1):\n        for combo in combinations(digits, i):\n            # Sort the combination in descending order and convert to string\n            num_str = ''.join(sorted(combo, reverse=True))\n            # Convert to integer\n            num = int(num_str)\n            # Avoid numbers that start with 0 (ignore leading zeros)\n            if not (num_str[0] == '0' and len(num_str) > 1):\n                num_list.append(num)\n\n    # Sort the list of numbers and remove duplicates\n    num_list = sorted(set(num_list))\n    \n    # Return the K-th smallest number (1-indexed)\n    return num_list[K-1]\n\n# Read input\nK = int(input().strip())\n\n# Find the K-th smallest 321-like number\nresult = find_kth_321_like_number(K)\n\n# Output the result\nprint(result)"}
{"task_id": "abc321_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    from bisect import bisect_right\n\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    A = list(map(int, data[3:3+N]))\n    B = list(map(int, data[3+N:3+N+M]))\n\n    # Sort the side dishes prices\n    B.sort()\n\n    total_price = 0\n\n    for a in A:\n        max_side_price = P - a\n        # Determine the number of side dishes that can be included\n        count_of_valid_b = bisect_right(B, max_side_price)\n        \n        # For all valid side dishes, add their prices\n        # If count_of_valid_b is positive, there are side dishes that A_i + B_j <= P\n        if count_of_valid_b > 0:\n            total_price += sum(B[:count_of_valid_b])\n        \n        # If all combinations exceed P, we add P for each main dish\n        total_price += (M - count_of_valid_b) * P\n\n    print(total_price)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_e", "solution": "def count_vertices_at_distance(N, X, K):\n    if K == 0:\n        return 1  # Only the vertex X itself\n    \n    count = 0\n    current_level = 0\n    current_vertex = X\n    \n    # Calculate distances upwards to the root\n    while current_vertex > 0 and current_level < K:\n        current_vertex //= 2\n        current_level += 1\n    \n    # If K is more than the height of the tree from X\n    if current_level < K:\n        return 0\n    \n    # Calculate number of vertices at distance K\n    # Start from the level of X downwards\n    # Maximum vertices at distance K from the original position\n    # Each level below doubles the count of vertices\n    vertices_at_distance = 1 << K  # This is 2^K\n    \n    # Calculate the limits\n    # We want to find the minimum between vertices we can count\n    # and the maximum limit of N\n    \n    total_vertices = min(vertices_at_distance, N - (1 << (K - 1)))\n    \n    return total_vertices\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    T = int(data[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        N, X, K = map(int, data[i].split())\n        result = count_vertices_at_distance(N, X, K)\n        results.append(result)\n    \n    # Print all results at once\n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc322_a", "solution": "def find_abc_position():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    S = data[1]\n    \n    # We need to check for substring \"ABC\"\n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            print(i + 1)  # Return 1-based index\n            return\n    \n    print(-1)  # If \"ABC\" is not found\n\nfind_abc_position()"}
{"task_id": "abc322_b", "solution": "def check_prefix_suffix():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    # Read N and M\n    N, M = map(int, data[0].split())\n    # Read strings S and T\n    S = data[1]\n    T = data[2]\n    \n    is_prefix = T[:N] == S\n    is_suffix = T[-N:] == S\n    \n    if is_prefix and is_suffix:\n        print(0)\n    elif is_prefix:\n        print(1)\n    elif is_suffix:\n        print(2)\n    else:\n        print(3)"}
{"task_id": "abc322_c", "solution": "def fireworks_days():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:M+2]))\n    \n    result = [0] * N\n    firework_index = 0\n    \n    for i in range(1, N + 1):\n        while firework_index < M and A[firework_index] < i:\n            firework_index += 1\n        \n        if firework_index < M and A[firework_index] == i:\n            result[i - 1] = 0  # Fireworks today\n        else:\n            result[i - 1] = A[firework_index] - i  # Next fireworks day\n    \n    # Print the result\n    print('\\n'.join(map(str, result)))"}
{"task_id": "abc322_d", "solution": "def generate_rotations(polyomino):\n    # Returns all rotations of a given 4x4 polyomino\n    def rotate_90(p):\n        return [''.join(p[3-j][i] for j in range(4)) for i in range(4)]\n    \n    rotations = []\n    current = polyomino\n    for _ in range(4):\n        current = rotate_90(current)\n        rotations.append(current)\n    return rotations\n\ndef extract_polyominoes(input_data):\n    # Extracts the three polyominoes from the input string\n    return [input_data[i:i+4] for i in range(0, 48, 4)]\n\ndef get_occupied_coordinates(polyomino):\n    return [(i, j) for i in range(4) for j in range(4) if polyomino[i][j] == '#']\n\ndef can_place(polyomino, grid, top, left):\n    for i, j in get_occupied_coordinates(polyomino):\n        if top + i >= 4 or left + j >= 4 or grid[top + i][left + j] == '#':\n            return False\n    return True\n\ndef place(polyomino, grid, top, left):\n    new_grid = [list(row) for row in grid]\n    for i, j in get_occupied_coordinates(polyomino):\n        new_grid[top + i][left + j] = '#'\n    return [''.join(row) for row in new_grid]\n\ndef backtrack(polyominoes, grid, index):\n    if index == len(polyominoes):\n        return all('#' in row for row in grid)\n    \n    for rotation in generate_rotations(polyominoes[index]):\n        for top in range(4):\n            for left in range(4):\n                if can_place(rotation, grid, top, left):\n                    new_grid = place(rotation, grid, top, left)\n                    if backtrack(polyominoes, new_grid, index + 1):\n                        return True\n    return False\n\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip().replace('\\n', '')\n    \n    polyominoes = extract_polyominoes(input_data)\n    empty_grid = ['.' * 4 for _ in range(4)]\n    \n    if backtrack(polyominoes, empty_grid, 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc322_e", "solution": "def minimal_cost_to_achieve_goals():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N, K, P\n    N, K, P = map(int, data[0].split())\n    \n    # Read development plans\n    plans = []\n    for i in range(1, N + 1):\n        line = list(map(int, data[i].split()))\n        cost = line[0]\n        increments = line[1:]\n        plans.append((cost, increments))\n    \n    # Number of combinations is 2^N\n    min_cost = float('inf')\n    achieved = False\n    \n    for combination in range(1 << N):\n        total_cost = 0\n        total_increments = [0] * K\n        \n        for i in range(N):\n            if combination & (1 << i):  # If i-th plan is included\n                total_cost += plans[i][0]\n                for j in range(K):\n                    total_increments[j] += plans[i][1][j]\n        \n        # Check if all parameters meet or exceed P\n        if all(increment >= P for increment in total_increments):\n            achieved = True\n            min_cost = min(min_cost, total_cost)\n    \n    if achieved:\n        print(min_cost)\n    else:\n        print(-1)"}
{"task_id": "abc323_a", "solution": "def check_even_index_zeros():\n    import sys\n    input = sys.stdin.read\n    S = input().strip()  # Read and strip any extra whitespace/newlines\n\n    # Check characters at even indices (1, 3, 5, 7, 9, 11, 13, 15 in 0-based indexing)\n    even_positions_are_zero = all(S[i] == '0' for i in range(1, 16, 2))\n    \n    if even_positions_are_zero:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# The function will be called in a complete environment where the input is provided through standard input."}
{"task_id": "abc323_b", "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N = int(data[0])\n    results = data[1:N+1]\n    \n    wins = [0] * N\n    \n    # Count wins for each player\n    for i in range(N):\n        for j in range(N):\n            if results[i][j] == 'o':\n                wins[i] += 1\n    \n    # Create a list of (wins, player_number)\n    player_ranks = [(wins[i], i + 1) for i in range(N)]\n    \n    # Sort primarily by wins (descending), secondarily by player number (ascending)\n    player_ranks.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Extract sorted player numbers\n    sorted_players = [player[1] for player in player_ranks]\n    \n    # Print the result\n    print(\" \".join(map(str, sorted_players)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc323_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and M\n    N, M = map(int, data[0].split())\n    \n    # Read scores of problems\n    scores = list(map(int, data[1].split()))\n    \n    # Read solved problems for each player\n    solved = data[2:2 + N]\n    \n    # Calculate current scores for each player\n    current_scores = []\n    for i in range(N):\n        score = sum(scores[j] for j in range(M) if solved[i][j] == 'o') + (i + 1)\n        current_scores.append(score)\n    \n    # Prepare the results\n    results = []\n    \n    for i in range(N):\n        # Calculate the maximum score among other players\n        max_other_score = max(current_scores[j] for j in range(N) if j != i)\n        \n        # Find the scores of unsolved problems\n        unsolved_scores = [scores[j] for j in range(M) if solved[i][j] == 'x']\n        \n        # Sort unsolved scores in descending order\n        unsolved_scores.sort(reverse=True)\n        \n        # Determine how many problems need to be solved\n        required_solves = 0\n        new_score = current_scores[i]\n        \n        for score in unsolved_scores:\n            new_score += score\n            required_solves += 1\n            if new_score > max_other_score:\n                break\n        \n        results.append(required_solves)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc323_d", "solution": "def minimum_slimes_after_synthesis(N, slime_counts):\n    from collections import defaultdict\n    import heapq\n\n    # Store sizes and counts in a dictionary\n    slime_dict = defaultdict(int)\n    for size, count in slime_counts:\n        slime_dict[size] += count\n\n    # Using a priority queue (min-heap) to handle sizes in ascending order\n    heap = []\n    for size, count in slime_dict.items():\n        heapq.heappush(heap, (size, count))\n\n    # Iterate until we can no longer combine slimes\n    while heap:\n        size, count = heapq.heappop(heap)\n        if count == 0:\n            continue\n        \n        # Number of pairs that can be formed\n        pairs = count // 2\n        remaining = count % 2\n\n        if pairs > 0:\n            new_size = size * 2\n            new_count = slime_dict[new_size] + pairs\n            \n            # Update the dictionary\n            slime_dict[new_size] = new_count\n            \n            # Push the new size back to the heap\n            heapq.heappush(heap, (new_size, new_count))\n\n        # If there's a remaining slime of the current size\n        if remaining > 0:\n            slime_dict[size] = remaining\n            heapq.heappush(heap, (size, remaining))\n    \n    # Calculate the total count of remaining slimes\n    total_slimes = sum(slime_dict.values())\n    return total_slimes\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\nN = int(data[0])\nslime_counts = [tuple(map(int, line.split())) for line in data[1:]]\n\n# Get the answer and print it\nresult = minimum_slimes_after_synthesis(N, slime_counts)\nprint(result)"}
{"task_id": "abc323_e", "solution": "def mod_inverse(a, p):\n    \"\"\" Return the modular inverse of a under modulo p using Extended Euclidean Algorithm. \"\"\"\n    original_p = p\n    x0, x1 = 1, 0\n    if p == 1:\n        return 0\n    while a > 1:\n        quotient = a // p\n        a, p = p, a % p\n        x0, x1 = x1, x0 - quotient * x1\n    if x0 < 0:\n        x0 += original_p\n    return x0\n\ndef calculate_probability(N, X, T):\n    MOD = 998244353\n    S = sum(T)\n    \n    # Initialize dp array\n    dp = [0] * (X + 2)\n    dp[0] = pow(N, MOD - 2, MOD)  # Probability of song 1 being played at time 0\n    \n    for time in range(X + 1):\n        for i in range(N):\n            if time + T[i] <= X + 1:\n                dp[time + T[i]] += dp[time] * pow(N, MOD - 2, MOD) % MOD\n                dp[time + T[i]] %= MOD\n    \n    # Now we have probabilities at times X and X + 1\n    prob_X = dp[X]\n    prob_X_plus_1 = dp[X + 1]\n    \n    # Probability that song 1 is being played at X + 0.5\n    # It can be represented as prob_X * (time remaining for song 1) + prob_X_plus_1 * (time remaining for song 1)\n    prob_playing_at_half = (prob_X + prob_X_plus_1) % MOD\n    \n    # We need to calculate the denominator which is S\n    denominator = S\n    \n    # We need to find the modular inverse of the denominator\n    denominator_inverse = mod_inverse(denominator, MOD)\n    \n    # Result is (prob_playing_at_half * denominator_inverse) % MOD\n    result = (prob_playing_at_half * denominator_inverse) % MOD\n    \n    return result\n\n# Implementation\nimport sys\n\ndef main():\n    input_data = sys.stdin.read().strip().splitlines()\n    N, X = map(int, input_data[0].split())\n    T = list(map(int, input_data[1].split()))\n    \n    result = calculate_probability(N, X, T)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_a", "solution": "def check_equal_integers():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N = int(data[0])  # the first value is N\n    A = list(map(int, data[1:]))  # the next N values are the integers A_1, A_2, ..., A_N\n    \n    # Check if all elements are equal\n    if all(x == A[0] for x in A):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"task_id": "abc324_b", "solution": "def can_be_expressed_as_2x3y(N):\n    # Step 1: Divide by 2 until it's no longer divisible\n    while N % 2 == 0:\n        N //= 2\n    \n    # Step 2: Divide by 3 until it's no longer divisible\n    while N % 3 == 0:\n        N //= 3\n    \n    # Step 3: Check if what's left is 1\n    if N == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Reading input\nimport sys\ninput = sys.stdin.read\nN = int(input().strip())\ncan_be_expressed_as_2x3y(N)"}
{"task_id": "abc324_c", "solution": "def can_form_by_inserting(s, t):\n    # s should be shorter than t\n    if len(s) + 1 != len(t):\n        return False\n    i, j = 0, 0\n    found_difference = False\n    while j < len(t):\n        if i < len(s) and s[i] == t[j]:\n            i += 1\n        else:\n            if found_difference:\n                return False\n            found_difference = True\n        j += 1\n    return True\n\ndef can_form_by_deleting(s, t):\n    # s should be longer than t\n    if len(s) != len(t) + 1:\n        return False\n    i, j = 0, 0\n    found_difference = False\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            j += 1\n        else:\n            if found_difference:\n                return False\n            found_difference = True\n        i += 1\n    return True\n\ndef can_form_by_changing(s, t):\n    # s and t should be the same length\n    if len(s) != len(t):\n        return False\n    difference_count = 0\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            difference_count += 1\n            if difference_count > 1:\n                return False\n    return difference_count == 1\n\ndef find_possible_originals(n, T_prime, strings):\n    results = []\n    \n    for index, S in enumerate(strings):\n        if S == T_prime:\n            results.append(index + 1)\n        elif len(S) + 1 == len(T_prime) and can_form_by_inserting(S, T_prime):\n            results.append(index + 1)\n        elif len(S) == len(T_prime) + 1 and can_form_by_deleting(S, T_prime):\n            results.append(index + 1)\n        elif len(S) == len(T_prime) and can_form_by_changing(S, T_prime):\n            results.append(index + 1)\n    \n    return len(results), results\n\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().splitlines()\nN, T_prime = data[0].split()\nN = int(N)\nstrings = data[1:N + 1]\n\n# Find possible original strings\nK, indices = find_possible_originals(N, T_prime, strings)\n\n# Print the output\nprint(K)\nif K > 0:\n    print(' '.join(map(str, indices)))"}
{"task_id": "abc324_d", "solution": "from itertools import permutations\nimport math\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    N = int(data[0])\n    S = data[1]\n    \n    unique_squares = set()\n    \n    # Generate all unique permutations of the string S\n    for perm in set(permutations(S)):\n        # Join the tuple to form the number string\n        num_str = ''.join(perm)\n        \n        # Skip if the number has leading zeros (except the number \"0\" itself)\n        if num_str[0] == '0' and len(num_str) > 1:\n            continue\n        \n        # Convert to an integer\n        number = int(num_str)\n        \n        # Check if the number is a perfect square\n        root = int(math.isqrt(number))\n        if root * root == number:\n            unique_squares.add(number)\n    \n    # Output the count of unique squares\n    print(len(unique_squares))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_e", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, T = data[0].split()\n    N = int(N)\n    S = data[1:N + 1]\n    \n    m = len(T)\n    \n    # Calculate prefix_count and suffix_count\n    prefix_count = [0] * N\n    suffix_count = [0] * N\n    \n    # Compute prefix match counts\n    for i in range(N):\n        t_index = 0\n        for char in S[i]:\n            if t_index < m and char == T[t_index]:\n                t_index += 1\n                if t_index == m:\n                    break\n        prefix_count[i] = t_index\n    \n    # Compute suffix match counts\n    for i in range(N):\n        t_index = m - 1\n        for char in reversed(S[i]):\n            if t_index >= 0 and char == T[t_index]:\n                t_index -= 1\n                if t_index < 0:\n                    break\n        suffix_count[i] = m - 1 - t_index  # How many from the end were matched\n    \n    # Count valid pairs\n    count = 0\n    # Create a frequency array for suffix matches\n    suffix_frequency = [0] * (m + 1)\n    \n    for j in range(N):\n        suffix_frequency[suffix_count[j]] += 1\n    \n    for i in range(N):\n        # We check how many suffixes can complement the current prefix_count[i]\n        needed_suffix = m - prefix_count[i]  # How many characters are needed from the end\n        if needed_suffix >= 0 and needed_suffix <= m:\n            count += suffix_frequency[needed_suffix]\n    \n    print(count)"}
{"task_id": "abc324_f", "solution": "import sys\nimport heapq\n\ndef can_achieve_ratio(N, edges, R):\n    graph = [[] for _ in range(N + 1)]\n    for u, v, b, c in edges:\n        graph[u].append((v, b, c))\n    \n    # Priority queue\n    pq = []\n    heapq.heappush(pq, (0, 1))  # (negative beauty, node) to simulate max-heap\n    max_beauty = [-float('inf')] * (N + 1)\n    max_beauty[1] = 0\n    \n    while pq:\n        neg_beauty, node = heapq.heappop(pq)\n        beauty = -neg_beauty\n        \n        if node == N:\n            return True\n        \n        for v, b, c in graph[node]:\n            new_beauty = beauty + b\n            # If we consider the cost in terms of R\n            new_cost = c\n            if new_beauty - R * new_cost >= 0:  # Check the modified condition\n                if new_beauty > max_beauty[v]:\n                    max_beauty[v] = new_beauty\n                    heapq.heappush(pq, (-new_beauty, v))\n    \n    return False\n\ndef max_beauty_to_cost_ratio(N, M, edge_list):\n    left, right = 0, 10000  # Initial bounds for binary search\n    epsilon = 1e-9\n    \n    while right - left > epsilon:\n        mid = (left + right) / 2.0\n        if can_achieve_ratio(N, edge_list, mid):\n            left = mid  # We can achieve at least mid, try for a larger R\n        else:\n            right = mid  # mid is too large, go smaller\n            \n    return left\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and M\n    N, M = map(int, data[0].split())\n    edge_list = []\n    \n    # Read edges\n    for i in range(1, M + 1):\n        u, v, b, c = map(int, data[i].split())\n        edge_list.append((u, v, b, c))\n    \n    # Calculate result\n    result = max_beauty_to_cost_ratio(N, M, edge_list)\n    \n    # Print result with sufficient precision\n    print(f\"{result:.10f}\")\n\n# Uncomment below to run the function as a script.\n# if __name__ == \"__main__\":\n#     main()"}
{"task_id": "abc325_a", "solution": "# Read the input from standard input\ninput_string = input().strip()\n\n# Split the input to get surname and first name\nsurname, firstname = input_string.split()\n\n# Create the desired output format\noutput_string = f\"{surname} san\"\n\n# Print the result\nprint(output_string)"}
{"task_id": "abc325_b", "solution": "def max_employees_participating():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    W = []\n    X = []\n    \n    for i in range(1, N + 1):\n        w, x = map(int, data[i].split())\n        W.append(w)\n        X.append(x)\n    \n    max_participants = 0\n    \n    # Check each hour from 0 to 23 as the start time for the meeting\n    for t in range(24):\n        current_participants = 0\n        \n        # Check each base\n        for i in range(N):\n            # Base i working hours in UTC\n            start_working_hour = (9 - X[i] + 24) % 24\n            end_working_hour = (18 - X[i] + 24) % 24\n            \n            # Meeting time from t to t + 1\n            # We need to check if (t, t+1) is within (start_working_hour, end_working_hour)\n            if start_working_hour < end_working_hour:\n                # Normal case: hours do not wrap around midnight\n                if t >= start_working_hour and t < end_working_hour:\n                    current_participants += W[i]\n            else:\n                # Wrapped case: hours wrap around midnight\n                if t >= start_working_hour or t < end_working_hour:\n                    current_participants += W[i]\n        \n        max_participants = max(max_participants, current_participants)\n    \n    print(max_participants)"}
{"task_id": "abc325_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read H and W\n    H, W = map(int, data[0].split())\n    \n    # Read the grid\n    grid = [list(data[i + 1]) for i in range(H)]\n    \n    # Directions for 8-connected neighbours\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    visited = [[False] * W for _ in range(H)]\n    \n    def dfs(x, y):\n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] == '#':\n                    visited[nx][ny] = True\n                    stack.append((nx, ny))\n    \n    sensor_count = 0\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#' and not visited[i][j]:\n                # New sensor group found\n                sensor_count += 1\n                visited[i][j] = True\n                dfs(i, j)\n    \n    print(sensor_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_d", "solution": "def max_products_printed(N, products):\n    events = []\n    \n    # Create events for each product\n    for T, D in products:\n        events.append((T, 'enter'))   # Product enters at time T\n        events.append((T + D, 'exit')) # Product exits at time T + D\n    \n    # Sort events: first by time, then by type (exit before enter)\n    events.sort(key=lambda x: (x[0], x[1] == 'enter'))\n    \n    next_available_time = 0\n    count_printed = 0\n    \n    # Process each event\n    for time, event_type in events:\n        if event_type == 'enter':\n            # Check if we can print\n            if time >= next_available_time:\n                # Print on this product\n                count_printed += 1\n                next_available_time = time + 1  # Next available time after charge\n        # If it's an exit event, we don't do anything else\n    \n    return count_printed\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nN = int(data[0])\nproducts = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n\n# Calculate the result\nresult = max_products_printed(N, products)\nprint(result)"}
{"task_id": "abc325_e", "solution": "def min_travel_time(N, A, B, C, D):\n    import sys\n    from math import inf\n\n    # Initialize arrays for the minimum travel times\n    min_time_car = [inf] * (N + 1)\n    min_time_train = [inf] * (N + 1)\n\n    # Starting from city 1\n    min_time_car[1] = 0\n\n    # Calculate minimum times\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j:\n                # Travel by company car\n                travel_time_car = D[i-1][j-1] * A\n                min_time_car[j] = min(min_time_car[j], min_time_car[i] + travel_time_car)\n\n                # Travel by train (only if already reached city i by car)\n                travel_time_train = D[i-1][j-1] * B + C\n                min_time_train[j] = min(min_time_train[j], min_time_car[i] + travel_time_train)\n\n    # The result will be the minimum time to reach city N\n    result = min(min_time_car[N], min_time_train[N])\n    \n    return result\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Read the first line for N, A, B, C\nN, A, B, C = map(int, data[0].split())\n\n# Read the distance matrix D\nD = []\nfor i in range(1, N + 1):\n    D.append(list(map(int, data[i].split())))\n\n# Calculate and print the minimum travel time\nprint(min_travel_time(N, A, B, C, D))"}
{"task_id": "abc325_f", "solution": "def minimum_sensor_cost(N, D, L1, C1, K1, L2, C2, K2):\n    total_cost = 0\n    \n    for length in D:\n        min_cost = float('inf')\n        \n        # Try all possible numbers of type 1 sensors from 0 to K1\n        for x1 in range(K1 + 1):\n            covered_length = x1 * L1\n            remaining_length = max(0, length - covered_length)\n            \n            # Number of type 2 sensors required to cover the remaining length\n            if remaining_length > 0:\n                x2 = (remaining_length + L2 - 1) // L2  # Ceiling division\n                if x2 > K2:\n                    continue  # Not enough type 2 sensors available\n            else:\n                x2 = 0\n            \n            # Calculate the cost for this combination\n            cost = x1 * C1 + x2 * C2\n            \n            # Update the minimum cost for this section\n            min_cost = min(min_cost, cost)\n        \n        # If we did not find any valid configuration for this section\n        if min_cost == float('inf'):\n            return -1\n        \n        total_cost += min_cost\n    \n    return total_cost\n\n# Reading Input\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split()\nN = int(data[0])\nD = list(map(int, data[1:N+1]))\nL1, C1, K1 = map(int, data[N+1:N+4])\nL2, C2, K2 = map(int, data[N+4:N+7])\n\n# Compute the result\nresult = minimum_sensor_cost(N, D, L1, C1, K1, L2, C2, K2)\n\n# Output the result\nprint(result)"}
{"task_id": "abc326_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    X = int(data[0])\n    Y = int(data[1])\n    \n    difference = abs(Y - X)\n    \n    if difference <= 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nmain()"}
{"task_id": "abc326_b", "solution": "def is_326_like(num):\n    h = num // 100           # Hundreds digit\n    t = (num // 10) % 10     # Tens digit\n    o = num % 10             # Ones digit\n    return h * t == o\n\ndef smallest_326_like_number(N):\n    for num in range(N, 1000):  # Check from N to 999\n        if is_326_like(num):\n            return num\n\n# Reading input\nimport sys\ninput = sys.stdin.read\nN = int(input().strip())\n\n# Finding the result\nresult = smallest_326_like_number(N)\n\n# Printing the result\nprint(result)"}
{"task_id": "abc326_c", "solution": "def max_gifts(N, M, A):\n    A.sort()  # Step 1: Sort the gift positions\n    max_count = 0\n    end = 0  # Initialize end pointer\n\n    for start in range(N):\n        # Move end pointer to include gifts within [A[start], A[start] + M)\n        while end < N and A[end] < A[start] + M:\n            end += 1\n        # Calculate the number of gifts in the interval\n        max_count = max(max_count, end - start)\n    \n    return max_count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN, M = int(data[0]), int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(max_gifts(N, M, A))"}
{"task_id": "abc326_d", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    N = int(data[0])\n    R = data[1].strip()\n    C = data[2].strip()\n    \n    # Step 1: Initialize the grid\n    grid = [['.' for _ in range(N)] for _ in range(N)]\n    \n    # Step 2: Mark mandatory placements\n    for i in range(N):\n        grid[i][0] = R[i]  # Fill first column with R[i]\n    \n    for j in range(N):\n        grid[0][j] = C[j]  # Fill first row with C[j]\n    \n    # Step 3: Track used characters per row and column\n    row_used = [set() for _ in range(N)]\n    col_used = [set() for _ in range(N)]\n    \n    for i in range(N):\n        row_used[i].add(R[i])  # R[i] is placed in row i\n        col_used[0].add(C[i])  # C[i] is placed in column i\n    \n    # Step 4: Fill the rest of the grid\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '.':\n                # Determine possible characters to place\n                possible_chars = {'A', 'B', 'C'}\n                \n                if i > 0:  # not the first row\n                    possible_chars -= row_used[i]\n                if j > 0:  # not the first column\n                    possible_chars -= col_used[j]\n                \n                if possible_chars:\n                    # Place one of the possible characters\n                    char_to_place = possible_chars.pop()\n                    grid[i][j] = char_to_place\n                    row_used[i].add(char_to_place)\n                    col_used[j].add(char_to_place)\n                else:\n                    print(\"No\")\n                    return\n    \n    # Step 5: Check if the grid is valid\n    for i in range(N):\n        if len(row_used[i]) != 3:  # must contain A, B, C\n            print(\"No\")\n            return\n    for j in range(N):\n        if len(col_used[j]) != 3:  # must contain A, B, C\n            print(\"No\")\n            return\n    \n    # If all checks passed\n    print(\"Yes\")\n    for row in grid:\n        print(''.join(row))"}
{"task_id": "abc326_e", "solution": "def modular_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_value(N, A):\n    MOD = 998244353\n    E = [0] * (N + 1)\n    \n    # Start calculating expected values from the back\n    for i in range(N - 1, -1, -1):\n        E[i] = sum(A[j] for j in range(i + 1, N)) / N  # E[i] calculation\n        E[i] += sum(E[j] for j in range(i + 1, N)) / N # E[i] calculation\n        E[i] = (E[i] % MOD + MOD) % MOD  # Ensure non-negative\n        \n    # The expected value starting with x = 0\n    numerator = int(E[0] * N) % MOD\n    denominator = N\n    \n    # Calculate the result as numerator * denominator^-1 mod MOD\n    denominator_inv = modular_inverse(denominator, MOD)\n    result = (numerator * denominator_inv) % MOD\n    \n    return result\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:N + 1]))\n\n# Call the expected value function and print result\nprint(expected_value(N, A))"}
{"task_id": "abc327_a", "solution": "def check_adjacent_a_b(N, S):\n    for i in range(N - 1):\n        if (S[i] == 'a' and S[i + 1] == 'b') or (S[i] == 'b' and S[i + 1] == 'a'):\n            return \"Yes\"\n    return \"No\"\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nS = data[1]\n\n# Get the result and print it\nresult = check_adjacent_a_b(N, S)\nprint(result)"}
{"task_id": "abc327_b", "solution": "def find_A(B):\n    A = 1\n    while True:\n        A_power_A = A ** A\n        if A_power_A == B:\n            print(A)\n            return\n        elif A_power_A > B:\n            print(-1)\n            return\n        A += 1\n\n# Read input\nimport sys\nB = int(sys.stdin.read().strip())\nfind_A(B)"}
{"task_id": "abc327_c", "solution": "def is_valid_sudoku(grid):\n    # Initialize sets for rows, columns, and subgrids\n    rows = [set() for _ in range(9)]\n    columns = [set() for _ in range(9)]\n    subgrids = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            num = grid[i][j]\n            if num < 1 or num > 9:\n                return \"No\"  # Number out of bounds\n\n            # Determine the subgrid index\n            subgrid_index = (i // 3) * 3 + (j // 3)\n\n            # Check if the number is already present in the respective row, column, or subgrid\n            if (num in rows[i] or num in columns[j] or num in subgrids[subgrid_index]):\n                return \"No\"\n\n            # Add the number to the sets\n            rows[i].add(num)\n            columns[j].add(num)\n            subgrids[subgrid_index].add(num)\n\n    return \"Yes\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split(\"\\n\")\ngrid = [list(map(int, line.split())) for line in data]\n\n# Output the result\nprint(is_valid_sudoku(grid))"}
{"task_id": "abc327_d", "solution": "def is_good_pair(N, M, A, B):\n    from collections import defaultdict, deque\n\n    # Create a graph with adjacency list\n    graph = defaultdict(list)\n    \n    for i in range(M):\n        graph[A[i]].append(B[i])\n        graph[B[i]].append(A[i])\n\n    # Colors array, -1 means unvisited\n    colors = [-1] * (N + 1)\n\n    # Function to perform BFS for bipartition\n    def bfs(start):\n        queue = deque([start])\n        colors[start] = 0  # Start coloring with 0\n        \n        while queue:\n            node = queue.popleft()\n            current_color = colors[node]\n\n            for neighbor in graph[node]:\n                if colors[neighbor] == -1:  # Unvisited\n                    colors[neighbor] = 1 - current_color  # Alternate color\n                    queue.append(neighbor)\n                elif colors[neighbor] == current_color:  # Conflict found\n                    return False\n        return True\n\n    # Check all components in the graph\n    for i in range(1, N + 1):\n        if colors[i] == -1:  # Not visited\n            if not bfs(i):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:2 + M]))\nB = list(map(int, data[2 + M:2 + 2 * M]))\n\n# Get the result and print it\nresult = is_good_pair(N, M, A, B)\nprint(result)"}
{"task_id": "abc327_e", "solution": "def maximize_rating(N, performances):\n    from math import sqrt\n    dp = [-float('inf')] * (N + 1)\n    dp[0] = -float('inf')  # No contests chosen, invalid state\n    \n    # Iterate through performances to fill the DP array\n    for performance in performances:\n        # We need to update in reverse to avoid overwriting values we still need\n        for k in range(N, 0, -1):\n            if dp[k - 1] > -float('inf'):  # Only consider valid previous states\n                # Update dp[k] with the new contest included\n                weight_sum = sum((0.9 ** (k - 1 - i)) for i in range(k))\n                weighted_sum = sum((0.9 ** (k - 1 - i)) * performances[i] for i in range(k - 1)) + performance\n                penalty = 1200 / sqrt(k)\n                rating = weighted_sum / weight_sum - penalty\n                dp[k] = max(dp[k], rating)\n    \n    # Find the maximum rating from dp[1] to dp[N]\n    return max(dp[1:])\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nperformances = list(map(int, data[1:N+1]))\n\n# Get the result\nresult = maximize_rating(N, performances)\n\n# Print the result with sufficient precision\nprint(f\"{result:.12f}\")"}
{"task_id": "abc328_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # First line contains N and X\n    N, X = map(int, data[0].split())\n    \n    # Second line contains the scores S_1 to S_N\n    scores = list(map(int, data[1].split()))\n    \n    # Calculate the total score of problems with a score of X or less\n    total_score = sum(score for score in scores if score <= X)\n    \n    # Print the result\n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc328_b", "solution": "def count_repdigit_dates():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    D = list(map(int, data[1].split()))\n    \n    total_repdigits = 0\n    \n    for month in range(1, N + 1):\n        month_digit = str(month)\n        if len(month_digit) == 1:  # it is a single digit month\n            day_digit = int(month_digit)  # convert to int\n            # Count how many days in this month are equal to day_digit\n            if day_digit <= D[month - 1]:  # Check if the day_digit is within the number of days\n                total_repdigits += 1  # day_digit itself is a valid day\n                # Check for repdigit days greater than day_digit\n                for multiple in range(2, (D[month - 1] // day_digit) + 1):\n                    if day_digit * multiple <= D[month - 1]:\n                        total_repdigits += 1\n    \n    print(total_repdigits)\n\ncount_repdigit_dates()"}
{"task_id": "abc328_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N and Q\n    N, Q = map(int, data[0].split())\n    \n    # Read the string S\n    S = data[1]\n    \n    # Preprocessing to create count array\n    count = [0] * N\n    for i in range(1, N):\n        count[i] = count[i - 1] + (1 if S[i] == S[i - 1] else 0)\n    \n    # Read the queries and output results\n    results = []\n    for i in range(2, 2 + Q):\n        l_i, r_i = map(int, data[i].split())\n        \n        # Convert to 0-indexed\n        l_i -= 1\n        r_i -= 1\n        \n        if r_i > l_i:\n            result = count[r_i] - count[l_i]\n        else:\n            result = 0  # If l_i == r_i, there's no space for pairs\n        \n        results.append(result)\n    \n    # Print all results\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc328_d", "solution": "def remove_abc(s):\n    stack = []\n    \n    for char in s:\n        stack.append(char)\n        # Check the last three characters in the stack\n        if len(stack) >= 3 and stack[-3] == 'A' and stack[-2] == 'B' and stack[-1] == 'C':\n            stack.pop()\n            stack.pop()\n            stack.pop()\n    \n    # Join the characters left in the stack to form the final string\n    return ''.join(stack)\n\n# Reading input\nimport sys\ninput_string = sys.stdin.read().strip()\n\n# Get the result and print it\nresult = remove_abc(input_string)\nprint(result)"}
{"task_id": "abc328_e", "solution": "def find(parent, u):\n    if parent[u] != u:\n        parent[u] = find(parent, parent[u])\n    return parent[u]\n\ndef union(parent, rank, u, v):\n    root_u = find(parent, u)\n    root_v = find(parent, v)\n    if root_u != root_v:\n        if rank[root_u] > rank[root_v]:\n            parent[root_v] = root_u\n        elif rank[root_u] < rank[root_v]:\n            parent[root_u] = root_v\n        else:\n            parent[root_v] = root_u\n            rank[root_u] += 1\n\ndef is_valid_spanning_tree(edges, N):\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n    for u, v in edges:\n        union(parent, rank, u, v)\n    \n    # Check if all vertices are connected\n    root = find(parent, 1)\n    for i in range(2, N + 1):\n        if find(parent, i) != root:\n            return False\n    return True\n\ndef minimum_cost_spanning_tree(N, M, K, edges):\n    from itertools import combinations\n    \n    min_cost = float('inf')\n    \n    for comb in combinations(edges, N - 1):\n        if is_valid_spanning_tree(comb, N):\n            current_cost = sum(weight for _, _, weight in comb) % K\n            min_cost = min(min_cost, current_cost)\n    \n    return min_cost\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M, K = map(int, data[0].split())\nedges = []\nfor line in data[1:]:\n    u, v, w = map(int, line.split())\n    edges.append((u, v, w))\n\n# Calculate result\nresult = minimum_cost_spanning_tree(N, M, K, edges)\n\n# Output result\nprint(result)"}
{"task_id": "abc329_a", "solution": "def separate_characters():\n    import sys\n    input = sys.stdin.read\n    # Read the input string\n    S = input().strip()\n    # Join the characters with a space\n    result = ' '.join(S)\n    # Print the result\n    print(result)\n\nseparate_characters()"}
{"task_id": "abc329_b", "solution": "def find_second_largest(N, A):\n    max_value = max(A)  # Step 2: Find the maximum value\n    non_max_values = [x for x in A if x < max_value]  # Step 3: Filter out the max value\n    second_largest = max(non_max_values)  # Step 4: Find the largest among non-maximum values\n    return second_largest  # Step 5: Return the result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])  # First line is N\nA = list(map(int, data[1:N + 1]))  # The rest are the integers\n\n# Get the result and print it\nresult = find_second_largest(N, A)\nprint(result)"}
{"task_id": "abc329_c", "solution": "def count_repeated_substrings(n, s):\n    total_count = 0\n    current_char_count = 1\n    \n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            current_char_count += 1\n        else:\n            total_count += (current_char_count * (current_char_count + 1)) // 2\n            current_char_count = 1\n    \n    # Account for the last sequence\n    total_count += (current_char_count * (current_char_count + 1)) // 2\n    \n    print(total_count)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    s = data[1]\n    \n    count_repeated_substrings(n, s)"}
{"task_id": "abc329_d", "solution": "def election_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])  # number of candidates\n    M = int(data[1])  # number of votes\n    votes = list(map(int, data[2:M+2]))  # the votes for candidates\n    \n    vote_count = [0] * (N + 1)  # vote counts for each candidate, 1-indexed\n    current_max_votes = 0\n    current_winner = 0\n    results = []\n    \n    for i in range(M):\n        candidate = votes[i]\n        vote_count[candidate] += 1\n        \n        if vote_count[candidate] > current_max_votes:\n            current_max_votes = vote_count[candidate]\n            current_winner = candidate\n        elif vote_count[candidate] == current_max_votes:\n            if candidate < current_winner:\n                current_winner = candidate\n        \n        results.append(current_winner)\n    \n    print(\"\\n\".join(map(str, results)))"}
{"task_id": "abc329_e", "solution": "def can_transform(N, M, S, T):\n    for i in range(N - M + 1):\n        if S[i:i + M] == T:\n            return \"Yes\"\n    return \"No\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, M = map(int, data[0].split())\n    S = data[1]\n    T = data[2]\n    \n    result = can_transform(N, M, S, T)\n    print(result)"}
{"task_id": "abc329_f", "solution": "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    # Read the first line for N and Q\n    N, Q = map(int, data[0].split())\n    \n    # Read colors of the balls in each box\n    colors = list(map(int, data[1].split()))\n    \n    # Initialize boxes with unique color sets\n    boxes = [set() for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        boxes[i].add(colors[i - 1])  # color at index i-1 for box i\n\n    results = []\n    \n    # Process each query\n    for i in range(2, 2 + Q):\n        a, b = map(int, data[i].split())\n        \n        # Move all balls from box a to box b\n        if boxes[a]:  # Only proceed if box a has any balls\n            boxes[b].update(boxes[a])  # Add all colors from a to b\n            boxes[a].clear()  # Clear box a since we moved the balls\n        \n        # Output the number of unique colors in box b\n        results.append(len(boxes[b]))\n    \n    # Print all results at once\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')"}
{"task_id": "abc330_a", "solution": "def count_passed_students():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    # Read the first line for N and L\n    first_line = data[0].split()\n    N = int(first_line[0])  # Number of students\n    L = int(first_line[1])  # Passing score\n    \n    # Read the scores from the second line\n    scores = list(map(int, data[1].split()))\n    \n    # Count how many students passed\n    passed_count = sum(1 for score in scores if score >= L)\n    \n    # Print the result\n    print(passed_count)\n\ncount_passed_students()"}
{"task_id": "abc330_b", "solution": "def find_x_values(N, L, R, A):\n    result = []\n    for a in A:\n        if a < L:\n            result.append(L)\n        elif a > R:\n            result.append(R)\n        else:\n            result.append(a)\n    return result\n\n# Read the inputs from stdin\nimport sys\n\ninput_data = sys.stdin.read().strip().split('\\n')\nN, L, R = map(int, input_data[0].split())\nA = list(map(int, input_data[1].split()))\n\n# Find the X values\noutput = find_x_values(N, L, R, A)\n\n# Output the results\nprint(' '.join(map(str, output)))"}
{"task_id": "abc330_c", "solution": "import sys\nimport math\n\ndef minimum_difference(D):\n    min_diff = float('inf')  # Initialize minimum difference as infinity\n    max_x = int(math.isqrt(D))  # Calculate the maximum value of x\n\n    for x in range(max_x + 1):  # Iterate through possible values of x\n        y_squared = D - x * x  # Calculate the remaining value to be filled by y^2\n        if y_squared < 0:\n            continue  # If y_squared is negative, skip to the next x\n        \n        y = int(math.isqrt(y_squared))  # Get the maximum integer y\n        # Check the two possible y values: y and y-1\n        for candidate_y in (y, y + 1):  \n            if candidate_y >= 0:  # Ensure we only consider non-negative integers\n                current_sum = x * x + candidate_y * candidate_y\n                min_diff = min(min_diff, abs(current_sum - D))  # Update minimum difference\n    \n    return min_diff\n\n# Main execution\nif __name__ == \"__main__\":\n    D = int(sys.stdin.read().strip())  # Read input D\n    result = minimum_difference(D)  # Find the minimum difference\n    print(result)  # Output the result"}
{"task_id": "abc330_d", "solution": "def count_valid_triples(N, grid):\n    # Step 1: Prepare a list to track the positions of 'o's in each column\n    column_counts = [0] * N\n    row_positions = [[] for _ in range(N)]\n    \n    # Populate row positions and column counts\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'o':\n                row_positions[i].append(j)\n                column_counts[j] += 1\n    \n    count_triples = 0\n    \n    # Step 2: Iterate through each row\n    for r1 in range(N):\n        # Get the list of columns containing 'o's in the current row\n        positions = row_positions[r1]\n        m = len(positions)\n        \n        # Step 3: Consider pairs of 'o's in the same row\n        for i in range(m):\n            for j in range(i + 1, m):\n                c1 = positions[i]\n                c2 = positions[j]\n                \n                # Step 4: Count 'o's in column c1 excluding the current row\n                count_in_column_c1 = column_counts[c1] - 1  # Exclude the current row\n                \n                # Each valid pair with a third cell gives us a valid triple\n                count_triples += count_in_column_c1\n\n    return count_triples\n\n# Read input and print output\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\ngrid = data[1:N+1]\n\nresult = count_valid_triples(N, grid)\nprint(result)"}
{"task_id": "abc330_e", "solution": "def find_mex_after_queries(N, Q, A, queries):\n    # Create a set to maintain unique values of A\n    current_values = set(A)\n    \n    # Function to find current mex\n    def get_mex():\n        mex = 0\n        while mex in current_values:\n            mex += 1\n        return mex\n    \n    # Initial mex\n    current_mex = get_mex()\n    \n    results = []\n    \n    for i, x in queries:\n        index = i - 1  # Convert to 0-based index\n        old_value = A[index]\n        A[index] = x\n\n        # Update the set\n        if old_value in current_values:\n            current_values.remove(old_value)\n        if x not in current_values:\n            current_values.add(x)\n        \n        # Update the mex\n        if x == current_mex:\n            current_mex = get_mex()\n        else:\n            while current_mex in current_values:\n                current_mex += 1\n        \n        results.append(current_mex)\n    \n    return results\n\n# Reading from standard input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    N, Q = map(int, data[0].split())\n    A = list(map(int, data[1].split()))\n    queries = [tuple(map(int, line.split())) for line in data[2:2+Q]]\n    \n    results = find_mex_after_queries(N, Q, A, queries)\n    \n    # Output results\n    print('\\n'.join(map(str, results)))\n\n# The main function will be called when the script runs\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc331_a", "solution": "def next_day(M, D, y, m, d):\n    d += 1  # Increment the day\n    if d > D:  # Check for overflow in days\n        d = 1  # Reset day to 1\n        m += 1  # Increment the month\n        if m > M:  # Check for overflow in months\n            m = 1  # Reset month to 1\n            y += 1  # Increment the year\n    return y, m, d\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\n\nM = int(data[0])  # Number of months\nD = int(data[1])  # Number of days in a month\ny = int(data[2])  # Current year\nm = int(data[3])  # Current month\nd = int(data[4])  # Current day\n\n# Get the next day\nnext_year, next_month, next_day = next_day(M, D, y, m, d)\n\n# Print the result\nprint(next_year, next_month, next_day)"}
{"task_id": "abc331_b", "solution": "def minimum_cost_to_purchase_eggs(N, S, M, L):\n    # Initialize the dp array with infinity\n    dp = [float('inf')] * (N + 1)\n    dp[0] = 0  # Base case: cost of 0 eggs is 0\n\n    # Pack sizes and their respective costs\n    packs = [(6, S), (8, M), (12, L)]\n    \n    # Fill the dp array\n    for i in range(1, N + 1):\n        for eggs, cost in packs:\n            if i >= eggs:\n                dp[i] = min(dp[i], dp[i - eggs] + cost)\n\n    # Find the minimum cost for at least N eggs\n    min_cost = float('inf')\n    for i in range(N, N + max(p[0] for p in packs) + 1):\n        if i < len(dp):\n            min_cost = min(min_cost, dp[i])\n\n    return min_cost\n\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N = int(data[0])\n    S = int(data[1])\n    M = int(data[2])\n    L = int(data[3])\n\n    result = minimum_cost_to_purchase_eggs(N, S, M, L)\n    print(result)"}
{"task_id": "abc331_c", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    max_value = 10**6\n    frequency = [0] * (max_value + 1)\n    \n    # Step 1: Calculate total sum and frequencies\n    total_sum = sum(A)\n    \n    for number in A:\n        frequency[number] += 1\n\n    # Step 2: Prepare prefix sums\n    prefix_sum = [0] * (max_value + 1)\n    \n    for i in range(1, max_value + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + (i * frequency[i])\n    \n    # Step 3: Calculate results for each A[i]\n    results = []\n    \n    for number in A:\n        # The sum of elements greater than number\n        sum_greater = total_sum - prefix_sum[number]\n        results.append(sum_greater)\n    \n    # Step 4: Print results\n    print(\" \".join(map(str, results)))"}
{"task_id": "abc331_d", "solution": "def count_black_squares(N, Q, P, queries):\n    # Create prefix sum array for the N x N grid\n    prefix_sum = [[0] * N for _ in range(N)]\n    \n    # Fill prefix_sum based on P\n    for i in range(N):\n        for j in range(N):\n            prefix_sum[i][j] = (1 if P[i][j] == 'B' else 0) + \\\n                                (prefix_sum[i - 1][j] if i > 0 else 0) + \\\n                                (prefix_sum[i][j - 1] if j > 0 else 0) - \\\n                                (prefix_sum[i - 1][j - 1] if i > 0 and j > 0 else 0)\n    \n    results = []\n    \n    for A, B, C, D in queries:\n        # Calculate the number of complete N x N blocks\n        total_black = 0\n        \n        # Calculate the number of complete blocks\n        num_blocks_x = (C // N) - (A // N)\n        num_blocks_y = (D // N) - (B // N)\n        \n        # Count black squares in complete blocks\n        total_black += num_blocks_x * num_blocks_y * prefix_sum[N - 1][N - 1]\n        \n        # Add remaining rows (if any)\n        for i in range(A % N, (C % N) + 1):\n            for j in range(B % N, (D % N) + 1):\n                if i < N and j < N:\n                    total_black += prefix_sum[i][j]\n        \n        # Add any additional rows or columns outside complete blocks\n        # Top additional rows\n        if A % N > 0:\n            for j in range(B % N, (D % N) + 1):\n                if j < N:\n                    total_black += prefix_sum[A % N - 1][j]\n        \n        # Left additional columns\n        if B % N > 0:\n            for i in range(A % N, (C % N) + 1):\n                if i < N:\n                    total_black += prefix_sum[i][B % N - 1]\n        \n        results.append(total_black)\n    \n    return results\n\n# Example usage:\nimport sys\n\ninput_data = sys.stdin.read().splitlines()\nN, Q = map(int, input_data[0].split())\nP = [input_data[i + 1] for i in range(N)]\nqueries = [list(map(int, input_data[i + 1 + N].split())) for i in range(Q)]\n\nresults = count_black_squares(N, Q, P, queries)\nprint(\"\\n\".join(map(str, results)))"}
{"task_id": "abc331_e", "solution": "def most_expensive_set_meal():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read N, M, L\n    N, M, L = map(int, data[0].split())\n    \n    # Read main dish prices\n    a = list(map(int, data[1].split()))\n    \n    # Read side dish prices\n    b = list(map(int, data[2].split()))\n    \n    # Initialize incompatibility pairs set\n    incompatible = set()\n    for i in range(3, 3 + L):\n        c, d = map(int, data[i].split())\n        incompatible.add((c - 1, d - 1))  # convert to 0-indexed\n    \n    # Find the maximum price\n    max_price = 0\n    for i in range(N):\n        for j in range(M):\n            if (i, j) not in incompatible:\n                price = a[i] + b[j]\n                if price > max_price:\n                    max_price = price\n    \n    # Print the result\n    print(max_price)"}
{"task_id": "abc332_a", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    # Read first line for N, S, K\n    first_line = data[0].split()\n    N = int(first_line[0])\n    S = int(first_line[1])\n    K = int(first_line[2])\n    \n    total_price = 0\n    \n    # Read each product's price and quantity\n    for i in range(1, N + 1):\n        price_quantity = data[i].split()\n        P_i = int(price_quantity[0])\n        Q_i = int(price_quantity[1])\n        total_price += P_i * Q_i\n        \n    # Determine shipping fee\n    if total_price < S:\n        total_price += K\n    \n    # Output the result\n    print(total_price)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc332_b", "solution": "def water_in_glass_and_mug(K, G, M):\n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        if glass == G:\n            glass = 0  # Discard all water from the glass\n        elif mug == 0:\n            mug = M  # Fill the mug with water\n        else:\n            transfer = min(mug, G - glass)  # Determine how much can be transferred\n            glass += transfer\n            mug -= transfer  # Update mug's water amount\n    \n    return glass, mug\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    K = int(data[0])\n    G = int(data[1])\n    M = int(data[2])\n    \n    glass, mug = water_in_glass_and_mug(K, G, M)\n    print(glass, mug)"}
{"task_id": "abc332_c", "solution": "def min_logo_tshirts_needed(N, M, S):\n    logo_needed = 0\n    plain_available = M\n    \n    for day in S:\n        if day == '0':\n            # No plans, wash all T-shirts\n            plain_available = min(plain_available, M)  # After washing, plain available remains M\n        elif day == '1':\n            # Plans to go out for a meal\n            if plain_available > 0:\n                # Use a plain T-shirt if available\n                plain_available -= 1\n            else:\n                # Need to use a logo T-shirt\n                logo_needed += 1\n        elif day == '2':\n            # Must wear a logo T-shirt\n            if logo_needed > 0:\n                logo_needed -= 1  # Use one existing logo T-shirt\n            else:\n                # Need to buy a new logo T-shirt\n                logo_needed += 1\n\n    # The number of new logo T-shirts needed\n    return max(0, logo_needed - (M - plain_available))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nN, M = map(int, data[0].split())\nS = data[1]\n\n# Output the result\nprint(min_logo_tshirts_needed(N, M, S))"}
{"task_id": "abc332_d", "solution": "def min_swaps_to_match(H, W, A, B):\n    from collections import Counter\n    \n    # Step 1: Check if both grids have the same elements\n    def flatten(grid):\n        return [elem for row in grid for elem in row]\n\n    if Counter(flatten(A)) != Counter(flatten(B)):\n        return -1\n\n    # Step 2: Count row swaps\n    # Build row indices from B\n    row_indices_B = {}\n    for i in range(H):\n        tuple_row = tuple(B[i])\n        if tuple_row in row_indices_B:\n            row_indices_B[tuple_row].append(i)\n        else:\n            row_indices_B[tuple_row] = [i]\n    \n    idx_A_to_B_rows = []\n    for i in range(H):\n        tuple_row = tuple(A[i])\n        idx_A_to_B_rows.append(row_indices_B[tuple_row].pop(0))\n\n    # Count cycles in row_indices\n    def count_cycles(positions):\n        visited = [False] * len(positions)\n        cycles = 0\n        for i in range(len(positions)):\n            if not visited[i]:\n                cycles += 1\n                j = i\n                while not visited[j]:\n                    visited[j] = True\n                    j = positions[j]\n        return cycles\n\n    row_cycles = count_cycles(idx_A_to_B_rows)\n    row_swaps = H - row_cycles\n\n    # Step 3: Count column swaps\n    # Build column indices from B\n    col_indices_B = {}\n    for j in range(W):\n        tuple_col = tuple(B[i][j] for i in range(H))\n        if tuple_col in col_indices_B:\n            col_indices_B[tuple_col].append(j)\n        else:\n            col_indices_B[tuple_col] = [j]\n\n    idx_A_to_B_cols = []\n    for j in range(W):\n        tuple_col = tuple(A[i][j] for i in range(H))\n        idx_A_to_B_cols.append(col_indices_B[tuple_col].pop(0))\n\n    # Count cycles in column_indices\n    col_cycles = count_cycles(idx_A_to_B_cols)\n    col_swaps = W - col_cycles\n\n    # Total minimum swaps required\n    return row_swaps + col_swaps\n\n# Read input values\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nH, W = map(int, data[0].split())\nA = [list(map(int, data[i+1].split())) for i in range(H)]\nB = [list(map(int, data[i + H + 1].split())) for i in range(H)]\n\n# Get the result\nresult = min_swaps_to_match(H, W, A, B)\nprint(result)"}
{"task_id": "abc333_a", "solution": "# Read input from standard input (stdin)\nN = int(input().strip())\n\n# Convert N to a string and multiply it by N to get the concatenated result\nresult = str(N) * N\n\n# Print the resulting string\nprint(result)"}
{"task_id": "abc333_b", "solution": "import math\nimport sys\n\ndef get_coordinates(vertex):\n    angles = {\n        'A': 0,\n        'B': 72,\n        'C': 144,\n        'D': 216,\n        'E': 288\n    }\n    \n    angle_rad = math.radians(angles[vertex])\n    return (math.cos(angle_rad), math.sin(angle_rad))\n\ndef distance(point1, point2):\n    return math.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2)\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    S1, S2 = input_data[0][0], input_data[0][1]\n    T1, T2 = input_data[1][0], input_data[1][1]\n    \n    # Get coordinates for each point\n    S1_coords = get_coordinates(S1)\n    S2_coords = get_coordinates(S2)\n    T1_coords = get_coordinates(T1)\n    T2_coords = get_coordinates(T2)\n    \n    # Calculate distances\n    length_S1S2 = distance(S1_coords, S2_coords)\n    length_T1T2 = distance(T1_coords, T2_coords)\n    \n    # Compare lengths\n    if math.isclose(length_S1S2, length_T1T2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc333_c", "solution": "def find_nth_repunits_sum(n):\n    repunits = [int('1' * i) for i in range(1, 20)]  # Generate repunits from 1 to 19 digits\n    sums = set()\n    \n    # Generate sums with three repunits\n    for a in range(len(repunits)):\n        for b in range(len(repunits)):\n            for c in range(len(repunits)):\n                sums.add(repunits[a] + repunits[b] + repunits[c])\n    \n    # Sort the unique sums\n    sorted_sums = sorted(sums)\n    \n    # Return the N-th smallest (1-indexed)\n    return sorted_sums[n - 1]\n\n# Main function to handle input and output\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    result = find_nth_repunits_sum(N)\n    print(result)"}
{"task_id": "abc333_d", "solution": "from collections import defaultdict, deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    edges = [tuple(map(int, line.split())) for line in data[1:N]]\n\n    # Create an adjacency list\n    tree = defaultdict(list)\n    \n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    # BFS to find the number of operations to delete vertex 1\n    queue = deque([1])\n    visited = {1}\n    leaf_count = 0\n    \n    while queue:\n        current = queue.popleft()\n        is_leaf = True\n        \n        for neighbor in tree[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                is_leaf = False\n        \n        if is_leaf:\n            leaf_count += 1\n    \n    # The number of operations needed to remove vertex 1 is the count of leaves found\n    print(leaf_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc333_e", "solution": "def adventure_simulation(N, events):\n    from collections import defaultdict\n\n    potions = defaultdict(int)\n    picks = []\n    max_potions_at_any_time = 0\n    current_potions = 0\n\n    # To record the choices for when to pick up potions\n    for t, x in events:\n        if t == 1:\n            picks.append(1)  # Assume we pick it up initially\n            potions[x] += 1\n            current_potions += 1\n            max_potions_at_any_time = max(max_potions_at_any_time, current_potions)\n        elif t == 2:\n            if potions[x] > 0:\n                potions[x] -= 1  # Use one potion to defeat the monster\n                current_potions -= 1\n            else:\n                # If we cannot defeat the monster, we have to check our choices\n                # We failed, so we need to output -1 immediately\n                print(-1)\n                return\n\n    # If we reached here, it means we could defeat all monsters\n    K_min = max_potions_at_any_time\n\n    # Output K_min\n    print(K_min)\n\n    # Print the picks\n    # We need to ensure we output what we really want to pick for the optimal solution\n    # Re-analyze the potion picks to minimize the maximum needed\n    needed_potions = defaultdict(int)\n    \n    # Re-check the needed potions by iterating again\n    for t, x in events:\n        if t == 2:\n            needed_potions[x] += 1\n\n    output_picks = []\n    for t, x in events:\n        if t == 1:\n            if needed_potions[x] > 0:\n                output_picks.append(1)  # Pick up the potion\n                needed_potions[x] -= 1  # Reduce the need for this potion\n            else:\n                output_picks.append(0)  # Discard the potion\n        elif t == 2:\n            output_picks.append(0)  # No pick action for monster events\n\n    print(\" \".join(map(str, output_picks)))\n\n# Example usage\nN = 13\nevents = [(1, 2), (1, 3), (1, 1), (1, 3), (1, 2), (2, 3), (1, 3), (1, 3), (2, 3), (1, 3), (2, 2), (2, 3), (2, 1)]\nadventure_simulation(N, events)"}
{"task_id": "abc334_a", "solution": "# Read the input from stdin\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    # Read the input\n    data = input().strip()\n    B, G = map(int, data.split())\n    \n    # Compare the prices\n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc334_b", "solution": "def count_christmas_trees(A, M, L, R):\n    # Calculate k_start\n    if (L - A) % M == 0:\n        k_start = (L - A) // M\n    else:\n        k_start = (L - A) // M + (1 if (L - A) > 0 else 0)\n\n    # Calculate k_end\n    k_end = (R - A) // M\n    \n    # Calculate the count of Christmas trees\n    count = k_end - k_start + 1\n    \n    return max(0, count)\n\nimport sys\ninput = sys.stdin.read\n\n# Read input\nA, M, L, R = map(int, input().strip().split())\n\n# Calculate and print the result\nresult = count_christmas_trees(A, M, L, R)\nprint(result)"}
{"task_id": "abc334_c", "solution": "def min_total_weirdness(N, K, lost_colors):\n    # Step 1: Initialize remaining socks for each color\n    remaining_socks = [2] * (N + 1)  # Index 0 is ignored, colors are from 1 to N\n    for color in lost_colors:\n        remaining_socks[color] -= 1  # One sock lost from this color\n\n    # Step 2: Create a list of available colors with at least one sock left\n    available_colors = []\n    for color in range(1, N + 1):\n        if remaining_socks[color] > 0:\n            available_colors.append(color)\n\n    # Step 3: Pair the socks optimally\n    total_weirdness = 0\n    pairs_to_form = (2 * N - K) // 2  # Maximum pairs we can form\n    num_available = len(available_colors)\n\n    # Step 4: Minimize weirdness by pairing adjacent colors\n    i = 0\n    while pairs_to_form > 0 and i + 1 < num_available:\n        # Pair available_colors[i] and available_colors[i + 1]\n        total_weirdness += abs(available_colors[i] - available_colors[i + 1])\n        pairs_to_form -= 1\n        i += 2  # Move to the next pair\n\n    # Step 5: Return the minimum total weirdness\n    return total_weirdness\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nlost_colors = list(map(int, data[2:2 + K]))\n\n# Calculate and print the result\nresult = min_total_weirdness(N, K, lost_colors)\nprint(result)"}
{"task_id": "abc334_d", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    R = list(map(int, data[2:N+2]))\n    queries = list(map(int, data[N+2:N+2+Q]))\n    \n    # Step 1: Sort the reindeer requirements\n    R.sort()\n    \n    # Step 2: Compute prefix sums\n    prefix_sums = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + R[i - 1]\n    \n    # Step 3: Answer each query using binary search\n    from bisect import bisect_right\n    \n    results = []\n    for x in queries:\n        # We need to find the largest number of sleighs such that\n        # prefix_sums[i] <= x.\n        max_sleighs = bisect_right(prefix_sums, x) - 1\n        results.append(max_sleighs)\n    \n    # Output all results\n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")"}
{"task_id": "abc334_e", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    from collections import deque\n    \n    MOD = 998244353\n    \n    # Read input\n    data = input().strip().splitlines()\n    H, W = map(int, data[0].split())\n    grid = [list(data[i + 1]) for i in range(H)]\n    \n    # Directions for adjacent cells\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def is_inside(x, y):\n        return 0 <= x < H and 0 <= y < W\n    \n    # Function to count initial green components\n    def count_green_components():\n        visited = [[False] * W for _ in range(H)]\n        component_count = 0\n        \n        def bfs(start_x, start_y):\n            queue = deque([(start_x, start_y)])\n            visited[start_x][start_y] = True\n            \n            while queue:\n                x, y = queue.popleft()\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if is_inside(nx, ny) and not visited[nx][ny] and grid[nx][ny] == '#':\n                        visited[nx][ny] = True\n                        queue.append((nx, ny))\n        \n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == '#' and not visited[i][j]:\n                    component_count += 1\n                    bfs(i, j)\n        \n        return component_count\n    \n    # Count the initial number of green components\n    initial_components = count_green_components()\n    \n    # Count the total number of red cells\n    red_cells = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                red_cells.append((i, j))\n    \n    total_red = len(red_cells)\n    total_expected_value = 0\n    \n    for x, y in red_cells:\n        # Temporarily repaint the red cell to green\n        grid[x][y] = '#'\n        \n        # Calculate the new number of components\n        new_components = 0\n        visited = [[False] * W for _ in range(H)]\n        \n        # Check adjacent cells to see if they connect new components\n        connected_components = set()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_inside(nx, ny) and grid[nx][ny] == '#':\n                connected_components.add((nx, ny))\n        \n        # Start BFS from the new green cell if it connects to any existing component\n        if connected_components:\n            # Only visit the green components connected to the new cell\n            for cx, cy in connected_components:\n                if not visited[cx][cy]:\n                    new_components += 1\n                    bfs(cx, cy)\n        \n        # Add the rest of the components that are not connected\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == '#' and not visited[i][j]:\n                    new_components += 1\n                    bfs(i, j)\n        \n        total_expected_value += new_components\n        \n        # Restore the red cell\n        grid[x][y] = '.'\n    \n    # Calculate the expected value in terms of fraction\n    P = total_expected_value\n    Q = total_red\n    \n    # Calculate R such that R * Q  P (mod MOD)\n    # Using Fermat's little theorem to find Q^(-1) mod MOD\n    def mod_inverse(a, mod):\n        return pow(a, mod - 2, mod)\n    \n    Q_inv = mod_inverse(Q, MOD)\n    result = (P * Q_inv) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc335_a", "solution": "# Read the input\nS = input().strip()\n\n# Replace the last character '3' with '4'\nmodified_string = S[:-1] + '4'\n\n# Print the modified string\nprint(modified_string)"}
{"task_id": "abc335_b", "solution": "def print_triples(N):\n    for x in range(N + 1):\n        for y in range(N - x + 1):\n            for z in range(N - x - y + 1):\n                print(x, y, z)\n\n# Reading input and calling the function\nimport sys\ninput = sys.stdin.read\nN = int(input().strip())\nprint_triples(N)"}
{"task_id": "abc335_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    # Read N and Q\n    first_line = data[0].split()\n    N = int(first_line[0])\n    Q = int(first_line[1])\n\n    # Initialize positions\n    positions = [(i, 0) for i in range(1, N + 1)]\n    \n    output = []\n\n    # Process each query\n    for i in range(1, Q + 1):\n        query = data[i].split()\n        if query[0] == '1':\n            direction = query[1]\n            head_x, head_y = positions[0]\n\n            # Update the head based on the direction\n            if direction == 'R':\n                head_x += 1\n            elif direction == 'L':\n                head_x -= 1\n            elif direction == 'U':\n                head_y += 1\n            elif direction == 'D':\n                head_y -= 1\n\n            # Update the head's position\n            positions[0] = (head_x, head_y)\n\n            # Update the positions of the remaining parts\n            for j in range(1, N):\n                positions[j] = positions[j - 1]\n\n        elif query[0] == '2':\n            part_index = int(query[1]) - 1  # Convert to 0-index\n            output.append(f\"{positions[part_index][0]} {positions[part_index][1]}\")\n\n    # Output all results for query type 2\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc335_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n\n    # Initialize the grid\n    grid = [[0] * N for _ in range(N)]\n    \n    # Center position\n    center = N // 2\n    grid[center][center] = 'T'  # Place Takahashi at the center\n    \n    # Directions for spiral movement: right, down, left, up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    x, y = center, center  # Start at Takahashi\n    num = 1  # Start placing parts from 1 to N^2-1\n    \n    # Spiral filling\n    step_length = 1  # This will increase every two directions\n    direction_index = 0\n    \n    while num < N * N:\n        for _ in range(2):  # Repeat the steps twice for each length\n            for _ in range(step_length):\n                if num >= N * N:\n                    break\n                # Move to the next cell in the current direction\n                x += directions[direction_index][0]\n                y += directions[direction_index][1]\n                \n                # Place the current number\n                grid[x][y] = num\n                num += 1\n            \n            # Change direction\n            direction_index = (direction_index + 1) % 4\n        \n        # Increase the step length after completing two directions\n        step_length += 1\n\n    # Output the grid\n    for row in grid:\n        print(' '.join(str(cell) for cell in row))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc336_a", "solution": "def generate_dragon_string():\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    \n    # Construct the Dragon String according to the pattern\n    dragon_string = 'L' + 'o' * N + 'n' + 'g'\n    \n    # Print the result\n    print(dragon_string)"}
{"task_id": "abc336_b", "solution": "def count_trailing_zeros(N):\n    count = 0\n    while N % 2 == 0:\n        N //= 2\n        count += 1\n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    print(count_trailing_zeros(N))"}
{"task_id": "abc336_c", "solution": "def find_good_integer(N):\n    # Determine the length of the good integer needed\n    count = 0\n    digit_length = 1\n    while True:\n        if digit_length == 1:\n            current_count = 5  # 0, 2, 4, 6, 8\n        else:\n            current_count = 4 * (5 ** (digit_length - 1))  # 4 * 5^(d-1)\n        \n        if count + current_count >= N:\n            break\n        count += current_count\n        digit_length += 1\n\n    # Now we know the digit length of the N-th good integer\n    # Calculate the index in this digit length\n    index = N - count - 1  # 0-based index\n\n    # Generate the good integer\n    good_integer = []\n    \n    # First digit (cannot be 0)\n    first_digit_options = [2, 4, 6, 8]\n    good_integer.append(first_digit_options[index // (5 ** (digit_length - 2))])\n    index %= (5 ** (digit_length - 2))\n\n    # Remaining digits (can be 0)\n    for i in range(digit_length - 1):\n        good_integer.append(index % 5 * 2)  # 0 -> 0, 1 -> 2, 2 -> 4, 3 -> 6, 4 -> 8\n        index //= 5\n\n    return ''.join(map(str, good_integer))\n\n# Reading input and output\nimport sys\ninput = sys.stdin.read\nN = int(input().strip())\nresult = find_good_integer(N)\nprint(result)"}
{"task_id": "abc336_d", "solution": "def max_pyramid_sequence_size(N, A):\n    from collections import Counter\n    \n    # Count occurrences of each number in A\n    count = Counter(A)\n    \n    k = 0\n    while True:\n        k += 1\n        # We need at least k elements to satisfy the pyramid sequence of size k\n        required = 0\n        for i in range(1, k + 1):\n            required += i  # required counts for 1 to k\n        \n        # Check if we can create the pyramid sequence of size k\n        if required > N:\n            break  # If we need more elements than available, we stop\n        \n        # Check if we have enough counts\n        sufficient = True\n        for i in range(1, k + 1):\n            if count[i] < i:\n                sufficient = False\n                break\n        \n        if not sufficient:\n            break\n    \n    return k - 1  # k is one too high when we break\n\n# The main input-output function\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    result = max_pyramid_sequence_size(N, A)\n    print(result)"}
{"task_id": "abc337_a", "solution": "# Read the number of matches\nN = int(input().strip())\n\n# Initialize scores\ntakahashi_score = 0\naoki_score = 0\n\n# Read the scores for each match\nfor _ in range(N):\n    X, Y = map(int, input().strip().split())\n    takahashi_score += X\n    aoki_score += Y\n\n# Determine the winner\nif takahashi_score > aoki_score:\n    print(\"Takahashi\")\nelif aoki_score > takahashi_score:\n    print(\"Aoki\")\nelse:\n    print(\"Draw\")"}
{"task_id": "abc337_b", "solution": "def is_extended_abc_string(S):\n    n = len(S)\n    i = 0\n    \n    # Count A's\n    while i < n and S[i] == 'A':\n        i += 1\n    count_A = i\n    \n    # Count B's\n    while i < n and S[i] == 'B':\n        i += 1\n    count_B = i - count_A  # since i has been incremented\n    \n    # Count C's\n    while i < n and S[i] == 'C':\n        i += 1\n    count_C = i - (count_A + count_B)  # total length minus previous counts\n    \n    # If we have processed the entire string and have at least one of each\n    if i == n and count_A > 0 and count_B > 0 and count_C > 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read the input\nimport sys\ninput = sys.stdin.read\nS = input().strip()\n\n# Output the result\nprint(is_extended_abc_string(S))"}
{"task_id": "abc337_c", "solution": "def arrange_people_in_line():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    # Find the index of the person at the front of the line\n    index_of_front = A.index(-1)\n    \n    # Create a list to hold the order of people in line\n    line_order = []\n    \n    # Start from the front person\n    current_person = index_of_front + 1  # convert to person number (1-indexed)\n    \n    while current_person != -1:\n        line_order.append(current_person)\n        current_person = A[current_person - 1]  # move to the next person in line\n    \n    print(\" \".join(map(str, line_order)))"}
{"task_id": "abc337_d", "solution": "def min_operations_to_form_sequence(H, W, K, grid):\n    min_operations = float('inf')\n\n    # Check horizontal sequences\n    for row in grid:\n        for start in range(W - K + 1):\n            segment = row[start:start + K]\n            operations_needed = segment.count('.')\n            min_operations = min(min_operations, operations_needed)\n\n    # Check vertical sequences\n    for col in range(W):\n        for start in range(H - K + 1):\n            segment = [grid[start + offset][col] for offset in range(K)]\n            operations_needed = segment.count('.')\n            min_operations = min(min_operations, operations_needed)\n\n    return min_operations if min_operations != float('inf') else -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nH, W, K = map(int, data[0].split())\ngrid = data[1:H + 1]\n\n# Get the result\nresult = min_operations_to_form_sequence(H, W, K, grid)\n\n# Print the result\nprint(result)"}
{"task_id": "abc337_e", "solution": "import sys\nimport math\n\n# Read the number of bottles\nN = int(sys.stdin.readline().strip())\n\n# Determine the number of friends needed\nM = math.ceil(math.log2(N))\n\n# Prepare the distribution of bottles\nbottle_distribution = [[] for _ in range(M)]\n\n# Assign bottles to friends based on binary representation\nfor bottle in range(1, N + 1):\n    for friend in range(M):\n        if bottle & (1 << friend):  # Check if the friend should test this bottle\n            bottle_distribution[friend].append(bottle)\n\n# Print the number of friends and their respective bottle assignments\nprint(M)\nfor friend_bottles in bottle_distribution:\n    print(len(friend_bottles), ' '.join(map(str, sorted(friend_bottles))))\n\n# Read the results from the judge\nS = sys.stdin.readline().strip()\n\n# Determine the spoiled bottle using the feedback\nspoiled_bottle = 0\nfor friend in range(M):\n    if S[friend] == '1':\n        spoiled_bottle += (1 << friend)  # Add the index corresponding to this friend\n\n# Output the index of the spoiled bottle\nprint(spoiled_bottle)"}
{"task_id": "abc338_a", "solution": "def check_string(S):\n    if S[0].isupper() and S[1:].islower():\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Reading input from stdin\nimport sys\ninput_string = sys.stdin.read().strip()\ncheck_string(input_string)"}
{"task_id": "abc338_b", "solution": "def most_frequent_character(S):\n    # Step 1: Initialize a frequency list for 26 lowercase English letters\n    frequency = [0] * 26\n    \n    # Step 2: Count the frequency of each character in the string\n    for char in S:\n        frequency[ord(char) - ord('a')] += 1\n    \n    # Step 3: Identify the maximum frequency\n    max_frequency = max(frequency)\n    \n    # Step 4: Find the character(s) with the maximum frequency\n    candidates = []\n    for i in range(26):\n        if frequency[i] == max_frequency:\n            candidates.append(chr(i + ord('a')))\n    \n    # Step 5: Determine the earliest character in alphabetical order\n    result = min(candidates)  # Since candidates are already alphabetically ordered by their index\n    \n    # Step 6: Print the result\n    print(result)\n\n# Read input from stdin\nimport sys\ninput_string = sys.stdin.read().strip()\nmost_frequent_character(input_string)"}
{"task_id": "abc338_c", "solution": "def max_servings(N, Q, A, B):\n    # Function to check if we can make `total_servings` total dishes\n    def can_make(total_servings):\n        # Check for all possible servings of dish A\n        for a in range(total_servings + 1):\n            b = total_servings - a\n            # Check if we can make `a` servings of dish A and `b` servings of dish B\n            if all(A[i] * a + B[i] * b <= Q[i] for i in range(N)):\n                return True\n        return False\n\n    # Binary search for the maximum total servings\n    low, high = 0, sum(Q)  # High could be at most the total amount of ingredients\n    max_servings = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        if can_make(mid):\n            max_servings = mid  # We can make `mid` total servings\n            low = mid + 1  # Try for more servings\n        else:\n            high = mid - 1  # Try for fewer servings\n\n    return max_servings\n\n# Reading input and preparing data\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nQ = list(map(int, data[1].split()))\nA = list(map(int, data[2].split()))\nB = list(map(int, data[3].split()))\n\n# Calculate the result\nresult = max_servings(N, Q, A, B)\nprint(result)"}
{"task_id": "abc338_d", "solution": "def minimum_tour_length(N, M, X):\n    # To compute the minimum length of the tour with one bridge closed\n    distances = [0] * (N + 1)\n    \n    # Calculate distances between visited islands\n    for i in range(M - 1):\n        from_island = X[i]\n        to_island = X[i + 1]\n        if from_island < to_island:\n            distances[from_island] += (to_island - from_island)\n        else:\n            distances[from_island] += (N - from_island + to_island)\n    \n    # Total length of the tour without any bridges closed\n    total_length = sum(distances)\n\n    min_length = float('inf')\n    \n    # Consider closing each bridge\n    for bridge in range(1, N + 1):\n        # Calculate the potential new length of the tour\n        new_length = 0\n        \n        # Check the distances considering the bridge is closed\n        for i in range(M - 1):\n            from_island = X[i]\n            to_island = X[i + 1]\n            if abs(from_island - to_island) == 1 or (from_island == 1 and to_island == N) or (from_island == N and to_island == 1):\n                # If the direct bridge is affected, we need to go around\n                new_length += min((to_island - from_island) % N, (from_island - to_island) % N) + 1\n            else:\n                new_length += (to_island - from_island) % N\n        \n        min_length = min(min_length, new_length)\n\n    return min_length\n\n# Reading inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\n\nN = int(data[0])\nM = int(data[1])\nX = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = minimum_tour_length(N, M, X)\nprint(result)"}
{"task_id": "abc338_e", "solution": "def has_intersection(n, chords):\n    # Normalize chords: make sure A_i < B_i for each chord\n    normalized_chords = [(min(A, B), max(A, B)) for A, B in chords]\n\n    # Sort chords based on the first endpoint\n    normalized_chords.sort()\n\n    # To check for intersections, we will use a list to track the right endpoints\n    active_rights = []\n\n    for left, right in normalized_chords:\n        # Check for intersections with current active rights\n        for r in active_rights:\n            if left < r < right:\n                return \"Yes\"\n        \n        # Add the right endpoint of the current chord to active rights\n        active_rights.append(right)\n\n    return \"No\"\n\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\nN = int(data[0])\nchords = [tuple(map(int, line.split())) for line in data[1:N+1]]\n\n# Compute and print the result\nresult = has_intersection(N, chords)\nprint(result)"}
{"task_id": "abc338_f", "solution": "def find_min_weight_walk(N, M, edges):\n    import sys\n    from itertools import product\n    \n    # Step 1: Initialize adjacency matrix\n    INF = float('inf')\n    dist = [[INF] * N for _ in range(N)]\n    \n    for i in range(N):\n        dist[i][i] = 0  # Distance to self is zero\n    \n    # Step 2: Fill the adjacency matrix with edge weights\n    for u, v, w in edges:\n        dist[u - 1][v - 1] = min(dist[u - 1][v - 1], w)  # Handle multiple edges, take the minimum weight\n    \n    # Step 3: Floyd-Warshall algorithm to find shortest paths\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i][k] != INF and dist[k][j] != INF:\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # Step 4: Initialize DP table\n    dp = [[INF] * N for _ in range(1 << N)]\n    for i in range(N):\n        dp[1 << i][i] = 0  # Starting at each vertex with only that vertex visited\n    \n    # Step 5: Fill the DP table\n    for mask in range(1 << N):\n        for u in range(N):\n            if not (mask & (1 << u)):  # u must be in the current mask\n                continue\n            for v in range(N):\n                if mask & (1 << v):  # v must not be in the current mask\n                    continue\n                new_mask = mask | (1 << v)\n                dp[new_mask][v] = min(dp[new_mask][v], dp[mask][u] + dist[u][v])\n    \n    # Step 6: Find the minimum cost to visit all vertices\n    min_cost = INF\n    final_mask = (1 << N) - 1\n    for i in range(N):\n        min_cost = min(min_cost, dp[final_mask][i])\n    \n    return min_cost if min_cost != INF else \"No\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\nN, M = map(int, data[0].split())\nedges = [tuple(map(int, line.split())) for line in data[1:M + 1]]\n\n# Print output\nresult = find_min_weight_walk(N, M, edges)\nprint(result)"}
{"task_id": "abc339_a", "solution": "# Read the input string S\nimport sys\n\nS = sys.stdin.read().strip()\n\n# Split the string by '.' and take the last part\nlast_substring = S.split('.')[-1]\n\n# Print the result\nprint(last_substring)"}
{"task_id": "abc339_b", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    N = int(data[2])\n    \n    # Initialize the grid with all cells white (.)\n    grid = [['.' for _ in range(W)] for _ in range(H)]\n    \n    # Directions: up, right, down, left\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Initial position and direction index (0 = up, 1 = right, 2 = down, 3 = left)\n    x, y = 0, 0\n    dir_index = 0  # starting facing 'up'\n    \n    for _ in range(N):\n        if grid[x][y] == '.':\n            # Paint it black\n            grid[x][y] = '#'\n            # Rotate 90 degrees clockwise\n            dir_index = (dir_index + 1) % 4\n        else:\n            # Paint it white\n            grid[x][y] = '.'\n            # Rotate 90 degrees counterclockwise\n            dir_index = (dir_index - 1 + 4) % 4\n        \n        # Move in the current direction\n        dx, dy = directions[dir_index]\n        x = (x + dx) % H  # Wrap around vertically\n        y = (y + dy) % W  # Wrap around horizontally\n\n    # Print the resulting grid\n    for row in grid:\n        print(''.join(row))"}
{"task_id": "abc339_c", "solution": "def minimum_passengers_on_bus(N, changes):\n    # Step 1: Calculate total change in passengers\n    net_change = sum(changes)\n    \n    # Step 2: Track the minimum running total of passengers\n    current_passengers = 0\n    min_passengers_needed = 0\n    \n    for change in changes:\n        current_passengers += change\n        # We track the minimum number of passengers required\n        if current_passengers < min_passengers_needed:\n            min_passengers_needed = current_passengers\n            \n    # Step 3: Calculate the minimum possible current number of passengers\n    return max(0, -min_passengers_needed) + net_change\n\n# Example of reading input and utilizing the function\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    changes = list(map(int, data[1:N+1]))\n    \n    result = minimum_passengers_on_bus(N, changes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc339_d", "solution": "from collections import deque\n\ndef bfs(start, N, grid):\n    # Distance grid initialized to a large number\n    distances = [[float('inf')] * N for _ in range(N)]\n    queue = deque([start])\n    distances[start[0]][start[1]] = 0\n    \n    # Directions for moving in 4 ways: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] in ('.', 'P') and distances[nx][ny] == float('inf'):\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n    \n    return distances\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    grid = data[1:N + 1]\n    \n    players = []\n    \n    # Find players' positions\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'P':\n                players.append((i, j))\n    \n    # If the number of players found is not 2, return -1 (invalid input based on problem statement)\n    if len(players) != 2:\n        print(-1)\n        return\n    \n    # Perform BFS for both players\n    dist1 = bfs(players[0], N, grid)\n    dist2 = bfs(players[1], N, grid)\n    \n    min_moves = float('inf')\n    \n    # Check all cells for minimum moves to meet\n    for i in range(N):\n        for j in range(N):\n            if dist1[i][j] != float('inf') and dist2[i][j] != float('inf'):\n                # Both players can reach (i, j), find the maximum distance to synchronize\n                moves = max(dist1[i][j], dist2[i][j])\n                min_moves = min(min_moves, moves)\n    \n    # If min_moves is still infinity, it means they cannot meet\n    if min_moves == float('inf'):\n        print(-1)\n    else:\n        print(min_moves)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc340_a", "solution": "def generate_arithmetic_sequence():\n    import sys\n    input = sys.stdin.read\n    # Step 1: Read input\n    A, B, D = map(int, input().strip().split())\n    \n    # Step 2: Generate the sequence\n    sequence = []\n    term = A\n    while term <= B:\n        sequence.append(term)\n        term += D\n    \n    # Step 3: Print the output in required format\n    print(\" \".join(map(str, sequence)))"}
{"task_id": "abc340_b", "solution": "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    Q = int(data[0])  # The number of queries\n    A = []            # The sequence to hold our values\n    output = []       # To collect the output for '2 k' queries\n    \n    for i in range(1, Q + 1):\n        query = data[i].split()\n        if query[0] == '1':\n            # Append x to the sequence A\n            x = int(query[1])\n            A.append(x)\n        elif query[0] == '2':\n            # Find the k-th value from the end of the sequence A\n            k = int(query[1])\n            output.append(A[-k])  # A[-k] gives us the k-th last element\n            \n    # Print all results for '2 k' queries\n    print('\\n'.join(map(str, output)))"}
{"task_id": "abc340_c", "solution": "def main():\n    import sys\n    \n    input = sys.stdin.read\n    N = int(input().strip())\n    \n    # Calculate the number of bits in N\n    number_of_bits = N.bit_length()  # Equivalent to the number of bits needed to represent N in binary\n    \n    # Calculate Total Payment\n    total_payment = 2 * N - number_of_bits\n    \n    # Output the result\n    print(total_payment)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc340_d", "solution": "def min_time_to_stage_n(N, stages):\n    # Create a list to hold minimum time to each stage\n    dp = [float('inf')] * (N + 1)\n    dp[1] = 0  # Starting at stage 1 takes 0 seconds\n\n    for i in range(1, N):  # stages are 1 to N-1\n        A_i, B_i, X_i = stages[i - 1]\n        \n        # Option 1: Move to stage i+1\n        if i + 1 <= N:\n            dp[i + 1] = min(dp[i + 1], dp[i] + A_i)\n        \n        # Option 2: Move to stage X_i\n        if X_i <= N:\n            dp[X_i] = min(dp[X_i], dp[i] + B_i)\n\n    return dp[N]\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nstages = [tuple(map(int, line.split())) for line in data[1:N]]\n\n# Calculate and print the minimum time to reach stage N\nresult = min_time_to_stage_n(N, stages)\nprint(result)"}
{"task_id": "abc340_e", "solution": "def redistribute_balls():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N and M\n    idx = 0\n    N = int(data[idx])\n    M = int(data[idx + 1])\n    idx += 2\n    \n    # Read initial counts of balls in boxes\n    A = list(map(int, data[idx:idx + N]))\n    idx += N\n    \n    # Read operation indices\n    B = list(map(int, data[idx:idx + M]))\n    \n    # Result array initialized with the current state of balls\n    X = A[:]\n    \n    # This will keep track of how many balls need to be added to each box\n    addition = [0] * N\n    \n    # Process each operation\n    for b in B:\n        # Number of balls to be taken from box b\n        num_balls = X[b]\n        if num_balls == 0:\n            continue\n        \n        # Clear box b\n        X[b] = 0\n        \n        # Distribute balls from box b\n        for c in range(num_balls):\n            addition[(b + c) % N] += 1\n    \n    # Apply additions to the result array\n    for i in range(N):\n        X[i] += addition[i]\n    \n    # Print the result\n    print(\" \".join(map(str, X)))"}
{"task_id": "abc341_a", "solution": "def generate_alternating_string(N):\n    result = []\n    for i in range(N):\n        result.append('1' if i % 2 == 0 else '0')\n    result.append('1')  # Append one extra '1'\n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    print(generate_alternating_string(N))"}
{"task_id": "abc341_b", "solution": "def maximize_currency(N, A, ST):\n    for i in range(N - 1):\n        # Get the required S_i and T_i for the current country\n        S_i, T_i = ST[i]\n        # Calculate how many full operations can be performed\n        while A[i] >= S_i:\n            num_operations = A[i] // S_i  # Maximum operations possible\n            A[i] -= num_operations * S_i   # Deduct the currency paid\n            A[i + 1] += num_operations * T_i  # Add the currency gained\n    # The result is the amount of currency in the last country\n    return A[N - 1]\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nA = list(map(int, data[1].split()))\nST = [list(map(int, line.split())) for line in data[2:]]\n\n# Get the result and print it\nresult = maximize_currency(N, A, ST)\nprint(result)"}
{"task_id": "abc341_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    # Read H, W, N\n    H, W, N = map(int, data[0].split())\n    T = data[1]  # movement sequence\n    \n    # Read the grid\n    grid = data[2:2 + H]\n    \n    # Direction vectors for reverse movements\n    reverse_moves = {\n        'L': (0, 1),  # move right\n        'R': (0, -1), # move left\n        'U': (1, 0),  # move down\n        'D': (-1, 0)  # move up\n    }\n    \n    possible_starts = set()\n    \n    # Check all cells in the grid\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                # Try to reverse the movements starting from (i, j)\n                current_pos = (i, j)\n                valid_start = True\n                \n                for move in reversed(T):\n                    di, dj = reverse_moves[move]\n                    ni, nj = current_pos[0] + di, current_pos[1] + dj\n                    \n                    # Check bounds and if it is land\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '.':\n                        current_pos = (ni, nj)\n                    else:\n                        valid_start = False\n                        break\n                \n                if valid_start:\n                    possible_starts.add(current_pos)\n    \n    # The answer is the number of unique possible starting positions\n    print(len(possible_starts))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_d", "solution": "import sys\nimport math\n\ndef count_exactly_one(N, M, x):\n    lcm_nm = (N * M) // math.gcd(N, M)\n    count_N = x // N\n    count_M = x // M\n    count_both = x // lcm_nm\n    return (count_N - count_both) + (count_M - count_both)\n\ndef kth_smallest_divisible(N, M, K):\n    low, high = 1, K * min(N, M)\n    while low < high:\n        mid = (low + high) // 2\n        if count_exactly_one(N, M, mid) < K:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    N, M, K = map(int, input_data.split())\n    print(kth_smallest_divisible(N, M, K))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_e", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Reading input\n    N, Q = map(int, data[0].split())\n    S = list(data[1])  # Convert string to list for mutability\n    queries = data[2:]\n    \n    results = []\n    \n    for query in queries:\n        parts = list(map(int, query.split()))\n        command_type = parts[0]\n        L = parts[1] - 1  # Convert to zero-based index\n        R = parts[2] - 1  # Convert to zero-based index\n        \n        if command_type == 1:\n            # Flip from L to R\n            for i in range(L, R + 1):\n                S[i] = '1' if S[i] == '0' else '0'\n        \n        elif command_type == 2:\n            # Check if good string from L to R\n            good = True\n            for i in range(L, R):\n                if S[i] == S[i + 1]:\n                    good = False\n                    break\n            results.append(\"Yes\" if good else \"No\")\n    \n    # Output all results for type 2 queries\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_f", "solution": "def max_operations(N, M, edges, weights, pieces):\n    from collections import defaultdict\n    import heapq\n    \n    # Build the graph as an adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    \n    # Priority queue to process vertices based on the number of pieces\n    pq = []\n    for i in range(N):\n        if pieces[i] > 0:\n            heapq.heappush(pq, (-weights[i], i))  # Use negative weight for max-heap behavior\n    \n    total_operations = 0\n    \n    while pq:\n        # Get the vertex with the most available weight\n        current_weight, x = heapq.heappop(pq)\n        current_weight = -current_weight  # Convert back to positive\n        \n        if pieces[x] == 0:\n            continue\n        \n        # Perform operations at vertex x\n        while pieces[x] > 0:\n            # Try to remove a piece from x\n            pieces[x] -= 1\n            total_operations += 1\n            \n            # Calculate available adjacent vertices\n            S = []\n            weight_sum = 0\n            \n            for y in graph[x]:\n                if pieces[y] < weights[y]:  # We can only place pieces if y has less than its weight\n                    weight_sum += weights[y]\n                    S.append(y)\n            \n            # Check if we can place pieces on selected vertices\n            if weight_sum < current_weight:\n                for y in S:\n                    pieces[y] += 1  # Place one piece on each selected adjacent vertex\n                    # If this vertex now has pieces, we can push it back to pq\n                    if pieces[y] == 1:  # First time it has pieces\n                        heapq.heappush(pq, (-weights[y], y))\n            else:\n                # Can't place any pieces from this vertex anymore\n                break\n        \n    return total_operations\n\n# Read inputs and execute the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\nedges = [tuple(map(int, line.split())) for line in data[1:M + 1]]\nweights = list(map(int, data[M + 1].split()))\npieces = list(map(int, data[M + 2].split()))\n\n# Calculate the result\nresult = max_operations(N, M, edges, weights, pieces)\nprint(result)"}
{"task_id": "abc342_a", "solution": "def find_unique_character_index(S):\n    # Step 1: Count the occurrences of each character\n    count = {}\n    for char in S:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    \n    # Step 2: Identify the unique character\n    unique_char = None\n    for char, freq in count.items():\n        if freq == 1:\n            unique_char = char\n            break\n    \n    # Step 3: Find the index of the unique character\n    for index in range(len(S)):\n        if S[index] == unique_char:\n            # Return 1-based index\n            return index + 1\n\n# Read input\nimport sys\ninput = sys.stdin.read\nS = input().strip()\n\n# Get the result and print it\nresult = find_unique_character_index(S)\nprint(result)"}
{"task_id": "abc342_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read number of people\n    N = int(data[0])\n    # Read positions of the people\n    P = list(map(int, data[1].split()))\n    # Read number of queries\n    Q = int(data[2])\n    # Read queries\n    queries = [tuple(map(int, line.split())) for line in data[3:3+Q]]\n    \n    results = []\n    for A, B in queries:\n        # Convert A and B to zero-based indexing\n        index_A = P.index(A)\n        index_B = P.index(B)\n        # Determine who is further in front\n        if index_A < index_B:\n            results.append(A)\n        else:\n            results.append(B)\n    \n    # Print all results\n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc342_c", "solution": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])  # Path compression\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    N = int(data[0])\n    S = data[1]\n    Q = int(data[2])\n    \n    parent = [chr(i) for i in range(ord('a'), ord('z') + 1)]\n    rank = [0] * 26  # For union by rank\n\n    for i in range(3, 3 + Q):\n        c, d = data[i].split()\n        union(parent, rank, ord(c) - ord('a'), ord(d) - ord('a'))\n\n    # Create a final mapping of each character to its representative\n    final_map = {}\n    for i in range(26):\n        final_map[chr(i + ord('a'))] = find(parent, i)\n\n    # Construct the final string\n    result = ''.join(final_map[char] for char in S)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc342_d", "solution": "import sys\nfrom collections import defaultdict\n\ndef sieve(n):\n    \"\"\" Returns a list of primes up to n using the Sieve of Eratosthenes. \"\"\"\n    is_prime = [True] * (n + 1)\n    p = 2\n    primes = []\n    while (p * p <= n):\n        if (is_prime[p]):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if is_prime[p]:\n            primes.append(p)\n    return primes\n\ndef get_parity_mask(x, primes):\n    \"\"\" Returns a bitmask representing the parity of the prime factorization of x. \"\"\"\n    mask = 0\n    for idx, prime in enumerate(primes):\n        if prime * prime > x:\n            break\n        count = 0\n        while x % prime == 0:\n            x //= prime\n            count += 1\n        if count % 2 == 1:  # Odd exponent\n            mask |= (1 << idx)\n    if x > 1:  # x is prime itself, count it\n        mask |= (1 << primes.index(x))\n    return mask\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n\n    # Step 1: Get all primes up to 200,000\n    max_A = 200000\n    primes = sieve(max_A)\n\n    # Step 2: Count the parity masks\n    count_masks = defaultdict(int)\n    pair_count = 0\n    \n    for number in A:\n        if number == 0:\n            # 0 can pair with any other number to form a perfect square (since 0 * any = 0)\n            pair_count += sum(count_masks.values())\n            count_masks[0] += 1\n            continue\n        \n        mask = get_parity_mask(number, primes)\n        pair_count += count_masks[mask]\n        count_masks[mask] += 1\n\n    print(pair_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc342_e", "solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    first_line = data[0].split()\n    N = int(first_line[0])\n    M = int(first_line[1])\n    \n    trains = defaultdict(list)\n    \n    for i in range(1, M + 1):\n        l, d, k, c, A, B = map(int, data[i].split())\n        for j in range(k):\n            t = l + j * d\n            trains[A].append((t, t + c, B))\n\n    results = []\n    \n    for start_station in range(1, N):\n        max_arrival = [-float('inf')] * (N + 1)\n        max_arrival[start_station] = float('inf')\n        \n        heap = []\n        heapq.heappush(heap, (-float('inf'), start_station))\n        \n        while heap:\n            current_time, station = heapq.heappop(heap)\n            current_time = -current_time\n            \n            if station == N:\n                results.append(current_time)\n                break\n            \n            for dep_time, arr_time, next_station in trains[station]:\n                if current_time >= dep_time and arr_time > max_arrival[next_station]:\n                    max_arrival[next_station] = arr_time\n                    heapq.heappush(heap, (-arr_time, next_station))\n        else:\n            results.append(\"Unreachable\")\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc343_a", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    # Read A and B\n    A, B = map(int, input().strip().split())\n    \n    # Calculate the sum of A and B\n    sum_ab = A + B\n    \n    # Find any integer in the range [0, 9] that is not equal to sum_ab\n    for i in range(10):\n        if i != sum_ab:\n            print(i)\n            return\n\n# Call the main function\nmain()"}
{"task_id": "abc343_b", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])  # First line contains the number of vertices\n    adjacency_matrix = [list(map(int, line.split())) for line in data[1:N+1]]\n    \n    results = []\n    \n    for i in range(N):\n        connected_vertices = []\n        for j in range(N):\n            if adjacency_matrix[i][j] == 1:\n                connected_vertices.append(j + 1)  # Adding 1 because vertices are 1-indexed\n        results.append(sorted(connected_vertices))\n    \n    for connected in results:\n        print(\" \".join(map(str, connected)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc343_c", "solution": "def is_palindrome(x):\n    return str(x) == str(x)[::-1]\n\ndef max_palindromic_cube(N):\n    max_palindrome = 0\n    x = 1\n    \n    while True:\n        cube = x ** 3\n        if cube > N:\n            break\n        if is_palindrome(cube):\n            max_palindrome = cube\n        x += 1\n\n    return max_palindrome\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n    \n    result = max_palindromic_cube(N)\n    print(result)"}
{"task_id": "abc343_d", "solution": "def main():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, T = map(int, data[0].split())\n    scores = [0] * (N + 1)  # scores[1] to scores[N], scores[0] is unused\n    score_count = defaultdict(int)  # To count frequencies of scores\n    \n    # Initially, all scores are zero\n    score_count[0] = N  # Initially, all N players have score 0\n    results = []\n    \n    for i in range(1, T + 1):\n        A_i, B_i = map(int, data[i].split())\n        \n        # Current score of player A_i\n        current_score = scores[A_i]\n        \n        # Update score\n        new_score = current_score + B_i\n        scores[A_i] = new_score\n        \n        # Update score_count\n        # Decrease count of the current score\n        score_count[current_score] -= 1\n        if score_count[current_score] == 0:\n            del score_count[current_score]  # Remove if count reaches zero\n        \n        # Increase count of the new score\n        score_count[new_score] += 1\n        \n        # The number of distinct scores is the number of keys in score_count\n        results.append(len(score_count))\n    \n    # Output result\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc343_e", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    V_1 = int(data[0])\n    V_2 = int(data[1])\n    V_3 = int(data[2])\n    \n    # Calculate total volume with three cubes\n    total_volume = 3 * (7 ** 3)  # 3 * 343 = 1029\n\n    # Check feasibility\n    if V_1 < 0 or V_2 < 0 or V_3 < 0 or (V_1 + V_2 + V_3 > total_volume):\n        print(\"No\")\n        return\n    \n    # Check if we can derive V1, V2, V3 from overlap volumes\n    # V1 + V2 + V3 = 1029\n    calculated_V1 = total_volume - V_2 - V_3\n    if calculated_V1 != V_1:\n        print(\"No\")\n        return\n\n    # Find coordinates of cubes that satisfy the volume constraints\n    # We assume the following configuration for simplicity:\n    # C1 at (0, 0, 0)\n    # C2 at (0, 0, 6)\n    # C3 at (6, 0, 0)\n    \n    # This setup will give us:\n    # Volume of C1 = 343\n    # Volume of C2 = 343\n    # Volume of C3 = 343\n    # Overlap C1 & C2 (0, 0, 0) to (0, 0, 7) gives V3 = 7 (only z overlaps)\n    # Overlap C1 & C3 (0, 0, 0) to (7, 0, 0) gives V2 = 84 (x overlaps)\n    # Overlap C2 & C3 (6, 0, 0) gives V2 = 84\n\n    # Example placement that satisfies V_1 = 840, V_2 = 84, V_3 = 7\n    a1, b1, c1 = 0, 0, 0\n    a2, b2, c2 = 0, 0, 6\n    a3, b3, c3 = 6, 0, 0\n\n    print(\"Yes\")\n    print(a1, b1, c1, a2, b2, c2, a3, b3, c3)"}
