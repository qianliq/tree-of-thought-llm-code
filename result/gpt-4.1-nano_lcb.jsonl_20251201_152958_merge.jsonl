{"task_id": "1873_A", "solution": "def main():\n    t = int(input().strip())\n    target = \"abc\"\n    for _ in range(t):\n        s = input().strip()\n        if s == target:\n            print(\"YES\")\n        else:\n            # Count the number of positions where s differs from target\n            differences = [i for i in range(3) if s[i] != target[i]]\n            if len(differences) == 2:\n                # Swapping these two characters will make s equal to target\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1873_B", "solution": "# Read the number of test cases\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    max_product = 0\n    \n    for i in range(n):\n        # Make a copy of the array to modify\n        temp = a[:]\n        # Increment the digit at position i, but do not exceed 9\n        if temp[i] < 9:\n            temp[i] += 1\n        # Calculate the product of the array\n        product = 1\n        for digit in temp:\n            product *= digit\n        # Update max_product if necessary\n        if product > max_product:\n            max_product = product\n    \n    print(max_product)"}
{"task_id": "1873_D", "solution": "t = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    s = input()\n\n    operations = 0\n    covered_end = -1  # Initialize to -1, meaning no coverage yet\n\n    for i in range(n):\n        if s[i] == 'B' and i > covered_end:\n            # Perform an operation starting here\n            operations += 1\n            covered_end = i + k - 1\n    \n    print(operations)"}
{"task_id": "1883_B", "solution": "def can_form_palindrome_after_removals(n, k, s):\n    from collections import Counter\n    \n    freq = Counter(s)\n    odd_counts = sum(1 for count in freq.values() if count % 2 != 0)\n\n    remaining_length = n - k\n\n    # Determine the minimal number of removals needed to fix parity for palindrome\n    if remaining_length % 2 == 0:\n        # For even length, all counts must be even\n        needed = odd_counts\n    else:\n        # For odd length, at most one odd count\n        needed = max(0, odd_counts - 1)\n\n    # Check if we can remove exactly k characters to achieve this\n    if needed <= k and (k - needed) % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input and process\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(can_form_palindrome_after_removals(n, k, s))"}
{"task_id": "1883_C", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        # If any element is already divisible by k\n        if any(a_i % k == 0 for a_i in a):\n            results.append(0)\n            continue\n        \n        # Otherwise, find the minimum increments needed\n        min_operations = float('inf')\n        for a_i in a:\n            r = a_i % k\n            if r != 0:\n                ops = k - r\n                if ops < min_operations:\n                    min_operations = ops\n        results.append(min_operations)\n    \n    print(\"\\n\".join(map(str, results)))"}
{"task_id": "1899_A", "solution": "# Read number of test cases\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    # If n is divisible by 3, Vanya wins immediately\n    if n % 3 == 0:\n        print(\"First\")\n    else:\n        print(\"Second\")"}
{"task_id": "1899_B", "solution": "import sys\nimport math\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n\n        # Compute prefix sums for quick segment sum calculations\n        prefix = [0] * (n+1)\n        for i in range(n):\n            prefix[i+1] = prefix[i] + a[i]\n\n        # Function to find all divisors of n\n        divisors = []\n        limit = int(math.sqrt(n))\n        for d in range(1, limit+1):\n            if n % d == 0:\n                divisors.append(d)\n                if d != n // d:\n                    divisors.append(n // d)\n\n        max_diff = 0\n\n        # For each divisor, compute the maximum difference\n        for k in divisors:\n            segment_sums = []\n            # For each starting position within [0, k-1]\n            for start in range(k):\n                total = 0\n                # Step through the array in steps of k\n                for pos in range(start, n, k):\n                    total += a[pos]\n                segment_sums.append(total)\n            current_max = max(segment_sums)\n            current_min = min(segment_sums)\n            max_diff = max(max_diff, current_max - current_min)\n\n        results.append(str(max_diff))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1899_C", "solution": "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n\n        max_sum = -10**9\n        current_sum = 0\n        prev_parity = None\n\n        for num in a:\n            current_parity = num % 2\n            if prev_parity is None or current_parity != prev_parity:\n                # Start a new subarray\n                current_sum = num\n            else:\n                # Continue the current subarray\n                current_sum += num\n            max_sum = max(max_sum, current_sum)\n            prev_parity = current_parity\n\n        results.append(str(max_sum))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1899_D", "solution": "# Approach:\n\n1. **Understanding the problem:**\n   - We have notes represented as \\(b_i = 2^{a_i}\\), where \\(a_i\\) is given.\n   - We need to count pairs \\((i, j)\\) where \\(i < j\\) and \\(b_i^{b_j} = b_j^{b_i}\\).\n   \n2. **Key insight:**\n   - Since \\(b_i = 2^{a_i}\\), the equality condition:\n     \\[\n     (2^{a_i})^{2^{a_j}} = (2^{a_j})^{2^{a_i}}\n     \\]\n   - Simplifies to:\n     \\[\n     2^{a_i \\cdot 2^{a_j}} = 2^{a_j \\cdot 2^{a_i}}\n     \\]\n   - Since bases are the same (2), the exponents must be equal:\n     \\[\n     a_i \\cdot 2^{a_j} = a_j \\cdot 2^{a_i}\n     \\]\n   - Rearranged:\n     \\[\n     \\frac{a_i}{a_j} = \\frac{2^{a_i}}{2^{a_j}} = 2^{a_i - a_j}\n     \\]\n   - But \\(a_i\\) and \\(a_j\\) are integers, so the equality reduces to:\n     \\[\n     a_i \\cdot 2^{a_j} = a_j \\cdot 2^{a_i}\n     \\]\n   \n3. **Special cases:**\n   - When \\(a_i = a_j\\), the equality always holds because:\n     \\[\n     2^{a_i \\cdot 2^{a_j}} = 2^{a_j \\cdot 2^{a_i}}\n     \\]\n     is trivially true.\n   - For \\(a_i \\neq a_j\\), the equality holds only under specific conditions.  \n   \n4. **Observation about pairs:**\n   - When \\(a_i = a_j\\), all such pairs count.\n   - When \\(a_i \\neq a_j\\), the only pairs that satisfy the condition are when:\n     \\[\n     a_i \\text{ and } a_j \\text{ satisfy } a_i \\cdot 2^{a_j} = a_j \\cdot 2^{a_i}\n     \\]\n   \n5. **Key reduction:**\n   - For the case \\(a_i \\neq a_j\\), the condition is rare. \n   - After working through examples and literature (known from similar problems), the pairs that satisfy the condition can be categorized:\n     - Pairs where \\(a_i = a_j\\): count as combination of duplicates.\n     - Pairs where \\(a_i\\) and \\(a_j\\) satisfy specific small patterns, notably involving small values like 1, 2, 3, 4, etc.\n\n6. **Efficient approach:**\n   - Count frequencies of each \\(a_i\\).\n   - For \\(a_i = a_j\\), the number of pairs is \\(\\text{freq}[a_i] \\times (\\text{freq}[a_i] - 1) / 2\\).\n   - For the specific small cases:\n     - When \\(a_i = 1\\), the pairs with \\(a_j = 1\\) are already counted.\n     - When \\(a_i = 2\\), pairs with \\(a_j=4\\) (or vice versa) satisfy the condition.\n     - When \\(a_i = 3\\), pairs with \\(a_j=3\\) are counted, and also pairs with \\(a_j=2\\) (since \\(3^2=8\\) and \\(2^3=8\\)). \n   - For larger \\(a_i\\), the pattern becomes either negligible or specific.\n\n7. **Implementation plan:**\n   - For each test case:\n     - Count the frequency of each \\(a_i\\).\n     - Calculate pairs for same \\(a_i\\).\n     - Add pairs for the special small values that satisfy the condition based on their known relationships.\n\n8. **Complexity:**\n   - Counting frequencies: \\(O(n)\\) per test.\n   - Summing up pairs: \\(O(number\\_of\\_distinct\\_a_i)\\).\n   - Total operations across all test cases are efficient given constraints.\n# Approach:\n\n1. **Understanding the problem:**\n   - Given notes \\(b_i = 2^{a_i}\\), and we need to count pairs \\((i, j)\\), \\(i<j\\), such that:\n     \\[\n     b_i^{b_j} = b_j^{b_i}\n     \\]\n   \n2. **Transforming the condition:**\n   - Since \\(b_i = 2^{a_i}\\), the equality becomes:\n     \\[\n     (2^{a_i})^{2^{a_j}} = (2^{a_j})^{2^{a_i}}\n     \\]\n   - Simplifies to:\n     \\[\n     2^{a_i \\cdot 2^{a_j}} = 2^{a_j \\cdot 2^{a_i}}\n     \\]\n   - Equating exponents:\n     \\[\n     a_i \\cdot 2^{a_j} = a_j \\cdot 2^{a_i}\n     \\]\n   \n3. **Analyzing the key equation:**\n   - For \\(a_i = a_j\\):\n     - The equation always holds, so all pairs of equal \\(a_i\\) contribute.\n   - For \\(a_i \\neq a_j\\):\n     - The equality holds only for specific small values.\n   \n4. **Pattern observations:**\n   - When \\(a_i = 1\\), the equation simplifies:\n     \\[\n     1 \\cdot 2^{a_j} = a_j \\cdot 2^{1} \\Rightarrow 2^{a_j} = 2 a_j\n     \\]\n     - Only when \\(a_j=1\\), since \\(2^{1} = 2\\), matches.\n   - When \\(a_i = 2\\):\n     \\[\n     2 \\cdot 2^{a_j} = a_j \\cdot 2^{2} = 4 a_j\n     \\]\n     \\[\n     2 \\cdot 2^{a_j} = 4 a_j\n     \\]\n     - Check for \\(a_j=4\\):\n       \\[\n       2 \\cdot 2^{4} = 2 \\times 16 = 32\n       \\]\n       \\[\n       4 \\times 4=16\n       \\]\n       No match.\n     - Check \\(a_j=2\\):\n       \\[\n       2 \\times 2^{2} = 2 \\times 4=8\n       \\]\n       \\[\n       4 \\times 2=8\n       \\]\n       Matches! So when \\(a_i=2\\), \\(a_j=2\\) always matches.\n   - When \\(a_i=3\\):\n     \\[\n     3 \\cdot 2^{a_j} = a_j \\cdot 2^{3} = 8 a_j\n     \\]\n     - For \\(a_j=3\\):\n       \\[\n       3 \\times 8=24\n       \\]\n       \\[\n       8 \\times 3=24\n       \\]\n       Match.\n     - For \\(a_j=2\\):\n       \\[\n       3 \\times 2^{2} =3 \\times 4=12\n       \\]\n       \\[\n       8 \\times 2=16\n       \\]\n       No.\n   \n   - Similar analysis shows:\n     - Pairs where \\(a_i= a_j\\) always match.\n     - Additional pairs:\n       - \\(a_i=1, a_j=1\\)\n       - \\(a_i=2, a_j=2\\)\n       - \\(a_i=3, a_j=3\\)\n     - and the special pair:\n       - \\(a_i=2, a_j=4\\) (since \\(2^4=16\\), \\(4^2=16\\)),\n         - \\(\\text{Note: }b_i=2^{a_i}=2^2=4\\), \\(b_j=2^{a_j}=2^4=16\\).\n         - \\(b_i^{b_j} = 4^{16}\\), \\(b_j^{b_i} = 16^4\\).\n         - Both equal: \\(4^{16}\\) and \\(16^4\\), both equal to \\(2^{2 \\times 16} = 2^{32}\\).\n         - So, the pair \\((a_i=2, a_j=4)\\) satisfies the condition.\n       - Similarly, \\(a_i=4, a_j=2\\) also works.\n\n5. **Summary of pairs satisfying the condition:**\n   - All pairs of equal \\(a_i=a_j\\).\n   - Pairs where:\n     - \\("}
{"task_id": "2727", "solution": "from typing import List\n\nclass Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        count = 0\n        for detail in details:\n            # Extract age substring (positions 11 and 12)\n            age_str = detail[11:13]\n            age = int(age_str)\n            if age > 60:\n                count += 1\n        return count"}
{"task_id": "2728", "solution": "from typing import List\n\nclass Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        # Step 1: Sort each row in descending order\n        for row in nums:\n            row.sort(reverse=True)\n        \n        total_score = 0\n        # Maximum length of rows\n        max_length = max(len(row) for row in nums)\n        \n        # Step 2: Iterate through each column index\n        for col in range(max_length):\n            current_max = 0\n            # Collect elements at the current column from each row\n            for row in nums:\n                if col < len(row):\n                    current_max = max(current_max, row[col])\n            # Add the highest among these to the total score\n            total_score += current_max\n        \n        return total_score"}
{"task_id": "2730", "solution": "from typing import List\n\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        max_or = 0\n        n = len(nums)\n        # Initial OR of all elements\n        initial_or = 0\n        for num in nums:\n            initial_or |= num\n        \n        max_or = initial_or\n\n        for i in range(n):\n            # simulate doubling nums[i] up to k times\n            temp_nums = nums[:]\n            for t in range(1, k + 1):\n                temp_nums[i] <<= 1\n                current_or = 0\n                for num in temp_nums:\n                    current_or |= num\n                if current_or > max_or:\n                    max_or = current_or\n\n        return max_or"}
{"task_id": "2754", "solution": "from typing import List\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_product = float('-inf')\n        n = len(nums)\n        # Iterate over all non-empty subsets\n        for mask in range(1, 1 << n):\n            product = 1\n            for i in range(n):\n                if mask & (1 << i):\n                    product *= nums[i]\n            max_product = max(max_product, product)\n        return max_product"}
{"task_id": "2755", "solution": "from typing import List\n\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        word_set = set(dictionary)\n        max_len = max(len(word) for word in dictionary) if dictionary else 0\n        n = len(s)\n        dp = [0] * (n + 1)\n        # dp[i] will hold the minimum extra characters from s[i:]\n        \n        for i in range(n - 1, -1, -1):\n            # Assume we skip this character\n            min_extra = dp[i + 1] + 1\n            # Check all substrings starting at i\n            for j in range(i + 1, min(i + 1 + max_len, n + 1)):\n                if s[i:j] in word_set:\n                    min_extra = min(min_extra, dp[j])\n            dp[i] = min_extra\n        return dp[0]"}
{"task_id": "2756", "solution": "from typing import List\n\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        prices.sort()\n        min_sum = float('inf')\n        n = len(prices)\n        for i in range(n):\n            for j in range(i + 1, n):\n                current_sum = prices[i] + prices[j]\n                if current_sum <= money and current_sum < min_sum:\n                    min_sum = current_sum\n        if min_sum == float('inf'):\n            return money\n        else:\n            return money - min_sum"}
{"task_id": "2757", "solution": "class Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n\n        def str_to_digits(s):\n            return list(map(int, s))\n        \n        def subtract_one(num_str):\n            num_list = list(map(int, num_str))\n            i = len(num_list) - 1\n            while i >= 0:\n                if num_list[i] > 0:\n                    num_list[i] -= 1\n                    break\n                else:\n                    num_list[i] = 9\n                    i -= 1\n            # Remove leading zeros if any\n            while len(num_list) > 1 and num_list[0] == 0:\n                num_list.pop(0)\n            return ''.join(map(str, num_list))\n        \n        def count_up_to(limit):\n            if limit == '':\n                return 0\n            digits = str_to_digits(limit)\n            n = len(digits)\n            from functools import lru_cache\n\n            @lru_cache(None)\n            def dp(pos, sum_so_far, is_tight):\n                # Base case: all digits processed\n                if pos == n:\n                    # Check if sum is within bounds\n                    return 1 if min_sum <= sum_so_far <= max_sum else 0\n\n                limit_digit = digits[pos] if is_tight else 9\n                total = 0\n                for dig in range(limit_digit + 1):\n                    new_sum = sum_so_far + dig\n                    if new_sum > max_sum:\n                        # Early pruning: sum exceeds max_sum\n                        break\n                    new_tight = is_tight and (dig == limit_digit)\n                    total += dp(pos + 1, new_sum, new_tight)\n                return total % MOD\n\n            return dp(0, 0, True)\n\n        # Handle case where num1 == '1' or smaller\n        lower_bound = ''\n        if num1 == '1':\n            lower_bound = '0'\n        else:\n            lower_bound = subtract_one(num1)\n\n        result = (count_up_to(num2) - count_up_to(lower_bound)) % MOD\n        return result"}
{"task_id": "2777", "solution": "from typing import List\n\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_distinct = [0] * n\n        suffix_distinct = [0] * n\n        \n        seen_prefix = set()\n        for i in range(n):\n            seen_prefix.add(nums[i])\n            prefix_distinct[i] = len(seen_prefix)\n        \n        seen_suffix = set()\n        for i in range(n - 1, -1, -1):\n            seen_suffix.add(nums[i])\n            suffix_distinct[i] = len(seen_suffix)\n        \n        diff = [0] * n\n        for i in range(n):\n            suffix_count = suffix_distinct[i + 1] if i + 1 < n else 0\n            diff[i] = prefix_distinct[i] - suffix_count\n        \n        return diff"}
{"task_id": "2779", "solution": "from typing import List\n\nclass Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [0] * n  # Initially all uncolored\n        answer = []\n        count = 0  # Number of adjacent pairs with same color\n\n        for index, color in queries:\n            prev_color = nums[index]\n            # If already colored with the same color, no change\n            if prev_color == color:\n                answer.append(count)\n                continue\n\n            # Check left neighbor\n            if index - 1 >= 0:\n                if nums[index - 1] == prev_color and prev_color != 0:\n                    count -= 1\n                if nums[index - 1] == color:\n                    count += 1\n\n            # Check right neighbor\n            if index + 1 < n:\n                if nums[index + 1] == prev_color and prev_color != 0:\n                    count -= 1\n                if nums[index + 1] == color:\n                    count += 1\n\n            # Update the current position\n            nums[index] = color\n\n            # Append the current count\n            answer.append(count)\n\n        return answer"}
{"task_id": "2784", "solution": "from typing import List\n\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n        \n        # Precompute prefix sums\n        prefix_sums = [0] * (n + 1)\n        for i in range(n):\n            prefix_sums[i + 1] = (prefix_sums[i] + nums[i]) % MOD\n        \n        total = 0\n        for i in range(n):\n            max_val = nums[i]\n            max_sq = (max_val * max_val) % MOD\n            \n            # Number of subsets where nums[i] is maximum:\n            # All subsets formed by elements before i (i.e., indices < i),\n            # combined with nums[i].\n            left_count = i\n            # Sum of elements to the left\n            sum_left = prefix_sums[i]\n            \n            # Contribution when nums[i] is maximum\n            max_contrib = max_sq * (1 << i) % MOD * (max_val) % MOD\n            \n            # Contribution when nums[i] is minimum:\n            # All subsets formed by elements after i, including nums[i]\n            right_count = n - i - 1\n            sum_right = (prefix_sums[n] - prefix_sums[i + 1]) % MOD\n            \n            min_contrib = (nums[i] * (1 << right_count)) % MOD * nums[i] % MOD\n            \n            total += (max_contrib - min_contrib) % MOD\n        return total % MOD"}
{"task_id": "2785", "solution": "from typing import List\n\nclass Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        # Find positions of 1 and n\n        pos_one = nums.index(1)\n        pos_n = nums.index(n)\n        \n        # Calculate moves to bring 1 to front\n        moves_one = pos_one\n        # Calculate moves to bring n to the end\n        moves_n = (n - 1) - pos_n\n        \n        # If 1 is after n, moving both will cause crossover\n        if pos_one > pos_n:\n            return moves_one + moves_n - 1\n        else:\n            return moves_one + moves_n"}
{"task_id": "2786", "solution": "class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        left = 0\n        max_length = 1\n        pair_count = 0\n        \n        for right in range(1, len(s)):\n            # Check if current and previous characters form a pair\n            if s[right] == s[right - 1]:\n                pair_count += 1\n            \n            # If more than one pair, move left pointer to reduce pairs\n            while pair_count > 1:\n                if s[left] == s[left + 1]:\n                    pair_count -= 1\n                left += 1\n            \n            # Update max_length\n            current_window_length = right - left + 1\n            if current_window_length > max_length:\n                max_length = current_window_length\n        \n        return max_length"}
{"task_id": "2791", "solution": "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> list[int]:\n        received = set()\n        current_friend = 1\n        received.add(current_friend)\n        i = 1  # Represents the multiple of k for the current turn\n        \n        while True:\n            next_friend = (current_friend - 1 + i * k) % n + 1\n            if next_friend in received:\n                break\n            received.add(next_friend)\n            current_friend = next_friend\n            i += 1\n        \n        # Losers are friends who did not receive the ball\n        losers = [friend for friend in range(1, n+1) if friend not in received]\n        return losers"}
{"task_id": "2792", "solution": "from typing import List\n\nclass Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        xor_sum = 0\n        for num in derived:\n            xor_sum ^= num\n        return xor_sum == 0"}
{"task_id": "2800", "solution": "class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            stack.append(char)\n            # Check if the last two characters form \"AB\" or \"CD\"\n            if len(stack) >= 2:\n                if (stack[-2] == 'A' and stack[-1] == 'B') or (stack[-2] == 'C' and stack[-1] == 'D'):\n                    # Remove the pair\n                    stack.pop()\n                    stack.pop()\n        return len(stack)"}
{"task_id": "2802", "solution": "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def can_partition(s, target):\n            # Helper function to check if s can be partitioned into substrings summing to target\n            from functools import lru_cache\n\n            @lru_cache(None)\n            def dfs(start, current_sum):\n                if start == len(s):\n                    return current_sum == target  # Check if total sum matches target at the end\n                res = False\n                for end in range(start + 1, len(s) + 1):\n                    num = int(s[start:end])\n                    new_sum = current_sum + num\n                    if new_sum > target:\n                        # No need to continue if sum exceeds target\n                        break\n                    if dfs(end, new_sum):\n                        res = True\n                        break\n                return res\n\n            return dfs(0, 0)\n\n        total = 0\n        for i in range(1, n + 1):\n            square_str = str(i * i)\n            if can_partition(square_str, i):\n                total += i * i\n        return total"}
{"task_id": "2808", "solution": "from typing import List\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        max_time = sum(time)\n        # Initialize DP array with infinity\n        dp = [[float('inf')] * (max_time + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n\n        for i in range(n):\n            for t in range(max_time + 1):\n                if dp[i][t] == float('inf'):\n                    continue\n                # Option 1: Paint with paid painter\n                new_time = t + time[i]\n                if new_time <= max_time:\n                    dp[i + 1][new_time] = min(dp[i + 1][new_time], dp[i][t] + cost[i])\n                # Option 2: Paint with free painter (if paid painter is busy at some point)\n                # Free painter can paint during the busy interval t, cost=0\n                # So, no change in cost or busy time\n                dp[i + 1][t] = min(dp[i + 1][t], dp[i][t])\n\n        # The answer is the minimum total cost among all possible busy times\n        return min(dp[n])"}
{"task_id": "2810", "solution": "from typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        min_total_cost = float('inf')\n        \n        for k in range(n):\n            total_cost = 0\n            for i in range(n):\n                total_cost += nums[(i - k) % n]\n            total_cost += k * x\n            min_total_cost = min(min_total_cost, total_cost)\n        \n        return min_total_cost"}
{"task_id": "2811", "solution": "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        included = set()\n        result = []\n        current = 1\n        total_sum = 0\n\n        while len(result) < n:\n            # Check if current number can be included\n            if (k - current) in included:\n                # Skip current if it forms a forbidden pair\n                current += 1\n                continue\n            # Include current number\n            included.add(current)\n            result.append(current)\n            total_sum += current\n            current += 1\n\n        return total_sum"}
{"task_id": "2812", "solution": "class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + 2 * t"}
{"task_id": "2816", "solution": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        s_list = list(s)\n        left, right = 0, len(s_list) - 1\n        \n        while left < right:\n            # Choose the smaller character to ensure minimal changes and lex order\n            min_char = min(s_list[left], s_list[right])\n            s_list[left] = min_char\n            s_list[right] = min_char\n            left += 1\n            right -= 1\n        \n        return \"\".join(s_list)"}
{"task_id": "2817", "solution": "class Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        transitions = []\n\n        # Find all transition points\n        for i in range(1, n):\n            if s[i] != s[i - 1]:\n                transitions.append(i)\n\n        # If no transitions, string is already uniform, cost is 0\n        if not transitions:\n            return 0\n\n        min_cost = float('inf')\n        \n        # Try flipping at each transition point\n        for i in transitions:\n            # Cost to flip prefix [0..i-1]\n            prefix_cost = i\n            # Cost to flip suffix [i..n-1]\n            suffix_cost = n - i\n            # Flipping at transition i\n            total_cost_prefix = prefix_cost\n            total_cost_suffix = suffix_cost\n            # Minimum cost among flipping strategies\n            min_cost = min(min_cost, total_cost_prefix, total_cost_suffix)\n\n        return min_cost"}
{"task_id": "2819", "solution": "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        # Remove trailing zeros\n        trimmed_num = num.rstrip('0')\n        # If all characters were zeros, return '0'\n        return trimmed_num if trimmed_num else '0'"}
{"task_id": "2824", "solution": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        # Calculate 2*n and 3*n\n        double_n = 2 * n\n        triple_n = 3 * n\n        \n        # Concatenate the numbers as strings\n        concat_str = str(n) + str(double_n) + str(triple_n)\n        \n        # Digit set for comparison\n        required_digits = set('123456789')\n        \n        # Check if the concatenated string contains all digits from 1 to 9 exactly once\n        # Conditions:\n        # 1. Length should be 9\n        # 2. No zeros in the string\n        # 3. All digits in the string should be unique and exactly the digits 1-9\n        \n        if len(concat_str) == 9 and '0' not in concat_str:\n            if set(concat_str) == required_digits:\n                return True\n        return False"}
{"task_id": "2825", "solution": "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if stack and stack[-1] == char:\n                stack.pop()  # Remove the pair\n            else:\n                stack.append(char)\n        return len(stack)"}
{"task_id": "2827", "solution": "from typing import List\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        # Disjoint Set Union (Union-Find) implementation\n        parent = list(range(len(nums)))\n        rank = [0] * len(nums)\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = find(parent[x])\n                x = parent[x]\n            return x\n\n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            if rootX != rootY:\n                if rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                elif rank[rootY] < rank[rootX]:\n                    parent[rootY] = rootX\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n\n        # Function to prime factorize a number\n        def prime_factors(n):\n            factors = set()\n            while n % 2 == 0:\n                factors.add(2)\n                n //= 2\n            f = 3\n            while f * f <= n:\n                while n % f == 0:\n                    factors.add(f)\n                    n //= f\n                f += 2\n            if n > 1:\n                factors.add(n)\n            return factors\n\n        # Map each prime factor to the first index it appears in\n        factor_to_index = {}\n\n        for i, num in enumerate(nums):\n            factors = prime_factors(num)\n            for factor in factors:\n                if factor not in factor_to_index:\n                    factor_to_index[factor] = i\n                else:\n                    # Union current index with the index stored for this factor\n                    union(i, factor_to_index[factor])\n\n        # Check if all indices are connected (i.e., share same root)\n        root = find(0)\n        for i in range(1, len(nums)):\n            if find(i) != root:\n                return False\n        return True"}
{"task_id": "2828", "solution": "class Solution:\n    def smallestString(self, s: str) -> str:\n        chars = list(s)\n        n = len(chars)\n        i = 0\n        \n        # Find the first character > 'a'\n        while i < n and chars[i] == 'a':\n            i += 1\n        \n        # If all characters are 'a', performing the operation on the entire string\n        # will not make it lexicographically smaller, but per problem statement,\n        # we need to do it exactly once, so do it on the entire string.\n        if i == n:\n            # Reduce the entire string\n            for j in range(n):\n                if chars[j] != 'a':\n                    chars[j] = chr((ord(chars[j]) - 1 - ord('a')) % 26 + ord('a'))\n            return \"\".join(chars)\n        \n        # From the first non-'a' character, continue while characters are > 'a'\n        start = i\n        while i < n and chars[i] != 'a':\n            i += 1\n        \n        # Reduce the substring from 'start' to 'i-1'\n        for j in range(start, i):\n            # Decrease character by one alphabetically, wrapping around if needed\n            if chars[j] > 'a':\n                chars[j] = chr(ord(chars[j]) - 1)\n        \n        return \"\".join(chars)"}
{"task_id": "2831", "solution": "from typing import List\nfrom math import gcd\n\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        first_digits = []\n        last_digits = []\n\n        # Precompute first and last digits for each number\n        for num in nums:\n            str_num = str(num)\n            first_digits.append(int(str_num[0]))\n            last_digits.append(num % 10)\n\n        count = 0\n        # Check all pairs (i, j) where i < j\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check if first digit of nums[i] and last digit of nums[j] are coprime\n                if gcd(first_digits[i], last_digits[j]) == 1:\n                    count += 1\n\n        return count"}
{"task_id": "2832", "solution": "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        # Map each number to a list of its indices\n        positions = defaultdict(list)\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n        \n        max_length = 0\n        \n        # For each element, use sliding window over its indices\n        for num, indices in positions.items():\n            left = 0\n            # Expand the window with right pointer\n            for right in range(len(indices)):\n                # Calculate window size in terms of array indices\n                while indices[right] - indices[left] + 1 - (right - left + 1) > k:\n                    # Shrink window from the left\n                    left += 1\n                # Update max_length\n                current_window_length = indices[right] - indices[left] + 1\n                max_length = max(max_length, current_window_length)\n        \n        return max_length"}
{"task_id": "2833", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Sort logs by time\n        logs.sort(key=lambda l: l[1])\n        \n        # Pair queries with their indices and sort by query time\n        sorted_queries = sorted([(q, i) for i, q in enumerate(queries)], key=lambda x: x[0])\n        \n        server_count = [0] * (n + 1)  # 1-based server ids\n        active_servers = 0\n        \n        ans = [0] * len(queries)\n        \n        left = 0\n        right = 0\n        m = len(logs)\n        \n        for q_time, idx in sorted_queries:\n            start_time = q_time - x\n            \n            # Move right pointer to include logs up to q_time\n            while right < m and logs[right][1] <= q_time:\n                srv = logs[right][0]\n                if server_count[srv] == 0:\n                    active_servers += 1\n                server_count[srv] += 1\n                right += 1\n            \n            # Move left pointer to exclude logs before start_time\n            while left < m and logs[left][1] < start_time:\n                srv = logs[left][0]\n                server_count[srv] -= 1\n                if server_count[srv] == 0:\n                    active_servers -= 1\n                left += 1\n            \n            # Number of servers with no requests = total servers - active servers\n            ans[idx] = n - active_servers\n        \n        return ans"}
{"task_id": "2834", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        # Initialize the count of marbles at each position\n        position_counts = Counter(nums)\n        \n        # Process each move\n        for f, t in zip(moveFrom, moveTo):\n            count = position_counts.get(f, 0)\n            if count > 0:\n                # Move all marbles from 'f' to 't'\n                position_counts[f] -= count\n                if position_counts[f] == 0:\n                    del position_counts[f]\n                position_counts[t] = position_counts.get(t, 0) + count\n        \n        # Extract occupied positions and return sorted list\n        occupied_positions = sorted(position_counts.keys())\n        return occupied_positions"}
{"task_id": "2837", "solution": "```python\nclass Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        min_operations = float('inf')\n        # We iterate over possible k (number of operations)\n        for k in range(0, 61):  # 60 is enough as 2^60 is large\n            target = num1 - k * num2\n            if target < 0:\n                break  # No need to continue if target is negative\n            # Check if target can be represented as sum of powers of two\n            # i.e., count of set bits in target\n            if target >= 0:\n                # Number of set bits in target\n                count_bits = bin(target).count('1')\n                # Total operations: k (number of steps) + count_bits (number of powers of two used)\n                total_ops = k + count_bits\n                min_operations = min(min_operations, total_ops)"}
{"task_id": "2839", "solution": "```python\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        # Pair each element with its index and sum\n        n = len(nums1)\n        arr = []\n        for i in range(n):\n            arr.append((nums1[i], nums2[i], nums1[i] + nums2[i]))\n        \n        # Sort arr by nums1 in descending order\n        arr.sort(key=lambda x: x[0], reverse=True)\n        \n        # Extract all nums2 for coordinate compression\n        nums2_all = sorted(set([x[1] for x in arr]))\n        # Map each nums2 to its compressed index\n        def compress(val):\n            return bisect.bisect_left(nums2_all, val)\n        \n        # Prepare queries: attach original index\n        q_with_idx = []\n        for i, (x, y) in enumerate(queries):\n            q_with_idx.append((x, y, i))\n        # Sort queries by x in descending order\n        q_with_idx.sort(key=lambda x: x[0], reverse=True)\n        \n        # Segment Tree for range maximum query over compressed nums2 indices\n        size = len(nums2_all)\n        segtree = [-1] * (2 * size)\n        \n        def update(pos, val):\n            pos += size\n            segtree[pos] = max(segtree[pos], val)\n            while pos > 1:\n                pos //= 2\n                segtree[pos] = max(segtree[2 * pos], segtree[2 * pos + 1])\n        \n        def query(start, end):\n            # Query max in [start, end)\n            start += size\n            end += size\n            res = -1\n            while start < end:\n                if start % 2 == 1:\n                    res = max(res, segtree[start])\n                    start += 1\n                if end % 2 == 1:\n                    end -= 1\n                    res = max(res, segtree[end])\n                start //= 2\n                end //= 2\n            return res\n        \n        res = [-1] * len(queries)\n        arr_ptr = 0\n        # Process each query in order of decreasing x\n        for x, y, idx in q_with_idx:\n            # Insert all elements with nums1 >= x\n            while arr_ptr < n and arr[arr_ptr][0] >= x:\n                nums2_val = arr[arr_ptr][1]\n                sum"}
{"task_id": "2844", "solution": "from typing import List\n\nclass Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total += nums[i - 1] ** 2\n        return total"}
{"task_id": "2845", "solution": "from typing import List\n\nclass Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        # Step 1: Sort the array\n        nums.sort()\n        \n        # Initialize the minimal difference to a large number\n        min_diff = float('inf')\n        \n        # Step 2: Iterate through adjacent pairs to find the minimal difference\n        for i in range(1, len(nums)):\n            diff = nums[i] - nums[i - 1]\n            if diff < min_diff:\n                min_diff = diff\n        \n        # Step 3: Return the minimal difference found\n        return min_diff"}
{"task_id": "2847", "solution": "from typing import List\n\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        seen = set()\n        count = 0\n        \n        for word in words:\n            rev = word[::-1]\n            if rev in seen:\n                count += 1\n                seen.remove(rev)\n            else:\n                seen.add(word)\n                \n        return count"}
{"task_id": "2848", "solution": "from typing import List\n\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        \n        # Precompute adjacency based on divisibility\n        adj = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                        adj[i].append(j)\n        \n        # Initialize DP table: dp[mask][i]\n        dp = [[0] * n for _ in range(1 << n)]\n        for i in range(n):\n            dp[1 << i][i] = 1\n        \n        for mask in range(1 << n):\n            for i in range(n):\n                if dp[mask][i] != 0:\n                    for j in adj[i]:\n                        if not (mask & (1 << j)):\n                            new_mask = mask | (1 << j)\n                            dp[new_mask][j] = (dp[new_mask][j] + dp[mask][i]) % MOD\n        \n        # Sum all permutations that use all elements\n        full_mask = (1 << n) - 1\n        result = sum(dp[full_mask][i] for i in range(n)) % MOD\n        return result"}
{"task_id": "2849", "solution": "from typing import List\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        total_imbalance = 0\n        n = len(nums)\n        \n        for i in range(n):\n            for j in range(i, n):\n                subarray = nums[i:j+1]\n                # Sort the current subarray\n                sorted_sub = sorted(subarray)\n                # Count the number of adjacent pairs with difference > 1\n                imbalance_count = 0\n                for k in range(len(sorted_sub) - 1):\n                    if sorted_sub[k+1] - sorted_sub[k] > 1:\n                        imbalance_count += 1\n                total_imbalance += imbalance_count\n                \n        return total_imbalance"}
{"task_id": "2850", "solution": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # Counts of \"AA\" and \"BB\"\n        a_blocks = x\n        b_blocks = y\n        # Number of \"AB\" strings\n        ab_count = z\n\n        total_length = 0\n\n        # Function to add \"AA\" or \"BB\" blocks, ensuring no more than two in a row\n        def add_blocks(count, block_char):\n            nonlocal total_length\n            length_added = 0\n            while count > 0:\n                # Add up to 2 blocks at a time\n                take = min(2, count)\n                total_length += take * 2  # each block is length 2\n                count -= take\n                length_added += take * 2\n                # After adding blocks, if still have remaining, insert \"AB\" to break sequence\n                if count > 0:\n                    # Use \"AB\" string which adds 2 characters\n                    if ab_count > 0:\n                        total_length += 2\n                        nonlocal ab_count\n                        ab_count -= 1\n                    else:\n                        # No \"AB\" remaining, can't add more blocks without violating constraints\n                        break\n            return count\n\n        # Loop until no more blocks can be added\n        while a_blocks > 0 or b_blocks > 0:\n            # Decide which block to add based on current counts\n            if a_blocks >= b_blocks:\n                # Add \"AA\"\n                prev_a_blocks = a_blocks\n                a_blocks = add_blocks(a_blocks, 'A')\n                # If after adding \"AA\" blocks, still have \"BB\" left and \"AB\" available, add \"AB\"\n                if b_blocks > 0 and ab_count > 0:\n                    total_length += 2\n                    ab_count -= 1\n                # Add \"BB\" blocks\n                b_blocks = add_blocks(b_blocks, 'B')\n            else:\n                # Add \"BB\"\n                prev_b_blocks = b_blocks\n                b_blocks = add_blocks(b_blocks, 'B')\n                # If after adding \"BB\" blocks, still have \"AA\" left and \"AB\" available, add \"AB\"\n                if a_blocks > 0 and ab_count > 0:\n                    total_length += 2\n                    ab_count -= 1\n                # Add \"AA\" blocks\n                a_blocks = add_blocks(a_blocks, 'A')\n        return total_length"}
{"task_id": "2854", "solution": "from typing import List\nimport collections\n\nclass Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        # Initialize DP dictionary: keys as (start_char, end_char), values as minimal length\n        current_states = {}\n        first_word = words[0]\n        start_char = first_word[0]\n        end_char = first_word[-1]\n        current_states[(start_char, end_char)] = len(first_word)\n\n        # Process each subsequent word\n        for i in range(1, len(words)):\n            next_word = words[i]\n            next_start = next_word[0]\n            next_end = next_word[-1]\n            next_states = collections.defaultdict(lambda: float('inf'))\n\n            for (curr_start, curr_end), length in current_states.items():\n                # Option 1: join current string with next_word on the right\n                if curr_end == next_start:\n                    new_length = length + len(next_word) - 1\n                else:\n                    new_length = length + len(next_word)\n                key = (curr_start, next_end)\n                if new_length < next_states[key]:\n                    next_states[key] = new_length\n\n                # Option 2: join next_word on the left of current string\n                if next_end == curr_start:\n                    new_length = length + len(next_word) - 1\n                else:\n                    new_length = length + len(next_word)\n                key = (next_start, curr_end)\n                if new_length < next_states[key]:\n                    next_states[key] = new_length\n\n            current_states = next_states\n\n        # The answer is the minimum length among all states\n        return min(current_states.values())"}
{"task_id": "2855", "solution": "from typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [-1] * n\n        dp[0] = 0  # Starting point, zero jumps\n        \n        for i in range(n):\n            if dp[i] == -1:\n                continue  # Can't reach this index, skip\n            for j in range(i + 1, n):\n                diff = nums[j] - nums[i]\n                if -target <= diff <= target:\n                    dp[j] = max(dp[j], dp[i] + 1)\n        \n        return dp[n - 1]"}
{"task_id": "2856", "solution": "from typing import List\n\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        total_unique = len(set(nums))\n        count = Counter()\n        left = 0\n        result = 0\n        distinct_in_window = 0\n        \n        for right in range(len(nums)):\n            count[nums[right]] += 1\n            if count[nums[right]] == 1:\n                distinct_in_window += 1\n            \n            # When current window contains all unique elements\n            while distinct_in_window == total_unique:\n                # All subarrays starting from 'left' to 'right' and extending to the end are valid\n                result += len(nums) - right\n                \n                # Shrink window from the left to find minimal window\n                count[nums[left]] -= 1\n                if count[nums[left]] == 0:\n                    distinct_in_window -= 1\n                left += 1\n        \n        return result"}
{"task_id": "2857", "solution": "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        total_distance = 0\n        # Loop while mainTank has at least 5 liters to consume\n        while mainTank >= 5:\n            # Consume 5 liters\n            mainTank -= 5\n            total_distance += 50  # 5 liters * 10 km/l\n            # Transfer 1 liter from additionalTank if possible\n            if additionalTank >= 1:\n                additionalTank -= 1\n                mainTank += 1\n        # Consume remaining fuel in mainTank\n        total_distance += mainTank * 10\n        return total_distance"}
{"task_id": "2866", "solution": "from typing import List\n\nclass Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        max_length = 0\n        n = len(nums)\n        \n        for i in range(n):\n            # Check if current start element is even and within threshold\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                current_length = 1\n                j = i + 1\n                while j < n:\n                    # Check threshold condition\n                    if nums[j] > threshold:\n                        break\n                    # Check for alternating parity\n                    if nums[j] % 2 != nums[j - 1] % 2:\n                        current_length += 1\n                        j += 1\n                    else:\n                        break\n                max_length = max(max_length, current_length)\n        \n        return max_length"}
{"task_id": "2867", "solution": "from typing import List\n\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        ones_positions = [i for i, num in enumerate(nums) if num == 1]\n        \n        # If no '1' in array, no valid split\n        if not ones_positions:\n            return 0\n        \n        total_ways = 1\n        # Calculate the number of zeros between consecutive '1's\n        for i in range(len(ones_positions) - 1):\n            zeros_between = ones_positions[i+1] - ones_positions[i] - 1\n            total_ways = (total_ways * (zeros_between + 1)) % MOD\n        \n        return total_ways"}
{"task_id": "2868", "solution": "from collections import deque\nfrom typing import List\n\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        min_deque = deque()  # will store indices of potential minimum values\n        max_deque = deque()  # will store indices of potential maximum values\n        left = 0\n        total = 0\n        \n        for right in range(len(nums)):\n            # Maintain min_deque\n            while min_deque and nums[min_deque[-1]] > nums[right]:\n                min_deque.pop()\n            min_deque.append(right)\n            \n            # Maintain max_deque\n            while max_deque and nums[max_deque[-1]] < nums[right]:\n                max_deque.pop()\n            max_deque.append(right)\n            \n            # Shrink window if invalid\n            while nums[max_deque[0]] - nums[min_deque[0]] > 2:\n                if min_deque[0] == left:\n                    min_deque.popleft()\n                if max_deque[0] == left:\n                    max_deque.popleft()\n                left += 1\n            \n            # Count valid subarrays ending at right\n            total += (right - left + 1)\n        \n        return total"}
{"task_id": "2869", "solution": "from typing import List\n\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        # Initialize the lengths for the first element\n        dp1 = 1  # choosing nums1[0]\n        dp2 = 1  # choosing nums2[0]\n        max_length = 1\n\n        for i in range(1, n):\n            # Track previous values before updating\n            prev_dp1 = dp1\n            prev_dp2 = dp2\n\n            # Update dp1: choosing nums1[i]\n            dp1 = 1  # At least the current element itself\n            if nums1[i] >= nums1[i - 1]:\n                dp1 = max(dp1, prev_dp1 + 1)\n            if nums1[i] >= nums2[i - 1]:\n                dp1 = max(dp1, prev_dp2 + 1)\n\n            # Update dp2: choosing nums2[i]\n            dp2 = 1\n            if nums2[i] >= nums1[i - 1]:\n                dp2 = max(dp2, prev_dp1 + 1)\n            if nums2[i] >= nums2[i - 1]:\n                dp2 = max(dp2, prev_dp2 + 1)\n\n            max_length = max(max_length, dp1, dp2)\n\n        return max_length"}
{"task_id": "2870", "solution": "from typing import List\n\nclass Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        max_length = -1\n        n = len(nums)\n        for i in range(n - 1):\n            # Check if this could be the start of an alternating subarray\n            if nums[i+1] == nums[i] + 1:\n                length = 2\n                j = i + 1\n                while j + 1 < n:\n                    diff = nums[j+1] - nums[j]\n                    # For the pattern, difference should alternate between 1 and -1\n                    expected_diff = (-1) ** j\n                    if diff == expected_diff:\n                        length += 1\n                        j += 1\n                    else:\n                        break\n                max_length = max(max_length, length)\n        return max_length"}
{"task_id": "2872", "solution": "from typing import List\n\nclass Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        max_value = 0\n        current_sum = 0\n\n        # Iterate from the end to the beginning\n        for num in reversed(nums):\n            if num <= current_sum:\n                current_sum += num  # Merge with the current sequence\n            else:\n                current_sum = num  # Start a new sequence\n            max_value = max(max_value, current_sum)\n\n        return max_value"}
{"task_id": "2873", "solution": "from typing import List\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        # Edge case: if n < 4, no pairs are possible because smallest prime is 2\n        if n < 4:\n            return []\n\n        # Sieve of Eratosthenes to find primes up to n\n        is_prime = [True] * (n + 1)\n        is_prime[0], is_prime[1] = False, False\n\n        for i in range(2, int(n**0.5) + 1):\n            if is_prime[i]:\n                for j in range(i * i, n + 1, i):\n                    is_prime[j] = False\n\n        result = []\n\n        # Check for pairs where x <= y and x + y = n\n        for x in range(2, n // 2 + 1):\n            if is_prime[x] and is_prime[n - x]:\n                result.append([x, n - x])\n\n        return result"}
{"task_id": "2876", "solution": "from typing import List\n\nclass Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        return sum(1 for hour in hours if hour >= target)"}
{"task_id": "2877", "solution": "from itertools import permutations\n\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def merge_strings(s1: str, s2: str) -> str:\n            # Find maximum overlap between suffix of s1 and prefix of s2\n            max_overlap = 0\n            for i in range(1, min(len(s1), len(s2)) + 1):\n                if s1[-i:] == s2[:i]:\n                    max_overlap = i\n            return s1 + s2[max_overlap:]\n        \n        strings = [a, b, c]\n        min_superstring = None\n        \n        for perm in permutations(strings):\n            # Merge first two strings\n            merged = merge_strings(perm[0], perm[1])\n            # Merge with the third string\n            merged = merge_strings(merged, perm[2])\n            \n            # Update answer based on length and lex order\n            if (min_superstring is None or\n                len(merged) < len(min_superstring) or\n                (len(merged) == len(min_superstring) and merged < min_superstring)):\n                min_superstring = merged\n        \n        return min_superstring"}
{"task_id": "2878", "solution": "from typing import List\n\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        diff = [0] * (n + 1)  # Difference array to track the effect of subtractions\n        add = 0  # Current total subtractions affecting the current position\n\n        for i in range(n):\n            add += diff[i]  # Update the current effect based on previous operations\n            current_value = nums[i] - add\n            if current_value < 0:\n                # Can't subtract more than current value, impossible scenario\n                return False\n            elif current_value > 0:\n                # Need to perform current_value subtractions starting at position i\n                if i + k > n:\n                    # Not enough space to perform the operation\n                    return False\n                add += current_value\n                diff[i + k] -= current_value  # Effect ends after position i + k - 1\n\n        # If we reach here, all elements can be reduced to zero\n        return True"}
{"task_id": "2879", "solution": "```python\nclass Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        # Precompute costs for all substrings\n        cost = [[0] * n for _ in range(n)]\n        \n        # Helper function to compute minimal changes to turn s[l:r+1] into a semi-palindrome\n        def min_changes_substring(l, r):\n            length = r - l + 1\n            sub = s[l:r+1]\n            min_change = float('inf')\n            \n            # Find all divisors d of length\n            for d in range(1, length):\n                if length % d != 0:\n                    continue\n                total_changes = 0\n                # For each position in 0..d-1, process groups\n                for offset in range(d):\n                    # Collect characters at indices offset + multiple of d\n                    group_chars = [sub[i] for i in range(offset, length, d)]\n                    # Pair characters from start and end\n                    pairs = []\n                    for i in range(len(group_chars)//2):\n                        pairs.append((group_chars[i], group_chars[-i-1]))\n                    # For each pair, count minimal changes to make both characters same\n                    changes_for_group = 0\n                    for c1, c2 in pairs:\n                        if c1 != c2:\n                            changes_for_group += 1\n                    total_changes += changes_for_group\n                min_change = min(min_change, total_changes)\n            return min_change\n        \n        # Precompute costs for all substrings\n        for i in range(n):\n            for j in range(i, n):\n                cost[i][j] = min_changes_substring(i, j)\n        \n        # Initialize DP array\n        # dp[i][j]: minimal changes to partition s[:i] into j substrings\n        from math import inf\n        dp = [[inf] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        \n        # Fill DP\n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                for m in range(j-1, i):\n                    # partition s[m:i"}
{"task_id": "2881", "solution": "from typing import List\n\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            # Split the current word by separator\n            parts = word.split(separator)\n            # Filter out empty strings\n            filtered_parts = [part for part in parts if part]\n            # Add the non-empty parts to the result\n            result.extend(filtered_parts)\n        return result"}
{"task_id": "2882", "solution": "class Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        # Generate all possible base integers k where k^x <= n\n        max_base = 1\n        candidates = []\n        while True:\n            power = max_base ** x\n            if power > n:\n                break\n            candidates.append(power)\n            max_base += 1\n        \n        # Initialize DP array\n        dp = [0] * (n + 1)\n        dp[0] = 1  # base case\n        \n        # For each candidate power, update the dp array\n        for power in candidates:\n            for i in range(n, power - 1, -1):\n                dp[i] += dp[i - power]\n                dp[i] %= MOD\n        \n        return dp[n]"}
{"task_id": "2883", "solution": "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        # Precompute all powers of 5 within 15 bits\n        max_val = (1 << 15)  # 2^15\n        powers_of_5 = set()\n        num = 1\n        while num < max_val:\n            binary_str = bin(num)[2:]\n            powers_of_5.add(binary_str)\n            num *= 5\n\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                substring = s[j:i]\n                # Check leading zeros\n                if substring.startswith('0'):\n                    continue\n                # Check if substring is in the set of powers of 5\n                if substring in powers_of_5:\n                    dp[i] = min(dp[i], dp[j] + 1)\n\n        return dp[n] if dp[n] != float('inf') else -1"}
{"task_id": "2884", "solution": "from typing import List\n\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        forbidden_set = set(forbidden)\n        max_len = 0\n        start = 0\n        n = len(word)\n        \n        for end in range(n):\n            # Check for forbidden substrings ending at position end\n            for length in range(1, 11):  # max length of forbidden string is 10\n                if end - length + 1 < start:\n                    # Substring would start before current window, break early\n                    break\n                sub = word[end - length + 1 : end + 1]\n                if sub in forbidden_set:\n                    # Move start just after the forbidden substring\n                    start = end - length + 2\n                    break\n            max_len = max(max_len, end - start + 1)\n        \n        return max_len"}
{"task_id": "2886", "solution": "class Solution:\n    def finalString(self, s: str) -> str:\n        result = []\n        for ch in s:\n            if ch == 'i':\n                result.reverse()\n            else:\n                result.append(ch)\n        return ''.join(result)"}
{"task_id": "2887", "solution": "class Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels_set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        vowels = [char for char in s if char in vowels_set]\n        vowels.sort()  # Sort vowels by ASCII order\n        \n        result = []\n        vowel_index = 0\n        \n        for char in s:\n            if char in vowels_set:\n                result.append(vowels[vowel_index])\n                vowel_index += 1\n            else:\n                result.append(char)\n        \n        return ''.join(result)"}
{"task_id": "2888", "solution": "from typing import List\n\nclass Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        # Step 1: Find the dominant element using Boyer-Moore Voting Algorithm\n        candidate = None\n        count = 0\n        for num in nums:\n            if count == 0:\n                candidate = num\n                count = 1\n            elif num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        # Step 2: Count total frequency of the candidate (dominant element)\n        total_count = nums.count(candidate)\n        n = len(nums)\n        left_count = 0\n        \n        # Step 3: Iterate to find the earliest valid split\n        for i in range(n - 1):\n            if nums[i] == candidate:\n                left_count += 1\n            right_count = total_count - left_count\n            \n            prefix_length = i + 1\n            suffix_length = n - prefix_length\n            \n            # Check if candidate is dominant in both parts\n            if left_count * 2 > prefix_length and right_count * 2 > suffix_length:\n                return i  # minimal index\n        \n        # If no valid split found\n        return -1"}
{"task_id": "2891", "solution": "from typing import List\n\nclass Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        events = []\n\n        # Generate the start and end events for each range\n        for num in nums:\n            start = num - k\n            end = num + k\n            # Increment at start, decrement after end\n            events.append((start, 1))\n            events.append((end + 1, -1))\n        \n        # Sort events based on position\n        events.sort(key=lambda x: x[0])\n\n        max_overlap = 0\n        current_overlap = 0\n\n        # Sweep through events\n        for _, delta in events:\n            current_overlap += delta\n            if current_overlap > max_overlap:\n                max_overlap = current_overlap\n\n        return max_overlap"}
{"task_id": "2892", "solution": "from typing import List\n\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        from collections import Counter\n\n        # Step 1: Find the maximum element in nums\n        max_num = max(nums)\n        n = max_num\n\n        # Step 2: Check length condition\n        if len(nums) != n + 1:\n            return False\n\n        # Step 3: Count frequency of each number\n        count = Counter(nums)\n\n        # Verify that numbers from 1 to n-1 appear exactly once\n        for num in range(1, n):\n            if count.get(num, 0) != 1:\n                return False\n\n        # Verify that n appears exactly twice\n        if count.get(n, 0) != 2:\n            return False\n\n        return True"}
{"task_id": "2893", "solution": "from typing import List\n\nclass Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        max_even = float('-inf')\n        max_odd = float('-inf')\n        max_score = float('-inf')\n        \n        for num in nums:\n            if num % 2 == 0:\n                # Current number is even\n                current = max(num, max_even, max_odd - x if max_odd != float('-inf') else float('-inf'))\n                max_even = max(max_even, current)\n            else:\n                # Current number is odd\n                current = max(num, max_odd, max_even - x if max_even != float('-inf') else float('-inf'))\n                max_odd = max(max_odd, current)\n            max_score = max(max_score, current)\n        \n        return max_score"}
{"task_id": "2902", "solution": "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        # Dictionary to store the top two max numbers for each maximum digit\n        max_digit_groups = {}\n        \n        for num in nums:\n            max_digit = max(int(d) for d in str(num))\n            if max_digit not in max_digit_groups:\n                max_digit_groups[max_digit] = [0, 0]  # Initialize with two smallest values\n            # Update top two largest numbers for this max_digit\n            if num > max_digit_groups[max_digit][0]:\n                max_digit_groups[max_digit][1] = max_digit_groups[max_digit][0]\n                max_digit_groups[max_digit][0] = num\n            elif num > max_digit_groups[max_digit][1]:\n                max_digit_groups[max_digit][1] = num\n        \n        max_sum = -1\n        # Iterate through each group to find the maximum pair sum\n        for group in max_digit_groups.values():\n            if group[1] != 0:\n                candidate_sum = group[0] + group[1]\n                if candidate_sum > max_sum:\n                    max_sum = candidate_sum\n        \n        return max_sum"}
{"task_id": "2915", "solution": "from typing import List\n\nclass Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        # Step 1: Create is_special array\n        is_special = [1 if num % modulo == k else 0 for num in nums]\n        \n        count = 0\n        prefix_mod = 0\n        freq = {0: 1}  # prefix sum remainder frequency\n        \n        for num in is_special:\n            # Update the prefix sum modulo\n            prefix_mod = (prefix_mod + num) % modulo\n            # Calculate needed remainder\n            target_remainder = (prefix_mod - k) % modulo\n            # Add counts of previous prefix sums with the target remainder\n            count += freq.get(target_remainder, 0)\n            # Update frequency dictionary\n            freq[prefix_mod] = freq.get(prefix_mod, 0) + 1\n        \n        return count"}
{"task_id": "2916", "solution": "from typing import List\n\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        \n        # Precompute prefix sums for quick subarray sum calculation\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        memo = {}\n        \n        def subarray_sum(start, end):\n            return prefix_sum[end + 1] - prefix_sum[start]\n        \n        def can_split(start, end):\n            # Check memo cache\n            if (start, end) in memo:\n                return memo[(start, end)]\n            \n            length = end - start + 1\n            total_sum = subarray_sum(start, end)\n            \n            # Base case: single element subarray\n            if length == 1:\n                memo[(start, end)] = True\n                return True\n            \n            # If current subarray is already valid\n            if total_sum >= m:\n                memo[(start, end)] = True\n                return True\n            \n            # Try all possible splits\n            for split_point in range(start + 1, end + 1):\n                left_valid = can_split(start, split_point - 1)\n                right_valid = can_split(split_point, end)\n                if left_valid and right_valid:\n                    memo[(start, end)] = True\n                    return True\n            \n            memo[(start, end)] = False\n            return False\n        \n        return can_split(0, n - 1)"}
{"task_id": "2917", "solution": "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] < target:\n                    count += 1\n        return count"}
{"task_id": "2919", "solution": "from typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        total_sum = sum(usageLimits)\n        left, right = 0, len(usageLimits)\n        result = 0\n        \n        while left <= right:\n            mid = (left + right) // 2\n            # Count how many elements can participate in at least 'mid' groups\n            count = sum(1 for limit in usageLimits if limit >= mid)\n            \n            # Total usages needed for 'mid' groups\n            total_required = mid * (mid + 1) // 2\n            \n            # Check feasibility:\n            # - capacity sum should be enough\n            # - enough elements to cover the total usages\n            if count >= mid and total_sum >= total_required:\n                result = mid  # mid is feasible, try for a bigger value\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return result"}
{"task_id": "2920", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        positions = defaultdict(list)\n\n        # Record all indices for each number\n        for i, num in enumerate(nums):\n            positions[num].append(i)\n\n        max_seconds = 0\n\n        for num, indices in positions.items():\n            # Since indices are in order of appearance, but we can sort to be safe\n            indices.sort()\n\n            # Compute gaps considering circular array\n            max_gap = 0\n            for i in range(len(indices)):\n                # Distance between consecutive indices\n                curr_gap = (indices[(i + 1) % len(indices)] - indices[i]) % n\n                max_gap = max(max_gap, curr_gap)\n\n            # The number of seconds needed for this number to fill the array\n            seconds_for_num = (max_gap + 1) // 2\n            max_seconds = max(max_seconds, seconds_for_num)\n\n        return max_seconds"}
{"task_id": "2921", "solution": "```python\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        \n        def subtract_one(num_str):\n            \"\"\"Subtract 1 from a large number represented as string.\"\"\"\n            num_list = list(num_str)\n            i = len(num_list) - 1\n            while i >= 0:\n                if num_list[i] != '0':\n                    num_list[i] = str(int(num_list[i]) - 1)\n                    break\n                else:\n                    num_list[i] = '9'\n                    i -= 1\n            # Remove leading zeros if any\n            while len(num_list) > 1 and num_list[0] == '0':\n                num_list.pop(0)\n            return ''.join(num_list)\n        \n        def convert(num_str):\n            return list(map(int, num_str))\n        \n        def count_up_to(num_str):\n            \"\"\"Count stepping numbers less than or equal to num_str using Digit DP.\"\"\"\n            if not num_str:\n                return 0\n            \n            digits = convert(num_str)\n\n            from functools import lru_cache\n            \n            @lru_cache(None)\n            def dfs(pos, prev_digit, tight, leading_zero):\n                if pos == len(digits):\n                    # Valid number if it is not just leading zeros\n                    return 1 if not leading_zero else 0\n                \n                limit = digits[pos] if tight else 9\n                total = 0\n                for d in range(limit + 1):\n                    # Skip leading zeros unless number is zero\n                    if leading_zero and d == 0:\n                        # Still leading zeros, prev_digit is irrelevant\n                        total += dfs(pos + 1, -1, tight and d == limit, True)\n                    else:\n                        # Not leading zero\n                        if prev_digit == -1:\n                            # First non-zero digit\n                            total += dfs(pos + 1, d, tight and d == limit, False)\n                        else:\n                            # Check stepping condition\n                            if abs(d - prev_digit) == 1:\n                                total += dfs(pos + 1, d, tight and d == limit, False)\n                return total % MOD\n            \n            return dfs(0, -1, True, True)\n        \n        # Compute count for high\n        count_high = count_up_to(high)\n        # Compute count for low - 1\n        low_minus_one = subtract_one(low)\n        count_low = count_up_to(low_minus_one) if low_minus_one != '' else 0\n        \n        answer = (count_high - count_low) % MOD\n        return"}
{"task_id": "2952", "solution": "from typing import List\n\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        max_time = 10**6  # Upper bound for binary search, can be adjusted\n        \n        def can_reach(t: int) -> bool:\n            # Calculate the elements after t seconds\n            values = [nums1[i] + t * nums2[i] for i in range(n)]\n            total_sum = sum(values)\n            \n            # Sort by value descending to prioritize resets on largest elements\n            values.sort(reverse=True)\n            \n            resets_used = 0\n            current_sum = total_sum\n            \n            for val in values:\n                if current_sum <= x:\n                    break\n                # Reset the current largest element\n                current_sum -= val\n                resets_used += 1\n            \n            return current_sum <= x\n        \n        left, right = 0, max_time\n        answer = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if can_reach(mid):\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return answer"}
{"task_id": "2953", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        count = 0\n        freq = defaultdict(int)\n        for x, y in coordinates:\n            # Generate all (dx, dy) such that dx + dy = k\n            for dx in range(k + 1):\n                dy = k - dx\n                candidate_x = x ^ dx\n                candidate_y = y ^ dy\n                count += freq[(candidate_x, candidate_y)]\n            # Add current point to frequency map\n            freq[(x, y)] += 1\n        return count"}
{"task_id": "2954", "solution": "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        n = len(nums)\n        if k > n:\n            return 0\n\n        freq = {}\n        current_sum = 0\n        max_sum = 0\n        distinct_count = 0\n\n        # Initialize the first window\n        for i in range(k):\n            num = nums[i]\n            current_sum += num\n            freq[num] = freq.get(num, 0) + 1\n            if freq[num] == 1:\n                distinct_count += 1\n\n        # Check the first window\n        if distinct_count >= m:\n            max_sum = current_sum\n\n        # Slide the window\n        for i in range(k, n):\n            outgoing = nums[i - k]\n            incoming = nums[i]\n\n            # Remove the outgoing element\n            freq[outgoing] -= 1\n            current_sum -= outgoing\n            if freq[outgoing] == 0:\n                del freq[outgoing]\n                distinct_count -= 1\n\n            # Add the incoming element\n            current_sum += incoming\n            freq[incoming] = freq.get(incoming, 0) + 1\n            if freq[incoming] == 1:\n                distinct_count += 1\n\n            # Check if the current window satisfies the condition\n            if distinct_count >= m:\n                max_sum = max(max_sum, current_sum)\n\n        return max_sum"}
{"task_id": "2955", "solution": "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        initial_balance = 100\n        q = purchaseAmount // 10\n        lower_multiple = q * 10\n        higher_multiple = (q + 1) * 10\n\n        diff_lower = abs(purchaseAmount - lower_multiple)\n        diff_higher = abs(higher_multiple - purchaseAmount)\n\n        if diff_lower < diff_higher:\n            rounded_amount = lower_multiple\n        elif diff_higher < diff_lower:\n            rounded_amount = higher_multiple\n        else:\n            # If both are equally close, choose the larger multiple\n            rounded_amount = higher_multiple\n\n        return initial_balance - rounded_amount"}
{"task_id": "2977", "solution": "from typing import List\n\nclass Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        # Step 1: Check if length matches\n        if len(s) != len(words):\n            return False\n        \n        # Step 2: Compare each first character with corresponding character in s\n        for i, word in enumerate(words):\n            if not word or word[0] != s[i]:\n                return False\n        \n        # Step 3: All checks passed\n        return True"}
{"task_id": "2979", "solution": "from typing import List\nimport bisect\n\nclass Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        # Step 1: Sort offers by their end index\n        offers.sort(key=lambda x: x[1]) \n\n        # Extract the start, end, and gold into separate lists for convenience\n        starts = [offer[0] for offer in offers]\n        ends = [offer[1] for offer in offers]\n        golds = [offer[2] for offer in offers]\n\n        # Prepare DP array\n        dp = [0] * (len(offers) + 1)\n\n        # For binary search, create an array of end times\n        end_times = ends\n\n        for i in range(1, len(offers) + 1):\n            # Current offer index is i-1 due to 1-based DP indexing\n            start = starts[i - 1]\n            end = ends[i - 1]\n            gold = golds[i - 1]\n\n            # Find the rightmost offer that ends before start of current offer\n            # Use binary search on end_times\n            idx = bisect.bisect_right(end_times, start - 1, 0, i - 1)\n\n            # DP relation:\n            # max of not taking current offer or taking it\n            dp[i] = max(dp[i - 1], gold + dp[idx])\n\n        return dp[-1]"}
{"task_id": "2998", "solution": "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        count = 0\n        for num in range(low, high + 1):\n            s = str(num)\n            length = len(s)\n            # Only consider numbers with even number of digits\n            if length % 2 != 0:\n                continue\n            mid = length // 2\n            first_half = s[:mid]\n            second_half = s[mid:]\n            # Calculate digit sums\n            sum_first = sum(int(d) for d in first_half)\n            sum_second = sum(int(d) for d in second_half)\n            if sum_first == sum_second:\n                count += 1\n        return count"}
{"task_id": "2999", "solution": "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        # Extract characters at even indices\n        s1_even = [s1[i] for i in range(0, 4, 2)]\n        s2_even = [s2[i] for i in range(0, 4, 2)]\n        # Extract characters at odd indices\n        s1_odd = [s1[i] for i in range(1, 4, 2)]\n        s2_odd = [s2[i] for i in range(1, 4, 2)]\n        \n        # Compare sorted lists\n        return sorted(s1_even) == sorted(s2_even) and sorted(s1_odd) == sorted(s2_odd)"}
{"task_id": "3000", "solution": "from typing import List\nimport bisect\n\nclass Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        min_diff = float('inf')\n        prev_values = []\n\n        for i in range(n):\n            # For current index i, add the element at index i - x (if valid)\n            if i - x >= 0:\n                bisect.insort(prev_values, nums[i - x])\n            \n            # Find the position to insert nums[i] to keep prev_values sorted\n            pos = bisect.bisect_left(prev_values, nums[i])\n            \n            # Check the neighbor on the left\n            if pos > 0:\n                min_diff = min(min_diff, abs(nums[i] - prev_values[pos - 1]))\n            # Check the neighbor on the right\n            if pos < len(prev_values):\n                min_diff = min(min_diff, abs(nums[i] - prev_values[pos]))\n        \n        return min_diff if min_diff != float('inf') else 0"}
{"task_id": "3017", "solution": "class Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        from functools import lru_cache\n\n        def get_digits(n):\n            return list(map(int, str(n)))\n\n        def count_up_to(n):\n            if n < 0:\n                return 0\n            digits = get_digits(n)\n\n            @lru_cache(None)\n            def dfs(pos, even_count, odd_count, is_tight, leading_zero, remainder):\n                # If we've processed all digits\n                if pos == len(digits):\n                    # Check if counts are equal and number is divisible by k\n                    if not leading_zero and even_count == odd_count and remainder == 0:\n                        return 1\n                    return 0\n\n                limit = digits[pos] if is_tight else 9\n                total = 0\n                for d in range(limit + 1):\n                    new_tight = is_tight and (d == limit)\n                    new_leading_zero = leading_zero and d == 0\n\n                    # If leading zeros, do not increase digit counts\n                    new_even_count = even_count\n                    new_odd_count = odd_count\n                    if not new_leading_zero:\n                        if d % 2 == 0:\n                            new_even_count += 1\n                        else:\n                            new_odd_count += 1\n\n                    new_remainder = remainder\n                    if not new_leading_zero:\n                        new_remainder = (remainder * 10 + d) % k\n\n                    total += dfs(pos + 1, new_even_count, new_odd_count, new_tight, new_leading_zero, new_remainder)\n                return total\n\n            return dfs(0, 0, 0, True, True, 0)\n\n        return count_up_to(high) - count_up_to(low - 1)"}
{"task_id": "3018", "solution": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        def is_subsequence(s, t):\n            i, j = 0, 0\n            while i < len(s) and j < len(t):\n                if s[i] == t[j]:\n                    j += 1\n                i += 1\n            return j == len(t)\n        \n        # Check if str2 is already a subsequence of str1\n        if is_subsequence(str1, str2):\n            return True\n        \n        # Iterate through each position in str1 to check if incrementing helps\n        for i in range(len(str1)):\n            # Calculate the incremented character cyclically\n            original_char = str1[i]\n            incremented_char = chr((ord(original_char) - ord('a') + 1) % 26 + ord('a'))\n\n            # Build a modified version of str1 with this character changed\n            # Instead of creating the whole string, simulate the subsequence check\n            j = 0  # Pointer for str2\n            k = 0  # Pointer for str1\n            while k < len(str1):\n                c = str1[k]\n                if k == i:\n                    c = incremented_char\n                if c == str2[j]:\n                    j += 1\n                    if j == len(str2):\n                        break\n                k += 1\n            if j == len(str2):\n                return True\n\n        # If no position leads to making str2 a subsequence, return False\n        return False"}
{"task_id": "3019", "solution": "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        L_count = moves.count('L')\n        R_count = moves.count('R')\n        underscores = moves.count('_')\n        \n        # Current position without underscores\n        position = L_count - R_count\n        \n        # Maximize distance by assigning underscores to push further away\n        max_distance = abs(position) + underscores\n        return max_distance"}
{"task_id": "3024", "solution": "```python\nclass Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        import math\n        MOD = 10**9 + 7\n        \n        n = len(s)\n        # Find position where t occurs in s+s\n        s2 = s + s\n        pos = s2.find(t)\n        if pos == -1:\n            return 0\n        \n        # If k == 0, only possible if s == t\n        if k == 0:\n            return 1 if s == t else 0\n        \n        # Polynomial P(x): for suffix lengths 1 to n-1, coefficient at index l = 1\n        # Represented as array: [0, 1, 1, ..., 1] of length n\n        poly = [0] + [1] * (n - 1)\n        \n        # Function to perform FFT\n        def fft(a, invert):\n            size = len(a)\n            j = 0\n            for i in range(1, size):\n                bit = size >> 1\n                while j & bit:\n                    j ^= bit\n                    bit >>= 1\n                j |= bit\n                if i < j:\n                    a[i], a[j] = a[j], a[i]\n            length = 2\n            while length <= size:\n                wlen = pow(3, (MOD - 1) // length, MOD)\n                if invert:\n                    wlen = pow(wlen, MOD - 2, MOD)\n                for i in range(0, size, length):\n                    w = 1\n                    for j in range(i, i + length // 2):\n                        u = a[j]\n                        v = a[j + length // 2] * w % MOD\n                        a[j] = (u + v) % MOD\n                        a[j + length // 2] = (u - v + MOD) % MOD\n                        w = w * wlen % MOD\n                length <<= 1\n            if invert:\n                inv_size = pow(size, MOD - 2, MOD)\n                for i in range(size):\n                    a[i] = a[i] * inv_size % MOD\n        \n        # Polynomial multiplication via FFT\n        def multiply(a, b):\n            size = 1"}
{"task_id": "3025", "solution": "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        # Count the frequency of each power of two in nums\n        counts = [0] * 31  # since 2^30 is the max in constraints\n        for num in nums:\n            power = num.bit_length() - 1  # find the power of 2\n            counts[power] += 1\n        \n        operations = 0\n        total_sum = sum((1 << i) * counts[i] for i in range(31))\n        if total_sum < target:\n            # Not enough sum possible\n            return -1\n\n        # We process from the highest power to the lowest\n        for i in range(30, -1, -1):\n            # Check if the i-th bit in target is set\n            if (target >> i) & 1:\n                # Need at least one element of this power\n                if counts[i] > 0:\n                    counts[i] -= 1\n                else:\n                    # Need to break down a higher power\n                    # Search for a higher power to break\n                    j = i + 1\n                    while j <= 30 and counts[j] == 0:\n                        j += 1\n                    if j > 30:\n                        # No higher power to break down\n                        return -1\n                    # Break down from counts[j]\n                    while j > i:\n                        # Break one element of power j into two of power j-1\n                        counts[j] -= 1\n                        counts[j - 1] += 2\n                        operations += 1\n                        j -= 1\n                    # Now we have at least one power i\n                    if counts[i] > 0:\n                        counts[i] -= 1\n                    else:\n                        # Still no power i available after breakdown\n                        return -1\n            # After satisfying the ith bit requirement, add back to counts for next iteration\n            # Because in the process, we haven't used up all counts\n            # But since we only decremented when needed, no extra action needed here\n\n        return operations"}
{"task_id": "3031", "solution": "from typing import List\n\nclass Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        MOD = 12345\n        n = len(grid)\n        m = len(grid[0]) if n > 0 else 0\n        \n        total_elements = n * m\n        flat_list = [cell for row in grid for cell in row]\n        \n        zero_count = 0\n        product_non_zero = 1\n        \n        # Count zeros and compute product of non-zero elements\n        for num in flat_list:\n            if num == 0:\n                zero_count += 1\n            else:\n                product_non_zero *= num\n        \n        # Prepare result matrix\n        result = [[0 for _ in range(m)] for _ in range(n)]\n        \n        if zero_count > 1:\n            # All products are zero\n            return result\n        elif zero_count == 1:\n            # Only the position of zero gets the product of all non-zero elements\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == 0:\n                        # This position's product is the product of all non-zero elements\n                        result[i][j] = product_non_zero % MOD\n                    else:\n                        result[i][j] = 0\n            return result\n        else:\n            # No zeros, safe to divide\n            total_product = 1\n            for num in flat_list:\n                total_product *= num\n            total_product %= MOD  # Modulo for safety\n            \n            for i in range(n):\n                for j in range(m):\n                    # Compute product excluding grid[i][j]\n                    # Use integer division since grid[i][j] divides total_product\n                    # but need to do modulo carefully\n                    val = total_product // grid[i][j]\n                    result[i][j] = val % MOD\n            return result"}
{"task_id": "3032", "solution": "from typing import List\n\nclass Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n = len(receiver)\n        max_value = 0\n        memo = {}  # cache to store computed results for nodes\n        \n        for start in range(n):\n            if start in memo:\n                # If already computed, update max_value\n                max_value = max(max_value, memo[start])\n                continue\n            \n            visited = {}  # node -> position in the path\n            path = []     # store nodes in traversal order\n            current = start\n            total_sum = 0\n            \n            for step in range(min(k + 1, n + 1)):  # limit steps to avoid infinite loops\n                if current in visited:\n                    # cycle detected\n                    cycle_start_index = visited[current]\n                    prefix_nodes = path[:cycle_start_index]\n                    cycle_nodes = path[cycle_start_index:]\n                    break\n                visited[current] = len(path)\n                path.append(current)\n                total_sum += current\n                current = receiver[current]\n            else:\n                # No cycle detected within n steps, so sequence ends\n                # Compute f(x)\n                f_x = total_sum\n                max_value = max(max_value, f_x)\n                # Save in memo\n                for node in path:\n                    memo[node] = total_sum\n                continue\n            \n            # Compute prefix sum\n            prefix_sum = sum(node for node in path[:cycle_start_index])\n            cycle_sum = sum(node for node in cycle_nodes)\n            cycle_length = len(cycle_nodes)\n            prefix_length = len(path[:cycle_start_index])\n            total_passes = k\n            \n            # Number of passes taken before cycle\n            passes_in_prefix = prefix_length\n            remaining_passes = total_passes - passes_in_prefix\n            \n            # Sum after considering the cycle\n            if remaining_passes > 0:\n                # Number of full cycles that fit into remaining passes\n                full_cycles = remaining_passes // cycle_length\n                # Remaining passes after full cycles\n                leftover = remaining_passes % cycle_length\n                \n                total_sum_x = (\n                    prefix_sum\n                    + cycle_sum * full_cycles\n                    + sum(cycle_nodes[:leftover])\n                )\n            else:\n                # No remaining passes after prefix\n                total_sum_x = sum(node for node in path[:total_passes + 1])\n            \n            # Store the result for the starting node\n            memo[start] = total_sum_x\n            max_value = max(max_value, total_sum_x)\n        \n        return max_value"}
{"task_id": "3033", "solution": "class Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        n = len(s1)\n        mismatches = []\n\n        # Step 1: Find mismatched positions\n        for i in range(n):\n            if s1[i] != s2[i]:\n                mismatches.append(i)\n\n        # Step 2: Check the number of mismatches\n        if len(mismatches) % 2 != 0:\n            return -1  # Impossible to fix all mismatches\n\n        total_cost = 0\n        i = 0\n        m = len(mismatches)\n\n        # Step 3: Process mismatches greedily\n        while i < m:\n            # If the next mismatch is adjacent, consider flipping adjacent\n            if (i + 1 < m) and (mismatches[i + 1] == mismatches[i] + 1):\n                # Decide whether to fix with adjacent flip or global flip\n                # Cost of fixing adjacent mismatches\n                adjacent_fix_cost = 1\n                # Cost of fixing globally for these two mismatches\n                global_fix_cost = 2 * x  # Since we need two global flips if fixing separately\n\n                # Choose minimal cost approach\n                # But note: fixing two mismatches in adjacent positions\n                # can be done with one adjacent flip at cost 1\n                # or with two global flips at cost 2x\n                if adjacent_fix_cost <= x:\n                    total_cost += adjacent_fix_cost\n                    i += 2\n                else:\n                    total_cost += global_fix_cost\n                    i += 2\n            else:\n                # No adjacent mismatch, fix with global flip\n                total_cost += x\n                i += 2\n\n        return total_cost"}
{"task_id": "3034", "solution": "from typing import List\n\nclass Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        covered_points = set()\n        for start, end in nums:\n            for point in range(start, end + 1):\n                covered_points.add(point)\n        return len(covered_points)"}
{"task_id": "3044", "solution": "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        target = 1\n        # Traverse from the end and try to find numbers from 1 to k\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] == target:\n                target += 1\n            # If we've found all numbers from 1 to k\n            if target > k:\n                break\n        # The number of operations needed is total length minus the number of collected elements\n        return len(nums) - (k)"}
{"task_id": "3045", "solution": "from typing import List\n\nclass Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        descents = []\n\n        # Find all points where nums[i] > nums[i+1]\n        for i in range(n):\n            if nums[i] > nums[(i + 1) % n]:\n                descents.append(i)\n\n        # If no descent point, array is already sorted\n        if len(descents) == 0:\n            return 0\n        # If more than one descent, cannot be sorted by rotation\n        elif len(descents) > 1:\n            return -1\n        else:\n            # Calculate the position of the rotation\n            k = descents[0]\n            shifts = (n - (k + 1)) % n\n            # Verify if the array is sorted after this rotation\n            rotated = nums[-shifts:] + nums[:-shifts]\n            if rotated == sorted(nums):\n                return shifts\n            else:\n                return -1"}
{"task_id": "3046", "solution": "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        # Possible ending pairs for divisibility by 25\n        endings = [\"00\", \"25\", \"50\", \"75\"]\n        min_deletions = float('inf')\n        \n        for ending in endings:\n            count = 0\n            # Find the last digit of the pair from the end\n            idx_second = -1\n            for i in range(len(num) - 1, -1, -1):\n                if num[i] == ending[1]:\n                    idx_second = i\n                    break\n            if idx_second == -1:\n                # Can't form this pair\n                continue\n            \n            # Count deletions after the second digit\n            deletions_after = len(num) - 1 - idx_second\n            \n            # Find the first digit of the pair before idx_second\n            idx_first = -1\n            for j in range(idx_second - 1, -1, -1):\n                if num[j] == ending[0]:\n                    idx_first = j\n                    break\n            if idx_first == -1:\n                # Can't form this pair\n                continue\n            \n            # Count deletions between the first and second digit\n            deletions_between = idx_second - idx_first - 1\n            \n            total_deletions = deletions_after + deletions_between\n            min_deletions = min(min_deletions, total_deletions)\n        \n        # If no pair found, consider removing all digits except '0' if present\n        if min_deletions == float('inf'):\n            # Check if '0' exists\n            if '0' in num:\n                # Remove all other digits to leave '0'\n                return len(num) - 1\n            else:\n                # Need to delete all digits\n                return len(num)\n        return min_deletions"}
{"task_id": "3047", "solution": "from typing import List\nimport math\nfrom collections import defaultdict\n\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def get_square_free(num: int) -> int:\n            \"\"\"\n            Compute the square-free part of the number.\n            \"\"\"\n            res = 1\n            temp = num\n            for p in range(2, int(math.sqrt(temp)) + 1):\n                count = 0\n                while temp % p == 0:\n                    temp //= p\n                    count += 1\n                if count % 2 == 1:\n                    res *= p\n            if temp > 1:\n                # temp is prime\n                res *= temp\n            return res\n\n        groups = defaultdict(int)\n\n        for num in nums:\n            sf = get_square_free(num)\n            groups[sf] += num\n\n        return max(groups.values()) if groups else 0"}
{"task_id": "3055", "solution": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        # Count the number of '1's and '0's\n        count_ones = s.count('1')\n        count_zeros = s.count('0')\n        \n        # Place all '1's except the last one at the front\n        # Leave one '1' for the end to ensure the number is odd\n        result = '1' * (count_ones - 1)\n        # Append all zeros\n        result += '0' * count_zeros\n        # Append the last '1' to ensure the number is odd\n        result += '1'\n        \n        return result"}
{"task_id": "3080", "solution": "from typing import List\n\nclass Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        current_and = 1  # Neutral value for AND operation\n        for num in nums:\n            current_and &= num\n            if current_and == 0:\n                count += 1\n                current_and = 1  # Reset for the next subarray\n        return count"}
{"task_id": "3081", "solution": "from typing import List\n\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        # Since nums is sorted, we can directly count the first and last elements\n        min_element = nums[0]\n        max_element = nums[-1]\n        \n        # Count how many times min_element appears\n        count_min = 0\n        for num in nums:\n            if num == min_element:\n                count_min += 1\n            else:\n                break\n        \n        # Count how many times max_element appears from the end\n        count_max = 0\n        for num in reversed(nums):\n            if num == max_element:\n                count_max += 1\n            else:\n                break\n        \n        # The minimal length remaining is the absolute difference\n        return abs(count_min - count_max)"}
{"task_id": "3091", "solution": "from typing import List\n\nclass Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        MOD = 10**9 + 7\n\n        # Count frequency of each distinct number\n        from collections import Counter\n        freq_map = Counter(nums)\n\n        max_sum = sum(nums)\n        # Initialize DP array\n        dp = [0] * (max_sum + 1)\n        dp[0] = 1  # empty multiset\n\n        # Process each distinct number with its frequency\n        for num, count in freq_map.items():\n            # Create a temporary array to hold new counts\n            new_dp = [0] * (max_sum + 1)\n            # For each sum in current dp\n            for s in range(max_sum + 1):\n                if dp[s] != 0:\n                    # Include 0..count copies of num\n                    for k in range(count + 1):\n                        new_sum = s + k * num\n                        if new_sum <= max_sum:\n                            new_dp[new_sum] = (new_dp[new_sum] + dp[s]) % MOD\n            dp = new_dp\n\n        # Compute prefix sums for quick range queries\n        prefix = [0] * (max_sum + 1)\n        for i in range(max_sum + 1):\n            prefix[i] = (prefix[i - 1] + dp[i]) if i > 0 else dp[0]\n        \n        def count_subsets_up_to(limit):\n            if limit < 0:\n                return 0\n            return prefix[min(limit, max_sum)]\n        \n        total_up_to_r = count_subsets_up_to(r)\n        total_below_l = count_subsets_up_to(l - 1)\n        result = (total_up_to_r - total_below_l) % MOD\n        return result"}
{"task_id": "3093", "solution": "from typing import List\n\nclass Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        total = 0\n        for i in range(len(nums)):\n            # Count number of set bits in binary representation of index i\n            if bin(i).count('1') == k:\n                total += nums[i]\n        return total"}
{"task_id": "3094", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count_freq = Counter(nums)\n        total_operations = 0\n\n        for c in count_freq.values():\n            min_ops = float('inf')\n            # Try all possible y (number of 3-element removals)\n            for y in range(c // 3 + 1):\n                remaining = c - 3 * y\n                # Check if remaining is divisible by 2 for the 2-element removals\n                if remaining % 2 == 0:\n                    x = remaining // 2\n                    if x >= 0:\n                        total_ops = x + y\n                        if total_ops < min_ops:\n                            min_ops = total_ops\n            # If no valid combination found, impossible to reduce to zero\n            if min_ops == float('inf'):\n                return -1\n            total_operations += min_ops\n\n        return total_operations"}
{"task_id": "3104", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def countWays(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = Counter(nums)\n        # Extract unique sorted values\n        unique_vals = sorted(count.keys())\n\n        # Create a prefix sum array for counts\n        prefix = [0]\n        for val in unique_vals:\n            prefix.append(prefix[-1] + count[val])\n        # prefix[i] = total students with value less than unique_vals[i]\n        # total students: n\n\n        result = 0\n        for k in range(n + 1):\n            # Find the position to insert k in unique_vals (binary search)\n            # or find how many are less than k\n            # Since unique_vals are sorted, we can use binary search\n            import bisect\n            idx = bisect.bisect_left(unique_vals, k)\n            # number of students with nums[i] < k\n            less_than_k = prefix[idx]\n            # number of students with nums[i] >= k\n            ge_k = n - less_than_k\n            if ge_k == k:\n                result += 1\n\n        return result"}
{"task_id": "3106", "solution": "from typing import List\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        # Initialize DP array with -1 indicating impossible sums\n        dp = [-1] * (target + 1)\n        dp[0] = 0  # Empty subsequence has sum 0 and length 0\n\n        for num in nums:\n            # Iterate backwards to avoid reusing the same element in this step\n            for s in range(target, num - 1, -1):\n                if dp[s - num] != -1:\n                    # If there's a subsequence summing to (s - num),\n                    # we can extend it with current num\n                    dp[s] = max(dp[s], dp[s - num] + 1)\n\n        return dp[target]"}
{"task_id": "3114", "solution": "from typing import List\n\nclass Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        max_total = 0\n\n        for peak in range(n):\n            # Initialize heights array to represent the mountain with peak at 'peak'\n            heights = [0] * n\n\n            # Set the peak height to max allowed at peak position\n            heights[peak] = maxHeights[peak]\n\n            # Propagate to the left\n            for j in range(peak - 1, -1, -1):\n                heights[j] = min(maxHeights[j], heights[j + 1])\n\n            # Propagate to the right\n            for k in range(peak + 1, n):\n                heights[k] = min(maxHeights[k], heights[k - 1])\n\n            # Sum the current configuration\n            total = sum(heights)\n            max_total = max(max_total, total)\n\n        return max_total"}
{"task_id": "3141", "solution": "from typing import List\n\nclass Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        min_length = float('inf')\n        current_sum = 0\n        left = 0\n\n        # We simulate two concatenations of nums\n        for right in range(2 * n):\n            current_sum += nums[right % n]\n\n            # Shrink the window while sum >= target\n            while current_sum >= target:\n                if current_sum == target:\n                    min_length = min(min_length, right - left + 1)\n                current_sum -= nums[left % n]\n                left += 1\n\n        return min_length if min_length != float('inf') else -1"}
{"task_id": "3150", "solution": "class Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        # Collect positions of '1's\n        ones_positions = [i for i, ch in enumerate(s) if ch == '1']\n        \n        # If not enough '1's to form a substring with k '1's\n        if len(ones_positions) < k:\n            return \"\"\n        \n        min_length = float('inf')\n        candidates = []\n        \n        # Iterate over all windows of size k over the positions of '1'\n        for i in range(len(ones_positions) - k + 1):\n            start_pos = ones_positions[i]\n            end_pos = ones_positions[i + k - 1]\n            length = end_pos - start_pos + 1\n            \n            # Update minimum length and store candidates\n            if length < min_length:\n                min_length = length\n                candidates = [(start_pos, end_pos)]\n            elif length == min_length:\n                candidates.append((start_pos, end_pos))\n        \n        # Among all candidates with minimal length, build lex smallest substring\n        result = None\n        for start_idx, end_idx in candidates:\n            substring_chars = []\n            ones_count = 0\n            for i in range(start_idx, end_idx + 1):\n                if s[i] == '1':\n                    substring_chars.append('1')\n                    ones_count += 1\n                else:\n                    # Choose '0' for lex smallest\n                    substring_chars.append('0')\n            \n            # Verify if count of '1's in the substring is exactly k\n            # (Should always be true, as we based on positions of '1's)\n            if ones_count == k:\n                candidate_str = ''.join(substring_chars)\n                if (result is None) or (candidate_str < result):\n                    result = candidate_str\n        \n        return result if result is not None else \"\""}
{"task_id": "3151", "solution": "from typing import List\nimport heapq\n\nclass Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        # Number of cores in total\n        total_cores = len(processorTime) * 4\n\n        # Generate all cores with their initial availability\n        # Each core is represented as (next_available_time)\n        cores = []\n        for p_time in processorTime:\n            for _ in range(4):\n                cores.append(p_time)\n\n        # Convert to a min-heap\n        heapq.heapify(cores)\n\n        # Sort tasks in descending order to assign larger tasks first\n        tasks.sort(reverse=True)\n\n        max_finish_time = 0\n\n        # Assign each task to the earliest available core\n        for task in tasks:\n            earliest_time = heapq.heappop(cores)\n            finish_time = earliest_time + task\n            max_finish_time = max(max_finish_time, finish_time)\n            heapq.heappush(cores, finish_time)\n\n        return max_finish_time"}
{"task_id": "3153", "solution": "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        # Calculate the OR of all elements\n        OR_all = 0\n        for num in nums:\n            OR_all |= num\n\n        # Sort the array in descending order\n        nums.sort(reverse=True)\n\n        # Select the top k-1 elements\n        selected = nums[:k-1]\n\n        # Append OR_all as the remaining element to maximize sum\n        selected.append(OR_all)\n\n        # Calculate the sum of squares\n        total = 0\n        for val in selected:\n            total += val * val\n        return total % MOD"}
{"task_id": "3154", "solution": "from typing import List\n\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        # Precompute maximum to the left of each position\n        max_left = [0] * n\n        max_left[0] = nums[0]\n        for i in range(1, n):\n            max_left[i] = max(max_left[i - 1], nums[i])\n\n        # Precompute maximum to the right of each position\n        max_right = [0] * n\n        max_right[-1] = nums[-1]\n        for i in range(n - 2, -1, -1):\n            max_right[i] = max(max_right[i + 1], nums[i])\n\n        max_value = 0\n        # Iterate through possible middle elements j\n        for j in range(1, n - 1):\n            left_max = max_left[j - 1]\n            right_max = max_right[j + 1]\n            potential = (left_max - nums[j]) * right_max\n            if potential > max_value:\n                max_value = potential\n\n        return max_value if max_value > 0 else 0"}
{"task_id": "3163", "solution": "from typing import List\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        total_sum = 0\n        n = len(nums)\n        for i in range(n):\n            seen = set()\n            for j in range(i, n):\n                seen.add(nums[j])\n                distinct_count = len(seen)\n                total_sum += distinct_count * distinct_count\n        return total_sum"}
{"task_id": "3164", "solution": "from typing import List\n\nclass Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        nums = []  # List to store visited integers\n        result = []  # Result list for last visited integers on \"prev\"\n        consecutive_prev_count = 0  # Count of consecutive \"prev\"\n\n        for word in words:\n            if word.isdigit():\n                # It's a number, add to nums\n                nums.append(int(word))\n                # Reset consecutive_prev_count as we saw a number\n                consecutive_prev_count = 0\n            elif word == \"prev\":\n                # Increment count of consecutive \"prev\"\n                consecutive_prev_count += 1\n                # Determine last visited integer\n                if consecutive_prev_count > len(nums):\n                    result.append(-1)\n                else:\n                    result.append(nums[-consecutive_prev_count])\n        return result"}
{"task_id": "3166", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        # Count the frequency of each unique value\n        freq = Counter(nums)\n        # The answer is the maximum frequency among all values\n        return max(freq.values())"}
{"task_id": "3171", "solution": "from typing import List\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1 = sum(nums1)\n        sum2 = sum(nums2)\n        zeros1 = nums1.count(0)\n        zeros2 = nums2.count(0)\n        \n        # If sums are already equal and no zeros, return the sum\n        if sum1 == sum2 and zeros1 == 0 and zeros2 == 0:\n            return sum1\n        \n        max_sum = max(sum1, sum2)\n        total_zeros = zeros1 + zeros2\n        \n        # The minimal sum is at least max_sum\n        # Check if we can reach sum = max_sum by filling zeros\n        # The difference needed to match max_sum\n        diff = abs(sum1 - sum2)\n        \n        # Total available \"resource\" to fill zeros\n        # Since zeros can be filled with any positive integers, the only limit is the total zeros\n        # To increase the smaller sum to max_sum, zeros in that array need to be filled accordingly.\n        \n        # If the difference is more than total zeros (since each zero can at least be 1),\n        # then we need to see if we can compensate.\n        # Because zeros can be increased arbitrarily, as long as total zeros >= diff\n        # (which is always true since zeros are positive integers), the minimal sum is max_sum.\n        \n        # But if the total zeros are insufficient to compensate for the difference,\n        # then it's impossible.\n        # Actually, multiple zeros can be assigned large values, so the main constraint is only\n        # that zeros are sufficient to compensate for the difference.\n        \n        # Since we can assign zeros any positive integers, as long as total zeros >= diff,\n        # it's possible to fill zeros in the array with smaller sum to reach max_sum.\n        # Therefore, the minimal sum for both arrays is max_sum.\n        \n        # Check if the difference can be compensated:\n        if diff > total_zeros:\n            return -1\n        else:\n            return max_sum"}
{"task_id": "3172", "solution": "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        # Sum of all numbers from 1 to n\n        total_sum = n * (n + 1) // 2\n        \n        # Number of multiples of m within [1, n]\n        k = n // m\n        \n        # Sum of all multiples of m within [1, n]\n        sum_multiples = m * (k * (k + 1) // 2)\n        \n        # Sum of numbers not divisible by m\n        num1 = total_sum - sum_multiples\n        \n        # Sum of numbers divisible by m\n        num2 = sum_multiples\n        \n        return num1 - num2"}
{"task_id": "3174", "solution": "class Solution:\n    def minChanges(self, s: str) -> int:\n        changes = 0\n        for i in range(0, len(s), 2):\n            if s[i] != s[i+1]:\n                changes += 1\n        return changes"}
{"task_id": "3176", "solution": "from typing import List\n\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        min_sum = float('inf')\n        n = len(nums)\n        \n        for j in range(1, n - 1):\n            # Find the smallest nums[i] where i < j and nums[i] < nums[j]\n            left_min = float('inf')\n            for i in range(j):\n                if nums[i] < nums[j]:\n                    left_min = min(left_min, nums[i])\n            \n            # Find the smallest nums[k] where k > j and nums[k] < nums[j]\n            right_min = float('inf')\n            for k in range(j + 1, n):\n                if nums[k] < nums[j]:\n                    right_min = min(right_min, nums[k])\n            \n            # If both sides have valid candidates, update min_sum\n            if left_min != float('inf') and right_min != float('inf'):\n                current_sum = left_min + nums[j] + right_min\n                min_sum = min(min_sum, current_sum)\n        \n        return -1 if min_sum == float('inf') else min_sum"}
{"task_id": "3183", "solution": "from typing import List\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # If k equals length of nums, return bitwise AND\n        if k == n:\n            result = nums[0]\n            for num in nums[1:]:\n                result &= num\n            return result\n        # If k == 1, return bitwise OR\n        if k == 1:\n            result = 0\n            for num in nums:\n                result |= num\n            return result\n        \n        result = 0\n        # Check each bit position from 0 to 30\n        for i in range(31):\n            count = 0\n            for num in nums:\n                # Check if the i-th bit is set\n                if (num >> i) & 1:\n                    count += 1\n            # If at least k numbers have this bit set, set the bit in result\n            if count >= k:\n                result |= (1 << i)\n        return result"}
{"task_id": "3184", "solution": "```python\nfrom typing import List\nimport bisect\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.data = [0] * (size + 1)\n\n    def update(self, index, value):\n        while index <= self.size:\n            if value > self.data[index]:\n                self.data[index] = value\n            index += index & -index\n\n    def query(self, index):\n        max_val = 0\n        while index > 0:\n            if self.data[index] > max_val:\n                max_val = self.data[index]\n            index -= index & -index\n        return max_val\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        adjusted = [nums[i] - i for i in range(n)]\n        \n        # Coordinate compression\n        sorted_unique = sorted(set(adjusted))\n        # Map each adjusted value to its compressed index\n        def get_idx(val):\n            return bisect.bisect_left(sorted_unique, val) + 1  # 1-based index for Fenwick Tree\n\n        fenwick = FenwickTree(len(sorted_unique))\n        max_sum = float('-inf')\n\n        for i in range(n):\n            idx = get_idx(adjusted[i])\n            # Query maximum sum for all adjusted[j] <= adjusted[i]\n            current_max = fenwick.query(idx)\n            # Include current element\n            current_sum = current_max + nums[i]\n            # Update Fenwick Tree\n            fenwick.update"}
{"task_id": "3188", "solution": "from typing import List\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        for i in range(n):\n            # Assume team i is the champion until proven otherwise\n            is_champion = True\n            for j in range(n):\n                if j != i and grid[j][i] == 1:\n                    # Found a team j that is stronger than team i\n                    is_champion = False\n                    break\n            if is_champion:\n                return i"}
{"task_id": "3190", "solution": "from typing import List\n\nclass Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        max1 = max(nums1)\n        max2 = max(nums2)\n        n = len(nums1)\n\n        # If already conditions are satisfied\n        if nums1[-1] == max1 and nums2[-1] == max2:\n            return 0\n\n        def count_swaps(target_max, arr1, arr2, last_arr):\n            swaps = 0\n            for i in range(n):\n                # If last element already the max, no need to swap at this index\n                if last_arr == arr1[-1] and last_arr == target_max:\n                    break\n                # Check if swapping helps\n                if arr1[i] < target_max and arr2[i] == target_max:\n                    swaps += 1\n            return swaps\n\n        # Count swaps needed to make nums1[-1] = max1\n        swaps_for_nums1 = 0\n        can_make_nums1_max = True\n        for i in range(n):\n            if nums1[-1] != max1:\n                if nums2[i] == max1 and nums1[i] < max1:\n                    swaps_for_nums1 += 1\n                elif nums1[i] != max1 and nums2[i] != max1:\n                    # Cannot help in making nums1[-1] == max1\n                    pass\n        # Count swaps needed to make nums2[-1] = max2\n        swaps_for_nums2 = 0\n        can_make_nums2_max = True\n        for i in range(n):\n            if nums2[-1] != max2:\n                if nums1[i] == max2 and nums2[i] < max2:\n                    swaps_for_nums2 += 1\n                elif nums2[i] != max2 and nums1[i] != max2:\n                    pass\n        # Check feasibility\n        if nums1[-1] != max1 and swaps_for_nums1 == 0:\n            can_make_nums1_max = False\n        if nums2[-1] != max2 and swaps_for_nums2 == 0:\n            can_make_nums2_max = False\n\n        # If both are already maximums\n        if nums1[-1] == max1 and nums2[-1] == max2:\n            return 0\n        # If impossible to make either last element the max\n        if not can_make_nums1_max or not can_make_nums2_max:\n            return -1\n\n        # The minimal swaps needed is the maximum of the two counts\n        # because we need to satisfy both simultaneously\n        result = max(swaps_for_nums1, swaps_for_nums2)\n        return result"}
{"task_id": "3192", "solution": "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        MOD = 10**9 + 7\n        max_val = 0\n\n        # Candidate x values to consider\n        candidates = set()\n\n        # Add boundary cases\n        candidates.add(0)\n        candidates.add((1 << n) - 1)\n\n        # Function to generate candidates by flipping bits near the highest differing bit\n        def add_candidates_for_bit(i):\n            mask = 1 << i\n            # Flip the i-th bit\n            candidates.add(mask)\n            candidates.add(((1 << n) - 1) ^ mask)\n\n        # Find the highest bit where a and b differ\n        max_bit = n - 1\n        for i in reversed(range(n)):\n            if ((a ^ b) >> i) & 1:\n                max_bit = i\n                break\n\n        # Generate candidates based on the highest differing bit\n        add_candidates_for_bit(max_bit)\n\n        # Also consider flipping bits just below the highest differing bit\n        for i in range(max_bit, -1, -1):\n            add_candidates_for_bit(i)\n\n        # Evaluate all candidate x values\n        for x in candidates:\n            # Ensure x is within range\n            if 0 <= x < (1 << n):\n                val = ( (a ^ x) * (b ^ x) ) % MOD\n                if val > max_val:\n                    max_val = val\n\n        return max_val"}
{"task_id": "3193", "solution": "from typing import List\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        max_xor = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(n):\n                x, y = nums[i], nums[j]\n                # Check the strong pair condition\n                if abs(x - y) <= min(x, y):\n                    current_xor = x ^ y\n                    if current_xor > max_xor:\n                        max_xor = current_xor\n        return max_xor"}
{"task_id": "3194", "solution": "from typing import List\n\nclass Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        result = []\n        for index, word in enumerate(words):\n            if x in word:\n                result.append(index)\n        return result"}
{"task_id": "3195", "solution": "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        zero_positions = [i for i, ch in enumerate(s) if ch == '0']\n        total_moves = 0\n        for i, pos in enumerate(zero_positions):\n            target_pos = i  # zeros should be at positions 0, 1, 2, ...\n            total_moves += abs(pos - target_pos)\n        return total_moves"}
{"task_id": "3196", "solution": "from typing import List\n\nclass Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        prefix_sums = [0]\n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n        \n        max_freq = 1\n        left = 0\n        for right in range(len(nums)):\n            # Calculate total operations needed to make all elements in [left, right] equal to nums[right]\n            total = nums[right] * (right - left + 1) - (prefix_sums[right + 1] - prefix_sums[left])\n            # Shrink window if total operations exceed k\n            while total > k:\n                left += 1\n                total = nums[right] * (right - left + 1) - (prefix_sums[right + 1] - prefix_sums[left])\n            max_freq = max(max_freq, right - left + 1)\n        return max_freq"}
{"task_id": "3199", "solution": "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        count = 0\n        for x in range(limit + 1):\n            for y in range(limit + 1):\n                z = n - x - y\n                if 0 <= z <= limit:\n                    count += 1\n        return count"}
{"task_id": "3200", "solution": "```python\nclass Solution:\n    def stringCount(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Precompute factorials and inverses for binomial coefficients\n        max_n = n\n        fact = [1] * (max_n + 1)\n        inv_fact = [1] * (max_n + 1)\n        \n        for i in range(2, max_n + 1):\n            fact[i] = fact[i - 1] * i % MOD\n        \n        # Fermat's little theorem for inverse: inv = pow(fact[max_n], MOD - 2, MOD)\n        inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n        for i in range(max_n - 1, 0, -1):\n            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n        \n        def nCr(n, r):\n            if r > n or r < 0:\n                return 0\n            return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n        \n        # Precompute powers of 26\n        pow26 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow26[i] = (pow26[i - 1] * 26) % MOD\n        \n        total = 0\n        for l_count in range(1, n + 1):  # at least 1 'l'\n            for e_count in range(2, n - l_count + 1):  # at least 2 'e's\n                for t_count in range(1, n - l_count - e_count + 1):  # at least 1 't'\n                    rest = n - (l_count + e_count + t_count)\n                    if rest < 0"}
{"task_id": "3203", "solution": "```python\nfrom typing import List\n\nclass Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        # Precompute prefix counts for each character\n        prefix_counts = [[0] * 26 for _ in range(n + 1)]\n        for i, ch in enumerate(s):\n            for c in range(26):\n                prefix_counts[i + 1][c] = prefix_counts[i][c]\n            prefix_counts[i + 1][ord(ch) - ord('a')] += 1\n\n        def get_char_count(l, r):\n            # Returns count of characters in s[l:r+1]\n            counts = [0] * 26\n            for c in range(26):\n                counts[c] = prefix_counts[r + 1][c] - prefix_counts[l][c]\n            return counts\n\n        results = []\n\n        for a, b, c, d in queries:\n            # Counts in the left part (a, b)\n            left_counts = get_char_count(a, b)\n            # Counts in the right part (c, d)\n            right_counts = get_char_count(c, d)\n\n            # Counts outside the manipulated substrings\n            # The fixed parts are:\n            # s[0:a], s[b+1:c], s[d+1:n]\n            outside_counts = [0] * 26\n\n            # Counts in s[0:a]\n            for c_idx in range(26):\n                outside_counts[c_idx] += prefix_counts[a][c_idx]\n            # Counts in s[b+1:c]\n            for c_idx in range(26):\n                outside_counts[c_idx] += prefix_counts[c][c_idx] - prefix_counts[b + 1][c_idx]\n            # Counts in s[d+1:n]\n            for c"}
{"task_id": "3206", "solution": "from typing import List\n\nclass Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        set_nums1 = set(nums1)\n        set_nums2 = set(nums2)\n        \n        count_in_nums1 = sum(1 for num in nums1 if num in set_nums2)\n        count_in_nums2 = sum(1 for num in nums2 if num in set_nums1)\n        \n        return [count_in_nums1, count_in_nums2]"}
{"task_id": "3207", "solution": "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        # Initialize pointers at the end of each string\n        i, j, k = len(s1) - 1, len(s2) - 1, len(s3) - 1\n        \n        # Find the longest common suffix\n        while i >= 0 and j >= 0 and k >= 0 and s1[i] == s2[j] == s3[k]:\n            i -= 1\n            j -= 1\n            k -= 1\n        \n        # Length of the common suffix\n        common_suffix_length = (len(s1) - 1 - i)\n        \n        # Calculate total operations needed\n        total_operations = (len(s1) - common_suffix_length) + \\\n                           (len(s2) - common_suffix_length) + \\\n                           (len(s3) - common_suffix_length)\n        \n        # Check if making all three strings equal is possible\n        # They can only be equal if the common suffix exists and is achievable\n        # Since we always remove characters from the right, if the strings have a common suffix,\n        # they can be reduced to it.\n        # But if no common suffix exists and the first characters differ, it's impossible.\n        if common_suffix_length == 0:\n            # Check if there's any possibility of making the strings equal\n            # If the first characters are not the same, impossible\n            if s1[0] != s2[0] or s2[0] != s3[0]:\n                return -1\n        return total_operations"}
{"task_id": "3209", "solution": "from typing import List\n\nclass Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        INF = float('inf')\n        dp = [INF] * n\n        \n        # Initialize: to buy the first fruit\n        dp[0] = prices[0]\n        \n        for i in range(n):\n            # If current position is not reachable, skip\n            if dp[i] == INF:\n                continue\n            \n            # Calculate the furthest index covered if we buy fruit at i\n            cover_end = i + i\n            if cover_end >= n:\n                cover_end = n - 1\n            \n            # Update dp for the range covered by buying fruit at i\n            for j in range(i, cover_end + 1):\n                # The cost to reach j is at most the cost to buy at i\n                dp[j] = min(dp[j], dp[i])\n                \n            # Additionally, consider buying the fruit at position i if not yet bought\n            # and updating the position at i\n            if dp[i] > dp[i]:\n                dp[i] = min(dp[i], dp[i])  # Already set, so no change\n            \n            # To explicitly handle the case where we buy at current position\n            # and update the furthest position\n            # (Although above, the loop already covers it)\n            # So no extra action needed here.\n        \n        return dp[-1]"}
{"task_id": "3210", "solution": "class Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        vowels_set = {'a', 'e', 'i', 'o', 'u'}\n        n = len(s)\n        \n        # Precompute prefix sums for vowels and consonants\n        vowel_count = [0] * (n + 1)\n        consonant_count = [0] * (n + 1)\n        \n        for i in range(n):\n            vowel_count[i + 1] = vowel_count[i] + (1 if s[i] in vowels_set else 0)\n            consonant_count[i + 1] = consonant_count[i] + (0 if s[i] in vowels_set else 1)\n        \n        count_beautiful = 0\n        \n        # Iterate through all substrings\n        for i in range(n):\n            for j in range(i, n):\n                # Calculate vowels and consonants in the substring s[i:j+1]\n                vowels = vowel_count[j + 1] - vowel_count[i]\n                consonants = consonant_count[j + 1] - consonant_count[i]\n                \n                # Check if the substring is beautiful\n                if vowels == consonants and vowels > 0:\n                    if (vowels * consonants) % k == 0:\n                        count_beautiful += 1\n                        \n        return count_beautiful"}
{"task_id": "3211", "solution": "from typing import List\n\nclass Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_length = 1  # At least one element is always non-decreasing\n        current_sum = nums[0]\n        start = 0  # Start index of the current subarray being considered\n        \n        for i in range(1, n):\n            if nums[i] >= nums[i - 1]:\n                # Continue extending the current non-decreasing segment\n                current_sum += nums[i]\n            else:\n                # Decrease detected, replace previous subarray with its sum\n                # This simulates the operation of replacing subarray with sum\n                # effectively \"merging\" the decreasing segment\n                current_sum = current_sum - nums[start] + sum(nums[start:i+1])\n                start = i  # Reset start to current position\n                \n            # The maximum length is the current prefix length\n            max_length = max(max_length, i - start + 1)\n        \n        return max_length"}
{"task_id": "3212", "solution": "class Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        last_occurrence = {}\n        boundary = 0  # The earliest index where a duplicate can affect the partition\n\n        for i in range(n):\n            if nums[i] in last_occurrence and last_occurrence[nums[i]] >= boundary:\n                # Move boundary to one position after the last occurrence of nums[i]\n                boundary = last_occurrence[nums[i]] + 1\n            last_occurrence[nums[i]] = i\n            # The total ways up to i+1 is:\n            # double the ways up to i (adding new partition options) minus ways before boundary\n            dp[i + 1] = (2 * dp[i] - dp[boundary - 1]) % MOD\n\n        return dp[n]"}
{"task_id": "3213", "solution": "```python\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        total_subarrays = 0\n\n        # Map each element to its list of indices\n        indices_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            indices_map[num].append(i)\n\n        # Get the unique elements sorted in descending order\n        unique_nums = sorted(indices_map.keys(), reverse=True)\n\n        for max_val in unique_nums:\n            positions = indices_map[max_val]\n\n            # Initialize the previous boundary to -1\n            prev_boundary = -1\n\n            # For each position of max_val, define segment boundaries\n            for idx in positions:\n                # Find the right boundary where larger element exists\n                # Since we process from largest to smallest, larger elements are already handled\n                left_bound = prev_boundary + 1\n                right_bound = n\n\n                # For current position, segment is from left_bound to right_bound - 1\n                segment_start = left_bound\n                segment_end = right_bound - 1\n\n                # Count subarrays in this segment that contain at least k occurrences of max_val\n                count_in_segment = self.count_subarrays_with_at_least_k_occurrences(\n                    nums, max_val, segment_start, segment_end, idx, k\n                )\n\n                total_subarrays += count_in_segment\n\n                # Update previous boundary\n                prev_boundary = max(prev_boundary, idx)\n\n        return total_subarrays\n\n    def count_subarrays_with_at_least_k_occurrences(\n        self, nums: List[int], target: int, start: int, end: int, current_idx: int, k: int\n    ) -> int:\n        \"\"\"\n        Counts the number of subarrays within [start, end], ending at positions >= current_idx,\n        that contain at least k occurrences of target.\n        \"\"\"\n        count = 0\n        left_pointer = start\n        occurrence_positions = []\n\n        # Collect all positions of target within the segment\n        for i in range(start, end + 1):\n            if nums[i] == target:\n                occurrence_positions.append(i)\n\n        # Use a sliding window over occurrence_positions to find windows with at least k elements\n        for i in range(len(occurrence_positions)):\n            if i + k - 1 >= len(occurrence_positions):\n                break\n            left_idx = occurrence_positions[i]\n            right_idx = occurrence_positions[i + k - 1]\n\n            # The subarray must start at or after left_pointer and before or at left_idx\n            # The subarray must end at or after right_idx\n            # The earliest start is max of current start and left_idx - (k-1)\n            min_start = max(start, left_idx)\n            # The subarray can end anywhere from right_idx to end\n            max_end = end"}
{"task_id": "3219", "solution": "from typing import List\n\nclass Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        # Disjoint Set Union (Union-Find) implementation\n        parent = list(range(len(nums)))\n        \n        def find(x):\n            while parent[x] != x:\n                parent[x] = find(parent[x])\n                x = parent[x]\n            return x\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                parent[py] = px\n        \n        # Since pairing every indices could be expensive for large input,\n        # we optimize by sorting the array's indices based on their values\n        # and then connecting indices that are within 'limit' difference.\n        # This reduces the number of comparisons.\n        indexed_nums = list(enumerate(nums))\n        indexed_nums.sort(key=lambda x: x[1])\n        \n        # Connect indices with values close enough\n        for i in range(len(indexed_nums) - 1):\n            idx1, val1 = indexed_nums[i]\n            idx2, val2 = indexed_nums[i + 1]\n            if abs(val1 - val2) <= limit:\n                union(idx1, idx2)\n        \n        # Group indices by their root parent\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i in range(len(nums)):\n            root = find(i)\n            groups[root].append(i)\n        \n        # For each group, sort the values and assign them back\n        res = [0] * len(nums)\n        for group_indices in groups.values():\n            # Extract values for the group\n            group_values = [nums[i] for i in group_indices]\n            # Sort the values to place smallest at smallest index\n            group_values.sort()\n            # Place sorted values back into the result array\n            for i, idx in enumerate(sorted(group_indices)):\n                res[idx] = group_values[i]\n        \n        return res"}
{"task_id": "3220", "solution": "from typing import List\n\nclass Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        tested_devices = 0\n        n = len(batteryPercentages)\n        \n        for i in range(n):\n            if batteryPercentages[i] > 0:\n                tested_devices += 1\n                # Decrease battery percentage of subsequent devices\n                for j in range(i + 1, n):\n                    if batteryPercentages[j] > 0:\n                        batteryPercentages[j] = max(0, batteryPercentages[j] - 1)\n        return tested_devices"}
{"task_id": "3221", "solution": "from typing import List\n\nclass Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        peaks = []\n        for i in range(1, len(mountain) - 1):\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n                peaks.append(i)\n        return peaks"}
{"task_id": "3223", "solution": "class Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        from collections import Counter\n        \n        n = len(word)\n        result = 0\n        \n        # Iterate over all possible starting points\n        for start in range(n):\n            counts = [0] * 26  # frequency of each character\n            distinct_chars = 0\n            min_char = 26  # Initialize beyond possible char indices\n            max_char = -1\n            valid_substring_start = start\n            \n            for end in range(start, n):\n                ch_idx = ord(word[end]) - ord('a')\n                counts[ch_idx] += 1\n                \n                # If it's the first occurrence of this character\n                if counts[ch_idx] == 1:\n                    distinct_chars += 1\n                # Update min and max characters in the current window\n                if ch_idx < min_char:\n                    min_char = ch_idx\n                if ch_idx > max_char:\n                    max_char = ch_idx\n                \n                # Check if all counts are either 0 or k\n                # To do this efficiently, verify:\n                # - the number of characters with count != 0\n                # - all non-zero counts are exactly k\n                non_zero_counts = [cnt for cnt in counts if cnt > 0]\n                \n                # If the number of distinct characters is more than 3,\n                # no need to continue expanding because difference > 2\n                if max_char - min_char > 2:\n                    break  # no need to expand further\n                \n                # Check if all non-zero counts are exactly k\n                if len(non_zero_counts) == distinct_chars and all(c == k for c in non_zero_counts):\n                    result += 1\n                \n                # When counts are not matching, or difference > 2,\n                # we continue expanding or break accordingly.\n                # But in this implementation, we only count when conditions are met.\n        \n        return result"}
{"task_id": "3224", "solution": "from typing import List\n\nclass Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Precompute powers of 2 up to n\n        max_len = n\n        pow2 = [1] * (max_len + 1)\n        for i in range(1, max_len + 1):\n            pow2[i] = (pow2[i-1] * 2) % MOD\n        \n        result = 1\n        # Handle the segment at the start (before the first sick child)\n        start_gap = sick[0]\n        if start_gap > 0:\n            result = (result * pow2[start_gap]) % MOD\n        \n        # Handle segments between sick children\n        for i in range(len(sick) - 1):\n            gap = sick[i+1] - sick[i] - 1\n            if gap > 0:\n                result = (result * pow2[gap]) % MOD\n        \n        # Handle the segment at the end (after the last sick child)\n        end_gap = n - 1 - sick[-1]\n        if end_gap > 0:\n            result = (result * pow2[end_gap]) % MOD\n        \n        return result"}
{"task_id": "3225", "solution": "from typing import List\n\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        left = 0\n        max_length = 0\n        freq = {}\n        \n        for right in range(len(nums)):\n            # Add the current element to the frequency map\n            freq[nums[right]] = freq.get(nums[right], 0) + 1\n            \n            # If any element's frequency exceeds k, shrink the window from the left\n            while any(count > k for count in freq.values()):\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n            \n            # Update maximum length\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"}
{"task_id": "3226", "solution": "from typing import List\n\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        arr = []\n        for i in range(0, len(nums), 2):\n            # Alice removes nums[i], Bob removes nums[i+1]\n            bob_element = nums[i+1]\n            alice_element = nums[i]\n            arr.append(bob_element)\n            arr.append(alice_element)\n        return arr"}
{"task_id": "3227", "solution": "from typing import List\n\nclass Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        max_num = n * n\n        freq = [0] * (max_num + 1)\n        \n        # Flatten the grid and count frequency\n        for row in grid:\n            for num in row:\n                freq[num] += 1\n        \n        a = b = -1\n        for num in range(1, max_num + 1):\n            if freq[num] == 2:\n                a = num  # Repeated number\n            elif freq[num] == 0:\n                b = num  # Missing number\n        \n        return [a, b]"}
{"task_id": "3228", "solution": "from typing import List\n\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)  # both arrays are of the same length\n        union_elements = set(nums1) | set(nums2)\n        # The maximum size is limited by the total unique elements and the total remaining elements\n        return min(len(union_elements), n)"}
{"task_id": "3229", "solution": "from typing import List\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # Generate all palindromes less than 10^9\n        palindromes = []\n\n        # Generate palindromes by creating halves\n        # Max length of palindrome is 9 digits\n        # Half length ranges from 1 to 5 (since 10^9 has 9 digits)\n        for half_len in range(1, 6):\n            start = 10 ** (half_len - 1)\n            end = 10 ** half_len\n            for half in range(start, end):\n                s = str(half)\n                # Even length palindrome\n                pal_even = int(s + s[::-1])\n                if pal_even < 10**9:\n                    palindromes.append(pal_even)\n                # Odd length palindrome\n                for middle_digit in range(10):\n                    pal_odd = int(s + str(middle_digit) + s[::-1])\n                    if pal_odd < 10**9:\n                        palindromes.append(pal_odd)\n\n        min_cost = float('inf')\n\n        # For each palindrome, compute total cost\n        for p in palindromes:\n            total_cost = 0\n            for num in nums:\n                total_cost += abs(num - p)\n            min_cost = min(min_cost, total_cost)\n\n        return min_cost"}
{"task_id": "3230", "solution": "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        def are_almost_equal(c1, c2):\n            return c1 == c2 or abs(ord(c1) - ord(c2)) == 1\n\n        stack = []\n        operations = 0\n\n        for ch in word:\n            if stack and are_almost_equal(stack[-1], ch):\n                # We found an almost-equal pair, perform an operation\n                operations += 1\n                # Remove the previous character to break the pair\n                stack.pop()\n            else:\n                # No pair, push current character\n                stack.append(ch)\n\n        return operations"}
{"task_id": "3231", "solution": "from typing import List\n\nclass Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        coins.sort()\n        reach = 0\n        count = 0\n        i = 0\n        while reach < target:\n            if i < len(coins) and coins[i] <= reach + 1:\n                reach += coins[i]\n                i += 1\n            else:\n                # Add a coin of value reach + 1\n                reach += reach + 1\n                count += 1\n        return count"}
{"task_id": "3233", "solution": "class Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        from collections import defaultdict\n\n        def compute_partitions(s, k):\n            count = 0\n            start = 0\n            freq = defaultdict(int)\n            distinct = 0\n            n = len(s)\n            for end in range(n):\n                c = s[end]\n                if freq[c] == 0:\n                    distinct += 1\n                freq[c] += 1\n                while distinct > k:\n                    left_char = s[start]\n                    freq[left_char] -= 1\n                    if freq[left_char] == 0:\n                        distinct -= 1\n                    start += 1\n                # When current prefix is maximally extended with at most k distinct,\n                # we consider ending the partition here\n                if end == n - 1 or (end + 1 < n and \n                                   (freq[s[end + 1]] == 0 and distinct >= k)):\n                    count += 1\n                    # Reset for next partition\n                    # But in this approach, we just continue since we are counting partitions as we go\n            return count\n\n        max_partitions = 0\n        original_partitions = compute_partitions(s, k)\n        max_partitions = max(max_partitions, original_partitions)\n\n        s_list = list(s)\n        n = len(s)\n        for i in range(n):\n            original_char = s_list[i]\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == original_char:\n                    continue\n                s_list[i] = c\n                new_s = ''.join(s_list)\n                partitions = compute_partitions(new_s, k)\n                if partitions > max_partitions:\n                    max_partitions = partitions\n            s_list[i] = original_char  # revert change\n\n        return max_partitions"}
{"task_id": "3234", "solution": "from typing import List\n\nclass Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        good_indices = []\n        for i, (a, b, c, m) in enumerate(variables):\n            # Compute (a^b) mod 10\n            base_mod = pow(a, b, 10)\n            # Compute (base_mod)^c\n            power_result = pow(base_mod, c)\n            # Final modulo m\n            final_result = power_result % m\n            # Check if equals target\n            if final_result == target:\n                good_indices.append(i)\n        return good_indices"}
{"task_id": "3235", "solution": "from typing import List\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        # Initialize distance matrix for all characters\n        dist = [[float('inf')] * 26 for _ in range(26)]\n        for i in range(26):\n            dist[i][i] = 0  # cost to convert same character to itself is zero\n        \n        # Map characters to indices\n        def char_to_index(c):\n            return ord(c) - ord('a')\n        \n        # Update direct conversions with minimal cost\n        for o, ch, c in zip(original, changed, cost):\n            o_idx = char_to_index(o)\n            ch_idx = char_to_index(ch)\n            if c < dist[o_idx][ch_idx]:\n                dist[o_idx][ch_idx] = c\n        \n        # Floyd-Warshall algorithm to compute all-pairs shortest paths\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    if dist[i][k] + dist[k][j] < dist[i][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n        \n        total_cost = 0\n        for s_char, t_char in zip(source, target):\n            s_idx = char_to_index(s_char)\n            t_idx = char_to_index(t_char)\n            if s_char == t_char:\n                continue  # no cost if characters are already equal\n            elif dist[s_idx][t_idx] == float('inf'):\n                # Impossible to convert s_char to t_char\n                return -1\n            else:\n                total_cost += dist[s_idx][t_idx]\n        \n        return total_cost"}
{"task_id": "3236", "solution": "from typing import List\n\nclass Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        # Convert list to set for O(1) lookups\n        nums_set = set(nums)\n        \n        # Find the longest sequential prefix\n        prefix_sum = 0\n        for i in range(len(nums)):\n            if i == 0:\n                # First element always forms a prefix\n                prefix_sum += nums[i]\n            else:\n                # Check if current element continues the sequence\n                if nums[i] == nums[i - 1] + 1:\n                    prefix_sum += nums[i]\n                else:\n                    break  # Sequence breaks here\n        \n        # Find the smallest integer >= prefix_sum not in nums\n        candidate = prefix_sum\n        while candidate in nums_set:\n            candidate += 1\n        \n        return candidate"}
{"task_id": "3239", "solution": "from collections import deque\n\nclass Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        # Edge case: if x already equals y\n        if x == y:\n            return 0\n        \n        # Define bounds for exploration\n        max_limit = max(x, y) + 20  # buffer to cover overshoot scenarios\n        \n        visited = set()\n        queue = deque()\n        queue.append((x, 0))\n        visited.add(x)\n        \n        while queue:\n            current, steps = queue.popleft()\n            \n            # If we've reached y\n            if current == y:\n                return steps\n            \n            # Generate possible next states\n            \n            # 1. Divide by 11 if divisible\n            if current % 11 == 0:\n                next_state = current // 11\n                if 0 <= next_state <= max_limit and next_state not in visited:\n                    visited.add(next_state)\n                    queue.append((next_state, steps + 1))\n            \n            # 2. Divide by 5 if divisible\n            if current % 5 == 0:\n                next_state = current // 5\n                if 0 <= next_state <= max_limit and next_state not in visited:\n                    visited.add(next_state)\n                    queue.append((next_state, steps + 1))\n            \n            # 3. Increment by 1\n            next_state = current + 1\n            if next_state <= max_limit and next_state not in visited:\n                visited.add(next_state)\n                queue.append((next_state, steps + 1))\n            \n            # 4. Decrement by 1\n            next_state = current - 1\n            if next_state >= 0 and next_state not in visited:\n                visited.add(next_state)\n                queue.append((next_state, steps + 1))"}
{"task_id": "3240", "solution": "class Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        # Function to compute sum of prices from 1 to n\n        def sum_prices(n):\n            total = 0\n            # For each bit position b from 1 to 50 (since 2^50 > 10^15)\n            for b in range(1, 51):\n                # Check if position b is divisible by x\n                if b % x == 0:\n                    # Count how many numbers in [1, n] have the b-th bit set\n                    block_size = 1 << b  # 2^b\n                    half_block = 1 << (b - 1)  # 2^{b-1}\n                    full_cycles = n // block_size\n                    remainder = n % block_size\n                    count = full_cycles * half_block + max(0, remainder - half_block + 1)\n                    total += count\n            return total\n\n        # Binary search boundaries\n        low, high = 0, 10**16\n        result = 0\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_price = sum_prices(mid)\n            if total_price <= k:\n                result = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return result"}
{"task_id": "3242", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        # Step 1: Count the frequency of each element\n        freq_counter = Counter(nums)\n        \n        # Step 2: Find the maximum frequency\n        max_freq = max(freq_counter.values())\n        \n        # Step 3: Sum all elements that have this maximum frequency\n        total = sum(count for count in freq_counter.values() if count == max_freq)\n        \n        # Step 4: Return the total\n        return total"}
{"task_id": "3243", "solution": "class Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        from itertools import product\n\n        s_len = len(s)\n        s_int = int(s)\n        count = 0\n\n        # The minimum number of digits in total is len(s) (when prefix is empty)\n        # The maximum number of total digits can be length of finish\n        max_total_length = len(str(finish))\n        min_total_length = s_len  # At least length of s\n\n        # Generate all candidate numbers\n        for total_length in range(min_total_length, max_total_length + 1):\n            prefix_length = total_length - s_len\n            # Generate all possible prefixes of length prefix_length\n            # Each digit in prefix must be <= limit\n            # To handle leading zeros in prefix, allow zero digits, but\n            # skip prefixes that would lead to invalid numbers with leading zeros if necessary.\n            if prefix_length == 0:\n                # No prefix, number is just s\n                candidate_str = s\n                candidate_num = int(candidate_str)\n                if start <= candidate_num <= finish:\n                    count += 1\n            else:\n                # Generate all possible prefixes\n                # Each digit in prefix: 0..limit\n                for prefix_digits in product(range(limit + 1), repeat=prefix_length):\n                    # If the prefix has leading zeros, it's allowed as per problem statement,\n                    # since leading zeros don't affect number value.\n                    prefix_str = ''.join(str(d) for d in prefix_digits)\n                    candidate_str = prefix_str + s\n                    # Convert to int\n                    candidate_num = int(candidate_str)\n                    # Check range\n                    if start <= candidate_num <= finish:\n                        count += 1\n        return count"}
{"task_id": "3244", "solution": "from typing import List\nimport math\n\nclass Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        current_gcd = nums[0]\n        for num in nums[1:]:\n            current_gcd = math.gcd(current_gcd, num)\n            if current_gcd == 1:\n                # No need to continue further if gcd is 1\n                break\n        return 1 if current_gcd > 1 else 2"}
{"task_id": "3245", "solution": "from typing import List\n\nclass Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        len_a = len(a)\n        len_b = len(b)\n        n = len(s)\n        \n        # Find all occurrences of a\n        a_positions = []\n        for i in range(n - len_a + 1):\n            if s[i:i+len_a] == a:\n                a_positions.append(i)\n        \n        # Find all occurrences of b\n        b_positions = []\n        for j in range(n - len_b + 1):\n            if s[j:j+len_b] == b:\n                b_positions.append(j)\n        \n        result = []\n        j_idx = 0  # Pointer for b_positions\n        \n        # For each occurrence of a, find if there's a b within k\n        for i in a_positions:\n            # Move j_idx to the first b position where b[j] >= i - k\n            while j_idx < len(b_positions) and b_positions[j_idx] < i - k:\n                j_idx += 1\n            # Check all b positions starting from j_idx that are within i + k\n            temp_j_idx = j_idx\n            while temp_j_idx < len(b_positions) and b_positions[temp_j_idx] <= i + k:\n                # If a b position within range is found, include i\n                if abs(b_positions[temp_j_idx] - i) <= k:\n                    result.append(i)\n                    break\n                temp_j_idx += 1\n        return result"}
{"task_id": "3246", "solution": "from typing import List\n\nclass Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        even_count = sum(1 for num in nums if num % 2 == 0)\n        # Check if at least two even numbers exist\n        if even_count >= 2:\n            return True\n        # Check if at least one even number exists and total length >= 2\n        elif even_count >= 1 and len(nums) >= 2:\n            return True\n        else:\n            return False"}
{"task_id": "3249", "solution": "from typing import List\nfrom functools import reduce\nfrom operator import xor\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        current_xor = reduce(xor, nums)\n        desired_mask = current_xor ^ k\n        if desired_mask == 0:\n            return 0\n        # Count the number of bits set in desired_mask\n        return bin(desired_mask).count('1')"}
{"task_id": "3251", "solution": "from typing import List\n\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        max_diagonal_squared = -1\n        max_area = 0\n        for length, width in dimensions:\n            diagonal_squared = length * length + width * width\n            area = length * width\n            if diagonal_squared > max_diagonal_squared:\n                max_diagonal_squared = diagonal_squared\n                max_area = area\n            elif diagonal_squared == max_diagonal_squared:\n                # If diagonals are equal, choose the rectangle with larger area\n                if area > max_area:\n                    max_area = area\n        return max_area"}
{"task_id": "3252", "solution": "from typing import List\n\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        def is_strictly_increasing(arr: List[int]) -> bool:\n            return all(arr[i] < arr[i+1] for i in range(len(arr)-1))\n        \n        for l in range(n):\n            for r in range(l, n):\n                # Prefix: nums[:l]\n                prefix = nums[:l]\n                # Suffix: nums[r+1:]\n                suffix = nums[r+1:]\n                \n                # Check if prefix is strictly increasing\n                if prefix and not is_strictly_increasing(prefix):\n                    continue\n                # Check if suffix is strictly increasing\n                if suffix and not is_strictly_increasing(suffix):\n                    continue\n                \n                # Check the boundary condition: last of prefix < first of suffix\n                if prefix and suffix:\n                    if nums[l-1] >= nums[r+1]:\n                        continue\n                # If all conditions pass, this subarray removal makes the array strictly increasing\n                count += 1\n\n        return count"}
{"task_id": "3261", "solution": "from typing import List\n\nclass Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if k == 0:\n            # No operations, just compute the OR directly\n            result = 0\n            for num in nums:\n                result |= num\n            return result\n\n        # Compute all adjacent pair ANDs along with their indices\n        pairs = []\n        for i in range(n - 1):\n            pairs.append((nums[i] & nums[i + 1], i))\n        \n        # Sort pairs by their AND value to prioritize merging pairs with smallest AND\n        pairs.sort(key=lambda x: x[0])\n        \n        # To keep track of which indices are merged\n        merged = [False] * n\n        merge_count = 0\n\n        for and_value, index in pairs:\n            if merge_count >= k:\n                break\n            # Only merge if both elements are unmerged\n            if not merged[index] and not merged[index + 1]:\n                # Mark as merged\n                merged[index] = True\n                merged[index + 1] = True\n                merge_count += 1\n\n        # After merging, build the final array\n        final_elements = []\n        i = 0\n        while i < n:\n            if not merged[i]:\n                final_elements.append(nums[i])\n                i += 1\n            else:\n                # Merge current and next\n                if i + 1 < n and merged[i + 1]:\n                    # Both are merged, skip both\n                    i += 1\n                elif i + 1 < n:\n                    # Merge these two\n                    merged_value = nums[i] & nums[i + 1]\n                    final_elements.append(merged_value)\n                    i += 2\n                else:\n                    # Last element, add as is\n                    final_elements.append(nums[i])\n                    i += 1\n\n        # Compute the OR of the final array\n        result = 0\n        for num in final_elements:\n            result |= num\n\n        return result"}
{"task_id": "3262", "solution": "from typing import List\n\nclass Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        # Sort in descending order\n        nums.sort(reverse=True)\n        # Iterate through the sorted list\n        for i in range(len(nums) - 2):\n            # Check if the three sides can form a polygon\n            if nums[i+2] + nums[i+1] > nums[i]:\n                # Return the sum of these sides as the maximum perimeter\n                return nums[i] + nums[i+1] + nums[i+2]\n        # If no valid triplet found, return -1\n        return -1"}
{"task_id": "3263", "solution": "from typing import List\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_cost = float('inf')\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                cost = nums[0] + nums[i + 1] + nums[j + 1]\n                if cost < min_cost:\n                    min_cost = cost\n        return min_cost"}
{"task_id": "3265", "solution": "from typing import List\n\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        max_sum_at_value = {}\n        max_total_sum = float('-inf')\n        \n        for num in nums:\n            candidate_sums = []\n            # Check if a previous value with difference +k exists\n            if num + k in max_sum_at_value:\n                candidate_sums.append(max_sum_at_value[num + k] + num)\n            # Check if a previous value with difference -k exists\n            if num - k in max_sum_at_value:\n                candidate_sums.append(max_sum_at_value[num - k] + num)\n            # Start a new subarray with current element if no extension\n            candidate_sums.append(num)\n            \n            # Update the maximum sum for current value\n            current_max = max(candidate_sums)\n            max_sum_at_value[num] = max(max_sum_at_value.get(num, float('-inf')), current_max)\n            \n            # Update global maximum sum if current is better\n            max_total_sum = max(max_total_sum, current_max)\n        \n        # If no good subarray found (max_total_sum is negative and no updates), return 0\n        return max_total_sum if max_total_sum != float('-inf') else 0"}
{"task_id": "3267", "solution": "class Solution:\n    def maximumLength(self, s: str) -> int:\n        max_length = -1\n        n = len(s)\n        \n        # Iterate through each lowercase letter\n        for ch in 'abcdefghijklmnopqrstuvwxyz':\n            i = 0\n            while i < n:\n                # Find the start of a run of character ch\n                if s[i] == ch:\n                    start = i\n                    # Move forward to find the end of this run\n                    while i < n and s[i] == ch:\n                        i += 1\n                    end = i\n                    run_length = end - start\n                    # For each possible substring length within this run\n                    for length in range(1, run_length + 1):\n                        for start_idx in range(start, end - length + 1):\n                            substr = s[start_idx:start_idx + length]\n                            # Count occurrences of this substring in s\n                            count = 0\n                            for j in range(n - length + 1):\n                                if s[j:j + length] == substr:\n                                    count += 1\n                            if count >= 3:\n                                if length > max_length:\n                                    max_length = length\n                else:\n                    i += 1\n        return max_length"}
{"task_id": "3269", "solution": "from typing import List\n\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        n = len(nums)\n        m = len(pattern)\n        count = 0\n        \n        # Loop through each possible starting index\n        for i in range(n - m):\n            match = True\n            # Check each pattern condition\n            for k in range(m):\n                if pattern[k] == 1 and not (nums[i + k + 1] > nums[i + k]):\n                    match = False\n                    break\n                elif pattern[k] == 0 and not (nums[i + k + 1] == nums[i + k]):\n                    match = False\n                    break\n                elif pattern[k] == -1 and not (nums[i + k + 1] < nums[i + k]):\n                    match = False\n                    break\n            if match:\n                count += 1\n                \n        return count"}
{"task_id": "3279", "solution": "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        odd_x = (n + 1) // 2\n        even_x = n - odd_x\n        odd_y = (m + 1) // 2\n        even_y = m - odd_y\n        \n        # Sum pairs where total flowers are odd\n        result = odd_x * even_y + even_x * odd_y\n        return result"}
{"task_id": "3291", "solution": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        # Helper function to count set bits\n        def count_set_bits(n):\n            return bin(n).count('1')\n\n        # Pair each number with its set bit count\n        pairs = [(num, count_set_bits(num)) for num in nums]\n\n        # Generate the sorted array\n        sorted_nums = sorted(nums)\n\n        # Group elements by their set bit counts in original and sorted arrays\n        original_groups = defaultdict(list)\n        sorted_groups = defaultdict(list)\n\n        for num, bit_count in pairs:\n            original_groups[bit_count].append(num)\n\n        for num in sorted_nums:\n            bit_count = count_set_bits(num)\n            sorted_groups[bit_count].append(num)\n\n        # Check whether each group's multisets match\n        for bit_count in original_groups:\n            if sorted(original_groups[bit_count]) != sorted(sorted_groups[bit_count]):\n                return False\n\n        return True"}
{"task_id": "3292", "solution": "from typing import List\n\nclass Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n = len(nums)\n        m = len(changeIndices)\n        \n        # Map each index to how many times it appears in changeIndices\n        count = [0] * (n + 1)\n        for idx in changeIndices:\n            count[idx] += 1\n        \n        # Binary search over the seconds\n        left, right = 1, m\n        answer = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            # For each index, check if it can be marked\n            possible = True\n            for i in range(1, n + 1):\n                # Number of times index i appears in first mid operations\n                if count[i] < nums[i - 1]:\n                    # Not enough operations to reduce nums[i] to zero\n                    possible = False\n                    break\n            if possible:\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        # Additional check: ensure that at `answer`, all indices can indeed be marked\n        if answer == -1:\n            return -1\n        for i in range(1, n + 1):\n            if count[i] < nums[i - 1]:\n                return -1\n        return answer"}
{"task_id": "3297", "solution": "from math import gcd\n\nclass Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        n = len(word)\n        g = gcd(n, k)\n        return n // g"}
{"task_id": "3298", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        left = 0\n        max_length = 1\n        # We will keep counters for the possible values in the current window\n        count = Counter()\n        min_possible = float('inf')\n        max_possible = float('-inf')\n\n        for right in range(len(nums)):\n            # For each element, possible values are nums[right] and nums[right] + 1\n            # Add both possibilities to the window\n            for val in [nums[right], nums[right] + 1]:\n                count[val] += 1\n\n            # Update min and max possible values\n            min_possible = min(count.keys())\n            max_possible = max(count.keys())\n            \n            # Shrink window if it becomes invalid\n            while max_possible - min_possible > 1:\n                # Remove the possibilities contributed by nums[left]\n                for val in [nums[left], nums[left] + 1]:\n                    count[val] -= 1\n                    if count[val] == 0:\n                        del count[val]\n                left += 1\n                if count:\n                    min_possible = min(count.keys())\n                    max_possible = max(count.keys())\n                else:\n                    # No elements in window\n                    min_possible = float('inf')\n                    max_possible = float('-inf')\n            \n            # Update maximum length\n            current_window_size = right - left + 1\n            max_length = max(max_length, current_window_size)\n\n        return max_length"}
{"task_id": "3299", "solution": "from collections import Counter\n\nclass Solution:\n    def maximumLength(self, nums: list[int]) -> int:\n        freq = Counter(nums)\n        max_num = max(nums)\n        max_length = 0\n        unique_nums = list(freq.keys())\n\n        for x in unique_nums:\n            total = 0\n            current = x\n            # Generate powers of x: x, x^2, x^4, ...\n            while current <= max_num:\n                if current in freq:\n                    total += freq[current]\n                # To move to next power, square current\n                # Careful to prevent overflow\n                if current > max_num // current:\n                    break\n                current = current * current\n            max_length = max(max_length, total)\n\n        return max_length"}
{"task_id": "3308", "solution": "class Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        # Count total occurrences of each character\n        counts = [0] * 26\n        for ch in s:\n            counts[ord(ch) - ord('a')] += 1\n        \n        # Track the earliest position where all remaining characters still exist\n        position = 0\n        for i, ch in enumerate(s):\n            idx = ord(ch) - ord('a')\n            counts[idx] -= 1\n            # If this character's count drops to zero, check if all counts are zero\n            if counts[idx] == 0:\n                # Check if all counts are zero\n                if all(c == 0 for c in counts):\n                    # All characters are exhausted, so the last string is upto this point\n                    position = i + 1\n                    break\n        else:\n            # If we didn't break, the entire string is the last remaining string\n            position = len(s)\n        \n        return s[:position]"}
{"task_id": "3309", "solution": "from typing import List\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        def isPrefixAndSuffix(str1: str, str2: str) -> bool:\n            return str2.startswith(str1) and str2.endswith(str1)\n\n        count = 0\n        n = len(words)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isPrefixAndSuffix(words[i], words[j]):\n                    count += 1\n        return count"}
{"task_id": "3311", "solution": "from typing import List\n\nclass Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        position = 0\n        count = 0\n        for num in nums:\n            start_pos = position\n            # Move the ant\n            position += num\n            # Check if the ant is back on boundary\n            if position == 0:\n                count += 1\n        return count"}
{"task_id": "3312", "solution": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        key_changes = 0\n        last_char = s[0]\n        \n        for i in range(1, len(s)):\n            if s[i].lower() != last_char.lower():\n                key_changes += 1\n            last_char = s[i]\n        \n        return key_changes"}
{"task_id": "3317", "solution": "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        def is_palindrome(w):\n            return w == w[::-1]\n\n        # Count of words already palindromes\n        palindrome_count = 0\n        # Count of words that can potentially be transformed into palindromes\n        transformable_count = 0\n\n        for word in words:\n            if is_palindrome(word):\n                palindrome_count += 1\n            else:\n                # Count character frequency\n                freq = Counter(word)\n                odd_counts = sum(1 for count in freq.values() if count % 2 != 0)\n                # For a word to be transformable into a palindrome:\n                # - at most one character can have an odd count\n                if odd_counts <= 1:\n                    transformable_count += 1\n\n        # The maximum number of palindromes is initial palindromes plus those\n        # that can be transformed into palindromes\n        return palindrome_count + transformable_count"}
{"task_id": "3320", "solution": "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        max_num = max(nums)\n        max_pairs = 0\n\n        # Range of possible target sums\n        for target in range(2, 2 * max_num + 1):\n            freq = Counter(nums)\n            count = 0\n            # Iterate over unique elements in sorted order for consistency\n            for x in sorted(freq):\n                while freq[x] > 0:\n                    complement = target - x\n                    # Decrease the count of x as we attempt to pair it\n                    freq[x] -= 1\n                    if freq[complement] > 0:\n                        # Pair formed\n                        freq[complement] -= 1\n                        count += 1\n                    else:\n                        # No pair found, revert the decrement for x\n                        freq[x] += 1\n                        break  # move to next x\n            max_pairs = max(max_pairs, count)\n        return max_pairs"}
{"task_id": "3324", "solution": "from typing import List\n\nclass Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        from collections import Counter\n        \n        n = len(nums)\n        count = Counter(nums)\n        \n        # If any element appears more than twice, impossible to split into two distinct parts\n        for freq in count.values():\n            if freq > 2:\n                return False\n        \n        # Count how many elements appear twice and how many appear once\n        count_two = sum(1 for v in count.values() if v == 2)\n        count_one = sum(1 for v in count.values() if v == 1)\n        \n        # Each part needs to have exactly n/2 elements\n        half = n // 2\n        \n        # For elements with count 2, only one can go into each part\n        # So, the maximum number of elements with count 2 that can be assigned to one part is count_two\n        # Check if we can assign these elements so that each part gets half elements\n        # The elements with count 1 can be assigned freely to fill remaining slots\n        # The total assigned to one part is count_two (one per each element with count 2) + some from count_one\n        # We need to verify if the sum of assigned elements can exactly fill half\n        \n        # Max elements with count 2 assigned to one part is count_two\n        # Remaining slots are filled with count_one elements\n        # To fill exactly half, the number of elements with count 2 assigned to the part should be at most half\n        if count_two <= half:\n            # Remaining slots after assigning count_two elements\n            remaining = half - count_two\n            # Check if count_one can fill the remaining slots\n            if count_one >= remaining:\n                return True\n        return False"}
{"task_id": "3329", "solution": "from typing import List\n\nclass Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        # Find the minimal numbers in both arrays\n        min1 = min(arr1)\n        min2 = min(arr2)\n        \n        # Convert to string for prefix analysis\n        s1 = str(min1)\n        s2 = str(min2)\n        \n        # The maximum prefix length can't be more than the shortest of the two minimal strings\n        max_possible_length = min(len(s1), len(s2))\n        \n        # Binary search boundaries\n        left, right = 0, max_possible_length\n        result = 0\n        \n        while left <= right:\n            mid = (left + right) // 2\n            prefix1 = s1[:mid]\n            prefix2 = s2[:mid]\n            \n            # Check if all elements in arr1 and arr2 start with the prefix\n            if all(str(x).startswith(prefix1) for x in arr1) and \\\n               all(str(y).startswith(prefix2) for y in arr2):\n                # Valid prefix, try to extend\n                result = mid\n                left = mid + 1\n            else:\n                # Not valid, try shorter prefix\n                right = mid - 1\n        \n        return result"}
{"task_id": "3331", "solution": "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Sort the array\n        nums.sort()\n        # Find the first index where element >= k\n        for i, num in enumerate(nums):\n            if num >= k:\n                # All elements before index i are < k and need to be removed\n                return i\n        # If all elements are less than k, remove all except the ones >= k\n        return len(nums)"}
{"task_id": "3347", "solution": "from typing import List\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1 = []\n        arr2 = []\n\n        # First operation\n        arr1.append(nums[0])\n        # Second operation\n        arr2.append(nums[1])\n\n        # Process remaining elements\n        for i in range(2, len(nums)):\n            if arr1[-1] > arr2[-1]:\n                arr1.append(nums[i])\n            else:\n                arr2.append(nums[i])\n\n        # Concatenate the two arrays\n        return arr1 + arr2"}
{"task_id": "abc301_a", "solution": "# Read inputs\nN = int(input())\nS = input().strip()\n\n# Initialize counters\nt_count = 0\na_count = 0\n\n# Record the first time each player reaches a certain number of wins\nt_win_indices = {}\na_win_indices = {}\n\n# Variables to keep track of current max wins\nmax_t_wins = 0\nmax_a_wins = 0\n\n# Loop through each game\nfor i, result in enumerate(S, start=1):\n    if result == 'T':\n        t_count += 1\n        if t_count not in t_win_indices:\n            t_win_indices[t_count] = i\n    else:  # result == 'A'\n        a_count += 1\n        if a_count not in a_win_indices:\n            a_win_indices[a_count] = i\n\n# Determine the maximum number of wins at the end\nmax_t_wins = t_count\nmax_a_wins = a_count\n\n# Check who has more wins\nif max_t_wins > max_a_wins:\n    print('T')\nelif max_a_wins > max_t_wins:\n    print('A')\nelse:\n    # They are tied, check who reached that number first\n    # The tied number of wins is max_t_wins (or max_a_wins)\n    first_t_game = t_win_indices[max_t_wins]\n    first_a_game = a_win_indices[max_a_wins]\n    if first_t_game < first_a_game:\n        print('T')\n    else:\n        print('A')"}
{"task_id": "abc301_b", "solution": "# Read inputs\nN = int(input())\nA = list(map(int, input().split()))\n\nwhile True:\n    # Find the first pair with difference not equal to 1\n    index = -1\n    for i in range(len(A) - 1):\n        if abs(A[i] - A[i + 1]) != 1:\n            index = i\n            break\n    # If all pairs differ by 1, break out of the loop\n    if index == -1:\n        break\n    # Insert the numbers between A[index] and A[index + 1]\n    a, b = A[index], A[index + 1]\n    if a < b:\n        # Insert increasing sequence from a+1 to b-1\n        insertion = list(range(a + 1, b))\n    else:\n        # Insert decreasing sequence from a-1 to b+1\n        insertion = list(range(a - 1, b, -1))\n    # Insert the sequence into A\n    A = A[:index + 1] + insertion + A[index + 1:]\n\n# Output the final sequence\nprint(' '.join(map(str, A)))"}
{"task_id": "abc301_c", "solution": "# Read inputs\nS = input().strip()\nT = input().strip()\n\n# Allowed characters for replacement\nallowed_chars = {'a', 't', 'c', 'o', 'd', 'e', 'r'}\n\n# Since order doesn't matter after rearrangement, check each position\nfor s_char, t_char in zip(S, T):\n    if s_char == t_char:\n        continue  # already match\n    elif s_char == '@' and t_char in allowed_chars:\n        continue  # '@' can be replaced to t_char\n    elif t_char == '@' and s_char in allowed_chars:\n        continue  # '@' can be replaced to s_char\n    elif s_char == '@' and t_char == '@':\n        continue  # both '@', can choose same replacement\n    else:\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")"}
{"task_id": "abc301_d", "solution": "```python\ndef main():\n    S = input().strip()\n    N = int(input().strip())\n\n    length = len(S)\n    bits = list(S)\n\n    # Memoization cache: for position and whether prefix is already less than N\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dfs(pos, less_than_N, current_value):\n        # Base case: reached end of string\n        if pos == length:\n            # Check if current_value <= N\n            if current_value <= N:\n                return current_value\n            else:\n                return -1\n\n        ch = bits[pos]\n        max_value = -1\n\n        # Determine possible bits to assign\n        possible_bits = []\n\n        if ch == '0':\n            bit = 0\n            # Check if assigning 0 keeps within limit\n            if less_than_N or bit <= (N >> (length - pos - 1)) & 1:\n                val = (current_value << 1) | bit\n                next_less = less_than_N or val < (N >> (length - pos - 1))\n                res = dfs(pos + 1, next_less, val)\n                if res > max_value:\n                    max_value = res\n        elif ch == '1':\n            bit = 1\n            if less_than_N or bit <= (N >> (length - pos - 1)) & 1:\n                val = (current_value << 1) | bit\n                next_less = less_than_N or val < (N >> (length - pos - 1))\n                res = dfs(pos + 1, next_less, val)\n                if res > max_value:\n                    max_value = res\n        else:\n            # ch == '?'\n            # Try '1' first (maximize)\n            bit = 1\n            if less_than_N or bit <= (N >> (length - pos - 1)) & 1:\n                val = (current_value << 1) | bit\n                next_less = less_than_N or val < (N >> (length - pos - 1))\n                res = dfs(pos + 1, next_less, val)\n                if res > max_value:\n                    max_value = res\n            # Try '0'\n            bit = 0\n            if less_than_N or bit <= (N >> (length - pos - 1)) & 1:\n                val = (current_value << 1) | bit\n                next_less = less_than"}
{"task_id": "abc301_e", "solution": "```python\nfrom collections import deque\nimport sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().splitlines()\n    H, W, T = map(int, data[0].split())\n    grid = data[1:]\n\n    # Find start, goal, candies\n    start = None\n    goal = None\n    candies = []\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] == 'o':\n                candies.append((i, j))\n    \n    # Relevant points: start, goal, candies\n    points = [start, goal] + candies\n    n_points = len(points)\n    start_idx = 0\n    goal_idx = 1\n    candy_start_idx = 2\n\n    # Directions for BFS\n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    # Function to compute shortest distance from a point to all others\n    def bfs(start_point):\n        dist_map = [[-1]*W for _ in range(H)]\n        q = deque()\n        (sx, sy) = start_point\n        dist_map[sx][sy] = 0\n        q.append((sx, sy))\n        while q:\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x+dx, y+dy\n                if 0 <= nx < H and 0 <= ny < W:\n                    if grid[nx][ny] != '#' and dist_map[nx][ny] == -1:\n                        dist_map[nx][ny] = dist_map[x][y] + 1\n                        q.append((nx, ny))\n        return dist_map\n\n    # Compute shortest distances between all relevant points\n    dist = [[-1]*n_points for _ in range(n_points)]\n    dist_maps = []\n    for i, p in enumerate(points):\n        dist_map = bfs(p)\n        dist_maps.append(dist_map)\n\n    for i, p1 in enumerate(points):\n        for j, p2 in enumerate(points):\n            if dist_map := dist_maps[i]:\n                (x2, y2) = p2\n                dist[i][j] = dist_map[x2][y2]\n\n    # Check reachability of the goal from start\n    if dist[start_idx][goal_idx] == -1 or dist[start_idx][goal_idx] > T:\n        print(-1)\n        return\n\n    # Number of candies\n    M = len(candies)\n    # Precompute distances between all points (start, candies, goal)\n    for i in range(n_points):\n        for j in range(n_points):\n            if i != j and dist[i][j] == -1:\n                #"}
{"task_id": "abc301_f", "solution": "```python\nMOD = 998244353\n\ndef main():\n    import sys\n    S = sys.stdin.readline().strip()\n    n = len(S)\n\n    # Pattern:\n    # P1: uppercase\n    # P2: same uppercase as P1\n    # P3: lowercase\n    # P4: uppercase\n\n    # To"}
{"task_id": "abc302_a", "solution": "# Read the inputs\nA, B = map(int, input().split())\n\n# Calculate the minimum number of attacks\nresult = (A + B - 1) // B\n\n# Output the result\nprint(result)"}
{"task_id": "abc302_b", "solution": "# Read input\nH, W = map(int, input().split())\ngrid = [input().strip() for _ in range(H)]\n\n# The target sequence\nsequence = ['s', 'n', 'u', 'k', 'e']\n\n# Directions (8-connected)\ndirections = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),           (0, 1),\n    (1, -1),  (1, 0),  (1, 1)\n]\n\n# Search for the sequence\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j] == 's':\n            # For each direction, check if sequence matches\n            for dr, dc in directions:\n                positions = [(i, j)]\n                valid = True\n                for k in range(1, 5):\n                    r_new = i + dr * k\n                    c_new = j + dc * k\n                    if 0 <= r_new < H and 0 <= c_new < W:\n                        if grid[r_new][c_new] == sequence[k]:\n                            positions.append((r_new, c_new))\n                        else:\n                            valid = False\n                            break\n                    else:\n                        valid = False\n                        break\n                if valid:\n                    # Output the sequence positions (convert to 1-based indexing)\n                    for r, c in positions:\n                        print(r + 1, c + 1)\n                    # Since the problem guarantees a unique solution, stop after finding it\n                    exit()"}
{"task_id": "abc302_c", "solution": "from itertools import permutations\n\ndef differ_by_one(str1, str2):\n    # Count the positions where characters differ\n    count_diff = sum(1 for c1, c2 in zip(str1, str2) if c1 != c2)\n    return count_diff == 1\n\ndef main():\n    # Read input\n    N, M = map(int, input().split())\n    strings = [input().strip() for _ in range(N)]\n    \n    # Check all permutations\n    for perm in permutations(strings):\n        valid = True\n        for i in range(N - 1):\n            if not differ_by_one(perm[i], perm[i + 1]):\n                valid = False\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc302_d", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndata = input().split()\nN, M, D = map(int, data[0:3])\nA = list(map(int, data[3:3+N]))\nB = list(map(int, data[3+N:3+N+M]))\n\n# Sort both lists\nA.sort()\nB.sort()\n\ni, j = 0, 0\nmax_sum = -1\n\n# Use two pointers to find maximum sum with difference at most D\nwhile i < N and j < M:\n    diff = abs(A[i] - B[j])\n    if diff <= D:\n        current_sum = A[i] + B[j]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        # Move the pointer of the smaller value to find potentially better pair\n        if A[i] < B[j]:\n            i += 1\n        else:\n            j += 1\n    else:\n        # Move the pointer that points to the smaller value\n        if A[i] < B[j]:\n            i += 1\n        else:\n            j += 1\n\n# Output the result\nprint(max_sum)"}
{"task_id": "abc302_e", "solution": "# Read input, process queries, output results\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, Q = int(data[0]), int(data[1])\n    queries = data[2:]\n    \n    degree = [0] * (N + 1)\n    zero_count = N\n    \n    results = []\n    index = 0\n    \n    for _ in range(Q):\n        t = int(queries[index])\n        index += 1\n        if t == 1:\n            u = int(queries[index])\n            v = int(queries[index + 1])\n            index += 2\n            # Add edge between u and v\n            # Update degrees\n            if degree[u] == 0:\n                zero_count -= 1\n            if degree[v] == 0:\n                zero_count -= 1\n            degree[u] += 1\n            degree[v] += 1\n        else:\n            v = int(queries[index])\n            index += 1\n            # Remove all edges incident to v\n            if degree[v] > 0:\n                degree[v] = 0\n                zero_count += 1\n        results.append(str(zero_count))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc302_f", "solution": "```python\nimport sys\nfrom collections import deque, defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    N, M = map(int, data[0:2])\n    \n    A = []\n    sets = []\n    index = 2\n    for _ in range(N):\n        A_i = int(data[index])\n        index += 1\n        s = list(map(int, data[index:index+A_i]))\n        index += A_i\n        sets.append(s)\n    \n    # Disjoint Set Union (Union-Find) implementation\n    parent = list(range(M+1))\n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n    def union(x, y):\n        rx = find(x)\n        ry = find(y)\n        if rx != ry:\n            parent[ry] = rx\n    \n    # Union all elements within each set\n    for s in sets:\n        base = s[0]\n        for elem in s[1:]:\n            union(base, elem)\n    \n    # Check if 1 and M are connected\n    if find(1) != find(M):\n        print(-1)\n        return\n    \n    # Map each element to the list of set indices that contain it\n    element_to_sets = defaultdict(list)\n    for i, s in enumerate(sets):\n        for elem in s:\n            element_to_sets[elem].append(i)\n    \n    # Build graph of sets: edges between sets sharing at least one element\n    # We will perform BFS over these sets\n    visited_sets = [False] * N\n    queue = deque()\n    \n    # Initialize queue with sets containing 1\n    for set_idx in element_to_sets[1]:\n        visited_sets[set_idx] = True\n        queue.append((set_idx, 0))\n    \n    # BFS to find shortest path to a set containing M\n    while queue:\n        current_set_idx, steps = queue.popleft()\n        # Check if this set contains M\n        if any(find(elem) == find(M) for elem in sets[current_set_idx]):\n            print(steps)\n            return\n        # Explore neighboring sets via shared elements\n        for elem in sets[current_set_idx]:\n            for neighbor_set_idx in element_to_sets[elem]:\n                if not visited_sets[neighbor_set_idx]:\n                    visited_sets[neighbor_set_idx] = True\n                    queue.append((neighbor_set_idx, steps + 1))\n    \n    # If no"}
{"task_id": "abc303_a", "solution": "# Read inputs\nN = int(input().strip())\nS = input().strip()\nT = input().strip()\n\ndef are_characters_similar(c1, c2):\n    # Check if characters are exactly the same\n    if c1 == c2:\n        return True\n    # Check for '1' and 'l' similarity\n    if (c1 == '1' and c2 == 'l') or (c1 == 'l' and c2 == '1'):\n        return True\n    # Check for '0' and 'o' similarity\n    if (c1 == '0' and c2 == 'o') or (c1 == 'o' and c2 == '0'):\n        return True\n    return False\n\n# Check each position\nfor i in range(N):\n    if not are_characters_similar(S[i], T[i]):\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")"}
{"task_id": "abc303_b", "solution": "# Read the inputs\nN, M = map(int, input().split())\n\n# Initialize a set to store adjacent pairs in any photo\nadjacent_pairs = set()\n\n# Read each photo's line-up\nfor _ in range(M):\n    lineup = list(map(int, input().split()))\n    # For each adjacent pair in the lineup, add to the set\n    for i in range(N - 1):\n        pair = tuple(sorted((lineup[i], lineup[i+1])))\n        adjacent_pairs.add(pair)\n\n# Generate all possible pairs of people\nfrom itertools import combinations\nall_pairs = combinations(range(1, N+1), 2)\n\n# Count pairs that never appeared adjacent\ncount = 0\nfor pair in all_pairs:\n    if pair not in adjacent_pairs:\n        count += 1\n\n# Output the result\nprint(count)"}
{"task_id": "abc303_c", "solution": "# Read input values\nN, M, H, K = map(int, input().split())\nS = input().strip()\n\n# Store item positions in a set for quick lookup\nitems = set()\nfor _ in range(M):\n    x, y = map(int, input().split())\n    items.add((x, y))\n\n# Initialize starting position and health\nx, y = 0, 0\nhealth = H\n\n# Iterate through each move\nfor move in S:\n    # Update position based on move character\n    if move == 'R':\n        x += 1\n    elif move == 'L':\n        x -= 1\n    elif move == 'U':\n        y += 1\n    elif move == 'D':\n        y -= 1\n\n    # Consume health for the move\n    health -= 1\n\n    # Check if Takahashi collapses\n    if health < 0:\n        print(\"No\")\n        break\n\n    # If there's an item at the current position and health is less than K, consume it\n    if (x, y) in items and health < K:\n        health = K\n        items.remove((x, y))\nelse:\n    # If loop completes without break, Takahashi can finish all moves\n    print(\"Yes\")"}
{"task_id": "abc303_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    X, Y, Z = map(int, data[:3])\n    S = data[3]\n\n    # Initialize DP variables:\n    # cost if Caps Lock is off\n    dp_off = 0\n    # cost if Caps Lock is on\n    dp_on = 0\n\n    for ch in S:\n        # Costs for current character based on current state\n        if ch == 'a':\n            # If Caps Lock is off:\n            cost_off = X  # press 'a'\n            # If Caps Lock is on:\n            cost_on = Y   # press Shift+'a'\n        else:  # ch == 'A'\n            # If Caps Lock is off:\n            cost_off = Y  # press Shift+'a'\n            # If Caps Lock is on:\n            cost_on = X   # press 'a'\n\n        # To produce ch without toggling:\n        new_dp_off = min(dp_off + cost_off, dp_on + Z + cost_off)\n        new_dp_on = min(dp_on + cost_on, dp_off + Z + cost_on)\n\n        # Update DP for next iteration\n        dp_off, dp_on = new_dp_off, new_dp_on\n\n    # The minimal total cost\n    print(min(dp_off, dp_on))"}
{"task_id": "abc303_e", "solution": "from collections import deque, defaultdict\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    edges = data[1:]\n    \n    adj = [[] for _ in range(N+1)]\n    degree = [0]*(N+1)\n    \n    for i in range(N-1):\n        u = int(edges[2*i])\n        v = int(edges[2*i+1])\n        adj[u].append(v)\n        adj[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    \n    # Queue of leaves\n    q = deque()\n    for i in range(1, N+1):\n        if degree[i] == 1:\n            q.append(i)\n    \n    # To keep track of star sizes\n    star_sizes = []\n    visited = [False]*(N+1)\n    # Each node initially belongs to no star, but we will mark leaves\n    # as belonging to a star during peeling.\n    \n    # For leaves, we can think of each as belonging to its own star initially.\n    # We will merge as we go.\n    \n    # To track star assignments\n    star_id = [0]*(N+1)\n    star_count = 0\n    \n    # We will process leaves, peeling them off\n    while q:\n        leaf = q.popleft()\n        if visited[leaf]:\n            continue\n        # Assign a new star for each leaf peeled\n        star_count += 1\n        size = 1  # count the leaf itself\n        visited[leaf] = True\n        star_id[leaf] = star_count\n        \n        # Peel the leaf\n        for neighbor in adj[leaf]:\n            if not visited[neighbor]:\n                # Remove leaf from neighbor\n                degree[neighbor] -= 1\n                if degree[neighbor] == 1:\n                    q.append(neighbor)\n                    \n                # Merge leaf into star\n                star_id[neighbor] = star_id[leaf]\n                size += 1\n        star_sizes.append(size)\n    \n    # The initial star level is size - 1\n    levels = [size - 1 for size in star_sizes]\n    levels.sort()\n    print(\" \".join(map(str, levels)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc304_a", "solution": "# Read the number of people\nN = int(input())\n\npeople = []\n\n# Read each person's name and age\nfor _ in range(N):\n    S, A = input().split()\n    A = int(A)\n    people.append((S, A))\n\n# Find the index of the youngest person\nyoungest_index = min(range(N), key=lambda i: people[i][1])\n\n# Generate the output starting from the youngest person\nfor i in range(N):\n    index = (youngest_index + i) % N\n    print(people[index][0])"}
{"task_id": "abc304_b", "solution": "# Read input from stdin\nN = int(input().strip())\n\n# Determine the range and apply truncation accordingly\nif N <= 999:\n    result = N\nelif N <= 9999:\n    result = (N // 10) * 10\nelif N <= 99999:\n    result = (N // 100) * 100\nelif N <= 999999:\n    result = (N // 1000) * 1000\nelif N <= 9999999:\n    result = (N // 10000) * 10000\nelif N <= 99999999:\n    result = (N // 100000) * 100000\nelse:\n    result = (N // 1000000) * 1000000\n\n# Print the result\nprint(result)"}
{"task_id": "abc304_c", "solution": "import math\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    D = float(data[1])\n\n    coords = []\n    for i in range(N):\n        x = float(data[2 + 2*i])\n        y = float(data[3 + 2*i])\n        coords.append((x, y))\n    \n    # Build adjacency list based on distance <= D\n    adjacency = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(i+1, N):\n            dist = math.dist(coords[i], coords[j])\n            if dist <= D:\n                adjacency[i].append(j)\n                adjacency[j].append(i)\n\n    infected = [False] * N\n    infected[0] = True  # Person 1 is initially infected\n    queue = deque([0])\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency[current]:\n            if not infected[neighbor]:\n                infected[neighbor] = True\n                queue.append(neighbor)\n\n    # Output results\n    for inf in infected:\n        print(\"Yes\" if inf else \"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc304_d", "solution": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    W, H = map(int, data[0:2])\n    N = int(data[2])\n    coords = data[3:3+2*N]\n    a_count = int(data[3+2*N])\n    a_lines = list(map(int, data[4+2*N:4+2*N + a_count]))\n    B_index = 4+2*N + a_count\n    B = int(data[B_index])\n    b_lines = list(map(int, data[B_index+1:B_index+1+B]))\n    \n    # Prepare boundary lines including edges\n    vertical_lines = [0] + a_lines + [W]\n    horizontal_lines = [0] + b_lines + [H]\n    \n    # Initialize counts for each piece\n    counts = [[0]*(B+1) for _ in range(A+1)]\n    \n    # Count strawberries in each segment\n    for i in range(N):\n        p = int(coords[2*i])\n        q = int(coords[2*i + 1])\n        \n        # Find the segment index for p\n        x_idx = bisect.bisect_right(vertical_lines, p) - 1\n        # Find the segment index for q\n        y_idx = bisect.bisect_right(horizontal_lines, q) - 1\n        \n        counts[x_idx][y_idx] += 1\n    \n    # Find min and max in counts\n    min_strawberries = float('inf')\n    max_strawberries = -float('inf')\n    \n    for row in counts:\n        for val in row:\n            if val < min_strawberries:\n                min_strawberries = val\n            if val > max_strawberries:\n                max_strawberries = val\n    \n    print(min_strawberries, max_strawberries)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc304_e", "solution": "```python\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n    \n    def find(self, x):\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n    \n    def union(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        return True\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    edges_start = 2\n    edges_end = 2 + 2*M\n\n    # Read initial edges\n    edges = []\n    for i in range(edges_start, edges_end, 2):\n        u, v = int(data[i]) - 1, int(data[i+1]) - 1\n        edges.append((u, v))\n    \n    K = int(data[edges_end])\n    pairs_start = edges_end + 1\n    pairs_end = pairs_start + 2 * K\n    \n    pairs = []\n    for i in range(pairs_start, pairs_end, 2):\n        x, y = int(data[i]) - 1, int(data[i+1]) - 1\n        pairs.append((x, y))\n    \n    Q = int(data[pairs_end])\n    queries_start = pairs_end + 1\n    queries_end = queries_start + 2 * Q\n    queries = []\n    for i in range(queries_start, queries_end, 2):\n        p, q = int(data[i]) - 1, int(data[i+1"}
{"task_id": "abc305_a", "solution": "# Read input\nN = int(input())\n\n# Find the nearest station candidates\nlower_station = (N // 5) * 5\nupper_station = lower_station + 5\n\n# Calculate distances to both candidates\ndist_lower = abs(N - lower_station)\ndist_upper = abs(N - upper_station)\n\n# Determine the nearest station\nif dist_lower <= dist_upper:\n    print(lower_station)\nelse:\n    print(upper_station)"}
{"task_id": "abc305_b", "solution": "# Define the positions of points based on cumulative distances\npositions = {\n    'A': 0,\n    'B': 3,\n    'C': 4,\n    'D': 8,\n    'E': 9,\n    'F': 14,\n    'G': 23\n}\n\n# Read input points\np, q = input().split()\n\n# Calculate the distance as the absolute difference of their positions\ndistance = abs(positions[p] - positions[q])\n\n# Output the distance\nprint(distance)"}
{"task_id": "abc305_c", "solution": "# Read input\nH, W = map(int, input().split())\nS = [input().strip() for _ in range(H)]\n\n# Initialize min and max bounds for rows and columns where '#' appears\nmin_row, max_row = H, -1\nmin_col, max_col = W, -1\n\n# Find bounds of the rectangle with cookies\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == '#':\n            if i < min_row:\n                min_row = i\n            if i > max_row:\n                max_row = i\n            if j < min_col:\n                min_col = j\n            if j > max_col:\n                max_col = j\n\n# Search within the rectangle for the '.' character\nfor i in range(min_row, max_row + 1):\n    for j in range(min_col, max_col + 1):\n        if S[i][j] == '.':\n            # Output the position with 1-based indexing\n            print(i + 1, j + 1)\n            break"}
{"task_id": "abc305_d", "solution": "```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    Q = int(data[1+N])\n    queries = data[2+N:]\n    \n    # Extract sleep intervals\n    intervals = []\n    for i in range(1, (N - 1)//2 + 1):\n        start = A[2*i]\n        end = A[2*i + 1]\n        intervals.append((start, end))\n    \n    # Prepare events for sweep line\n    events = []\n    for start, end in intervals:\n        events.append((start, 1))   # sleep starts\n        events.append((end, -1))    # sleep ends\n    \n    # Sort events by position\n    events.sort()\n    \n    # Build prefix sum of sleep time\n    prefix_positions = []\n    prefix_sums = []\n    \n    current_coverage = 0\n    prev_pos = 0\n    total_sleep = 0\n    \n    # To handle the first segment, initialize prev_pos\n    # We will iterate through events and calculate sleep in segments\n    for i, (pos, delta) in enumerate(events):\n        if i == 0:\n            prev_pos = pos\n        else:\n            segment_length = pos - prev_pos\n            if current_coverage > 0:\n                total_sleep += segment_length\n            prev_pos = pos\n        current_coverage += delta\n        # Record at each position\n        prefix_positions.append(pos)\n        prefix_sums.append(total_sleep)\n    \n    # For queries, we need to quickly find total sleep up to any point\n    # Use binary search on prefix_positions\n    \n    for i in range(Q):\n        l = int(queries[2*i])\n        r = int(queries[2*i + 1])\n        \n        # Find total sleep up to r\n        idx_r = bisect.bisect_right(prefix_positions, r) - 1\n        sleep_r = prefix_sums[idx_r] if idx_r >= 0 else 0\n        \n        # Find total sleep up to l\n        idx_l = bisect.bisect_right(prefix_positions, l) - 1\n        sleep_l = prefix_sums[idx_l] if idx_l >= 0 else"}
{"task_id": "abc305_e", "solution": "from collections import deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = data[3:3+2*M]\n    guard_data = data[3+2*M:]\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N+1)]\n    for i in range(0, 2*M, 2):\n        a, b = int(edges[i]), int(edges[i+1])\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Read guard positions and stamina\n    p = []\n    h = []\n    for i in range(K):\n        p_i = int(guard_data[2*i])\n        h_i = int(guard_data[2*i + 1])\n        p.append(p_i)\n        h.append(h_i)\n        \n    # Initialize distances with a large number\n    INF = 10**9\n    dist = [INF] * (N+1)\n    queue = deque()\n    \n    # Set initial positions for BFS\n    for i in range(K):\n        dist[p[i]] = 0\n        queue.append(p[i])\n    \n    # Multi-source BFS\n    while queue:\n        v = queue.popleft()\n        for u in adj[v]:\n            if dist[v] + 1 < dist[u]:\n                dist[u] = dist[v] + 1\n                queue.append(u)\n    \n    # For each vertex, check if it is guarded\n    guarded_vertices = []\n    for v in range(1, N+1):\n        # If the minimal distance to any guard (already in dist[v]) \n        # is within at least one guard's stamina\n        # we need to verify if there's a guard with h_i >= dist[v]\n        # Since dist[v] is minimal over all guards, check if dist[v] <= max stamina among guards\n        # but more precise: the vertex is guarded if dist[v] <= h_i for at least one guard i\n        # We can simply check for each guard:\n        if any(dist[v] <= h_i for h_i in h):\n            guarded_vertices.append(v)\n    \n    # Output results\n    print(len(guarded_vertices))\n    print(' '.join(map(str, guarded_vertices)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc306_a", "solution": "# Read input values\nN = int(input().strip())\nS = input().strip()\n\n# Initialize an empty string to store the result\nresult = \"\"\n\n# Loop through each character in S\nfor ch in S:\n    # Append the character twice\n    result += ch * 2\n\n# Output the final string\nprint(result)"}
{"task_id": "abc306_b", "solution": "# Read the input line, split into bits\nbits = input().strip().split()\n\n# Convert bits to integers\nbits_int = list(map(int, bits))\n\n# Create a binary string with the most significant bit first\nbinary_str = ''.join(str(bit) for bit in reversed(bits_int))\n\n# Convert binary string to decimal integer\nresult = int(binary_str, 2)\n\n# Output the result\nprint(result)"}
{"task_id": "abc306_c", "solution": "# Read input values\nN = int(input())\nA = list(map(int, input().split()))\n\n# Initialize a list to store the positions for each number\npositions = [[] for _ in range(N+1)]\n\n# Record the positions of each number\nfor index, value in enumerate(A, start=1):\n    positions[value].append(index)\n\n# Compute f(i) for each i\nf_values = []\nfor i in range(1, N+1):\n    # Get the sorted indices of the three occurrences\n    sorted_indices = sorted(positions[i])\n    # The middle occurrence\n    middle_index = sorted_indices[1]\n    f_values.append((middle_index, i))\n\n# Sort by the middle occurrence\nf_values.sort(key=lambda x: x[0])\n\n# Print the sequence of i in sorted order\nresult = [str(i) for _, i in f_values]\nprint(' '.join(result))"}
{"task_id": "abc306_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    X = []\n    Y = []\n    idx = 1\n    for _ in range(N):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        X.append(x)\n        Y.append(y)\n        idx += 2\n    \n    # Initialize DP arrays\n    # Use a very small number to represent impossible states\n    NEG_INF = -10**15\n    dp_healthy = 0\n    dp_upset = NEG_INF\n    \n    for i in range(N):\n        x = X[i]\n        y = Y[i]\n        \n        new_dp_healthy = max(dp_healthy, 0)  # consider skipping\n        new_dp_upset = max(dp_upset, 0)\n        \n        # If he eats this course\n        if x == 0:\n            # Antidotal: can eat from healthy and upset\n            # From healthy to healthy\n            eat_healthy = dp_healthy + y\n            # From upset to healthy\n            eat_h_to_h = dp_upset + y\n            \n            new_dp_healthy = max(new_dp_healthy, eat_healthy, eat_h_to_h)\n        else:\n            # Poisonous\n            # From healthy to upset\n            eat_h_to_u = dp_healthy + y\n            if eat_h_to_u > new_dp_upset:\n                new_dp_upset = eat_h_to_u\n            # From upset to death (not allowed), so ignore\n            \n        # If he skips, states stay the same\n        new_dp_healthy = max(new_dp_healthy, dp_healthy)\n        new_dp_upset = max(new_dp_upset, dp_upset)\n        \n        # Update for next iteration\n        dp_healthy = new_dp_healthy\n        dp_upset = new_dp_upset\n    \n    # The result is the best among ending in healthy or upset (but not dead)\n    # Since dead state is not represented, max of the two states is our answer\n    answer = max(dp_healthy, dp_upset)\n    if answer < 0:\n        answer = 0  # If all options are negative, choose to eat nothing\n    \n    print(answer)"}
{"task_id": "abc306_e", "solution": "```python\nimport sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N, K, Q = map(int, data[0:3])\n    queries = data[3:]\n    \n    A = [0] * N  # initial array\n    # We will maintain two heaps:\n    # top_heap: max-heap for top K elements (store negatives for max-heap behavior)\n    # rest_heap: min-heap for the remaining elements\n    top_heap = []\n    rest_heap = []\n\n    # Counts for lazy deletion\n    count_map = {}\n    def add_count(val, counts):\n        counts[val] = counts.get(val, 0) + 1\n\n    def remove_count(val, counts):\n        counts[val] -= 1\n        if counts[val] == 0:\n            del counts[val]\n\n    def is_valid(val, counts):\n        return val in counts\n\n    # Initialize all elements to 0\n    # Insert all into rest_heap\n    for _ in range(N):\n        heapq.heappush(rest_heap, 0)\n        add_count(0, count_map)\n\n    # Move the largest K elements from rest_heap to top_heap\n    top_sum = 0\n    for _ in range(K):\n        val = heapq.heappop(rest_heap)\n        remove_count(val, count_map)\n        heapq.heappush(top_heap, -val)\n        top_sum += val\n        add_count(val, count_map)\n\n    # Helper functions\n    def clean_heap(heap, counts, is_top):\n        # Remove invalid elements from heap top\n        while heap and (not is_valid(abs(heap[0]), counts)):\n            heapq.heappop(heap)\n\n    def get_smallest_top():\n        # Get smallest in top heap\n        clean_heap(top_heap, count_map, True)\n        if top_heap:\n            return -top_heap[0]\n        return None\n\n    def get_largest_rest():\n        # Get largest in rest heap\n        clean_heap(rest_heap, count_map"}
{"task_id": "abc307_a", "solution": "# Read the number of weeks\nN = int(input())\n\n# Read the steps for all days\nA = list(map(int, input().split()))\n\n# Initialize list for weekly sums\nweekly_sums = []\n\n# Loop through each week\nfor i in range(N):\n    # Calculate start and end indices for the current week\n    start_idx = i * 7\n    end_idx = start_idx + 7\n    # Sum the steps for the current week\n    week_sum = sum(A[start_idx:end_idx])\n    # Store the result\n    weekly_sums.append(week_sum)\n\n# Output the weekly sums separated by spaces\nprint(' '.join(map(str, weekly_sums)))"}
{"task_id": "abc307_b", "solution": "# Read the number of strings\nN = int(input())\n\n# Read the strings into a list\nS = [input().strip() for _ in range(N)]\n\n# Helper function to check if a string is a palindrome\ndef is_palindrome(t):\n    return t == t[::-1]\n\n# Check all pairs for the palindrome condition\nfor i in range(N):\n    for j in range(N):\n        if i != j:\n            concatenated = S[i] + S[j]\n            if is_palindrome(concatenated):\n                print(\"Yes\")\n                exit()\n\n# If no such pair found\nprint(\"No\")"}
{"task_id": "abc307_c", "solution": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read input\n    H_A, W_A = map(int, data[0].split())\n    A = data[1:1+H_A]\n    idx = 1 + H_A\n    H_B, W_B = map(int, data[idx].split())\n    B = data[idx+1:idx+1+H_B]\n    idx += 1 + H_B\n    H_X, W_X = map(int, data[idx].split())\n    X = data[idx+1:idx+1+H_X]\n    \n    # Function to get black square positions\n    def get_black_positions(sheet):\n        positions = []\n        for r in range(len(sheet)):\n            for c in range(len(sheet[0])):\n                if sheet[r][c] == '#':\n                    positions.append((r, c))\n        return positions\n    \n    A_blacks = get_black_positions(A)\n    B_blacks = get_black_positions(B)\n    \n    # Determine bounds for placement:\n    # Since sheets are small, we can try all possible shifts\n    # The shifts range from negative to positive, within the size constraints\n    max_shift_row = 20\n    max_shift_col = 20\n    \n    # Helper function to check if pattern matches\n    def matches_pattern(rect, target):\n        for r in range(len(target)):\n            for c in range(len(target[0])):\n                if rect[r][c] != target[r][c]:\n                    return False\n        return True\n    \n    # For each placement of A and B\n    for a_r_shift in range(-max_shift_row, max_shift_row+1):\n        for a_c_shift in range(-max_shift_col, max_shift_col+1):\n            for b_r_shift in range(-max_shift_row, max_shift_row+1):\n                for b_c_shift in range(-max_shift_col, max_shift_col+1):\n                    # Collect black squares after placement\n                    blacks = []\n                    for (r, c) in A_blacks:\n                        blacks.append((r + a_r_shift, c + a_c_shift))\n                    for (r, c) in B_blacks:\n                        blacks.append((r + b_r_shift, c + b_c_shift))\n                    \n                    if not blacks:\n                        continue  # No black squares, invalid as per constraints\n                        \n                    # Find bounding rectangle\n                    min_r = min(pos[0] for pos in blacks)\n                    max_r = max(pos[0] for pos in blacks)\n                    min_c = min(pos[1] for pos in blacks)\n                    max_c = max(pos[1] for pos in blacks)\n                    \n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    \n                    # Check if size matches X\n                    if height != H_X or width != W_X:\n                        continue"}
{"task_id": "abc307_d", "solution": "# Read inputs\nN = int(input())\nS = input()\n\n# Initialize a list for the output characters\nresult = []\n# Stack to keep track of indices of '('\nstack = []\n\nfor ch in S:\n    if ch == '(':\n        # Push the index of '(' onto the stack\n        stack.append(len(result))\n        result.append(ch)\n    elif ch == ')':\n        if stack:\n            # Found a matching '(' to remove\n            open_idx = stack.pop()\n            # Remove the '(' from result to simulate deletion\n            result.pop(open_idx)\n            # Do not add ')' to result, effectively deleting the pair\n        else:\n            # No matching '(', so just add ')'\n            result.append(ch)\n    else:\n        # For lowercase letters, just add to result\n        result.append(ch)\n\n# Print the resulting string\nprint(''.join(result))"}
{"task_id": "abc307_e", "solution": "# Read inputs\nN, M = map(int, input().split())\n\nMOD = 998244353\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\n# Compute (M-1)^N mod\npower = mod_pow(M - 1, N, MOD)\n\n# Determine the sign based on whether N is even or odd\nsign = -1 if N % 2 == 1 else 1\n\n# Compute the final answer\nanswer = (power + (M - 1) * sign) % MOD\n\nprint(answer)"}
{"task_id": "abc308_a", "solution": "# Read the integers from input\nS = list(map(int, input().split()))\n\n# Check if all values are within [100, 675]\nrange_condition = all(100 <= s <= 675 for s in S)\n\n# Check if all values are multiples of 25\nmultiple_condition = all(s % 25 == 0 for s in S)\n\n# Check if sequence is non-decreasing\nnon_decreasing_condition = all(S[i] <= S[i+1] for i in range(len(S)-1))\n\n# Final decision\nif range_condition and multiple_condition and non_decreasing_condition:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc308_b", "solution": "# Read inputs\nN, M = map(int, input().split())\nplates = input().split()\ncolors = input().split()\nprices = list(map(int, input().split()))\n\n# Create a mapping from color to price\ncolor_price_map = {colors[i]: prices[i+1] for i in range(M)}\ndefault_price = prices[0]\n\n# Calculate total cost\ntotal = 0\nfor color in plates:\n    if color in color_price_map:\n        total += color_price_map[color]\n    else:\n        total += default_price\n\n# Output the total amount\nprint(total)"}
{"task_id": "abc308_c", "solution": "# Read the number of people\nN = int(input())\n\npeople = []\n\nfor i in range(1, N + 1):\n    A, B = map(int, input().split())\n    success_rate = A / (A + B)\n    # Store with negative success rate for sorting in descending order\n    people.append((success_rate, i))\n\n# Sort by success rate descending, then by person number ascending\npeople.sort(key=lambda x: (-x[0], x[1]))\n\n# Print the order of people\nprint(' '.join(str(person[1]) for person in people))"}
{"task_id": "abc308_d", "solution": "from collections import deque\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n\n    pattern = ['s', 'n', 'u', 'k', 'e']\n    # BFS queue: stores tuples (row, col, pattern_index)\n    queue = deque()\n\n    # Visited array: 3D boolean array to track visited states\n    visited = [[[False] * 5 for _ in range(W)] for __ in range(H)]\n\n    # Initialize starting point\n    if grid[0][0] == pattern[0]:\n        queue.append((0, 0, 0))\n        visited[0][0][0] = True\n\n    # Directions: up, down, left, right\n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n\n    while queue:\n        i, j, idx = queue.popleft()\n\n        # Check if reached the target cell\n        if i == H - 1 and j == W - 1:\n            print(\"Yes\")\n            return\n\n        next_idx = (idx + 1) % 5\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                if not visited[ni][nj][next_idx]:\n                    if grid[ni][nj] == pattern[next_idx]:\n                        visited[ni][nj][next_idx] = True\n                        queue.append((ni, nj, next_idx))\n\n    # If no path found\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc308_e", "solution": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    S = data[1+N]\n    \n    # Map characters to indices\n    # For prefix sums: 'M' and 'X' positions\n    prefix_M_counts = [[0, 0, 0] for _ in range(N+1)]  # prefix_M_counts[i][a]: count of 'M' with A=a up to position i-1\n    suffix_X_counts = [[0, 0, 0] for _ in range(N+1)]  # suffix_X_counts[i][a]: count of 'X' with A=a from position i to end\n    \n    # Build prefix count for 'M'\n    for i in range(N):\n        for a in range(3):\n            prefix_M_counts[i+1][a] = prefix_M_counts[i][a]\n        if S[i] == 'M':\n            prefix_M_counts[i+1][A[i]] += 1\n    \n    # Build suffix count for 'X'\n    for i in range(N-1, -1, -1):\n        for a in range(3):\n            suffix_X_counts[i][a] = suffix_X_counts[i+1][a]\n        if S[i] == 'X':\n            suffix_X_counts[i][A[i]] += 1\n    \n    result = 0\n    \n    # For each position j"}
{"task_id": "abc308_f", "solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, M = map(int, data[0:2])\n    P = list(map(int, data[2:2+N]))\n    L = list(map(int, data[2+N:2+N+M]))\n    D = list(map(int, data[2+N+M:2+N+2*M]))\n\n    # Pair coupons as (threshold, discount) and sort by threshold descending\n    coupons = list(zip(L, D))\n    coupons.sort(key=lambda x: x[0], reverse=True)\n\n    # Sort item prices ascending\n    P.sort()\n\n    total_cost = 0\n    max_heap = []\n    idx = 0  # index for coupons\n\n    for price in reversed(P):\n        # Add all coupons that can be applied to this item\n        while idx < M and coupons[idx][0] <= price:\n            # Push discount as negative because heapq is min-heap\n            heapq.heappush(max_heap, -coupons[idx][1])\n            idx += 1\n\n        # Use the best coupon if available\n        if max_heap:\n            best_discount = -heapq.heappop(max_heap)\n            total_cost += max(price - best_discount, 0)\n        else:\n            total_cost += price\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_a", "solution": "# Read inputs\nA, B = map(int, input().split())\n\n# Calculate positions\nA_row, A_col = divmod(A - 1, 3)\nB_row, B_col = divmod(B - 1, 3)\n\n# Check if they are in the same row and adjacent horizontally\nif A_row == B_row and abs(A_col - B_col) == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc309_b", "solution": "# Read input\nN = int(input())\nA = [list(input().strip()) for _ in range(N)]\n\n# Collect outer squares in clockwise order\nouter_positions = []\n\n# top row\nfor j in range(N):\n    outer_positions.append((0, j))\n# right column (excluding the top corner)\nfor i in range(1, N-1):\n    outer_positions.append((i, N-1))\n# bottom row (if N > 1)\nif N > 1:\n    for j in range(N-1, -1, -1):\n        outer_positions.append((N-1, j))\n# left column (excluding top and bottom corners)\nif N > 1:\n    for i in range(N-2, 0, -1):\n        outer_positions.append((i, 0))\n\n# Extract outer values\nouter_values = [A[i][j] for i, j in outer_positions]\n\n# Rotate the outer values clockwise by one position\nouter_values = [outer_values[-1]] + outer_values[:-1]\n\n# Assign the rotated values back\nfor (i, j), val in zip(outer_positions, outer_values):\n    A[i][j] = val\n\n# Print the resulting grid\nfor row in A:\n    print(\"\".join(row))"}
{"task_id": "abc309_c", "solution": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, K = int(data[0]), int(data[1])\n    a = []\n    b = []\n    idx = 2\n    for _ in range(N):\n        ai = int(data[idx])\n        bi = int(data[idx + 1])\n        a.append(ai)\n        b.append(bi)\n        idx += 2\n\n    # Pair and sort by a_i\n    medicines = sorted(zip(a, b))\n    a_sorted = [med[0] for med in medicines]\n    b_sorted = [med[1] for med in medicines]\n\n    # Compute suffix sums of b for quick total calculation\n    suffix_sum = [0] * (N + 1)\n    for i in range(N - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + b_sorted[i]\n\n    max_day = a_sorted[-1]\n\n    # Binary search for the earliest day where total pills <= K\n    low, high = 1, max_day\n    answer = max_day + 1  # If not found, default to something larger\n\n    while low <= high:\n        mid = (low + high) // 2\n        # Find first index where a_i >= mid\n        idx = bisect.bisect_left(a_sorted, mid)\n        total = suffix_sum[idx]\n        if total <= K:\n            answer = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    print(answer)\n    \nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc309_d", "solution": "from collections import deque\nimport sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    N1, N2, M = map(int, data[:3])\n    edges_data = data[3:]\n    \n    total_vertices = N1 + N2\n    \n    # Build adjacency list\n    adj = [[] for _ in range(total_vertices + 1)]\n    for i in range(M):\n        a = int(edges_data[2*i])\n        b = int(edges_data[2*i + 1])\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # BFS function\n    def bfs(start):\n        dist = [-1] * (total_vertices + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    \n    # Compute distances from node 1\n    dist1 = bfs(1)\n    # Compute distances from node N1+N2\n    dist2 = bfs(N1 + N2)\n    \n    # Find the maximum distance in part 1 from node 1\n    max_dist1 = max(dist1[1:N1+1])\n    # Find the maximum distance in part 2 from node N1+N2\n    max_dist2 = max(dist2[N1+1:N1+N2+1])\n    \n    # The answer is maximum distance from 1 to N1+N2 after adding one edge\n    # which is max_dist1 + 1 + max_dist2\n    print(max_dist1 + 1 + max_dist2)"}
{"task_id": "abc309_e", "solution": "# Approach:\n# - Build a tree from parent list.\n# - Record insurance start points.\n# - DFS traversal to propagate coverage based on y_i limits.\n# - Count total covered persons.\n\n## Implementation:"}
{"task_id": "abc310_a", "solution": "# Read the first line of input: N, P, Q\nN, P, Q = map(int, input().split())\n# Read the dish prices\nD = list(map(int, input().split()))\n\n# Find the minimum dish price\nmin_D = min(D)\n\n# Calculate the total costs for both options\ncost_without_coupon = P\ncost_with_coupon = Q + min_D\n\n# Output the minimum of the two options\nprint(min(cost_without_coupon, cost_with_coupon))"}
{"task_id": "abc310_b", "solution": "# Read the input\nN, M = map(int, input().split())\nproducts = []\n\nfor _ in range(N):\n    data = list(map(int, input().split()))\n    P = data[0]\n    C = data[1]\n    F = set(data[2:])\n    products.append((P, F))\n\n# Check for the existence of a product that is strictly superior\nfor i in range(N):\n    P_i, F_i = products[i]\n    for j in range(N):\n        P_j, F_j = products[j]\n        if P_i >= P_j and F_i.issubset(F_j):\n            # Conditions:\n            # P_i > P_j or F_j does not contain all functions of F_i\n            if P_i > P_j or not F_i.issubset(F_j):\n                print(\"Yes\")\n                exit()\n\nprint(\"No\")"}
{"task_id": "abc310_c", "solution": "# Read the number of sticks\nN = int(input())\n\n# Initialize a set to store normalized representations\nrepresentations = set()\n\nfor _ in range(N):\n    S = input().strip()\n    R = S[::-1]\n    # Normalize to the lexicographically smaller string between S and its reverse\n    normalized = S if S < R else R\n    representations.add(normalized)\n\n# The number of unique representations\nprint(len(representations))"}
{"task_id": "abc310_d", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N, T, M = map(int, data[0:3])\n    pairs = []\n\n    index = 3\n    for _ in range(M):\n        A, B = map(int, data[index:index+2])\n        index += 2\n        # Convert to 0-based index\n        pairs.append((A-1, B-1))\n    \n    count = 0\n    team_assignment = [-1] * N  # team assignment for each player\n\n    def backtrack(player_idx, teams_used, max_team):\n        nonlocal count\n\n        if player_idx == N:\n            # All players assigned\n            # Check if exactly T teams used\n            if teams_used == T:\n                count += 1\n            return\n\n        # Try assigning current player to existing teams\n        for team in range(teams_used):\n            # Check incompatibility with current team\n            valid = True\n            for (a, b) in pairs:\n                if (a == player_idx or b == player_idx):\n                    other = b if a == player_idx else a\n                    if team_assignment[other] == team:\n                        # incompatible pair in same team\n                        valid = False\n                        break\n            if valid:\n                team_assignment[player_idx] = team\n                backtrack(player_idx + 1, teams_used, max_team)\n                team_assignment[player_idx] = -1\n\n        # Try assigning to a new team if we haven't reached T\n        if teams_used < T:\n            team = teams_used\n            # Check incompatibilities with current team\n            valid = True\n            for (a, b) in pairs:\n                if (a == player_idx or b == player_idx):\n                    other = b if a == player_idx else a\n                    if team_assignment[other] == team:\n                        valid = False\n                        break\n            if valid:\n                team_assignment[player_idx] = team\n                backtrack(player_idx + 1, teams_used + 1, max_team + 1)\n                team_assignment[player_idx] = -1\n\n    backtrack(0, 0, 0)\n    print(count)"}
{"task_id": "abc310_e", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    \n    total_subarrays = N * (N + 1) // 2\n    all_one_subarrays = 0\n    \n    length = 0\n    for ch in S:\n        if ch == '1':\n            length += 1\n        else:\n            if length > 0:\n                all_one_subarrays += length * (length + 1) // 2\n                length = 0\n    # Handle last run if it ends with '1'\n    if length > 0:\n        all_one_subarrays += length * (length + 1) // 2\n    \n    result = total_subarrays - all_one_subarrays\n    print(result)\n\n# Run the solution\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "abc310_f", "solution": "# Approach:\n\n1. **Understanding the problem:**\n   - We have `N` dice, each die `i` has faces numbered from `1` to `A_i`.\n   - When thrown, each die shows a number uniformly at random from 1 to `A_i`.\n   - We are to find the probability that **there exists a non-empty subset of dice such that the sum of the results of those dice is exactly 10**.\n   - The answer should be given modulo `998244353`, and the output should be the modular inverse of the denominator when the probability is expressed as a simplified fraction.\n\n2. **Key observations:**\n   - The total number of outcomes:\n     \\[\n     \\prod_{i=1}^N A_i\n     \\]\n   - The probability is:\n     \\[\n     \\frac{\\text{Number of favorable outcomes}}{\\prod_{i=1}^N A_i}\n     \\]\n   - We need to find the probability that **at least one subset** sums to 10.\n\n3. **Strategy:**\n   - Use **inclusion-exclusion principle** over all non-empty subsets of dice:\n     \\[\n     P(\\text{some subset sums to 10}) = \\sum_{k=1}^N (-1)^{k+1} \\sum_{S \\subseteq \\{1,\\dots,N\\}, |S|=k} P_S\n     \\]\n     where:\n     - \\( P_S \\) is the probability that **the sum of dice in subset \\(S\\) equals 10**, and all dice outside \\(S\\) can be anything.\n\n4. **Computing \\( P_S \\):**\n   - For a subset \\(S\\):\n     - The probability that all dice in \\(S\\) sum to 10:\n       \\[\n       P_{S,\\text{sum}=10} = \\frac{\\text{Number of sequences } (d_i)_{i \\in S} \\text{ with } d_i \\in [1, A_i], \\sum d_i = 10}{\\prod_{i \\in S} A_i}\n       \\]\n   - Since the dice are independent, the probability that the dice in \\(S\\) sum to 10 is:\n     \\[\n     \\frac{\\text{count of valid sequences}}{\\prod_{i \\in S} A_i}\n     \\]\n   - For the subset \\(S\\), the total number of outcomes:\n     \\[\n     \\prod_{i \\in S} A_i\n     \\]\n   - The total probability of the subset sum being 10:\n     \\[\n     \\frac{\\text{Number of valid sequences summing to 10}}{\\prod_{i \\in S} A_i}\n     \\]\n\n5. **Counting sequences with sum = 10:**\n   - We can use **dynamic programming (DP)**:\n     - `dp` array where `dp[s]` is the number of sequences with sum `s`.\n     - Initialize `dp[0] = 1`.\n     - For each die in the subset:\n       - For each existing sum, add contributions from the die's face values (1 to `A_i`).\n     - The count of sequences summing to 10 is `dp[10]`.\n\n6. **Handling large `A_i`:**\n   - Since `A_i` can be up to `10^6`, but the sum we're interested in is only 10, the DP per subset is manageable because:\n     - The sum is small (max 10), so for each die, we only need to consider face values up to `A_i`, but for summing to 10, face values larger than 10 do not contribute beyond the sum of 10.\n     - For each die:\n       - Only face values from 1 to `min(A_i, 10)` matter for the sum 10.\n   \n   - **Optimization:**\n     - For each die, the contribution to sequences summing to 10 is:\n       - 0 if `A_i` < 1 (not possible).\n       - For face values from 1 to `min(A_i,10)`, count how many face values are equal to each possible face value.\n   \n7. **Inclusion-exclusion:**\n   - Sum over all non-empty subsets:\n     \\[\n     P = \\sum_{k=1}^N (-1)^{k+1} \\sum_{S \\subseteq \\{1,\\ldots,N\\}, |S|=k} \\left( \\frac{\\text{dp}[10]}{\\prod_{i \\in S} A_i} \\right)\n     \\]\n   \n   - To compute the total probability:\n     - For each subset:\n       - Calculate numerator (`dp[# Approach:\n\n1. **Understanding the problem:**\n   - We have `N` dice, each with faces numbered from `1` to `A_i`.\n   - When rolled, each die's result is uniform over its faces.\n   - We want the probability that **there exists a non-empty subset of dice such that the sum of their results is exactly 10**.\n   - The output should be the probability modulo `998244353`, expressed as the modular inverse of the denominator when the probability is written as a fraction in lowest terms.\n\n2. **Key observations:**\n   - Total number of outcomes:\n     \\[\n     \\prod_{i=1}^N A_i\n     \\]\n   - We seek the probability:\n     \\[\n     P = \\frac{\\text{Number of favorable outcomes}}{\\prod_{i=1}^N A_i}\n     \\]\n   - Favorable outcomes are those outcomes where **some subset** of dice sums exactly to 10.\n\n3. **Using Inclusion-Exclusion:**\n   - The event \"some subset sums to 10\" can be expressed as the union over all non-empty subsets \\( S \\subseteq \\{1,\\ldots,N\\} \\) of the event \"subset \\(S\\) sums to 10\".\n   - By inclusion-exclusion:\n     \\[\n     P = \\sum_{\\substack{S \\subseteq \\{1,\\ldots,N\\} \\\\ S \\neq \\emptyset}} (-1)^{|S|+1} P_S\n     \\]\n     where \\( P_S \\) is the probability that **the sum of dice in \\(S\\) is 10**.\n\n4. **Calculating \\( P_S \\):**\n   - For subset \\( S \\), the probability that the sum of dice in \\( S \\) is 10:\n     \\[\n     P_S = \\frac{\\text{Number of sequences where sum of dice in } S = 10}{\\prod_{i \\in S} A_i}\n     \\]\n   - The numerator is the count of sequences \\((d_i)_{i \\in S}\\), with \\( 1 \\leq d_i \\leq A_i \\), such that \\( \\sum_{i \\in S} d_i = 10 \\).\n\n5. **Counting sequences summing to 10:**\n   - Use DP:\n     - Initialize `dp` array with size 11 (for sums 0..10).\n     - Set `dp[0] = 1`.\n     - For each die in subset:\n       - For sum `s` from 10 down to 0:\n         - For each face value \\( f \\) from 1 to \\(\\min(A_i, 10)\\):\n           - If \\( s + f \\leq 10 \\), then:\n             \\[\n             dp_{new}[s+f] += dp[s]\n             \\]\n   - After processing all dice in \\( S \\), `dp[10]` gives the number of sequences with sum 10.\n\n6. **Computational efficiency considerations:**\n   - For each subset \\( S \\), the DP runs in \\( O(|S| \\times 11 \\times \\text{max face value} \\text{ limited to 10}) \\), which is feasible because:\n     - \\( |S| \\leq N \\leq 100 \\).\n     - For each die, only face values up to 10 matter for sum=10.\n   - Total subsets are \\( 2^N - 1 \\), which can be large. But since \\( N \\leq 20 \\) is manageable in code; at \\( N=100 \\), full enumeration isn't feasible directly, so we need a more efficient approach.\n\n7. **Optimization:**\n   - Since the sum is only 10, and the face values beyond 10 do not contribute to sequences summing to 10, for each die:\n     - The probability of that die showing a face value \\( f \\) is \\( 1/A_i \\).\n     - The contribution to sequences summing to 10 is only from face values \\( f \\) where \\( 1 \\leq f \\leq \\min(A_i, 10) \\).\n\n8. **Alternative approach for large \\( N \\):**\n   - Instead of enumerating all subsets, observe that the probability that **no subset** sums to 10 is easier to compute:\n     - It's the probability that **for all non-empty subsets**, the sum is not 10.\n   - But this is complex.\n   \n   - **Better approach:**\n     - Use the principle of **probability generating functions**:\n       - For each die, define a polynomial:\n         \\[\n         G_i(x) = \\frac{1}{A_i} \\"}
{"task_id": "abc311_a", "solution": "# Read inputs\nN = int(input().strip())\nS = input().strip()\n\n# Initialize a set to keep track of encountered characters\nencountered_chars = set()\n\n# Iterate through the string\nfor i, ch in enumerate(S):\n    encountered_chars.add(ch)\n    # Check if all three characters are in the set\n    if {'A', 'B', 'C'}.issubset(encountered_chars):\n        # Output the position (1-based index)\n        print(i + 1)\n        break"}
{"task_id": "abc311_b", "solution": "# Read input values\nN, D = map(int, input().split())\nS = [input().strip() for _ in range(N)]\n\n# Determine which days are free for all people\nfree_days = []\nfor j in range(D):\n    all_free = True\n    for i in range(N):\n        if S[i][j] == 'x':\n            all_free = False\n            break\n    free_days.append(all_free)\n\n# Find the maximum consecutive days all are free\nmax_length = 0\ncurrent_length = 0\n\nfor day_free in free_days:\n    if day_free:\n        current_length += 1\n        if current_length > max_length:\n            max_length = current_length\n    else:\n        current_length = 0\n\nprint(max_length)"}
{"task_id": "abc311_c", "solution": "# Read input and implement the cycle detection\ndef find_cycle(N, A):\n    visited = [0] * (N + 1)\n    parent = [0] * (N + 1)\n    cycle_start = -1\n    cycle_end = -1\n    \n    def dfs(node):\n        nonlocal cycle_start, cycle_end\n        visited[node] = 1  # mark as in recursion stack\n        next_node = A[node]\n        if visited[next_node] == 0:\n            parent[next_node] = node\n            if dfs(next_node):\n                return True\n        elif visited[next_node] == 1:\n            # cycle detected\n            cycle_start = next_node\n            cycle_end = node\n            return True\n        visited[node] = 2  # fully explored\n        return False\n\n    for i in range(1, N + 1):\n        if visited[i] == 0:\n            if dfs(i):\n                break\n\n    # Reconstruct the cycle\n    cycle = []\n    cycle.append(cycle_start)\n    node = cycle_end\n    while node != cycle_start:\n        cycle.append(node)\n        node = parent[node]\n    cycle.reverse()\n    return cycle\n\n# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = [0] + list(map(int, data[1:]))\n\n    cycle = find_cycle(N, A)\n    print(len(cycle))\n    print(' '.join(map(str, cycle)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc311_d", "solution": "from collections import deque\n\n# Read input\nN, M = map(int, input().split())\ngrid = [input().strip() for _ in range(N)]\n\n# Directions for movement: up, down, left, right\ndirections = [(-1,0), (1,0), (0,-1), (0,1)]\n\n# Initialize visited array\nvisited = [[False]*M for _ in range(N)]\n\n# Starting position (convert to 0-based)\nstart_x, start_y = 1, 1  # (2,2) in 1-based indexing\n\n# BFS queue\nqueue = deque()\nqueue.append((start_x, start_y))\nvisited[start_x][start_y] = True\n\nwhile queue:\n    x, y = queue.popleft()\n    for dx, dy in directions:\n        nx, ny = x, y\n        # Move in the direction until hitting a rock or boundary\n        while True:\n            next_x = nx + dx\n            next_y = ny + dy\n            if not (0 <= next_x < N and 0 <= next_y < M):\n                break\n            if grid[next_x][next_y] == '#':\n                break\n            nx, ny = next_x, next_y\n        # If new position is different and not visited\n        if not visited[nx][ny]:\n            visited[nx][ny] = True\n            queue.append((nx, ny))\n\n# Count all reachable squares\nresult = sum(sum(1 for cell in row if cell) for row in visited)\nprint(result)"}
{"task_id": "abc311_e", "solution": "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    H, W, N = map(int, data[0:3])\n    coords = data[3:]\n    \n    # Initialize grid with 1s (no holes)\n    grid = [[1] * W for _ in range(H)]\n    \n    # Mark holes as 0\n    for i in range(N):\n        a = int(coords[2*i]) - 1  # zero-based index\n        b = int(coords[2*i + 1]) - 1\n        grid[a][b] = 0\n    \n    # DP array for maximum size of holeless square starting at (i,j)\n    dp = [[0] * W for _ in range(H)]\n    \n    total_squares = 0\n    \n    # Fill dp from bottom-right to top-left\n    for i in reversed(range(H)):\n        for j in reversed(range(W)):\n            if grid[i][j] == 1:\n                if i == H - 1 or j == W - 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1])\n                total_squares += dp[i][j]\n            else:\n                dp[i][j] = 0\n    \n    print(total_squares)"}
{"task_id": "abc312_a", "solution": "# Define the set of valid strings\nvalid_strings = {\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"}\n\n# Read input string S\nS = input().strip()\n\n# Check and output the result\nif S in valid_strings:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc312_b", "solution": "# Read input\nN, M = map(int, input().split())\ngrid = [input().strip() for _ in range(N)]\n\n# Function to check if a 3x3 block starting at (r, c) is all black\ndef is_black_block(r, c):\n    for dr in range(3):\n        for dc in range(3):\n            if grid[r + dr][c + dc] != '#':\n                return False\n    return True\n\n# Function to check if all the surrounding cells of a block are white\ndef is_surrounding_white(r, c):\n    # Surrounding cells are the border cells outside the 3x3 block within the 9x9 region\n    for dr in range(-1, 4):  # from -1 to 3\n        for dc in range(-1, 4):\n            # Skip inside the 3x3 block\n            if 0 <= dr < 3 and 0 <= dc < 3:\n                continue\n            nr = r + dr\n            nc = c + dc\n            # Check boundaries\n            if 0 <= nr < N and 0 <= nc < M:\n                if grid[nr][nc] != '.':\n                    return False\n    return True\n\n# Collect valid positions\nresults = []\n\nfor i in range(N - 8):\n    for j in range(M - 8):\n        # Check top-left 3x3 block\n        if not is_black_block(i, j):\n            continue\n        # Check bottom-right 3x3 block\n        if not is_black_block(i + 6, j + 6):\n            continue\n        # Check surrounding white cells for top-left block\n        if not is_surrounding_white(i, j):\n            continue\n        # Check surrounding white cells for bottom-right block\n        if not is_surrounding_white(i + 6, j + 6):\n            continue\n        # If all conditions satisfied\n        results.append((i + 1, j + 1))  # Convert to 1-based index\n\n# Print results\nfor r, c in results:\n    print(r, c)"}
{"task_id": "abc312_c", "solution": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, M = map(int, data[:2])\n    A = list(map(int, data[2:2+N]))\n    B = list(map(int, data[2+N:2+N+M]))\n\n    A.sort()\n    B.sort()\n\n    low = 1\n    high = max(max(A), max(B)) + 1  # upper bound for binary search\n\n    while low < high:\n        mid = (low + high) // 2\n        sellers_count = bisect.bisect_right(A, mid)\n        buyers_count = M - bisect.bisect_left(B, mid)\n        if sellers_count >= buyers_count:\n            high = mid\n        else:\n            low = mid + 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_d", "solution": "MOD = 998244353\n\ndef main():\n    import sys\n    S = sys.stdin.read().strip()\n    n = len(S)\n\n    # Initialize DP table\n    # dp[i][balance]: number of ways to process first i characters with 'balance' unmatched '('\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        ch = S[i]\n        for balance in range(n + 1):\n            if dp[i][balance] == 0:\n                continue\n            ways = dp[i][balance]\n            if ch == '(':\n                if balance + 1 <= n:\n                    dp[i + 1][balance + 1] = (dp[i + 1][balance + 1] + ways) % MOD\n            elif ch == ')':\n                if balance > 0:\n                    dp[i + 1][balance - 1] = (dp[i + 1][balance - 1] + ways) % MOD\n            else:  # '?'\n                # Treat '?' as '('\n                if balance + 1 <= n:\n                    dp[i + 1][balance + 1] = (dp[i + 1][balance + 1] + ways) % MOD\n                # Treat '?' as ')'\n                if balance > 0:\n                    dp[i + 1][balance - 1] = (dp[i + 1][balance - 1] + ways) % MOD\n\n    # The answer is the number of ways to process all characters with zero unmatched parentheses\n    print(dp[n][0] % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc312_e", "solution": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    coords = data[1:]\n    \n    cuboids = []\n    for i in range(N):\n        X1 = int(coords[6*i])\n        Y1 = int(coords[6*i + 1])\n        Z1 = int(coords[6*i + 2])\n        X2 = int(coords[6*i + 3])\n        Y2 = int(coords[6*i + 4])\n        Z2 = int(coords[6*i + 5])\n        cuboids.append((X1, Y1, Z1, X2, Y2, Z2))\n    \n    # Maps for boundaries along each axis\n    x_min_map = {}\n    x_max_map = {}\n    y_min_map = {}\n    y_max_map = {}\n    z_min_map = {}\n    z_max_map = {}\n\n    for i, (X1, Y1, Z1, X2, Y2, Z2) in enumerate(cuboids):\n        x_min_map.setdefault(X1, []).append(i)\n        x_max_map.setdefault(X2, []).append(i)\n        y_min_map.setdefault(Y1, []).append(i)\n        y_max_map.setdefault(Y2, []).append(i)\n        z_min_map.setdefault(Z1, []).append(i)\n        z_max_map.setdefault(Z2, []).append(i)\n\n    # Initialize adjacency counts\n    adj_counts = [0] * N\n\n    # Helper function to check overlap on other axes\n    def axes_overlap(cA, cB, axes):\n        for axis in axes:\n            a_min, a_max = cA[axis], cA[axis+3]\n            b_min, b_max = cB[axis], cB[axis+3]\n            # Overlap occurs if ranges intersect\n            if a_max <= b_min or b_max <= a_min:\n                return False\n        return True\n\n    # Check neighbors sharing boundary along a given axis\n    def check_boundary(boundary_map1, boundary_map2, axis_idx1, axis_idx2, axis_idx3, axis_idx4):\n        # boundary_map1 and boundary_map2 are dictionaries\n        # axis_idx1 and axis_idx2 are the boundary coordinate keys\n        for boundary_value in boundary_map1:\n            if boundary_value in boundary_map2:\n                list1 = boundary_map1[boundary_value]\n                list2 = boundary_map2[boundary_value]\n                for i in list1:\n                    cA = cub"}
{"task_id": "abc312_f", "solution": "# Read input\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    \n    items = []\n    for i in range(N):\n        T = int(data[2 + 2*i])\n        X = int(data[3 + 2*i])\n        items.append((T, X))\n    \n    # Separate items into lists\n    pull_tabs = []\n    regular_cans = []\n    can_openers = []\n\n    for T, X in items:\n        if T == 0:\n            pull_tabs.append(X)\n        elif T == 1:\n            regular_cans.append(X)\n        else:\n            can_openers.append(X)\n    \n    # Sort descending\n    pull_tabs.sort(reverse=True)\n    regular_cans.sort(reverse=True)\n    can_openers.sort(reverse=True)\n    \n    # Prefix sums\n    def prefix_sums(arr):\n        ps = [0]\n        for x in arr:\n            ps.append(ps[-1] + x)\n        return ps\n    \n    pull_prefix = prefix_sums(pull_tabs)\n    regular_prefix = prefix_sums(regular_cans)\n    total_openers_capacity = sum(can_openers)\n    \n    max_happiness = 0\n    \n    max_pull = min(M, len(pull_tabs))\n    for k in range(max_pull + 1):\n        # Happiness from k pull-tabs\n        happiness = pull_prefix[k]\n        remaining = M - k\n        \n        # Select top remaining regular cans\n        regular_count = min(remaining, len(regular_cans))\n        happiness += regular_prefix[regular_count]\n        \n        # Remaining regular cans beyond the selected ones\n        remaining_regulars = regular_cans[regular_count:]\n        # We can use can openers to unlock some of these\n        # We take the highest happiness regular cans beyond the selected ones\n        # They are already sorted\n        # Use can openers to unlock up to total_openers_capacity cans\n        can_opened = min(total_openers_capacity, len(remaining_regulars))\n        happiness += sum(remaining_regulars[:can_opened])\n        \n        if happiness > max_happiness:\n            max_happiness = happiness\n    \n    print(max_happiness)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc313_a", "solution": "# Read the number of people\nN = int(input())\n\n# Read the programming abilities\nP = list(map(int, input().split()))\n\n# Extract person 1's ability\nP_1 = P[0]\n\n# Find the maximum ability among others\nmax_other = max(P[1:]) if N > 1 else 0\n\n# Calculate the minimum points needed\nx = max(0, max_other - P_1 + 1)\n\n# Output the result\nprint(x)"}
{"task_id": "abc313_b", "solution": "# Read input\nN, M = map(int, input().split())\nrelations = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Initialize the graph\ngraph = [[False] * N for _ in range(N)]\n\n# Fill in known relations\nfor A, B in relations:\n    graph[A - 1][B - 1] = True\n\n# Apply transitive closure (Floyd-Warshall)\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if graph[i][k] and graph[k][j]:\n                graph[i][j] = True\n\n# Find the candidate(s) who are stronger than all others\ncandidates = []\nfor i in range(N):\n    # Check if programmer i is stronger than all others\n    if all(graph[i][j] for j in range(N) if j != i):\n        candidates.append(i + 1)\n\n# Output result\nif len(candidates) == 1:\n    print(candidates[0])\nelse:\n    print(-1)"}
{"task_id": "abc313_c", "solution": "# Read the input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Calculate total sum\ntotal_sum = sum(A)\n\n# Determine the target values\nbase = total_sum // N\nremainder = total_sum % N\n\n# The target levels:\n# - `remainder` elements should be `base + 1`\n# - rest should be `base`\n\n# Count surplus and deficit\nsurplus = 0\ndeficit = 0\n\nfor a in A:\n    if a > base + 1:\n        surplus += a - (base + 1)\n    elif a < base:\n        deficit += (base - a)\n\n# The minimum operations needed is the maximum of surplus and deficit\nprint(max(surplus, deficit))"}
{"task_id": "abc314_a", "solution": "# Store pi to 100 decimal places as a string\npi_str = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n\n# Read input\nN = int(input())\n\n# Extract the required part of pi\nresult = pi_str[:N+2]\n\n# Print the truncated value\nprint(result)"}
{"task_id": "abc314_b", "solution": "# Read the number of players\nN = int(input())\n\n# Initialize list to store each player's outcomes and number of bets\nplayers = []\n\nfor i in range(1, N + 1):\n    C_i = int(input())  # Number of outcomes this player bets on\n    outcomes = list(map(int, input().split()))\n    players.append({'index': i, 'C': C_i, 'outcomes': set(outcomes)})\n\n# Read the spin result\nX = int(input())\n\n# Find players who bet on X\nbetting_players = [p for p in players if X in p['outcomes']]\n\n# If no one bets on X, output 0\nif not betting_players:\n    print(0)\n    print()\nelse:\n    # Find the minimum number of bets among these players\n    min_bets = min(p['C'] for p in betting_players)\n    # Select players with the minimum number of bets\n    result_players = [p['index'] for p in betting_players if p['C'] == min_bets]\n    # Sort the players in ascending order\n    result_players.sort()\n    # Print the count and the players\n    print(len(result_players))\n    print(' '.join(map(str, result_players)))"}
{"task_id": "abc314_c", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndata = input().split()\nN, M = map(int, data[0:2])\nS = list(data[2])\nC = list(map(int, data[3:]))\n\n# Store indices for each color\ncolor_positions = [[] for _ in range(M + 1)]  # 1-based indexing for colors\n\nfor idx, color in enumerate(C):\n    color_positions[color].append(idx)\n\n# Process each color\nfor color in range(1, M + 1):\n    positions = color_positions[color]\n    # Extract characters at these positions\n    chars = [S[pos] for pos in positions]\n    # Rotate right by one\n    if len(chars) > 0:\n        chars = [chars[-1]] + chars[:-1]\n    # Assign back to S\n    for i, pos in enumerate(positions):\n        S[pos] = chars[i]\n\n# Print the final string\nprint(\"\".join(S))"}
{"task_id": "abc314_d", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    S = list(data[1])\n    Q = int(data[2])\n    \n    operations = data[3:]\n    \n    # case_state: 0 = no change, 1 = uppercase, 2 = lowercase\n    case_state = 0\n    \n    for i in range(Q):\n        t = int(operations[3*i])\n        x = int(operations[3*i + 1])\n        c = operations[3*i + 2]\n        \n        if t == 1:\n            # Convert string position to 0-based index\n            idx = x - 1\n            # Update the character based on current case state\n            if case_state == 1:\n                S[idx] = c.upper()\n            elif case_state == 2:\n                S[idx] = c.lower()\n            else:\n                S[idx] = c\n        elif t == 2:\n            # Convert all to uppercase\n            case_state = 1\n        elif t == 3:\n            # Convert all to lowercase\n            case_state = 2\n    \n    # After all operations, apply the final case transformation\n    if case_state == 1:\n        S = [ch.upper() for ch in S]\n    elif case_state == 2:\n        S = [ch.lower() for ch in S]\n    # If case_state == 0, do nothing\n    \n    print(\"\".join(S))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc314_e", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n\n    # Parse input\n    index = 2\n    wheels = []\n    for _ in range(N):\n        C = int(data[index])\n        P = int(data[index+1])\n        outcomes = list(map(int, data[index+2:index+2+P]))\n        index += 2 + P\n        wheels.append((C, outcomes))\n    \n    # Initialize DP array\n    # For points >= M, cost is 0 (absorbing state)\n    # For points < M, initialize with a large number\n    max_points = M  # We only need to compute up to M, beyond that cost is zero\n    dp = [0.0] * (max_points + 1)\n    \n    # For x >= M, dp[x] = 0, so only need to compute from M-1 down to 0\n    # We will iterate from M-1 down to 0\n    for x in range(M - 1, -1, -1):\n        min_expected_cost = float('inf')\n        for C, outcomes in wheels:\n            total = 0.0\n            P = len(outcomes)\n            for s in outcomes:\n                next_state = x + s\n                if next_state >= M:\n                    total += 0  # Already at or beyond M, no additional cost\n                else:\n                    total += dp[next_state]\n            expected_value = C + (total / P)\n            if expected_value < min_expected_cost:\n                min_expected_cost = expected_value\n        dp[x] = min_expected_cost\n\n    # Output the expected minimum cost starting from 0 points\n    print(dp[0])"}
{"task_id": "abc314_f", "solution": "```python\nMOD = 998244353\n\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef modinv(x):\n    # Fermat's little theorem for modular inverse\n    return pow(x, MOD - 2, MOD)\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    N = int(input[0])\n    p_q = input[1:]\n    \n    # Build adjacency list for the tree\n    # Each match merges two teams: p_i and q_i\n    # We'll store the edges as (parent, child) relationships\n    # Since matches are given in sequence, we can reconstruct the tree accordingly.\n    \n    # For convenience, assign each player as a node; internal nodes are matches\n    # but in this problem, match info tells which teams are merged.\n    \n    # We'll model the process as building a tree from bottom up.\n    # But here, since each match merges two teams, and each team is a node,\n    # we can store the parent for each match.\n    \n    parent = [0] * (N + 1)\n    children = [[] for _ in range(N + 1)]\n    \n    # Initially, each player is their own team; assign their node id as their index\n    # For internal nodes, assign new ids from N+1 onwards\n    current_node_id = N\n    # We'll process matches in order\n    matches = []\n    for i in range(N - 1):\n        p_i = int(p_q[2 * i])\n        q_i = int(p_q[2 * i + 1])\n        matches.append((p_i, q_i))\n    \n    # For each match, create a new node representing the merged team\n    # and connect the players/teams as children\n    # We will store the component teams in a structure\n    # Initialize each player as a team node"}
{"task_id": "abc315_a", "solution": "# Read the input string from stdin\nS = input().strip()\n\n# Set of vowels for quick lookup\nvowels = {'a', 'e', 'i', 'o', 'u'}\n\n# Filter out vowels from the string\nresult = ''.join([char for char in S if char not in vowels])\n\n# Print the resulting string\nprint(result)"}
{"task_id": "abc315_b", "solution": "# Read the number of months\nM = int(input())\n\n# Read the list of days in each month\nD = list(map(int, input().split()))\n\n# Calculate total days and middle day\ntotal_days = sum(D)\nmiddle_day = (total_days + 1) // 2\n\n# Find the month and day of the middle day\ncumulative = 0\nfor i in range(M):\n    cumulative += D[i]\n    if cumulative >= middle_day:\n        # The middle day is in month i+1\n        day_in_month = middle_day - (cumulative - D[i])\n        print(i+1, day_in_month)\n        break"}
{"task_id": "abc315_c", "solution": "# Read the inputs\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    F = data[1::2]\n    S = data[2::2]\n    \n    # Convert to integers\n    F = list(map(int, F))\n    S = list(map(int, S))\n    \n    from collections import defaultdict\n    \n    flavor_dict = defaultdict(list)\n    \n    # Organize cups by flavor\n    for f, s in zip(F, S):\n        flavor_dict[f].append(s)\n    \n    max_global = -1\n    second_global = -1\n    \n    max_same_flavor = 0\n    \n    # For each flavor, find top two deliciousness values\n    for flavor, values in flavor_dict.items():\n        values.sort(reverse=True)\n        max1 = values[0]\n        max2 = values[1] if len(values) > 1 else -1\n        # Update global top two\n        if max1 > max_global:\n            second_global = max_global\n            max_global = max1\n        elif max1 > second_global:\n            second_global = max1\n        # Calculate satisfaction for same flavor pairs\n        if max2 != -1:\n            satisfaction_same = max1 + max2 / 2\n            if satisfaction_same > max_same_flavor:\n                max_same_flavor = satisfaction_same\n    \n    # Check the best pair with different flavors\n    max_diff_pair = max_global + second_global\n    \n    # The answer is the maximum of same-flavor and different-flavor pairs\n    answer = max(max_diff_pair, max_same_flavor)\n    print(int(answer))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_d", "solution": "from collections import Counter\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    H, W = map(int, data[:2])\n    grid_lines = data[2:]\n\n    grid = [list(row) for row in grid_lines]\n    \n    while True:\n        marked = [[False]*W for _ in range(H)]\n        any_marked = False\n\n        # Mark rows\n        for i in range(H):\n            counts = Counter(grid[i])\n            for color, count in counts.items():\n                if count >= 2:\n                    for j in range(W):\n                        if grid[i][j] == color:\n                            marked[i][j] = True\n\n        # Mark columns\n        for j in range(W):\n            col = [grid[i][j] for i in range(H)]\n            counts = Counter(col)\n            for color, count in counts.items():\n                if count >= 2:\n                    for i in range(H):\n                        if grid[i][j] == color:\n                            marked[i][j] = True\n\n        # Remove marked cookies\n        for i in range(H):\n            for j in range(W):\n                if marked[i][j]:\n                    grid[i][j] = None\n                    any_marked = True\n\n        if not any_marked:\n            break\n\n    # Count remaining cookies\n    remaining = sum(1 for i in range(H) for j in range(W) if grid[i][j] is not None)\n    print(remaining)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc315_e", "solution": "import sys\nsys.setrecursionlimit(10**7)\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    dependencies = [[] for _ in range(N + 1)]  # dependencies[i]: list of books i depends on\n    reverse_graph = [[] for _ in range(N + 1)]  # reverse_graph[p]: books dependent on p\n    \n    index = 1\n    for i in range(1, N + 1):\n        C_i = int(data[index])\n        index += 1\n        P_i = list(map(int, data[index:index + C_i]))\n        index += C_i\n        dependencies[i] = P_i\n        for p in P_i:\n            reverse_graph[p].append(i)\n    \n    # Step 1: Find all books required to read book 1\n    visited = [False] * (N + 1)\n    def dfs(book):\n        visited[book] = True\n        for prereq in dependencies[book]:\n            if not visited[prereq]:\n                dfs(prereq)\n    \n    dfs(1)\n    \n    # The required books are those visited excluding book 1\n    required_books = [i for i in range(2, N + 1) if visited[i]]\n    \n    # Step 2: Topological sort on the subgraph of required books\n    # Build subgraph\n    subgraph = {i: [] for i in required_books}\n    in_degree = {i: 0 for i in required_books}\n    \n    for book in required_books:\n        for prereq in dependencies[book]:\n            if prereq in subgraph:\n                subgraph[prereq].append(book)\n                in_degree[book] += 1\n    \n    # Kahn's algorithm for topological sort\n    from collections import deque\n    queue = deque()\n    for node in required_books:\n        if in_degree[node] == 0:\n            queue.append(node)\n    \n    topo_order = []\n    while queue:\n        current = queue.popleft()\n        topo_order.append(current)\n        for neighbor in subgraph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # The topological order is the reading order\n    # Exclude book 1 (not in required_books anyway)\n    # Print the order\n    print(' '.join(map(str, topo_order)))"}
{"task_id": "abc315_f", "solution": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    coords = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    \n    # Initialize DP array with infinity\n    dp = [float('inf')] * N\n    dp[0] = 0.0  # starting point\n    \n    for i in range(1, N):\n        x_i, y_i = coords[i]\n        for j in range(i):\n            x_j, y_j = coords[j]\n            dist = math.sqrt((x_j - x_i)**2 + (y_j - y_i)**2)\n            skip_count = i - j - 1\n            penalty = 0.0\n            if skip_count > 0:\n                penalty = pow(2, skip_count - 1)\n            cost = dp[j] + dist + penalty\n            if cost < dp[i]:\n                dp[i] = cost\n    \n    # Output the minimum total cost to reach checkpoint N\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc318_a", "solution": "# Read input values\nN, M, P = map(int, input().split())\n\n# Calculate the number of days he can see a full moon\nif M > N:\n    # The first full moon day is beyond N, so none within range\n    print(0)\nelse:\n    # Compute how many full moon days are on or before N\n    count = ((N - M) // P) + 1\n    print(count)"}
{"task_id": "abc318_b", "solution": "# Read input values\nN = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Initialize a 2D grid to track coverage\ncovered = [[False] * 101 for _ in range(101)]\n\n# Mark the covered cells for each rectangle\nfor A, B, C, D in rectangles:\n    for x in range(A, B):\n        for y in range(C, D):\n            covered[x][y] = True\n\n# Count the total covered cells\narea = sum(sum(1 for cell in row if cell) for row in covered)\n\n# Output the total area\nprint(area)"}
{"task_id": "abc318_c", "solution": "# Read inputs\nN, D, P = map(int, input().split())\nF = list(map(int, input().split()))\n\ntotal_cost = 0\ni = 0\n\nwhile i < N:\n    # Check the next D days or the remaining days\n    segment_end = min(i + D, N)\n    \n    # Sum of fares in current segment\n    sum_segment = sum(F[i:segment_end])\n    \n    # Decide whether to buy a batch or pay individual fares\n    if sum_segment > P:\n        # Cheaper to buy a batch of D passes\n        total_cost += P\n    else:\n        # Cheaper to pay individual fares\n        total_cost += sum_segment\n    i = segment_end\n\nprint(total_cost)"}
{"task_id": "abc318_d", "solution": "def solve():\n    import sys\n    sys.setrecursionlimit(10**7)\n\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    # Read the upper triangle of the matrix, since input is in condensed form\n    D = [[0] * N for _ in range(N)]\n    index = 1\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            D[i][j] = D[j][i] = int(data[index])\n            index += 1\n\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dfs(mask):\n        # If all vertices are matched\n        if mask == (1 << N) - 1:\n            return 0\n\n        # Find the first unmatched vertex\n        for i in range(N):\n            if not (mask & (1 << i)):\n                break\n\n        max_value = 0\n        # Try pairing vertex i with another unmatched vertex j\n        for j in range(i + 1, N):\n            if not (mask & (1 << j)):\n                new_mask = mask | (1 << i) | (1 << j)\n                val = D[i][j] + dfs(new_mask)\n                if val > max_value:\n                    max_value = val\n\n        return max_value\n\n    result = dfs(0)\n    print(result)"}
{"task_id": "abc318_e", "solution": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Step 1: Map each value to its list of indices\n    positions = {}\n    for idx, val in enumerate(A, start=1):\n        positions.setdefault(val, []).append(idx)\n\n    # Step 2: Build prefix sums for each value\n    # We'll create a prefix sum array for each value that indicates\n    # how many times the value has occurred up to each position.\n    prefix_counts = {}\n    for val, inds in positions.items():\n        prefix = [0] * (N + 1)\n        for i in range(1, N + 1):\n            prefix[i] = prefix[i - 1] + (1 if A[i - 1] == val else 0)\n        prefix_counts[val] = prefix\n\n    total_triples = 0\n\n    # Step 3: For each value, process pairs of its occurrence indices\n    for val, inds in positions.items():\n        prefix = prefix_counts[val]\n        length = len(inds)\n        for idx in range(length - 1):\n            start = inds[idx]\n            end = inds[idx + 1]\n            # Number of positions between start and end\n            total_between = end - start - 1\n            # Count of positions with same value between start and end\n            count_same = prefix[end - 1] - prefix[start]\n            # Positions where A_j  A_i\n            count_diff = total_between - count_same\n            total_triples += count_diff\n\n    print(total_triples)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc319_b", "solution": "# Read input\nN = int(input())\n\n# Find divisors j of N with 1 <= j <= 9\ndivisors = [j for j in range(1, 10) if N % j == 0]\n\nresult = []\n\nfor i in range(N + 1):\n    s_i = '-'  # default if no divisor matches\n    for j in sorted(divisors):\n        if i % (N // j) == 0:\n            s_i = str(j)\n            break\n    result.append(s_i)\n\n# Print the resulting string\nprint(''.join(result))"}
{"task_id": "abc319_c", "solution": "import sys\nimport math\nfrom itertools import permutations\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    grid = [list(map(int, input[i*3:(i+1)*3])) for i in range(3)]\n    \n    # All 8 lines: 3 rows, 3 columns, 2 diagonals\n    lines = [\n        # Rows\n        [(0,0),(0,1),(0,2)],\n        [(1,0),(1,1),(1,2)],\n        [(2,0),(2,1),(2,2)],\n        # Columns\n        [(0,0),(1,0),(2,0)],\n        [(0,1),(1,1),(2,1)],\n        [(0,2),(1,2),(2,2)],\n        # Diagonals\n        [(0,0),(1,1),(2,2)],\n        [(0,2),(1,1),(2,0)]\n    ]\n    \n    # Map each cell to its value\n    cell_values = []\n    for i in range(3):\n        for j in range(3):\n            cell_values.append(grid[i][j])\n    \n    total_permutations = 0\n    safe_permutations = 0\n    \n    for perm in permutations(range(9)):\n        # Map each cell index to its position in permutation\n        pos_in_perm = [0]*9\n        for idx, cell in enumerate(perm):\n            pos_in_perm[cell] = idx\n        \n        disappointed = False\n        # Check all lines\n        for line in lines:\n            # Get positions and values\n            positions = [pos_in_perm[cell] for cell in line]\n            # Order cells by position\n            ordered = [line[i] for i in sorted(range(3), key=lambda k: positions[k])]\n            # Get their values in viewing order\n            vals = [cell_values[cell] for cell in ordered]\n            # Check the disappointment condition\n            if vals[0] == vals[1] and vals[2] != vals[0]:\n                disappointed = True\n                break\n        \n        total_permutations += 1\n        if not disappointed:\n            safe_permutations += 1\n    \n    probability = safe_permutations / total_permutations\n    print(probability)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc319_d", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndef can_fit(words, max_width, M):\n    line_count = 1\n    current_width = 0\n    \n    for L in words:\n        # If starting a new line\n        if current_width == 0:\n            # Place the word at the start of the line\n            current_width = L\n        else:\n            # Try to add the word with a preceding space\n            if current_width + 1 + L <= max_width:\n                current_width += 1 + L\n            else:\n                # Need a new line\n                line_count += 1\n                current_width = L\n                if line_count > M:\n                    return False\n    return True\n\ndef main():\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    words = list(map(int, data[2:]))\n\n    low = max(words)\n    high = sum(words) + (N - 1)  # maximum possible width\n\n    while low < high:\n        mid = (low + high) // 2\n        if can_fit(words, mid, M):\n            high = mid\n        else:\n            low = mid + 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc319_e", "solution": "```python\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    P = [0] * (N)  # P[0] unused, P[1]..P[N-1]\n    T = [0] * (N)  # T[0] unused, T[1]..T[N-1]\n    idx = 3\n    for i in range(N-1):\n        P[i] = int(data[idx])\n        T[i] = int(data[idx+1])\n        idx += 2\n\n    Q = int(data[idx])\n    idx += 1\n    q_list = list(map(int, data[idx:idx+Q]))\n\n    # Precompute earliest arrival times at each bus stop\n    # Starting from the last bus stop N (index N-1)\n    # and moving backwards\n    dp = [0] * N  # dp[i]: earliest time to reach bus stop i\n    # For bus stop N (index N-1), just the time to arrive is 0\n    # because from there, walking Y to Aoki's house is final step\n    # We'll add Y after calculating.\n\n    for i in range(N-2, -1, -1):\n        # To arrive at bus stop i, we consider earliest arrival at stop i+1\n        # plus the travel time T[i].\n        # We need to find the earliest bus departure time from stop i\n        # that is >= dp[i+1] - T[i], because bus departs at multiples of P[i]\n        earliest_arrival_next = dp"}
{"task_id": "abc320_a", "solution": "# Read input from stdin\nA, B = map(int, input().split())\n\n# Calculate A^B and B^A\nresult = A ** B + B ** A\n\n# Output the result\nprint(result)"}
{"task_id": "abc320_b", "solution": "# Read the input string from stdin\nS = input().strip()\n\nmax_length = 1  # Since there's always at least one palindrome of length 1\n\nfor start in range(len(S)):\n    for end in range(start, len(S)):\n        substring = S[start:end+1]\n        # Check if the substring is a palindrome\n        if substring == substring[::-1]:\n            # Update max_length if necessary\n            current_length = end - start + 1\n            if current_length > max_length:\n                max_length = current_length\n\nprint(max_length)"}
{"task_id": "abc320_c", "solution": "# Read inputs\nM = int(input().strip())\nS1 = input().strip()\nS2 = input().strip()\nS3 = input().strip()\n\n# Collect positions for each character in each string\npos_map_1 = {}\npos_map_2 = {}\npos_map_3 = {}\n\nfor i, ch in enumerate(S1):\n    pos_map_1.setdefault(ch, []).append(i)\nfor i, ch in enumerate(S2):\n    pos_map_2.setdefault(ch, []).append(i)\nfor i, ch in enumerate(S3):\n    pos_map_3.setdefault(ch, []).append(i)\n\n# Find common characters\ncommon_chars = set(pos_map_1.keys()) & set(pos_map_2.keys()) & set(pos_map_3.keys())\n\nmin_time = float('inf')\nfor c in common_chars:\n    positions1 = pos_map_1[c]\n    positions2 = pos_map_2[c]\n    positions3 = pos_map_3[c]\n    for p1 in positions1:\n        for p2 in positions2:\n            for p3 in positions3:\n                max_time = max(p1, p2, p3)\n                if max_time < min_time:\n                    min_time = max_time\n\nif min_time == float('inf'):\n    print(-1)\nelse:\n    print(min_time)"}
{"task_id": "abc320_d", "solution": "from sys import stdin, stdout\nfrom collections import deque\n\ndef solve():\n    input = stdin.read().strip().split()\n    N, M = int(input[0]), int(input[1])\n    \n    # Adjacency list: for each person, store (neighbor, X, Y)\n    graph = [[] for _ in range(N+1)]\n    \n    index = 2\n    for _ in range(M):\n        A = int(input[index])\n        B = int(input[index+1])\n        X = int(input[index+2])\n        Y = int(input[index+3])\n        index += 4\n        # Add edges (bi-directional)\n        graph[A].append((B, X, Y))\n        graph[B].append((A, -X, -Y))\n    \n    positions = [None] * (N+1)\n    positions[1] = (0, 0)\n    \n    queue = deque([1])\n    \n    while queue:\n        current = queue.popleft()\n        cur_x, cur_y = positions[current]\n        for neighbor, dx, dy in graph[current]:\n            if positions[neighbor] is None:\n                # Assign position based on current\n                positions[neighbor] = (cur_x + dx, cur_y + dy)\n                queue.append(neighbor)\n            else:\n                # Check for consistency (not strictly necessary as problem states input is consistent)\n                expected_x = cur_x + dx\n                expected_y = cur_y + dy\n                if positions[neighbor] != (expected_x, expected_y):\n                    # Inconsistent, but problem guarantees consistency, so ignore\n                    pass\n    \n    # Output results\n    for i in range(1, N+1):\n        if positions[i] is None:\n            stdout.write(\"undecidable\\n\")\n        else:\n            s, t = positions[i]\n            stdout.write(f\"{s} {t}\\n\")"}
{"task_id": "abc320_e", "solution": "import sys\nimport heapq\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    T = [0]*M\n    W = [0]*M\n    S = [0]*M\n    \n    index = 2\n    for i in range(M):\n        T[i] = int(data[index])\n        W[i] = int(data[index+1])\n        S[i] = int(data[index+2])\n        index += 3\n    \n    # Initialize result array\n    result = [0]*N\n    \n    # Queue of persons currently in the row (initially all)\n    queue = deque(range(N))\n    \n    # Min-heap for re-entry events: (time, person)\n    reentry_heap = []\n    \n    # Pointer for re-entry scheduling\n    # Each person will be scheduled once they leave\n    # But since multiple re-entries are possible, handle dynamically\n    \n    # Process all events\n    for i in range(M):\n        current_time = T[i]\n        # Re-insert anyone who is re-entering at or before current_time\n        while reentry_heap and reentry_heap[0][0] <= current_time:\n            time_reenter, person = heapq.heappop(reentry_heap)\n            queue.append(person)\n        \n        # If someone is in the queue, give noodles\n        if queue:\n            person = queue.popleft()\n            result[person] += W[i]\n            # Schedule their re-entry\n            re_entry_time = current_time + S[i]\n            heapq.heappush(reentry_heap, (re_entry_time, person))\n    \n    # Output results\n    for noodles in result:\n        print(noodles)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_a", "solution": "# Read input number as string\nN = input().strip()\n\n# Check if the number is a single-digit number\nif len(N) == 1:\n    print(\"Yes\")\nelse:\n    # Assume the number is 321-like until proven otherwise\n    is_321_like = True\n    for i in range(len(N) - 1):\n        if N[i] <= N[i+1]:\n            is_321_like = False\n            break\n    print(\"Yes\" if is_321_like else \"No\")"}
{"task_id": "abc321_b", "solution": "# Read inputs\nN, X = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Initialize answer to -1 (default if no solution)\nanswer = -1\n\n# Check all possible scores for the Nth round\nfor A_N in range(101):\n    scores = A + [A_N]\n    scores.sort()\n    \n    # Sum middle N-2 scores (exclude smallest and largest)\n    middle_sum = sum(scores[1:N-1])\n    \n    if middle_sum >= X:\n        answer = A_N\n        break  # Since we want the minimum score, can break once found\n\nprint(answer)"}
{"task_id": "abc321_c", "solution": "from itertools import combinations\n\ndef main():\n    K = int(input().strip())\n    numbers = []\n\n    # Generate all non-empty subsets of {1, 2, ..., 9}\n    for size in range(1, 10):\n        for subset in combinations(range(1, 10), size):\n            # Sort subset in decreasing order to form number\n            digits = sorted(subset, reverse=True)\n            num = int(''.join(map(str, digits)))\n            numbers.append(num)\n\n    # Sort all generated numbers\n    numbers.sort()\n\n    # Output the K-th smallest number\n    print(numbers[K - 1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_d", "solution": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, M, P = map(int, data[:3])\n    A = list(map(int, data[3:3+N]))\n    B = list(map(int, data[3+N:3+N+M]))\n\n    B.sort()\n    prefix_B = [0]\n    for b in B:\n        prefix_B.append(prefix_B[-1] + b)\n\n    total = 0\n    for a in A:\n        # Find the index where a + B[idx] >= P\n        idx = bisect.bisect_left(B, P - a)\n        # Sum for pairs where sum < P\n        count_less = idx\n        sum_B_less = prefix_B[count_less]\n        total += a * count_less + sum_B_less\n        # Remaining pairs where sum >= P\n        count_ge = M - count_less\n        total += P * count_ge\n\n    print(total)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc321_e", "solution": "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    T = int(data[0])\n    idx = 1\n    results = []\n\n    for _ in range(T):\n        N = int(data[idx]); idx += 1\n        X = int(data[idx]); idx += 1\n        K = int(data[idx]); idx += 1\n\n        # Find ancestor at distance K\n        ancestor = X\n        for _ in range(K):\n            ancestor = ancestor // 2\n            if ancestor == 0:\n                break\n\n        count = 0\n        # If ancestor is valid, check if it is at distance K\n        # At this point, ancestor is the node at K steps above X (if exists)\n        # We need to verify if moving up K times from X gives this ancestor\n        # which it does by construction.\n        # If ancestor == 0, then no ancestor at K distance\n        if ancestor != 0:\n            # Count descendants at distance K in the subtree rooted at ancestor\n            from collections import deque\n            queue = deque()\n            queue.append((ancestor, 0))\n            while queue:\n                node, depth = queue.popleft()\n                if depth == K:\n                    count += 1\n                elif depth < K:\n                    left = 2 * node\n                    right = 2 * node + 1\n                    if left <= N:\n                        queue.append((left, depth + 1))\n                    if right <= N:\n                        queue.append((right, depth + 1))\n        else:\n            # No ancestor at distance K, only consider descendants if K > 0\n            if K == 0:\n                # The node itself counts\n                count = 1\n            else:\n                # Descendants at distance K from original X\n                from collections import deque\n                queue = deque()\n                queue.append((X, 0))\n                while queue:\n                    node, depth = queue.popleft()\n                    if depth == K:\n                        count += 1\n                    elif depth < K:\n                        left = 2 * node\n                        right = 2 * node + 1\n                        if left <= N:\n                            queue.append((left, depth + 1))\n                        if right <= N:\n                            queue.append((right, depth + 1))\n        results.append(str(count))\n    print(\"\\n\".join(results))"}
{"task_id": "abc322_a", "solution": "# Read inputs\nN = int(input().strip())\nS = input().strip()\n\n# Initialize result as -1 (not found)\nresult = -1\n\n# Loop through the string to find the first occurrence of 'ABC'\nfor i in range(N - 2):\n    if S[i:i+3] == 'ABC':\n        result = i + 1  # Convert to 1-based index\n        break\n\n# Output the result\nprint(result)"}
{"task_id": "abc322_b", "solution": "# Read input values\nN, M = map(int, input().split())\nS = input().strip()\nT = input().strip()\n\n# Check prefix and suffix conditions\nis_prefix = T.startswith(S)\nis_suffix = T.endswith(S)\n\n# Determine and print the result\nif is_prefix and is_suffix:\n    print(0)\nelif is_prefix:\n    print(1)\nelif is_suffix:\n    print(2)\nelse:\n    print(3)"}
{"task_id": "abc322_c", "solution": "# Read input values\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    A = list(map(int, data[2:]))\n\n    result = [0] * N\n    fireworks_idx = 0\n\n    for i in range(1, N + 1):\n        # Move the fireworks index forward until the fireworks day is >= current day\n        while fireworks_idx < M and A[fireworks_idx] < i:\n            fireworks_idx += 1\n        # The current fireworks day is at A[fireworks_idx], which is >= i\n        result[i - 1] = A[fireworks_idx] - i\n\n    # Output the results\n    print('\\n'.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc322_d", "solution": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read().strip().split('\\n')\n    \n    # Read the 16 lines into three 4x4 shapes\n    grid_lines = input\n    shapes = []\n    for i in range(3):\n        shape_cells = []\n        for j in range(4):\n            line = grid_lines[i*4 + j]\n            for k in range(4):\n                if line[k] == '#':\n                    shape_cells.append((j, k))\n        shapes.append(shape_cells)\n    \n    # Function to normalize shape coordinates\n    def normalize(cells):\n        min_r = min(c[0] for c in cells)\n        min_c = min(c[1] for c in cells)\n        normalized = sorted((c[0] - min_r, c[1] - min_c) for c in cells)\n        return normalized\n\n    # Generate all rotations (no flips) of a shape\n    def rotations(shape):\n        rot_shapes = []\n        current = shape\n        for _ in range(4):\n            rot_shapes.append(current)\n            # rotate 90 degrees\n            current = [ (c[1], -c[0]) for c in current ]\n            # normalize after rotation\n            min_r = min(c[0] for c in current)\n            min_c = min(c[1] for c in current)\n            current = sorted((c[0] - min_r, c[1] - min_c) for c in current)\n        # Remove duplicates\n        unique_shapes = []\n        seen = set()\n        for shape_variant in rot_shapes:\n            shape_tuple = tuple(shape_variant)\n            if shape_tuple not in seen:\n                seen.add(shape_tuple)\n                unique_shapes.append(shape_variant)\n        return unique_shapes\n\n    # Generate all orientations for each shape\n    all_shapes = []\n    for shape in shapes:\n        shape_normalized = normalize(shape)\n        all_orients = rotations(shape_normalized)\n        all_shapes.append(all_orients)\n\n    from itertools import permutations, product\n\n    # The grid is 4x4\n    GRID_SIZE = 4\n\n    # Check if shape at position (top-left at (r, c)) fits within grid\n    def fits(shape, r, c):\n        for (dr, dc) in shape:\n            nr, nc = r + dr, c + dc\n            if nr < 0 or nr >= GRID_SIZE or nc < 0 or nc >= GRID_SIZE:\n                return False\n        return True\n\n    # Place shape on grid\n    def place(shape, r, c, grid):\n        for (dr, dc) in shape:\n            nr, nc = r + dr, c + dc\n            grid[nr][nc] = True\n\n    # Remove shape from grid\n    def remove(shape, r, c, grid):\n        for (dr, dc) in shape:\n            nr, nc = r + dr, c + dc\n            grid[nr][nc] = False\n\n    # Try to fill the grid"}
{"task_id": "abc322_e", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    P = int(data[2])\n    \n    plans = []\n    idx = 3\n    for _ in range(N):\n        C = int(data[idx])\n        A = list(map(int, data[idx+1:idx+1+K]))\n        plans.append((C, A))\n        idx += 1 + K\n    \n    from collections import deque\n    import math\n    \n    # Initialize DP dictionary\n    # State: tuple of parameter levels\n    # Value: minimum cost\n    start_state = tuple([0]*K)\n    dp = {start_state: 0}\n    \n    for _ in range(N):\n        new_dp = dict(dp)\n        for state, cost in dp.items():\n            for C, A in plans:\n                new_state = list(state)\n                for j in range(K):\n                    new_state[j] = min(P, new_state[j] + A[j])\n                new_state = tuple(new_state)\n                new_cost = cost + C\n                if new_state not in new_dp or new_dp[new_state] > new_cost:\n                    new_dp[new_state] = new_cost\n        dp = new_dp\n    \n    # Check for goal state\n    answer = -1\n    for state, cost in dp.items():\n        if all(level >= P for level in state):\n            if answer == -1 or cost < answer:\n                answer = cost\n    \n    print(answer)"}
{"task_id": "abc323_a", "solution": "# Read input string\nS = input().strip()\n\n# Check even positions (1-based), which correspond to odd indices in 0-based indexing\nfor i in range(1, 16, 2):\n    if S[i] != '0':\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")"}
{"task_id": "abc323_b", "solution": "# Read the number of players\nN = int(input())\n\n# Read the results strings\nS = [input().strip() for _ in range(N)]\n\n# Calculate wins for each player\nwins = []\nfor i in range(N):\n    count_wins = 0\n    for j in range(N):\n        if i != j:\n            if S[i][j] == 'o':\n                count_wins += 1\n    wins.append((i+1, count_wins))\n\n# Sort players by number of wins (descending), then by player number (ascending)\nwins.sort(key=lambda x: (-x[1], x[0]))\n\n# Output the sorted player numbers\nprint(' '.join(str(player[0]) for player in wins))"}
{"task_id": "abc323_c", "solution": "# Read input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nS = [input().strip() for _ in range(N)]\n\n# Precompute total scores and problem info\nscores = A\nanswers = []\n\nfor i in range(N):\n    # Calculate current score for player i\n    solved_score = 0\n    for j in range(M):\n        if S[i][j] == 'o':\n            solved_score += scores[j]\n    # Add bonus (player index + 1)\n    current_total = solved_score + (i + 1)\n    answers.append(current_total)\n\n# For each player, determine minimum number of problems needed\nfor i in range(N):\n    current_score = answers[i]\n    # Collect unsolved problem scores\n    unsolved_scores = []\n    for j in range(M):\n        if S[i][j] == 'x':\n            unsolved_scores.append(scores[j])\n    # Sort the unsolved scores in descending order for optimal solving\n    unsolved_scores.sort(reverse=True)\n    \n    max_other_score = max(answers[:i] + answers[i+1:])\n    \n    total_unsolved = len(unsolved_scores)\n    answer = total_unsolved  # worst case: solve all remaining problems\n    \n    # Try solving 0 to all unsolved problems\n    prefix_sum = 0\n    for k in range(total_unsolved + 1):\n        if k > 0:\n            prefix_sum += unsolved_scores[k - 1]\n        new_score = current_score - sum(scores[j] for j in range(M) if S[i][j] == 'o') + prefix_sum + (i + 1)\n        # Alternatively, since we have current_score as current total, subtract previous solved sum\n        # But current_score is already calculated as the sum + bonus\n        # To avoid confusion, recompute current_score as:\n        # sum of solved problems + bonus\n        solved_sum = 0\n        for j in range(M):\n            if S[i][j] == 'o':\n                solved_sum += scores[j]\n        new_total_score = solved_sum + prefix_sum + (i + 1)\n        if new_total_score > max_other_score:\n            answer = k\n            break\n    \n    print(answer)"}
{"task_id": "abc323_d", "solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    size_counts = {}\n    \n    # Read initial sizes and counts\n    index = 1\n    for _ in range(N):\n        S = int(data[index])\n        C = int(data[index + 1])\n        index += 2\n        size_counts[S] = size_counts.get(S, 0) + C\n\n    # Use a min-heap to process sizes in increasing order\n    heap = list(size_counts.keys())\n    heapq.heapify(heap)\n\n    # We'll keep track of counts in a separate dictionary\n    counts = size_counts\n\n    # Process until no more sizes to handle\n    while heap:\n        size = heapq.heappop(heap)\n        count = counts.get(size, 0)\n        if count < 2:\n            # No merge possible for this size\n            continue\n        # Number of pairs to merge\n        pairs = count // 2\n        # Remaining slimes after merging\n        counts[size] = count % 2\n        # Add merged slimes to size 2*size\n        new_size = size * 2\n        prev_count = counts.get(new_size, 0)\n        new_count = prev_count + pairs\n        counts[new_size] = new_count\n        # If the count for new_size was zero before, add to heap\n        if new_size not in counts or prev_count == 0:\n            heapq.heappush(heap, new_size)\n\n    # The answer is sum of all remaining slimes\n    result = sum(counts.values())\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc323_e", "solution": "```python\nMOD = 998244353\n\ndef modinv(a, m=MOD):\n    # Modular inverse using Fermat's little theorem since m is prime\n    return pow(a, m-2, m)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    X = int(data[1])\n    T = list(map(int, data[2:]))\n\n    # Convert times to half-seconds\n    T_half = [t * 2 for t in T]\n    target_time_half = X * 2 + 1  # (X + 0.5) seconds in half-seconds\n\n    max_time = target_time_half + max(T_half)  # maximum time we may need to simulate\n\n    # Initialize DP array\n    # Dimensions: time, song, remaining_time\n    # We'll store probabilities as numerator/denominator\n    # To handle probabilities in modular form, store as (num, den)\n    # But since fractions are guaranteed to be irreducible, we can store numerator only\n    # and handle mod inverse when summing.\n    # Alternatively, store as float and convert at the end.\n    # But to adhere strictly, store numerator and denominator separately.\n    from fractions import Fraction\n\n    # Initialize a 3D array of Fra"}
{"task_id": "abc324_a", "solution": "# Read the number of integers\nN = int(input())\n\n# Read the list of integers\nA = list(map(int, input().split()))\n\n# Check if all elements are equal by converting to a set\nif len(set(A)) == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc324_b", "solution": "# Read the input number\nN = int(input())\n\n# Factor out powers of 2\nwhile N % 2 == 0:\n    N //= 2\n\n# Factor out powers of 3\nwhile N % 3 == 0:\n    N //= 3\n\n# Check if the remaining number is 1\nif N == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc324_c", "solution": "# Read input data, process and output results accordingly\nimport sys\n\ndef is_one_char_diff(s, t):\n    # Both strings have same length\n    diff_count = 0\n    for a, b in zip(s, t):\n        if a != b:\n            diff_count += 1\n            if diff_count > 1:\n                return False\n    return diff_count == 1 or diff_count == 0\n\ndef can_transform_by_insertion_or_deletion(s, t):\n    # s longer by 1 (deletion in s), or s shorter by 1 (insertion in s)\n    # We can check both by trying to align with one mismatch\n    len_s = len(s)\n    len_t = len(t)\n    if abs(len_s - len_t) != 1:\n        return False\n\n    # Ensure s is the shorter or equal length\n    if len_s > len_t:\n        s, t = t, s\n        len_s, len_t = len_t, len_s\n\n    i = j = 0\n    mismatch_found = False\n    while i < len_s and j < len_t:\n        if s[i] != t[j]:\n            if mismatch_found:\n                return False\n            mismatch_found = True\n            j += 1  # skip one character in t\n        else:\n            i += 1\n            j += 1\n\n    # If we reached the end of s, remaining in t should be only one character or none\n    return True\n\ndef main():\n    input = sys.stdin.read().split()\n    N = int(input[0])\n    T_prime = input[1]\n    S_list = input[2:]\n\n    results = []\n\n    for i, S in enumerate(S_list, start=1):\n        len_S = len(S)\n        len_T = len(T_prime)\n\n        # Check for no change\n        if S == T_prime:\n            results.append(i)\n            continue\n\n        # Check for same length (possible change)\n        if len_S == len_T:\n            if is_one_char_diff(S, T_prime):\n                results.append(i)\n            continue\n\n        # Check for insertion/deletion (length difference = 1)\n        if abs(len_S - len_T) == 1:\n            if can_transform_by_insertion_or_deletion(S, T_prime):\n                results.append(i)\n            continue\n\n        # If length difference > 1, cannot be derived by one operation\n        # do nothing\n\n    print(len(results))\n    if results:\n        print(' '.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc324_d", "solution": "import math\nfrom itertools import permutations\n\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n\n    digits = list(S)\n    seen_numbers = set()\n    perfect_squares = set()\n\n    # Generate all unique permutations (to avoid duplicates)\n    for perm in set(permutations(digits)):\n        num_str = ''.join(perm)\n        number = int(num_str)\n        if number in seen_numbers:\n            continue\n        seen_numbers.add(number)\n\n        # Check if the number is a perfect square\n        if number >= 0:\n            r = int(math.isqrt(number))\n            if r * r == number:\n                perfect_squares.add(number)\n\n    print(len(perfect_squares))"}
{"task_id": "abc324_e", "solution": "```python\nimport sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    N = int(data[0])\n    T = data[1]\n    S_list = data[2:]\n    \n    # Constraints\n    max_total_length = 5 * 10**5\n    len_T = len(T)\n    \n    # Build next occurrence arrays\n    # For each string, create a 2D array: next_pos[string_index][pos][char]\n    # But to save memory, we'll store per string only a 2D array: next_occur[pos][char]\n    # We'll process each string separately.\n    \n    # Precompute for all strings:\n    next_arrays = []\n    for s in S_list:\n        length = len(s)\n        # Initialize next occurrence: position after the end\n        next_pos_char = [[-1] * 26 for _ in range(length + 1)]\n        # Fill from the end\n        for c in range(26):\n            next_pos_char[length][c] = -1\n        for i in range(length - 1, -1, -1):\n            for c in range(26):\n                next_pos_char[i][c] = next_pos_char[i + 1][c]\n            current_char = ord(s[i]) - ord('a')\n            next_pos_char[i][current_char] = i\n        next_arrays.append(next_pos_char)\n    \n    # count_suffix[k] will store how many strings can match T[k:]\n    count_suffix = [0] * (len_T + 1)\n    \n    total_length = sum(len(s) for s in S_list)\n    \n    # For each string, find how many characters of T can be matched\n    for s_idx, s in enumerate(S_list):\n        next_pos_char = next_arrays[s_idx]\n        pos_in_s = 0\n        matched_chars = 0\n        for c in T:\n            c_idx = ord(c) - ord('a')\n            if pos"}
{"task_id": "abc324_f", "solution": "import sys\nimport math\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    edges = []\n    max_ratio = 0.0\n    \n    idx = 2\n    for _ in range(M):\n        u = int(data[idx])\n        v = int(data[idx+1])\n        b = int(data[idx+2])\n        c = int(data[idx+3])\n        idx += 4\n        edges.append((u, v, b, c))\n        # Track maximum ratio for initial upper bound\n        ratio = b / c\n        if ratio > max_ratio:\n            max_ratio = ratio\n    \n    def can_achieve(R):\n        # Check if there's a path from 1 to N with sum of (b - R * c) >= 0\n        # Use a variant of Bellman-Ford or Dijkstra\n        dist = [-math.inf] * (N + 1)\n        dist[1] = 0.0\n        \n        # Relax edges up to N-1 times\n        for _ in range(N):\n            updated = False\n            for u, v, b, c in edges:\n                weight = b - R * c\n                if dist[u] != -math.inf and dist[u] + weight > dist[v]:\n                    dist[v] = dist[u] + weight\n                    updated = True\n            if not updated:\n                break\n        \n        return dist[N] >= -1e-9  # Allow some floating point tolerance\n    \n    low, high = 0.0, max_ratio\n    for _ in range(60):  # 60 iterations for ~1e-18 precision\n        mid = (low + high) / 2\n        if can_achieve(mid):\n            low = mid\n        else:\n            high = mid\n    \n    print(low)"}
{"task_id": "abc325_a", "solution": "# Read the input line, strip whitespace and split into two parts\nS, T = input().split()\n\n# Output the surname with the honorific \"san\"\nprint(f\"{S} san\")"}
{"task_id": "abc325_b", "solution": "# Read number of bases\nN = int(input())\n\n# Initialize list to hold intervals and employee counts\nintervals = []\n\nfor _ in range(N):\n    W, X = map(int, input().split())\n    start = 9 - X\n    end = 17 - X\n    intervals.append((start, end, W))\n\n# Collect all boundary points\ncandidate_points = set()\nfor start, end, _ in intervals:\n    candidate_points.add(start)\n    candidate_points.add(end)\n\nmax_participants = 0\n\n# Evaluate each candidate point\nfor t in candidate_points:\n    total = 0\n    for start, end, W in intervals:\n        if start <= t <= end:\n            total += W\n    if total > max_participants:\n        max_participants = total\n\nprint(max_participants)"}
{"task_id": "abc325_c", "solution": "# Approach:\n# Use DFS to find connected components of sensors.\n# For each unvisited '#' cell, perform DFS to mark all connected '#' cells.\n# Count how many such DFS invocations are needed.\n\n\ndef main():\n    import sys\n    sys.setrecursionlimit(10**7)\n    input = sys.stdin.read\n    \n    data = input().split()\n    H, W = map(int, data[0:2])\n    grid_lines = data[2:]\n    \n    grid = [list(line) for line in grid_lines]\n    visited = [[False] * W for _ in range(H)]\n    \n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),           (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    \n    def dfs(x, y):\n        stack = [(x, y)]\n        visited[x][y] = True\n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < H and 0 <= ny < W:\n                    if not visited[nx][ny] and grid[nx][ny] == '#':\n                        visited[nx][ny] = True\n                        stack.append((nx, ny))\n    \n    sensor_count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#' and not visited[i][j]:\n                sensor_count += 1\n                dfs(i, j)\n    \n    print(sensor_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_d", "solution": "# Read input and implement the greedy algorithm\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    products = []\n\n    # Parse input\n    idx = 1\n    for _ in range(N):\n        T = int(data[idx])\n        D = int(data[idx + 1])\n        idx += 2\n        start = T\n        end = T + D\n        products.append((start, end))\n    \n    # Sort products by their end time\n    products.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_print_time = -1  # Initialize to a time before any possible printing\n    \n    for start, end in products:\n        # Determine earliest feasible print time\n        print_time = max(start, last_print_time + 1)\n        if print_time <= end:\n            # Schedule the print\n            last_print_time = print_time\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc325_e", "solution": "```python\nimport sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, A, B, C = map(int, data[:4])\n    D = []\n    index = 4\n    for _ in range(N):\n        row = list(map(int, data[index:index+N]))\n        index += N\n        D.append(row)\n    \n    # Initialize distances\n    INF = float('inf')\n    dist_car = [INF] * N\n    dist_train = [INF] * N\n    \n    # Starting at city 1 (index 0)\n    dist_car[0] = 0\n    dist_train[0] = C  # switch immediately to train at city 1\n    \n    # Priority queue elements: (cost, city, mode)\n    # mode: 0 for car, 1 for train\n    pq = []\n    heapq.heappush(pq, (dist_car[0], 0, 0))\n    heapq.heappush(pq, (dist_train[0], 0, 1))\n    \n    while pq:\n        cost, u, mode = heapq.heappop(pq)\n        if mode == 0:\n            if cost > dist_car[u]:\n                continue\n            # From city u in car mode\n            for v in range(N):\n                if u == v:\n                    continue\n                travel_time_car = D[u][v] * A\n                if dist_car[v] > dist_car[u] + travel_time_car:\n                    dist_car[v] = dist_car[u] + travel_time_car\n                    heapq.heappush(pq, (dist_car[v], v, 0))\n                # Switch to train at city v\n                travel_time_train = D[u][v] * B + C\n                if dist_train[v] > dist_car[u] + travel_time_train:\n                    dist_train[v] = dist_car[u] + travel_time_train\n                    heapq.heappush(pq, (dist_train[v], v, 1))\n        else:\n            if cost > dist_train[u]:\n                continue\n            # From city u in train mode\n            for v in range(N):\n                if u == v:\n                    continue\n                travel_time_train = D[u][v] * B"}
{"task_id": "abc325_f", "solution": "```python\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    D = list(map(int, data[1:1+N]))\n    \n    L1, C1, K1 = map(int, data[1+N:4+N])\n    L2, C2, K2 = map(int, data[4+N:7+N])\n    \n    # Precompute minimal cost to cover length x with unlimited sensors of each type\n    max_length = max(D) if D else 0\n\n    # For each length up to max D, compute minimal cost for covering that"}
{"task_id": "abc326_a", "solution": "# Read input\nX, Y = map(int, input().split())\n\n# Calculate the absolute difference\ndiff = abs(X - Y)\n\n# Check and output the result\nif diff <= 3:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc326_b", "solution": "N = int(input())\n\nfor num in range(N, 1000):\n    hundreds = num // 100\n    tens = (num // 10) % 10\n    ones = num % 10\n    if hundreds * tens == ones:\n        print(num)\n        break"}
{"task_id": "abc326_c", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Sort the coordinates\n    A.sort()\n\n    max_gifts = 0\n    left = 0\n\n    # Use two pointers to find maximum gifts in interval\n    for right in range(N):\n        # Move left pointer to maintain interval condition\n        while A[right] - A[left] >= M:\n            left += 1\n        # Update maximum gifts count\n        max_gifts = max(max_gifts, right - left + 1)\n\n    print(max_gifts)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc326_d", "solution": "```python\ndef solve():\n    N = int(input().strip())\n    R = input().strip()\n    C = input().strip()\n\n    # Initialize the grid with '.'\n    grid = [['.' for _ in range(N)] for _ in range(N)]\n    \n    # Track used characters per row and column\n    row_used = [set() for _ in range(N)]\n    col_used = [set() for _ in range(N)]\n    \n    # Fix the first column according to R\n    for i in range(N):\n        ch = R[i]\n        # Place character at grid[i][0]\n        if grid[i][0] != '.' and grid[i][0] != ch:\n            print(\"No\")\n            return\n        # Check for conflicts in row and column\n        if ch in row_used[i] or ch in col_used[0]:\n            print(\"No\")\n            return\n        grid[i][0] = ch\n        row_used[i].add(ch)\n        col_used[0].add(ch)\n        \n    # Fix the first row according to C\n    for j in range(N):\n        ch = C[j]\n        # Place character at grid[0][j]\n        if grid[0][j] != '.' and grid[0][j] != ch:\n            print(\"No\")\n            return\n        # Check for conflicts\n        if ch in row_used[0] or ch in col_used[j]:\n            print(\"No\")\n            return\n        grid[0][j] = ch\n        row_used[0].add(ch)\n        col_used[j].add(ch)\n    \n    # Function to check if we can place character ch at (i, j)\n    def can_place(i, j, ch):\n        # Check if character is already used in row or column\n        if ch in row_used[i] or ch in col_used[j]:\n            return False\n        return True\n    \n    # Recursive backtracking to fill the grid\n    def backtrack(r):\n        if r == N:\n            # All rows processed, verify column constraints\n            for j in range(N):\n                # Count characters in column j\n                col_chars = set(grid[i][j] for i in range(N))\n                if len(col_chars) != 3 or set(['A','B','C']) != set(ch for ch in col_chars):\n                    return False\n            return True\n\n        # For the current row, fill cells from 1 to N-1 (0th is fixed)\n        # Collect the set of characters already in this row\n        used_in_row = set(grid[r][j] for j in range(N))\n        # Remaining characters to place\n        remaining_chars = {'A','B','C'} - used_in_row\n\n        # Find position to fill next\n        for j in range(1, N):\n            if grid[r][j] == '.':\n                # Try placing each remaining character\n                for ch in remaining_chars:\n                    if can_place(r, j, ch):\n                        grid[r][j] = ch\n                        row_used[r].add(ch)\n                        col_used[j].add(ch)\n                        remaining_chars.remove(ch)\n                        if backtrack(r + (j == N - 1)):\n                            return True\n                        # backtrack\n                        grid[r][j] = '.'\n                        row_used[r].remove(ch)\n                        col_used"}
{"task_id": "abc326_e", "solution": "MOD = 998244353\n\ndef modinv(a, m=MOD):\n    # Fermat's little theorem: a^(m-2) mod m\n    return pow(a, m-2, m)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # 1-based indexing for convenience\n    A = [0] + A\n\n    # Prefix sums for A\n    sum_A = [0] * (N + 2)\n    for i in range(N, 0, -1):\n        sum_A[i] = (sum_A[i+1] + A[i]) % MOD\n\n    # Initialize dp array\n    dp = [0] * (N + 2)\n    # sum_dp for prefix sums of dp\n    sum_dp = [0] * (N + 2)\n\n    invN = modinv(N, MOD)\n\n    # Compute from the end\n    for i in range(N, 0, -1):\n        # sum of A_y + dp_y for y > i\n        total = (sum_A[i+1] + sum_dp[i+1]) % MOD\n        dp[i] = (total * invN) % MOD\n        sum_dp[i] = (dp[i] + sum_dp[i+1]) % MOD\n\n    # The expected value starting from x=0\n    print(dp[1] % MOD)"}
{"task_id": "abc327_a", "solution": "# Read the length of the string\nN = int(input().strip())\n\n# Read the string\nS = input().strip()\n\n# Iterate through adjacent pairs\nfor i in range(N - 1):\n    # Check if adjacent characters are 'a' and 'b' in any order\n    if (S[i] == 'a' and S[i+1] == 'b') or (S[i] == 'b' and S[i+1] == 'a'):\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"}
{"task_id": "abc327_b", "solution": "B = int(input().strip())\n\n# Since A^A grows very fast, check only A up to 60\nlow, high = 1, 60\nresult = -1\n\nwhile low <= high:\n    mid = (low + high) // 2\n    val = pow(mid, mid)\n    if val == B:\n        result = mid\n        break\n    elif val < B:\n        low = mid + 1\n    else:\n        high = mid - 1\n\nprint(result)"}
{"task_id": "abc327_c", "solution": "def solve():\n    # Read the 9x9 grid\n    grid = [list(map(int, input().split())) for _ in range(9)]\n    \n    # Check rows\n    for row in grid:\n        if set(row) != set(range(1, 10)):\n            print(\"No\")\n            return\n    \n    # Check columns\n    for col_idx in range(9):\n        col = [grid[row_idx][col_idx] for row_idx in range(9)]\n        if set(col) != set(range(1, 10)):\n            print(\"No\")\n            return\n    \n    # Check 3x3 subgrids\n    for box_row in range(0, 9, 3):\n        for box_col in range(0, 9, 3):\n            block = []\n            for i in range(3):\n                for j in range(3):\n                    block.append(grid[box_row + i][box_col + j])\n            if set(block) != set(range(1, 10)):\n                print(\"No\")\n                return\n    \n    # If all checks are passed\n    print(\"Yes\")"}
{"task_id": "abc327_d", "solution": "def main():\n    import sys\n    sys.setrecursionlimit(10**7)\n    input = sys.stdin.read\n    data = input().split()\n\n    N, M = map(int, data[0:2])\n    A = list(map(int, data[2:2+M]))\n    B = list(map(int, data[2+M:2+2*M]))\n\n    # Build the adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for i in range(M):\n        a, b = A[i], B[i]\n        adj[a].append(b)\n        adj[b].append(a)\n\n    color = [-1] * (N + 1)\n\n    def bfs(start):\n        from collections import deque\n        queue = deque()\n        color[start] = 0\n        queue.append(start)\n        while queue:\n            u = queue.popleft()\n            for v in adj[u]:\n                if color[v] == -1:\n                    color[v] = 1 - color[u]\n                    queue.append(v)\n                elif color[v] == color[u]:\n                    # Same color on both ends of an edge -> not bipartite\n                    return False\n        return True\n\n    for node in range(1, N + 1):\n        if color[node] == -1:\n            if not bfs(node):\n                print(\"No\")\n                return\n\n    print(\"Yes\")"}
{"task_id": "abc327_e", "solution": "import math\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:]))\n\n    # Initialize variables\n    weighted_sum = 0.0\n    sum_weights = 0.0\n    max_rating = -float('inf')\n\n    for i in range(N):\n        # Update weighted sum and weight with the current contest\n        weighted_sum = weighted_sum * 0.9 + P[i]\n        sum_weights = sum_weights * 0.9 + 1\n\n        # Number of contests selected is (i+1)\n        k = i + 1\n        # Calculate the weighted average\n        Q = weighted_sum / sum_weights\n        # Calculate the rating\n        R = Q - 1200 / math.sqrt(k)\n\n        # Track maximum rating\n        if R > max_rating:\n            max_rating = R\n\n    # Output the maximum rating with appropriate precision\n    print(f\"{max_rating:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc328_a", "solution": "# Read inputs\nN, X = map(int, input().split())\nS = list(map(int, input().split()))\n\n# Compute total score for problems with score <= X\ntotal_score = sum(score for score in S if score <= X)\n\n# Output the result\nprint(total_score)"}
{"task_id": "abc328_b", "solution": "def is_repdigit(num):\n    s = str(num)\n    return all(d == s[0] for d in s)\n\n# Read inputs\nN = int(input())\nD = list(map(int, input().split()))\n\ncount = 0\nfor i in range(1, N + 1):\n    if is_repdigit(i):  # Check if month number is repdigit\n        for j in range(1, D[i - 1] + 1):\n            if is_repdigit(j):  # Check if day number is repdigit\n                count += 1\n\nprint(count)"}
{"task_id": "abc328_c", "solution": "# Read input values\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN, Q = map(int, data[0:2])\nS = data[2]\nqueries = data[3:]\n\n# Precompute diffs array\ndiffs = [0] * (N - 1)\nfor i in range(N - 1):\n    if S[i] == S[i + 1]:\n        diffs[i] = 1\n\n# Build prefix sums\nprefix_counts = [0] * N\nfor i in range(1, N):\n    prefix_counts[i] = prefix_counts[i - 1] + diffs[i - 1]\n\n# Process each query\nindex = 0\noutput = []\nfor _ in range(Q):\n    l = int(queries[index])\n    r = int(queries[index + 1])\n    index += 2\n    # Convert to zero-based index\n    l -= 1\n    r -= 1\n    if l == r:\n        # Single character, no consecutive pairs\n        output.append('0')\n    else:\n        result = prefix_counts[r] - prefix_counts[l]\n        output.append(str(result))\n\n# Print results\nprint('\\n'.join(output))"}
{"task_id": "abc328_d", "solution": "# Read the input string from stdin\nS = input().strip()\n\nstack = []\n\nfor char in S:\n    stack.append(char)\n    # Check if the last three characters form \"ABC\"\n    if len(stack) >= 3 and ''.join(stack[-3:]) == 'ABC':\n        # Remove the last three characters\n        del stack[-3:]\n\n# Output the final string\nprint(''.join(stack))"}
{"task_id": "abc328_e", "solution": "import sys\nfrom itertools import combinations\n\ndef solve():\n    input = sys.stdin.read().strip().split()\n    N = int(input[0])\n    M = int(input[1])\n    K = int(input[2])\n    edges = []\n    idx = 3\n    for _ in range(M):\n        u = int(input[idx])\n        v = int(input[idx+1])\n        w = int(input[idx+2])\n        edges.append((u, v, w))\n        idx += 3\n\n    min_cost = K  # Since weights are modulo K, max cost is K-1, so initialize with K for minimization\n    \n    # Generate all combinations of edges of size N-1\n    for combo in combinations(edges, N-1):\n        # Check connectivity using Union-Find\n        parent = list(range(N+1))\n        \n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n        \n        def union(a, b):\n            pa = find(a)\n            pb = find(b)\n            if pa != pb:\n                parent[pb] = pa\n                return True\n            return False\n\n        # Union all edges in combo\n        for u, v, _ in combo:\n            union(u, v)\n\n        # Check if all vertices are connected\n        root = find(1)\n        if all(find(i) == root for i in range(1, N+1)):\n            # Compute sum of weights modulo K\n            total_w = sum(w for _, _, w in combo) % K\n            if total_w < min_cost:\n                min_cost = total_w\n\n    print(min_cost)"}
{"task_id": "abc329_a", "solution": "# Read input string from stdin\nS = input().strip()\n\n# Join each character with a space\nresult = ' '.join(S)\n\n# Print the result\nprint(result)"}
{"task_id": "abc329_b", "solution": "# Read the number of integers\nN = int(input())\n\n# Read the list of integers\nA = list(map(int, input().split()))\n\n# Find the maximum value in A\nmax_value = max(A)\n\n# Filter out all occurrences of max_value\nnot_max = [x for x in A if x != max_value]\n\n# Find the largest among the remaining integers\nresult = max(not_max)\n\n# Output the result\nprint(result)"}
{"task_id": "abc329_c", "solution": "# Read inputs\nN = int(input().strip())\nS = input().strip()\n\n# Initialize variables\ntotal_substrings = 0\ncurrent_char = None\ncurrent_length = 0\n\nfor ch in S:\n    if ch == current_char:\n        # Continue the current run\n        current_length += 1\n    else:\n        # End of the current run, add its contribution\n        if current_char is not None:\n            total_substrings += current_length * (current_length + 1) // 2\n        # Start a new run\n        current_char = ch\n        current_length = 1\n\n# Add the last run\ntotal_substrings += current_length * (current_length + 1) // 2\n\n# Output the result\nprint(total_substrings)"}
{"task_id": "abc329_d", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize counts\ncounts = [0] * (N + 1)  # 1-based indexing for convenience\nmax_votes = 0\ncurrent_winner = 1\n\nfor vote in A:\n    counts[vote] += 1\n    if counts[vote] > max_votes:\n        max_votes = counts[vote]\n        current_winner = vote\n    elif counts[vote] == max_votes:\n        # Tie-break by smaller candidate number\n        if vote < current_winner:\n            current_winner = vote\n    print(current_winner)"}
{"task_id": "abc329_e", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    S = data[2]\n    T = data[3]\n    \n    # Array to mark positions where T can be placed\n    can_place = [False] * N\n    \n    # Identify all positions where T matches in S\n    for i in range(N - M + 1):\n        if S[i:i+M] == T:\n            can_place[i] = True\n            \n    # Array to mark which positions are covered after placement\n    covered = [False] * N\n    \n    # Greedy placement: place T where possible starting from left\n    for i in range(N - M + 1):\n        if can_place[i]:\n            for j in range(i, i + M):\n                covered[j] = True\n    \n    # Check if entire S is covered\n    if all(covered[i] for i in range(N)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc329_f", "solution": "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, Q = int(data[0]), int(data[1])\n    C = list(map(int, data[2:2+N]))\n    queries = data[2+N:]\n    \n    # Disjoint Set Union (Union-Find) with extra data for sets of colors\n    parent = list(range(N))\n    size = [1] * N\n    color_sets = [set([C[i]]) for i in range(N)]\n    \n    def find(x):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n    \n    def union(a, b):\n        a = find(a)\n        b = find(b)\n        if a != b:\n            # Union by size\n            if size[a] < size[b]:\n                a, b = b, a\n            # Now a is the larger set\n            parent[b] = a\n            # Merge color sets\n            color_sets[a].update(color_sets[b])\n            size[a] += size[b]\n        return find(b)\n    \n    index = 0\n    output = []\n    for _ in range(Q):\n        a = int(queries[index]) - 1\n        b = int(queries[index + 1]) - 1\n        index += 2\n        # Move all balls from a to b\n        root_a = find(a)\n        root_b = find(b)\n        if root_a != root_b:\n            # Merge the sets\n            new_root = union(root_a, root_b)\n        else:\n            new_root = root_b\n        # Print the number of distinct colors in box b after merging\n        output.append(str(len(color_sets[new_root])))\n    \n    print(\"\\n\".join(output))\n    \nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc330_a", "solution": "# Read integers N and L\nN, L = map(int, input().split())\n# Read list of scores\nA = list(map(int, input().split()))\n\n# Count how many scores are at least L\npass_count = sum(1 for score in A if score >= L)\n\n# Output the result\nprint(pass_count)"}
{"task_id": "abc330_b", "solution": "# Read inputs\nN, L, R = map(int, input().split())\nA = list(map(int, input().split()))\n\nresult = []\n\nfor A_i in A:\n    # If A_i is within [L, R], select A_i directly\n    if L <= A_i <= R:\n        result.append(A_i)\n    else:\n        # Calculate distances to boundaries\n        dist_L = abs(L - A_i)\n        dist_R = abs(R - A_i)\n        # Choose the closer boundary; if tie, pick L\n        if dist_L <= dist_R:\n            result.append(L)\n        else:\n            result.append(R)\n\n# Output result\nprint(' '.join(map(str, result)))"}
{"task_id": "abc330_c", "solution": "import math\nimport sys\n\ndef main():\n    D = int(sys.stdin.read().strip())\n    min_diff = float('inf')\n    max_x = int(math.isqrt(D)) + 1\n\n    for x in range(max_x + 1):\n        x_sq = x * x\n        if x_sq > D:\n            # Since x^2 > D, y^2 should be zero or negative (not possible), so skip\n            continue\n        remaining = D - x_sq\n        y_candidate = int(math.isqrt(remaining))\n        \n        # Check y = y_candidate\n        for y in [y_candidate, y_candidate + 1]:\n            if y >= 0:\n                diff = abs(x_sq + y * y - D)\n                if diff < min_diff:\n                    min_diff = diff\n    print(min_diff)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc330_d", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    S = data[1:]\n    \n    # Count total 'o's in each column\n    col_counts = [0] * N\n    for row in S:\n        for j, ch in enumerate(row):\n            if ch == 'o':\n                col_counts[j] += 1\n                \n    answer = 0\n    \n    # For each row, gather columns with 'o'\n    for row in S:\n        o_cols = [j for j, ch in enumerate(row) if ch == 'o']\n        length = len(o_cols)\n        # For each pair of 'o's in the same row\n        for i in range(length):\n            for j in range(i + 1, length):\n                col1 = o_cols[i]\n                col2 = o_cols[j]\n                # Count triples contributed by this pair\n                answer += (col_counts[col1] - 1) * (col_counts[col2] - 1)\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc330_e", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, Q = map(int, data[:2])\n    A = list(map(int, data[2:2+N]))\n    queries = data[2+N:]\n\n    # We only need to track counts for values 0 to N+1\n    max_value = N + 1\n\n    counts = [0] * (max_value + 1)\n\n    # Initialize counts\n    for val in A:\n        if 0 <= val <= max_value:\n            counts[val] += 1\n\n    # Initialize current_mex\n    current_mex = 0\n    while current_mex <= max_value and counts[current_mex] > 0:\n        current_mex += 1\n\n    # Process queries\n    for q in range(Q):\n        i_idx = 2 * q\n        i_k = int(queries[i_idx]) - 1  # zero-based index\n        x_k = int(queries[i_idx + 1])\n\n        old_value = A[i_k]\n        # Decrement count of the old value\n        if 0 <= old_value <= max_value:\n            counts[old_value] -= 1\n\n        # Update the array\n        A[i_k] = x_k\n\n        # Increment count for new value\n        if 0 <= x_k <= max_value:\n            counts[x_k] += 1\n\n        # Adjust current_mex\n        while current_mex <= max_value and counts[current_mex] > 0:\n            current_mex += 1\n\n        print(current_mex)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc331_a", "solution": "# Read the first line: M D\nM, D = map(int, input().split())\n\n# Read the second line: y m d\ny, m, d = map(int, input().split())\n\nif d < D:\n    # Just move to the next day in the same month\n    y_next, m_next, d_next = y, m, d + 1\nelse:\n    # End of the month\n    if m < M:\n        # Next month in the same year\n        y_next, m_next, d_next = y, m + 1, 1\n    else:\n        # End of the year\n        y_next, m_next, d_next = y + 1, 1, 1\n\n# Output the result\nprint(y_next, m_next, d_next)"}
{"task_id": "abc331_b", "solution": "# Read inputs\nN, S, M, L = map(int, input().split())\n\n# Initialize answer with a large value\nmin_cost = float('inf')\n\n# Since N <= 100, loop over possible counts of 12-egg packs\nfor a in range(0, (N // 12) + 2):\n    for b in range(0, (N // 8) + 2):\n        # Calculate total eggs from a and b\n        eggs_from_ab = 12 * a + 8 * b\n        # If total eggs from a and b already  N, no need for 6-egg packs\n        if eggs_from_ab >= N:\n            total_eggs = eggs_from_ab\n            total_cost = L * a + M * b\n            if total_cost < min_cost:\n                min_cost = total_cost\n        else:\n            # Need some 6-egg packs\n            remaining = N - eggs_from_ab\n            c = (remaining + 6 - 1) // 6  # Ceiling division\n            total_eggs = eggs_from_ab + 6 * c\n            total_cost = L * a + M * b + S * c\n            if total_cost < min_cost:\n                min_cost = total_cost\n\nprint(min_cost)"}
{"task_id": "abc331_c", "solution": "# Read input\nimport sys\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    N = int(input[0])\n    A = list(map(int, input[1:]))\n\n    maxA = max(A)\n\n    # Initialize frequency array\n    freq = [0] * (maxA + 1)\n\n    # Fill frequency array\n    for num in A:\n        freq[num] += 1\n\n    # Compute prefix sums of frequencies and weighted sums\n    cum_freq = [0] * (maxA + 1)\n    cum_weighted_sum = [0] * (maxA + 1)\n\n    for i in range(1, maxA + 1):\n        cum_freq[i] = cum_freq[i-1] + freq[i]\n        cum_weighted_sum[i] = cum_weighted_sum[i-1] + i * freq[i]\n\n    total_sum = cum_weighted_sum[maxA]\n\n    # For each A_i, find sum of elements greater than A_i\n    result = []\n    for num in A:\n        sum_greater = total_sum - cum_weighted_sum[num]\n        result.append(str(sum_greater))\n\n    # Print the result\n    print(' '.join(result))\n    \nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc331_d", "solution": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    Q = int(data[1])\n    pattern_data = data[2:2+N]\n    queries_data = data[2+N:]\n\n    # Build the pattern grid\n    P = pattern_data\n\n    # Compute prefix sums for the pattern grid\n    prefix = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(N):\n        for j in range(N):\n            prefix[i+1][j+1] = prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\n            if P[i][j] == 'B':\n                prefix[i+1][j+1] += 1\n\n    # Total black cells in one full pattern\n    total_black_in_pattern = prefix[N][N]\n\n    # Helper function to get black count in a sub-pattern\n    def pattern_black_count(r1, c1, r2, c2):\n        # r1, c1, r2, c2 are inclusive indices in the pattern\n        return prefix[r2+1][c2+1] - prefix[r2+1][c1] - prefix[r1][c2+1] + prefix[r1][c1]\n\n    # Function to compute black squares in rectangle [A, B, C, D]\n    def query(A, B, C, D):\n        # Break down rectangle into pattern tiles\n        # Compute the number of full pattern tiles along rows and columns\n        A_tile_row = A // N\n        B_tile_col = B // N\n        C_tile_row = C // N\n        D_tile_col = D // N\n\n        # Calculate the number of full pattern blocks\n        full_rows = C_tile_row - A_tile_row - 1\n        full_cols = D_tile_col - B_tile_col - 1\n\n        # Initialize total black count\n        total = 0\n\n        # Add full pattern tiles contribution\n        total += max(0, full_rows) * max(0, full_cols)"}
{"task_id": "abc331_e", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N, M, L = map(int, data[0:3])\n    a = list(map(int, data[3:3+N]))\n    b = list(map(int, data[3+N:3+N+M]))\n\n    forbidden_pairs = data[3+N+M:]\n    forbidden = dict()\n\n    # Build forbidden pairs structure\n    for i in range(L):\n        c = int(forbidden_pairs[2*i]) - 1\n        d = int(forbidden_pairs[2*i+1]) - 1\n        if c not in forbidden:\n            forbidden[c] = set()\n        forbidden[c].add(d)\n\n    # Prepare sorted list of side dishes indices in descending order of price\n    # along with their prices for quick access\n    side_with_indices = sorted([(b_j, j) for j, b_j in enumerate(b)], key=lambda x: x[0], reverse=True)\n\n    max_a = max(a)\n    max_b = max(b)\n\n    # Initial answer assuming the best pair without restrictions\n    answer = max_a + max_b\n\n    for i in range(N):\n        # For main dish i, try to find the best side dish not forbidden\n        forbidden_set = forbidden.get(i, set())\n        for price_b, j in side_with_indices:\n            if j not in forbidden_set:\n                candidate = a[i] + price_b\n                if candidate > answer:\n                    answer = candidate\n                # Since side_with_indices is sorted descending, the first valid is the best\n                break\n\n    print(answer)"}
{"task_id": "abc332_a", "solution": "# Read initial inputs\nN, S, K = map(int, input().split())\n\ntotal_price = 0\nfor _ in range(N):\n    P, Q = map(int, input().split())\n    total_price += P * Q\n\n# Determine shipping fee\nif total_price >= S:\n    shipping_fee = 0\nelse:\n    shipping_fee = K\n\n# Calculate total amount to pay\ntotal_amount = total_price + shipping_fee\n\n# Output the result\nprint(total_amount)"}
{"task_id": "abc332_b", "solution": "# Read inputs\nK, G, M = map(int, input().split())\n\n# Initialize water amounts\nglass = 0\nmug = 0\n\nfor _ in range(K):\n    if glass == G:\n        # Discard water from glass\n        glass = 0\n    elif mug == 0:\n        # Fill the mug with water\n        mug = M\n    else:\n        # Transfer water from mug to glass\n        space_in_glass = G - glass\n        transfer_amount = min(mug, space_in_glass)\n        glass += transfer_amount\n        mug -= transfer_amount\n\n# Output the final amounts\nprint(glass, mug)"}
{"task_id": "abc332_c", "solution": "#\n        # So, at each '1' or '2' day, we decrement counts.\n        # At '0', we just restore all T-shirts used in previous days.\n        #"}
{"task_id": "abc332_d", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    H, W = map(int, data[0:2])\n    A_vals = data[2:2+H*W]\n    B_vals = data[2+H*W:2+2*H*W]\n    \n    A = [A_vals[i*W:(i+1)*W] for i in range(H)]\n    B = [B_vals[i*W:(i+1)*W] for i in range(H)]\n    \n    from collections import Counter\n    \n    # Step 1: Check frequency counts\n    counter_A = Counter()\n    counter_B = Counter()\n    for row in A:\n        counter_A.update(row)\n    for row in B:\n        counter_B.update(row)\n    \n    if counter_A != counter_B:\n        print(-1)\n        return\n    \n    # Step 2: Find row permutation\n    # Map each row in B to its index (for quick lookup)\n    row_map_B = {}\n    for i, row in enumerate(B):\n        row_tuple = tuple(row)\n        if row_tuple not in row_map_B:\n            row_map_B[row_tuple] = []\n        row_map_B[row_tuple].append(i)\n    \n    row_perm = [0]*H\n    used_rows_in_B = [False]*H\n    \n    for i, row in enumerate(A):\n        row_tuple = tuple(row)\n        # Find a matching row in B\n        if row_tuple not in row_map_B:\n            print(-1)\n            return\n        # Assign the first unused matching row\n        for j in row_map_B[row_tuple]:\n            if not used_rows_in_B[j]:\n                row_perm[i] = j\n                used_rows_in_B[j] = True\n                break\n        else:\n            # No available match\n            print(-1)\n            return\n    \n    # Step 3: Find column permutation\n    # For columns, similar approach\n    col_map_B = {}\n    for j in range(W):\n        col = tuple(B[i][j] for i in range(H))\n        if col not in col_map_B:\n            col_map_B[col] = []\n        col_map_B[col].append(j)\n    \n    col_perm = [0]*W\n    used_cols_in_B = [False]*W\n    \n    for j in range(W):\n        col = tuple(A[i][j] for i in range(H))\n        if col not in col_map_B:\n            print(-1)\n            return\n        for k in col_map_B[col]:\n            if not used_cols_in_B[k]:\n                col_perm[j] = k\n                used_cols_in_B[k] = True\n                break\n        else:\n            print(-1)\n            return\n    \n    # Helper function to compute minimum swaps to match permutation\n    def min_swaps_to_sort(perm):\n        visited = [False]*len(perm)\n        swaps = 0\n        for i in range(len(perm)):\n            if not visited[i]:\n                cycle_length = 0\n                j = i\n                while not visited[j]:\n                    visited[j] = True\n                    j = perm[j]\n                    cycle_length += 1\n                if cycle_length > 1:\n                    swaps += cycle_length - 1\n        return swaps\n    \n    total_swaps = min_swaps_to_sort(row_perm) + min_swaps_to_sort(col_perm)\n    print(total_swaps)"}
{"task_id": "abc333_a", "solution": "# Read the integer N from input\nN = int(input())\n\n# Convert N to string\ndigit_str = str(N)\n\n# Concatenate N copies of the digit\nresult = digit_str * N\n\n# Print the result\nprint(result)"}
{"task_id": "abc333_b", "solution": "# Read inputs\nS_1S_2 = input().strip()\nT_1T_2 = input().strip()\n\n# Map vertices to indices\nvertex_map = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}\n\n# Extract points\ns1, s2 = S_1S_2[0], S_1S_2[1]\nt1, t2 = T_1T_2[0], T_1T_2[1]\n\n# Convert to indices\ns1_idx = vertex_map[s1]\ns2_idx = vertex_map[s2]\nt1_idx = vertex_map[t1]\nt2_idx = vertex_map[t2]\n\n# Function to compute minimal cyclic distance\ndef cyclic_distance(a, b):\n    diff = abs(a - b)\n    return min(diff, 5 - diff)\n\n# Calculate distances\ndist_S = cyclic_distance(s1_idx, s2_idx)\ndist_T = cyclic_distance(t1_idx, t2_idx)\n\n# Compare and output result\nif dist_S == dist_T:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc333_c", "solution": "# Read input\nN = int(input())\n\n# Generate repunits: for lengths 1 to 15\nrepunits = [int('1' * length) for length in range(1, 16)]\n\n# Generate all sums of three repunits\nsums_set = set()\nfor a in repunits:\n    for b in repunits:\n        for c in repunits:\n            sums_set.add(a + b + c)\n\n# Convert to sorted list\nsums_list = sorted(sums_set)\n\n# Output the N-th smallest sum\nprint(sums_list[N - 1])"}
{"task_id": "abc333_d", "solution": "from collections import deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    edges = data[1:]\n    \n    # Build adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for i in range(0, 2 * (N - 1), 2):\n        u = int(edges[i])\n        v = int(edges[i + 1])\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # BFS to find the depth of each node from vertex 1\n    depth = [-1] * (N + 1)\n    depth[1] = 0\n    queue = deque([1])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in adj[node]:\n            if depth[neighbor] == -1:\n                depth[neighbor] = depth[node] + 1\n                queue.append(neighbor)\n    \n    # The answer is the maximum depth value\n    print(max(depth))\n    \nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc333_e", "solution": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    events = []\n    for i in range(N):\n        t = int(data[2*i + 1])\n        x = int(data[2*i + 2])\n        events.append((t, x))\n    \n    # Step 1: Identify all monster types needed and their positions\n    needed_types = set()\n    for t, x in events:\n        if t == 2:\n            needed_types.add(x)\n\n    # Step 2: For each potion type, we'll keep track of whether we decide to pick it up\n    # We'll also need to record actions for potion events\n    actions = [0] * N  # 1 if pick up, 0 if discard, only relevant for t_i=1 events\n    potion_in_hand = {}\n    max_potions = 0\n\n    # To minimize max, we decide to pick up potions only when necessary:\n    # - When we encounter a monster, if we don't have the potion, we must have previously picked it up.\n    # - To do this consistently and minimize max, we'll simulate forward:\n    # Since multiple strategies are possible, a greedy approach is suitable:\n    # - For each potion event, pick it up if it will be needed later or for immediate use.\n    # - Otherwise, discard.\n\n    # We'll process events and keep track of future needs\n    # First, build a list of future positions for each potion type\n    future_positions = {}\n    for idx, (t, x) in enumerate(events):\n        if t == 2:\n            future_positions.setdefault(x, []).append(idx)\n        elif t == 1:\n            future_positions.setdefault(x, []).append(idx)\n\n    # For each potion type, maintain a pointer to the next position where it is needed\n    next_need_idx = {}\n    for x in future_positions:\n        # For each potion type, initialize the pointer to the first occurrence\n        future_positions[x].reverse()  # To facilitate popping from end\n        next_need_idx[x] = len(future_positions[x]) - 1\n\n    potion_picked = [False] * N  # record if we pick potion"}
{"task_id": "abc334_a", "solution": "# Read the integers B and G from input\nB, G = map(int, input().split())\n\n# Compare and print the result\nif B > G:\n    print(\"Bat\")\nelse:\n    print(\"Glove\")"}
{"task_id": "abc334_b", "solution": "# Read input values\nA, M, L, R = map(int, input().split())\n\n# Calculate k_min: smallest integer k such that A + k * M >= L\nk_min = -((- (L - A)) // M)\n\n# Calculate k_max: largest integer k such that A + k * M <= R\nk_max = (R - A) // M\n\n# Calculate the number of trees in the range\nif k_max < k_min:\n    print(0)\nelse:\n    print(k_max - k_min + 1)"}
{"task_id": "abc334_c", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, K = int(data[0]), int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Initialize counts: each color starts with 2 socks\n    counts = [2] * N\n\n    # Reduce counts for lost socks\n    for color in A:\n        counts[color - 1] -= 1\n\n    # Build list of remaining socks\n    socks = []\n    for i in range(N):\n        socks.extend([i + 1] * counts[i])\n    \n    total_socks = len(socks)\n    pairs = total_socks // 2\n\n    # Pair adjacent socks to minimize total weirdness\n    total_weirdness = 0\n    for i in range(0, pairs * 2, 2):\n        total_weirdness += abs(socks[i] - socks[i + 1])\n\n    print(total_weirdness)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc334_d", "solution": "# Approach:\n# 1. Read input values.\n# 2. Sort the list of reindeer requirements R.\n# 3. Compute prefix sums of sorted R.\n# 4. For each query X, use binary search on prefix sums\n#    to determine maximum number of sleighs that can be pulled.\n# 5. Output the result for each query.\n\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    N, Q = map(int, input[0:2])\n    R = list(map(int, input[2:2+N]))\n    queries = list(map(int, input[2+N:2+N+Q]))\n    \n    R.sort()\n    prefix_sums = [0]\n    for r in R:\n        prefix_sums.append(prefix_sums[-1] + r)\n    \n    # For each query, use binary search to find the maximum number of sleighs\n    for X in queries:\n        # bisect_right returns the insertion point to maintain sorted order\n        # We want the largest index i where prefix_sums[i] <= X\n        idx = bisect.bisect_right(prefix_sums, X) - 1\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc334_e", "solution": "MOD = 998244353\n\nimport sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.read\n\ndef modinv(a, m=MOD):\n    # Fermat's little theorem: a^(m-2) mod m\n    return pow(a, m - 2, m)\n\ndef solve():\n    data = input().split()\n    H, W = map(int, data[0:2])\n    grid = data[2:]\n    \n    # Directions for neighbors\n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n    \n    # Step 1: Find initial green connected components\n    component_id = [[-1]*W for _ in range(H)]\n    comp_count = 0\n    \n    def bfs(sx, sy):\n        from collections import deque\n        queue = deque()\n        queue.append((sx, sy))\n        component_id[sx][sy] = comp_count\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W:\n                    if grid[nx][ny] == '#' and component_id[nx][ny] == -1:\n                        component_id[nx][ny] = comp_count\n                        queue.append((nx, ny))\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#' and component_id[i][j] == -1:\n                bfs(i, j)\n                comp_count += 1\n    \n    # Step 2: For each red cell, find neighboring green components\n    total_red = 0\n    sum_new_components = 0\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                total_red += 1\n                neighbor_comps = set()\n                for dx, dy in directions:\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < H and 0 <= ny < W:\n                        if grid[nx][ny] == '#':\n                            neighbor_comps.add(component_id[nx][ny])\n                merged = len(neighbor_comps)\n                new_components = comp_count - merged + 1\n                sum_new_components += new_components\n    \n    if total_red == 0:\n        # If no red cells, then no expected value (though problem guarantees at least one red)\n        print(0)\n        return\n    \n    inv_red = modinv(total_red)\n    answer = (sum_new_components * inv_red) % MOD\n    \n    print(answer)\n\n# Run the solution\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "abc335_a", "solution": "# Read the input string\nS = input().strip()\n\n# Replace the last character with '4'\nmodified_string = S[:-1] + '4'\n\n# Print the result\nprint(modified_string)"}
{"task_id": "abc335_b", "solution": "# Read the input value N\nN = int(input().strip())\n\n# Iterate through all possible triples\nfor x in range(N + 1):\n    for y in range(N + 1):\n        for z in range(N + 1):\n            if x + y + z <= N:\n                print(x, y, z)"}
{"task_id": "abc335_c", "solution": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, Q = int(data[0]), int(data[1])\n\n    # Initialize head position\n    head_x, head_y = 1, 0\n    \n    # offsets for each part (1-indexed)\n    dx = [0] * (N + 1)\n    dy = [0] * (N + 1)\n    for i in range(1, N + 1):\n        dx[i] = i - 1\n        dy[i] = 0\n\n    # Process queries\n    idx = 2\n    output = []\n    for _ in range(Q):\n        query_type = int(data[idx])\n        idx += 1\n        if query_type == 1:\n            C = data[idx]\n            idx += 1\n            if C == 'R':\n                head_x += 1\n            elif C == 'L':\n                head_x -= 1\n            elif C == 'U':\n                head_y += 1\n            elif C == 'D':\n                head_y -= 1\n        else:\n            p = int(data[idx])\n            idx += 1\n            x = head_x + dx[p]\n            y = head_y + dy[p]\n            output.append(f\"{x} {y}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc335_d", "solution": "# Read input\nN = int(input())\n\n# Initialize grid\ngrid = [[0] * N for _ in range(N)]\n\n# Center position\nmid = (N + 1) // 2 - 1\n\n# Directions for adjacency: up, down, left, right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\nfrom collections import deque\n\n# BFS initialization\nqueue = deque()\ngrid[mid][mid] = 1  # Place Takahashi\nqueue.append((mid, mid, 1))\n\n# BFS traversal to assign parts\nwhile queue:\n    i, j, num = queue.popleft()\n    next_num = num + 1\n    for dx, dy in directions:\n        ni, nj = i + dx, j + dy\n        if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 0:\n            grid[ni][nj] = next_num\n            queue.append((ni, nj, next_num))\n\n# Output the grid\nfor i in range(N):\n    row = []\n    for j in range(N):\n        if i == mid and j == mid:\n            row.append('T')\n        else:\n            row.append(str(grid[i][j]))\n    print(' '.join(row))"}
{"task_id": "abc336_a", "solution": "# Read the input value for N\nN = int(input())\n\n# Construct the Dragon String of level N\ndragon_string = 'L' + ('o' * N) + 'n' + 'g'\n\n# Output the result\nprint(dragon_string)"}
{"task_id": "abc336_b", "solution": "# Read input integer N\nN = int(input())\n\n# Compute the number of trailing zeros\nctz = (N & -N).bit_length() - 1\n\n# Print the result\nprint(ctz)"}
{"task_id": "abc336_c", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n\n    # Digits mapping\n    digits = [0, 2, 4, 6, 8]\n    base = 5\n\n    # Special case: if N=1, answer is 0\n    if N == 1:\n        print(0)\n        return\n\n    count = 1  # Counting '0' as the first good integer\n    length = 1\n\n    # Find the length of the N-th good integer\n    while True:\n        total_numbers_current_length = base ** length\n        if count + total_numbers_current_length >= N:\n            break\n        count += total_numbers_current_length\n        length += 1\n\n    # Calculate the offset within the current length\n    offset = N - count - 1  # zero-based index\n\n    # Convert offset to base-5 with length 'length'\n    digits_in_number = []\n    for _ in range(length):\n        digits_in_number.append(offset % base)\n        offset //= base\n    digits_in_number.reverse()\n\n    # Map base-5 digits to actual even digits\n    result_digits = [digits[d] for d in digits_in_number]\n\n    # Convert list of digits to integer\n    result_str = ''.join(str(d) for d in result_digits)\n    print(int(result_str))"}
{"task_id": "abc336_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Binary search over the possible pyramid sizes\n    low, high = 1, (N + 1) // 2\n    result = 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        length = 2 * mid - 1\n\n        # Generate the pattern for current mid\n        pattern = [min(i + 1, 2 * mid - 1 - i) for i in range(length)]\n\n        # Check if there's any subarray of length 'length' suitable\n        can_form = False\n        for start in range(N - length + 1):\n            # Validate the subarray\n            valid = True\n            for i in range(length):\n                if A[start + i] < pattern[i]:\n                    valid = False\n                    break\n            if valid:\n                can_form = True\n                break\n\n        if can_form:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc337_a", "solution": "# Read the number of matches\nN = int(input())\n\ntotal_takahashi = 0\ntotal_aoki = 0\n\n# Loop through each match and accumulate scores\nfor _ in range(N):\n    X, Y = map(int, input().split())\n    total_takahashi += X\n    total_aoki += Y\n\n# Determine the winner or if it's a draw\nif total_takahashi > total_aoki:\n    print(\"Takahashi\")\nelif total_aoki > total_takahashi:\n    print(\"Aoki\")\nelse:\n    print(\"Draw\")"}
{"task_id": "abc337_b", "solution": "S = input().strip()\n\n# States: 'A' phase, 'B' phase, 'C' phase\nphase = 'A'\n\nfor ch in S:\n    if phase == 'A':\n        if ch == 'A':\n            continue\n        elif ch == 'B':\n            phase = 'B'  # switch to B phase\n        else:\n            # if character is 'C' before B phase starts, it's invalid\n            print(\"No\")\n            break\n    elif phase == 'B':\n        if ch == 'B':\n            continue\n        elif ch == 'C':\n            phase = 'C'  # switch to C phase\n        else:\n            # if character is 'A' again, invalid\n            print(\"No\")\n            break\n    else:  # phase == 'C'\n        if ch != 'C':\n            # any character other than 'C' after C phase started is invalid\n            print(\"No\")\n            break\nelse:\n    # If loop completes without break, sequence is valid\n    print(\"Yes\")"}
{"task_id": "abc337_c", "solution": "# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Initialize an array to hold the person behind each person\nnext_person = [-1] * (N + 1)\n\n# Find the front person\nfront = -1\nfor i in range(1, N + 1):\n    if A[i - 1] == -1:\n        front = i\n    else:\n        # person A[i-1] is in front of person i\n        next_person[A[i - 1]] = i\n\n# Reconstruct the line\nresult = []\ncurrent = front\nwhile current != -1:\n    result.append(current)\n    current = next_person[current]\n\n# Output the reconstructed line\nprint(' '.join(map(str, result)))"}
{"task_id": "abc337_d", "solution": "# Approach:\n# - Read input\n# - Process rows: find minimal '.' count in any window of length K\n# - Process columns: do the same\n# - Take the minimum over all\n# - Output the result or -1 if impossible\n\nH, W, K = map(int, input().split())\nS = [input().strip() for _ in range(H)]\n\n# Edge case: if K is larger than both dimensions, impossible\nif K > H and K > W:\n    print(-1)\n    exit()\n\n# Initialize min_operations with a large number\nmin_operations = float('inf')\n\n# Process rows\nfor i in range(H):\n    count_dot = 0\n    # Count dots in the first window\n    for j in range(K):\n        if S[i][j] == '.':\n            count_dot += 1\n    # Update min_operations\n    min_operations = min(min_operations, count_dot)\n    # Slide over the row\n    for j in range(K, W):\n        if S[i][j] == '.':\n            count_dot += 1\n        if S[i][j - K] == '.':\n            count_dot -= 1\n        min_operations = min(min_operations, count_dot)\n\n# Process columns\nfor j in range(W):\n    count_dot = 0\n    # Count dots in the first window\n    for i in range(K):\n        if S[i][j] == '.':\n            count_dot += 1\n    min_operations = min(min_operations, count_dot)\n    # Slide down the column\n    for i in range(K, H):\n        if S[i][j] == '.':\n            count_dot += 1\n        if S[i - K][j] == '.':\n            count_dot -= 1\n        min_operations = min(min_operations, count_dot)\n\n# If min_operations is still infinity, it means no sequence is possible\nif min_operations == float('inf'):\n    print(-1)\nelse:\n    print(min_operations)"}
{"task_id": "abc337_e", "solution": "import math\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    \n    # Calculate the minimum number of friends needed\n    M = math.ceil(math.log2(N))\n    \n    # Prepare the distribution for each friend based on binary encoding\n    distributions = []\n    for i in range(M):\n        bottles_for_friend = []\n        for bottle in range(1, N + 1):\n            # Check if the i-th bit (from right, 0-based) is set\n            if (bottle >> i) & 1:\n                bottles_for_friend.append(bottle)\n        distributions.append(bottles_for_friend)\n    \n    # Output the number of friends\n    print(M)\n    # Output each friend's distribution\n    for bottles in distributions:\n        print(len(bottles), *bottles)\n    sys.stdout.flush()\n    \n    # Read the response string S\n    S = sys.stdin.read().strip()\n    \n    # Reconstruct the bad bottle based on S\n    bad_bottle = 0\n    for i, ch in enumerate(S):\n        if ch == '1':\n            bad_bottle |= (1 << i)\n    \n    # Output the identified bad bottle\n    print(bad_bottle)\n    sys.stdout.flush()\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc338_a", "solution": "# Read the input string from standard input\nS = input().strip()\n\n# Check if the first character is uppercase and the rest are lowercase\nif S[0].isupper() and S[1:].islower():\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"task_id": "abc338_b", "solution": "from collections import Counter\n\n# Read input string\nS = input().strip()\n\n# Count the frequency of each character\ncounter = Counter(S)\n\n# Find the maximum frequency\nmax_freq = max(counter.values())\n\n# Filter characters with maximum frequency\nmax_chars = [char for char, freq in counter.items() if freq == max_freq]\n\n# Get the earliest character in alphabetical order\nresult = min(max_chars)\n\n# Output the result\nprint(result)"}
{"task_id": "abc338_c", "solution": "# Read inputs\nN = int(input().strip())\nQ = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nmax_servings = 0\n\n# Find an upper bound for x\n# For each ingredient with A_i > 0, maximum x is Q_i // A_i\n# To cover all, take the minimum over these\nmax_x_bound = 0\nfor i in range(N):\n    if A[i] > 0:\n        max_x_bound = max(max_x_bound, Q[i] // A[i])\n\n# Iterate over possible x\nfor x in range(max_x_bound + 1):\n    feasible = True\n    min_y = float('inf')  # to store the limiting y for current x\n    \n    for i in range(N):\n        # Check if x servings of dish A are feasible\n        if A[i] * x > Q[i]:\n            feasible = False\n            break\n        # If B_i == 0, no limit on y from this ingredient\n        if B[i] == 0:\n            continue\n        # Max y from this ingredient\n        remaining = Q[i] - A[i] * x\n        y_max = remaining // B[i]\n        if y_max < min_y:\n            min_y = y_max\n    if feasible:\n        total = x + min_y\n        if total > max_servings:\n            max_servings = total\n\nprint(max_servings)"}
{"task_id": "abc338_d", "solution": "# Approach:\n# - Compute the total initial shortest path sum.\n# - For each pair, determine the bridges on the shortest path.\n# - Accumulate contributions for each bridge.\n# - Find the maximum contribution and subtract from total initial sum.\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X = list(map(int, data[2:]))\n\n    total_distance = 0\n    # For each pair, compute shortest distance\n    # and the set of bridges on the shortest path\n    # We'll store the contributions for each bridge\n    contributions = [0] * N  # 0-based for bridges\n\n    for i in range(M - 1):\n        a = X[i]\n        b = X[i+1]\n        diff = abs(a - b)\n        dist = min(diff, N - diff)\n        total_distance += dist\n\n        # Determine the direction of shortest path\n        # and which bridges are on that path\n        # We'll analyze both directions and pick minimal\n\n        # Clockwise distance\n        cw_dist = diff\n        # Counter-clockwise distance\n        ccw_dist = N - diff\n\n        # Starting point for the shortest path\n        if cw_dist <= ccw_dist:\n            # Shortest path is clockwise from min(a, b) to max(a, b)\n            start = min(a, b)\n            end = max(a, b)\n            # Bridges on this path are from start to end-1 (1-based)\n            for bridge in range(start, end):\n                contributions[bridge - 1] += dist\n        else:\n            # Shortest path is counter-clockwise\n            # from end to start wrapping around\n            start = max(a, b) + 1\n            end = min(a, b) + N\n            for bridge in range(start, end):\n                contributions[(bridge - 1) % N] += dist\n\n    max_reduction = max(contributions)\n    print(total_distance - max_reduction)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc338_e", "solution": "import sys\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    N = int(data[0])\n    points = data[1:]\n    \n    chords = []\n    for i in range(N):\n        A = int(points[2*i])\n        B = int(points[2*i + 1])\n        if A > B:\n            A, B = B, A\n        chords.append((A, B))\n    \n    # Sort by starting point\n    chords.sort(key=lambda x: x[0])\n    \n    # Extract all B endpoints for coordinate compression\n    B_values = [b for _, b in chords]\n    unique_B = sorted(set(B_values))\n    \n    # Map each B to its compressed index\n    def compress(val):\n        # Binary search in unique_B\n        import bisect\n        return bisect.bisect_left(unique_B, val) + 1  # 1-based index for Fenwick Tree\n    \n    # Fenwick Tree (Binary Indexed Tree) for counting\n    size = len(unique_B)\n    fenw = [0] * (size + 1)\n    \n    def fenw_update(idx):\n        while idx <= size:\n            fenw[idx] += 1\n            idx += idx & -idx\n    \n    def fenw_query(idx):\n        s = 0\n        while idx > 0:\n            s += fenw[idx]\n            idx -= idx & -idx\n        return s\n    \n    # Check for intersections\n    for A, B in chords:\n        B_idx = compress(B)\n        # Count how many B_j > B\n        count_greater = fenw_query(size) - fenw_query(B_idx)\n        if count_greater > 0:\n            print(\"Yes\")\n            return\n        fenw_update(B_idx)\n    \n    print(\"No\")"}
{"task_id": "abc338_f", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N, M = int(data[0]), int(data[1])\n    edges = data[2:]\n    \n    # Initialize distance matrix\n    INF = float('inf')\n    dist = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        dist[i][i] = 0\n    \n    # Read edges\n    for i in range(M):\n        U = int(edges[3*i]) - 1\n        V = int(edges[3*i+1]) - 1\n        W = int(edges[3*i+2])\n        dist[U][V] = min(dist[U][V], W)\n    \n    # Floyd-Warshall to compute all-pairs shortest paths\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i][k] != INF and dist[k][j] != INF:\n                    if dist[i][j] > dist[i][k] + dist[k][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n    \n    # Check reachability: ensure each vertex is reachable from some starting point\n    # and can reach every other vertex\n    for i in range(N):\n        for j in range(N):\n            if dist[i][j] == INF:\n                # If there's no path from i to j\n                # Check if all vertices are mutually reachable\n                continue\n    \n    # For the problem, it's enough to check if for each pair (i,j), dist[i][j] != INF\n    for i in range(N):\n        for j in range(N):\n            if dist[i][j] == INF:\n                # Not all vertices are mutually reachable\n                print(\"No\")\n                return\n    \n    # DP over subsets\n    size = 1 << N\n    dp = [[INF] * N for _ in range(size)]\n    \n    # Initialize: starting at each vertex\n    for v in range(N):\n        dp[1 << v][v] = 0\n    \n    for mask in range(size):\n        for v in range(N):\n            if dp[mask][v] == INF:\n                continue\n            # Try to go to next vertex u\n            for u in range(N):\n                if mask & (1 << u) == 0:\n                    new_mask = mask | (1 << u)\n                    cost = dp[mask][v] + dist[v][u]\n                    if cost < dp[new_mask][u]:\n                        dp[new_mask][u] = cost\n    \n    full_mask = (1 << N) - 1\n    ans = min(dp[full_mask])\n    if ans == INF:\n        print(\"No\")\n    else:\n        print(ans)"}
{"task_id": "abc339_a", "solution": "S = input().strip()\n# Find the last occurrence of '.'\nlast_dot_index = S.rfind('.')\n# Slice from the character after the last '.' to the end\nresult = S[last_dot_index + 1:]\nprint(result)"}
{"task_id": "abc339_b", "solution": "# Read inputs\nH, W, N = map(int, input().split())\n\n# Initialize grid\ngrid = [['.' for _ in range(W)] for _ in range(H)]\n\n# Directions: Up, Right, Down, Left\ndirections = [(-1, 0), (0, 1), (1, 0), (0, -1)]\ndir_idx = 0  # Start facing Up\n\n# Starting position\nrow, col = 0, 0\n\nfor _ in range(N):\n    current_cell = grid[row][col]\n    if current_cell == '.':\n        # White cell: paint black, turn clockwise\n        grid[row][col] = '#'\n        dir_idx = (dir_idx + 1) % 4\n    else:\n        # Black cell: paint white, turn counterclockwise\n        grid[row][col] = '.'\n        dir_idx = (dir_idx - 1) % 4\n\n    # Move forward\n    dr, dc = directions[dir_idx]\n    row = (row + dr) % H\n    col = (col + dc) % W\n\n# Print the final grid\nfor row in grid:\n    print(''.join(row))"}
{"task_id": "abc339_c", "solution": "# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Initialize prefix sum and minimum prefix sum\nprefix_sum = 0\nmin_prefix_sum = 0\n\n# Calculate prefix sums and track the minimum\nfor a in A:\n    prefix_sum += a\n    if prefix_sum < min_prefix_sum:\n        min_prefix_sum = prefix_sum\n\n# Compute initial passengers to satisfy non-negativity constraints\ninitial_passengers = -min_prefix_sum\n\n# Compute the total sum of all A_i to find current passengers\ntotal_change = sum(A)\n\n# Final current number of passengers\ncurrent_passengers = initial_passengers + total_change\n\nprint(current_passengers)"}
{"task_id": "abc339_d", "solution": "from collections import deque\n\ndef main():\n    N = int(input().strip())\n    grid = [input().strip() for _ in range(N)]\n    \n    # Find the initial positions of the two players\n    players = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'P':\n                players.append((i, j))\n    (r1, c1), (r2, c2) = players\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Visited states: 4D array or set\n    # Using a set for memory efficiency\n    visited = set()\n    visited.add((r1, c1, r2, c2))\n    \n    # BFS queue: contains tuples of ((r1, c1), (r2, c2), moves)\n    queue = deque()\n    queue.append(((r1, c1), (r2, c2), 0))\n    \n    while queue:\n        (pr1, pc1), (pr2, pc2), dist = queue.popleft()\n        \n        # Check if players are on the same cell\n        if pr1 == pr2 and pc1 == pc2:\n            print(dist)\n            return\n        \n        for dr, dc in directions:\n            # Attempt to move player 1\n            nr1, nc1 = pr1 + dr, pc1 + dc\n            if not (0 <= nr1 < N and 0 <= nc1 < N) or grid[nr1][nc1] == '#':\n                nr1, nc1 = pr1, pc1  # Player 1 stays if move invalid\n            \n            # Attempt to move player 2\n            nr2, nc2 = pr2 + dr, pc2 + dc\n            if not (0 <= nr2 < N and 0 <= nc2 < N) or grid[nr2][nc2] == '#':\n                nr2, nc2 = pr2, pc2  # Player 2 stays if move invalid\n            \n            state = (nr1, nc1, nr2, nc2)\n            if state not in visited:\n                visited.add(state)\n                queue.append(((nr1, nc1), (nr2, nc2), dist + 1))\n    \n    # If BFS completes without players meeting\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc340_a", "solution": "A, B, D = map(int, input().split())\n\nsequence = []\ncurrent = A\nwhile current <= B:\n    sequence.append(str(current))\n    current += D\n\nprint(\" \".join(sequence))"}
{"task_id": "abc340_b", "solution": "Q = int(input())\nA = []\n\nfor _ in range(Q):\n    query = input().split()\n    t = int(query[0])\n    \n    if t == 1:\n        x = int(query[1])\n        A.append(x)\n    elif t == 2:\n        k = int(query[1])\n        print(A[-k])"}
{"task_id": "abc340_c", "solution": "import sys\nsys.setrecursionlimit(10**7)\n\ndef total_cost(x, memo):\n    if x == 1:\n        return 0\n    if x in memo:\n        return memo[x]\n    left = x // 2\n    right = (x + 1) // 2\n    result = x + total_cost(left, memo) + total_cost(right, memo)\n    memo[x] = result\n    return result\n\ndef main():\n    N = int(sys.stdin.read())\n    memo = {}\n    answer = total_cost(N, memo)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc340_d", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    A = [0] * (N+1)\n    B = [0] * (N+1)\n    X = [0] * (N+1)\n\n    # Read input data\n    for i in range(1, N):\n        A[i] = int(data[3*(i-1)+1])\n        B[i] = int(data[3*(i-1)+2])\n        X[i] = int(data[3*(i-1)+3])\n\n    # Initialize dp array with a large number\n    INF = 10**15\n    dp = [INF] * (N+1)\n    dp[1] = 0  # Starting at stage 1\n\n    for i in range(1, N):\n        # Move to next stage\n        if i+1 <= N:\n            if dp[i] + A[i] < dp[i+1]:\n                dp[i+1] = dp[i] + A[i]\n        # Jump to stage X_i\n        if X[i] <= N:\n            if dp[i] + B[i] < dp[X[i]]:\n                dp[X[i]] = dp[i] + B[i]\n\n    print(dp[N])"}
{"task_id": "abc340_e", "solution": "# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN, M = int(data[0]), int(data[1])\nA = list(map(int, data[2:2+N]))\nB = list(map(int, data[2+N:2+N+M]))\n\n# Initialize difference array\ndiff = [0] * (N + 1)  # Extra element to handle wrap-around updates easily\n\nfor b in B:\n    count = A[b]\n    # Remove all balls from box b\n    diff[b] -= count\n    \n    start = (b + 1) % N\n    end = (b + count) % N\n\n    if count == 0:\n        continue\n\n    if start <= end:\n        # Continuous range\n        diff[start] += count\n        if end + 1 <= N - 1:\n            diff[end + 1] -= count\n    else:\n        # Wrap-around range\n        diff[start] += count\n        if end + 1 <= N - 1:\n            diff[end + 1] -= count\n        # Since it wraps around, also add the range from 0 to end\n        diff[0] += count\n        diff[end + 1] -= count\n\n# Compute prefix sum to get the total increments\nfor i in range(1, N):\n    diff[i] += diff[i - 1]\n\n# Final counts: initial A plus increments\nresult = [A[i] + diff[i] for i in range(N)]\n\n# Output the result\nprint(' '.join(map(str, result)))"}
{"task_id": "abc341_a", "solution": "# Read the input\nN = int(input().strip())\n\n# Generate the pattern\nresult = ''.join('1' if i % 2 == 0 else '0' for i in range(2 * N + 1))\n\n# Print the result\nprint(result)"}
{"task_id": "abc341_b", "solution": "# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    S = [0]*(N-1)\n    T = [0]*(N-1)\n    idx = 1 + N\n    for i in range(N-1):\n        S[i] = int(data[idx])\n        T[i] = int(data[idx+1])\n        idx += 2\n\n    # Process each country from 1 to N-1\n    for i in range(N-1):\n        # Number of times we can perform the operation\n        k = A[i] // S[i]\n        # Update current and next country units\n        A[i] -= k * S[i]\n        A[i+1] += k * T[i]\n    \n    # Output the maximum units in country N\n    print(A[-1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_c", "solution": "# Approach:\n\n# 1. Read inputs\n# 2. Initialize possible positions\n# 3. Reverse simulate moves to find potential starting positions\n# 4. Count the number of such positions\n\n## Implementation:"}
{"task_id": "abc341_d", "solution": "import math\nimport sys\n\ndef main():\n    input = sys.stdin.read()\n    N, M, K = map(int, input.strip().split())\n\n    # Compute gcd and lcm\n    gcd_nm = math.gcd(N, M)\n    lcm_nm = N // gcd_nm * M\n\n    # Binary search boundaries\n    low, high = 1, 10**18\n\n    def count_exactly_one(mid):\n        count_N = mid // N\n        count_M = mid // M\n        count_both = mid // lcm_nm\n        return (count_N + count_M - 2 * count_both)\n\n    while low < high:\n        mid = (low + high) // 2\n        if count_exactly_one(mid) >= K:\n            high = mid\n        else:\n            low = mid + 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc341_e", "solution": "```python\nimport sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    N, Q = int(data[0]), int(data[1])\n    S = list(data[2])\n    queries = data[3:]\n\n    # Convert string to integer bits for easier flipping\n    bits = [1 if ch == '1' else 0 for ch in S]\n\n    # Segment tree data structures\n    size = 1\n    while size < N:\n        size <<= 1\n    \n    # Each node will store:\n    # left_char, right_char, bad_pairs, flip_flag\n    # Initialize with dummy values\n    left_char = [0] * (2 * size)\n    right_char = [0] * (2 * size)\n    bad_pairs = [0] * (2 * size)\n    flip_flag = [False] * (2 * size)\n\n    def build():\n        # Build leaves\n        for i in range(N):\n            left_char[size + i] = bits[i]\n            right_char[size + i] = bits[i]\n            bad_pairs[size + i] = 0\n        for i in range(N, size):\n            # For extra leaves (beyond N), initialize as arbitrary or zeros\n            left_char[size + i] = 0\n            right_char[size + i] = 0\n            bad_pairs[size + i] = 0\n        # Build internal nodes\n        for i in range(size - 1, 0, -1):\n            pull(i)\n\n    def pull(i):\n        # Merge children\n        left = 2 * i\n        right = 2 * i + 1\n        # Merge boundary characters\n        left_char[i] = left_char[left]\n        right_char[i] = right_char[right]\n        # Sum bad pairs\n        bad_pairs[i] = bad_pairs[left] + bad_pairs[right]\n        # Check boundary for bad pair\n        if right_char[left] == left_char[right]:\n            bad_pairs[i] += 1\n\n    def apply_flip(i):\n        # Flip bits in the node\n        left_char[i] ^= 1\n        right_char[i] ^= 1\n        # If leaf, just flip; if internal node, flip the boundary characters\n        # The number of bad pairs remains the same because flipping bits doesn't change the number of same/different pairs directly.\n        # But the boundary characters flip, so the bad_pairs check remains consistent.\n        # Also, toggle flip flag\n        flip_flag[i] = not flip_flag[i]\n        # When flipping, the bad_pairs within children need to be recal"}
{"task_id": "abc341_f", "solution": "```python\nfrom collections import deque\n\n# Dinic's max flow implementation\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n    \n    def add_edge(self, u, v, cap):\n        self.adj[u].append([v, cap, len(self.adj[v])])\n        self.adj[v].append([u, 0, len(self.adj[u]) - 1])\n    \n    def bfs(self, s, t, level):\n        for i in range(len(level)):\n            level[i] = -1\n        level[s] = 0\n        queue = deque([s])\n        while queue:\n            u = queue.popleft()\n            for i, (v, cap, rev) in enumerate(self.adj[u]):\n                if cap > 0 and level[v] < 0:\n                    level[v] = level[u] + 1\n                    queue.append(v)\n        return level[t] >= 0\n    \n    def send_flow(self, u, t, flow, level, start):\n        if u == t:\n            return flow\n        while start[u] < len(self.adj[u]):\n            v, cap, rev = self.adj[u][start[u]]\n            if cap > 0 and level[v] == level[u] + 1:\n                curr_flow = min(flow, cap)\n                temp_flow = self.send_flow(v, t, curr_flow, level, start)\n                if temp_flow > 0:\n                    self.adj[u][start[u]][1] -= temp_flow\n                    self.adj[v][rev][1] += temp_flow\n                    return temp_flow\n            start[u] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        total = 0\n        level = [-1] * self.n\n        while self.bfs(s, t, level):\n            start = [0] * self.n\n            while True:\n                flow = self.send_flow(s, t, float('inf'), level, start)\n                if flow <= 0:\n                    break\n                total += flow\n        return total\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N, M"}
{"task_id": "abc342_a", "solution": "# Read the input string\nS = input().strip()\n\n# Check the first two characters to determine the common character\nif S[0] != S[1]:\n    # If the third character matches S[0], then S[1] is unique\n    if S[2] == S[0]:\n        print(2)  # second character is unique\n    else:\n        print(1)  # first character is unique\nelse:\n    # First two characters are the same, find the differing character\n    for i in range(2, len(S)):\n        if S[i] != S[0]:\n            print(i + 1)  # 1-based index\n            break"}
{"task_id": "abc342_b", "solution": "# Read the number of people\nN = int(input())\n\n# Read the sequence of people\nP = list(map(int, input().split()))\n\n# Read the number of queries\nQ = int(input())\n\n# Process each query\nfor _ in range(Q):\n    A, B = map(int, input().split())\n    # Determine who is further to the front\n    if A < B:\n        print(P[A - 1])\n    else:\n        print(P[B - 1])"}
{"task_id": "abc342_c", "solution": "# Read input\nN = int(input())\nS = input()\nQ = int(input())\n\n# Initialize the mapping for each character ('a' to 'z')\n# Using a list for direct index access: mapping[0] corresponds to 'a', etc.\nmapping = [chr(i + ord('a')) for i in range(26)]\n\n# Process all operations\nfor _ in range(Q):\n    c_i, d_i = input().split()\n    # Map the current mapped character of c_i to d_i\n    index_c = ord(c_i) - ord('a')\n    mapping[index_c] = d_i\n\n# Construct the final string\nresult = []\nfor ch in S:\n    index_ch = ord(ch) - ord('a')\n    result.append(mapping[index_ch])\n\n# Print the final string\nprint(\"\".join(result))"}
{"task_id": "abc342_d", "solution": "import sys\ninput = sys.stdin.read\n\ndef sieve_spf(max_limit):\n    spf = [0] * (max_limit + 1)\n    spf[1] = 1\n    for i in range(2, max_limit + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            for j in range(i * i, max_limit + 1, i):\n                if spf[j] == 0:\n                    spf[j] = i\n    return spf\n\ndef factorize(n, spf):\n    factors = {}\n    while n > 1:\n        p = spf[n]\n        factors[p] = factors.get(p, 0) + 1\n        n //= p\n    return factors\n\ndef main():\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    maxA = 2 * 10**5\n    spf = sieve_spf(maxA)\n\n    zero_count = 0\n    signature_counts = {}\n\n    for num in A:\n        if num == 0:\n            zero_count += 1\n        else:\n            factors = factorize(num, spf)\n            # create signature with primes and exponents mod 2\n            sig = []\n            for p in sorted(factors):\n                exp = factors[p] % 2\n                if exp != 0:\n                    sig.append((p, exp))\n            sig_tuple = tuple(sig)\n            signature_counts[sig_tuple] = signature_counts.get(sig_tuple, 0) + 1\n\n    # Count pairs with same signatures\n    pairs = 0\n    for count in signature_counts.values():\n        pairs += count * (count - 1) // 2\n\n    # Count pairs involving zeros\n    # Zero-zero pairs\n    zero_pairs = zero_count * (zero_count - 1) // 2\n    # Zero-nonzero pairs\n    zero_nonzero_pairs = zero_count * (N - zero_count)\n\n    print(pairs + zero_pairs + zero_nonzero_pairs)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc342_e", "solution": "```python\nimport sys\nimport math\nimport bisect\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N, M = int(data[0]), int(data[1])\n    info = data[2:]\n    \n    # Adjacency list: for each station, store a list of trains\n    # Each train: (departure_time, arrival_time, destination)\n    trains_from = [[] for _ in range(N+1)]\n    \n    idx = 0\n    for _ in range(M):\n        l_i = int(info[idx]); d_i = int(info[idx+1])\n        k_i = int(info[idx+2])\n        c_i = int(info[idx+3])\n        A_i = int(info[idx+4])\n        B_i = int(info[idx+5])\n        idx += 6\n        \n        # Generate all departure times for this train\n        departure_times = [l_i + d_i * j for j in range(k_i)]\n        # For each departure, store in adjacency list: (departure, arrival, destination)\n        for t in departure_times:\n            departure_time = t\n            arrival_time = t + c_i\n            trains_from[A_i].append((departure_time, arrival_time, B_i))\n    \n    # Initialize the maximum arrival times\n    f = [-math.inf] * (N+1)\n    f[N] = 0  # At destination, can arrive at time 0\n    \n    # Process stations in reverse order\n    for station in range(N, 0, -1):\n        outgoing_trains = trains_from[station]\n        # Sort outgoing trains by departure time for binary search\n        outgoing_trains.sort(key=lambda x: x[0])\n        departure_times = [t[0] for t in outgoing_trains]\n        \n        new_f = f[:]\n        for (dep_time, arr_time, next_station) in outgoing_trains:\n            # We can catch this train if f(next_station) >= dep_time"}
{"task_id": "abc343_a", "solution": "# Read inputs\nA, B = map(int, input().split())\n\n# Calculate sum\nS = A + B\n\n# Find and print any number between 0 and 9 not equal to S\nfor num in range(10):\n    if num != S:\n        print(num)\n        break"}
{"task_id": "abc343_b", "solution": "# Read the number of vertices\nN = int(input())\n\n# Read the adjacency matrix\nA = [list(map(int, input().split())) for _ in range(N)]\n\n# For each vertex, find and print connected vertices\nfor i in range(N):\n    connected_vertices = []\n    for j in range(N):\n        if A[i][j] == 1:\n            connected_vertices.append(j + 1)\n    print(' '.join(map(str, connected_vertices)))"}
{"task_id": "abc343_c", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    N = int(input().strip())\n\n    max_cube = 0\n\n    # Generate palindromic numbers up to 10^6\n    # We can generate palindromes by constructing from half parts\n    for length in range(1, 8):  # length of the palindrome in digits\n        half_len = (length + 1) // 2\n        start = 10**(half_len - 1)\n        end = 10**half_len\n        for half in range(start, end):\n            half_str = str(half)\n            if length % 2 == 0:\n                # even length palindrome\n                pal_str = half_str + half_str[::-1]\n            else:\n                # odd length palindrome\n                pal_str = half_str + half_str[:-1][::-1]\n            x = int(pal_str)\n            cube = x**3\n            if cube <= N and cube > max_cube:\n                max_cube = cube\n\n    print(max_cube)"}
{"task_id": "abc343_d", "solution": "# Read input and process\nimport sys\nfrom collections import Counter\n\ndef main():\n    input = sys.stdin.read().strip().split()\n    N, T = map(int, input[:2])\n    A = [int(input[2 + 2*i]) for i in range(T)]\n    B = [int(input[3 + 2*i]) for i in range(T)]\n    \n    # Initialize player scores\n    player_scores = [0] * N\n    \n    # Initialize counts of scores\n    score_counts = Counter()\n    score_counts[0] = N\n    \n    result = []\n    \n    for i in range(T):\n        player_idx = A[i] - 1  # zero-based index\n        old_score = player_scores[player_idx]\n        new_score = old_score + B[i]\n        player_scores[player_idx] = new_score\n        \n        # Decrease count of old score\n        score_counts[old_score] -= 1\n        if score_counts[old_score] == 0:\n            del score_counts[old_score]\n        \n        # Increase count of new score\n        score_counts[new_score] = score_counts.get(new_score, 0) + 1\n        \n        # Number of distinct scores is the size of score_counts\n        result.append(str(len(score_counts)))\n    \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc343_e", "solution": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    V1, V2, V3 = map(int, input().split())\n\n    # For simplicity, consider placing the cubes in the xy-plane with offsets:\n    # C1 at (0, 0, 0)\n    # C2 at (d, 0, 0)\n    # C3 at (0, e, 0)\n    #\n    # The overlaps:\n    # - Triple intersection volume:\n    #   volume = s^3, where s = min(7, 7 - |d|, 7 - |e|), if positive.\n    # - Pairwise overlaps:\n    #   along x-axis: overlap if |d| < 7\n    #   along y-axis: overlap if |e| < 7\n    #\n    # To get specified V3, set s accordingly:\n    #   s = (V3)^(1/3)\n    #   But since V3 is an integer volume, s must be integer and s^3 = V3.\n    #   So check if V3 is a perfect cube <= 343.\n    def is_perfect_cube(n):\n        if n == 0:\n            return True, 0\n        c = int(round(n ** (1/3)))\n        if c ** 3 == n:\n            return True, c\n        elif (c+1) ** 3 == n:\n            return True, c+1\n        elif (c-1) ** 3 == n:\n            return"}
