{"task_id": "1575_A. Another Sorting Problem", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    books = data[1:n + 1]\n\n    # Create a sortable structure with the custom sorting logic\n    indexed_books = [(i + 1, books[i]) for i in range(n)]\n    \n    def custom_sort_key(book):\n        index, title = book\n        # Create a new tuple based on odd/even index sorting rules\n        return tuple((title[i] if i % 2 == 0 else -ord(title[i])) for i in range(m))\n\n    # Sort the books based on the custom key\n    sorted_books = sorted(indexed_books, key=custom_sort_key)\n\n    # Extract the original indices of the books in the new sorted order\n    result_indices = [index for index, title in sorted_books]\n    \n    # Print the result\n    print(\" \".join(map(str, result_indices)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_B. Building an Amusement Park", "solution": "import sys\nimport math\n\ndef main():\n    # Read input\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, k = map(int, data[0].split())\n    distances = []\n    \n    for i in range(1, n + 1):\n        x, y = map(int, data[i].split())\n        # Calculate the distance from the origin\n        distance = math.sqrt(x * x + y * y)\n        distances.append(distance)\n    \n    # Sort distances\n    distances.sort()\n    \n    # The minimum radius r to cover at least k habitats\n    r = distances[k - 1]\n    \n    # Print the result with sufficient precision\n    print(f\"{r:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_C. Cyclic Sum", "solution": "def count_segments(n, m, k, a):\n    MOD = 10**9 + 7\n    \n    # Calculate cumulative prefix sums\n    prefix_sum = [0] * (n * m + 1)\n    for i in range(1, n * m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[(i - 1) % n]\n    \n    # Count occurrences of each remainder\n    remainder_count = [0] * k\n    count = 0\n    \n    # Initial condition: the empty prefix has a remainder of 0\n    remainder_count[0] = 1\n    \n    for j in range(1, n * m + 1):\n        remainder = prefix_sum[j] % k\n        count += remainder_count[remainder]\n        count %= MOD\n        \n        # Update the count of this remainder\n        remainder_count[remainder] += 1\n        \n        # We only need to keep the count of the first n occurrences for cyclic behavior\n        if j >= n:\n            old_remainder = prefix_sum[j - n] % k\n            remainder_count[old_remainder] -= 1\n    \n    return count\n\n# Read input and execute the function\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:n + 3]))\n\nresult = count_segments(n, m, k, a)\nprint(result)"}
{"task_id": "1575_D. Divisible by Twenty-Five", "solution": "def count_valid_integers(s):\n    valid_pairs = ['00', '25', '50', '75']\n    total_count = 0\n    n = len(s)\n\n    for pair in valid_pairs:\n        # Prepare a new string where the last two characters are replaced with the pair\n        if n >= 2:\n            modified_s = s[:-2] + pair\n        else:\n            modified_s = pair\n            \n        # Check if the replacement is valid\n        if not is_valid_replacement(s, modified_s):\n            continue\n        \n        # Replace 'X' with every digit from 0 to 9 and count the valid combinations\n        for x_value in range(10):\n            current_s = modified_s.replace('X', str(x_value))\n            if is_valid(current_s):\n                total_count += count_wildcards(current_s)\n\n    return total_count\n\ndef is_valid_replacement(original, modified):\n    \"\"\" Check if the modified string can be formed from the original string \"\"\"\n    orig_len = len(original)\n    mod_len = len(modified)\n    for i in range(orig_len):\n        if original[i] != modified[i] and original[i] != '_' and original[i] != 'X':\n            return False\n    return True\n\ndef is_valid(s):\n    \"\"\" Check if the string s represents a valid number without leading zeros \"\"\"\n    if len(s) > 1 and s[0] == '0':\n        return False\n    return True\n\ndef count_wildcards(s):\n    \"\"\" Count the number of ways to replace '_' in s \"\"\"\n    count = 1\n    for char in s:\n        if char == '_':\n            count *= 10  # 10 choices for each '_'\n    return count\n\n# Reading input and executing the function\nimport sys\n\nif __name__ == \"__main__\":\n    input_string = sys.stdin.read().strip()\n    result = count_valid_integers(input_string)\n    print(result)"}
{"task_id": "1575_E. Eye-Pleasing City Park Tour", "solution": "def main():\n    import sys\n    from collections import defaultdict\n    sys_input = sys.stdin.read\n    data = sys_input().splitlines()\n    \n    MOD = 10**9 + 7\n    \n    n, k = map(int, data[0].split())\n    happiness = list(map(int, data[1].split()))\n    \n    edges = defaultdict(list)\n    for i in range(2, n + 1):\n        u, v, t = map(int, data[i].split())\n        edges[u].append((v, t))\n        edges[v].append((u, t))\n\n    total_happiness = 0\n    \n    def dfs(node, parent, current_happiness, current_switches):\n        nonlocal total_happiness\n        current_happiness += happiness[node - 1]  # 0-indexed access\n        total_happiness = (total_happiness + current_happiness) % MOD\n        \n        for neighbor, color in edges[node]:\n            if neighbor == parent:\n                continue\n            \n            # Count how many switches would be involved\n            next_switches = current_switches\n            if color != last_color:\n                next_switches += 1\n            \n            if next_switches <= k:\n                last_color = color\n                dfs(neighbor, node, current_happiness, next_switches)\n\n    for i in range(1, n + 1):\n        last_color = -1  # No color at the start\n        dfs(i, -1, 0, 0)\n\n    print(total_happiness)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_F. Finding Expected Value", "solution": "def modular_inverse(x, mod):\n    # Fermat's little theorem for computing modular inverse\n    return pow(x, mod - 2, mod)\n\ndef expected_operations(n, k, a):\n    MOD = 10**9 + 7\n    c = a.count(-1)\n    \n    # Count fixed numbers (not -1)\n    fixed_nums = set(x for x in a if x != -1)\n    distinct_fixed_count = len(fixed_nums)\n\n    # Total distinct numbers after random replacements\n    total_distinct = distinct_fixed_count + c\n    \n    # Compute the expected number of operations\n    E_sum = 0\n    for j in range(1, total_distinct + 1):\n        E_sum += n / (n - j)  # This will be a float\n    \n    # Total number of configurations\n    total_configurations = pow(k, c, MOD)\n    \n    # Scale E_sum by total configurations\n    E = (E_sum * total_configurations) % MOD\n    \n    # We need to convert E into a fraction p/q where q = total_configurations\n    # p = E * total_configurations, q = total_configurations\n    p = int(E % MOD)\n    q = total_configurations\n    \n    # Result is (p * q^{-1}) % MOD\n    result = (p * modular_inverse(q, MOD)) % MOD\n    \n    return result\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\n\n# Getting the expected operations\nresult = expected_operations(n, k, a)\n\n# Output the result\nprint(result)"}
{"task_id": "1575_G. GCD Festival", "solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef calculate_prettiness(n, a):\n    MOD = 10**9 + 7\n    \n    # Step 1: Count occurrences of each number in a\n    max_a = 100000\n    count_a = [0] * (max_a + 1)\n    for num in a:\n        count_a[num] += 1\n    \n    # Step 2: Calculate contribution for each g = gcd(a_i, a_j)\n    prettiness = 0\n    \n    # GCD contributions from elements in a\n    for g in range(1, max_a + 1):\n        # Count the number of elements that are multiples of g\n        multiples_count = 0\n        for multiple in range(g, max_a + 1, g):\n            multiples_count += count_a[multiple]\n        \n        if multiples_count > 0:\n            # The number of pairs (i, j) where gcd(a_i, a_j) = g\n            pairs_count = (multiples_count * multiples_count) % MOD\n            # Contribution of g to the prettiness value\n            prettiness += (g * pairs_count) % MOD\n            prettiness %= MOD\n    \n    # Step 3: Calculate contribution for gcd(i, j)\n    for g in range(1, n + 1):\n        # Count the number of indices that are multiples of g\n        indices_count = n // g\n        if indices_count > 0:\n            pairs_count = (indices_count * indices_count) % MOD\n            prettiness += (g * pairs_count) % MOD\n            prettiness %= MOD\n    \n    return prettiness\n\n# Reading input and invoking the function\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:n + 1]))\n    \n    result = calculate_prettiness(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_H. Holiday Wall Ornaments", "solution": "def min_changes_to_k_occurrences(n, m, a, b):\n    # Step 1: Count occurrences and changes needed\n    change_count = [0] * (n - m + 1)\n    for i in range(n - m + 1):\n        change_count[i] = sum(1 for j in range(m) if a[i + j] != b[j])\n    \n    # Step 2: Initialize DP table\n    dp = [float('inf')] * (n - m + 2)  # dp[k] is minimal changes for k occurrences\n    dp[0] = 0  # 0 occurrences require 0 changes\n    \n    # Step 3: Calculate changes for k occurrences\n    for i in range(n - m + 1):\n        for k in range(n - m, -1, -1):  # we go backwards to avoid overwriting\n            # We can add this occurrence if we're under limits\n            if k < n - m + 1:\n                dp[k + 1] = min(dp[k + 1], dp[k] + change_count[i])\n\n            # If we want to ensure no overlaps, we can skip to the next valid position\n            # We need to ensure to consider the next non-overlapping position\n            if k > 0:\n                next_position = i + m  # next position to consider\n                if next_position < n - m + 1:\n                    # We can also take the result of not using the current position\n                    dp[k] = min(dp[k], dp[k - 1])\n\n    # Step 4: Prepare result for output\n    result = []\n    for k in range(n - m + 2):\n        if dp[k] == float('inf'):\n            result.append(-1)\n        else:\n            result.append(dp[k])\n\n    return result\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn, m = map(int, data[0].split())\na = data[1].strip()\nb = data[2].strip()\n\n# Solve the problem and print the results\nresult = min_changes_to_k_occurrences(n, m, a, b)\nprint(\" \".join(map(str, result)))"}
{"task_id": "1575_I. Illusions of the Desert", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    from collections import defaultdict, deque\n\n    data = input().splitlines()\n    \n    n, q = map(int, data[0].split())\n    a = list(map(int, data[1].split()))\n    \n    tree = defaultdict(list)\n    \n    for i in range(2, n + 1):\n        s, t = map(int, data[i].split())\n        tree[s - 1].append(t - 1)\n        tree[t - 1].append(s - 1)\n    \n    queries = data[n + 1:]\n    \n    def dfs(start, end):\n        stack = [(start, -1)]\n        parent = {start: -1}\n        \n        while stack:\n            node, par = stack.pop()\n            if node == end:\n                break\n            parent[node] = par\n            for neighbor in tree[node]:\n                if neighbor != par:\n                    stack.append((neighbor, node))\n        \n        path = []\n        current_node = end\n        while current_node != -1:\n            path.append(current_node)\n            current_node = parent[current_node]\n        path.reverse()\n        return path\n\n    output = []\n    \n    for query in queries:\n        parts = list(map(int, query.split()))\n        if parts[0] == 1:  # Update query\n            u, c = parts[1] - 1, parts[2]\n            a[u] = c\n        elif parts[0] == 2:  # Query for energy\n            u, v = parts[1] - 1, parts[2] - 1\n            path = dfs(u, v)\n            total_energy = 0\n            for i in range(len(path) - 1):\n                x = path[i]\n                y = path[i + 1]\n                total_energy += max(abs(a[x] + a[y]), abs(a[x] - a[y]))\n            output.append(total_energy)\n\n    sys.stdout.write('\\n'.join(map(str, output)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_J. Jeopardy of Dropped Balls", "solution": "def dropping_balls(n, m, k, grid, drops):\n    # Initialize the results array\n    result = [0] * k\n    # Create a map to remember where each column ends up\n    end_positions = {}\n\n    for i in range(k):\n        col = drops[i] - 1  # Convert to zero-based index\n        start_col = col\n        \n        if start_col in end_positions:\n            result[i] = end_positions[start_col] + 1  # Convert back to one-based index\n            continue\n        \n        # Simulate the drop\n        x, y = 0, col\n        while True:\n            if x >= n:  # Ball falls out of bounds\n                end_positions[start_col] = -1\n                break\n            \n            direction = grid[x][y]\n            \n            if direction == 1:  # Move right\n                if y + 1 < m:\n                    y += 1\n                else:\n                    end_positions[start_col] = y  # Falls out of bounds on the right\n                    break\n            elif direction == 2:  # Move down\n                x += 1\n            elif direction == 3:  # Move left\n                if y - 1 >= 0:\n                    y -= 1\n                else:\n                    end_positions[start_col] = y  # Falls out of bounds on the left\n                    break\n\n            # Update the cell to down (2) after the ball leaves it\n            if x < n:\n                grid[x][y] = 2  # Change direction to down (2)\n\n        result[i] = y + 1 if end_positions[start_col] == -1 else end_positions[start_col] + 1\n\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn, m, k = map(int, data[0].split())\ngrid = [list(map(int, line.split())) for line in data[1:n + 1]]\ndrops = list(map(int, data[n + 1].split()))\n\n# Solve the problem\nresults = dropping_balls(n, m, k, grid, drops)\n\n# Print results\nprint(\" \".join(map(str, results)))"}
{"task_id": "1575_K. Knitting Batik", "solution": "def modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:  # If exp is odd\n            result = (result * base) % mod\n        exp = exp >> 1  # exp //= 2\n        base = (base * base) % mod\n    return result\n\ndef count_color_combinations(n, m, k, r, c, a_x, a_y, b_x, b_y):\n    MOD = 10**9 + 7\n    # Calculate the number of ways to color a r x c rectangle\n    total_patterns = modular_exponentiation(k, r * c, MOD)\n    return total_patterns\n\n# Read input\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    r = int(data[3])\n    c = int(data[4])\n    a_x = int(data[5])\n    a_y = int(data[6])\n    b_x = int(data[7])\n    b_y = int(data[8])\n    \n    result = count_color_combinations(n, m, k, r, c, a_x, a_y, b_x, b_y)\n    print(result)"}
{"task_id": "1575_L. Longest Array Deconstruction", "solution": "def maximize_f(n, a):\n    # Step 1: Create a frequency dictionary to count occurrences of each number\n    from collections import defaultdict\n    frequency = defaultdict(int)\n    \n    # Step 2: Count current matches and frequency of elements\n    current_matches = 0\n    for i in range(1, n + 1):\n        if a[i - 1] == i:\n            current_matches += 1\n        frequency[a[i - 1]] += 1\n    \n    # Step 3: Calculate potential matches\n    max_possible_matches = current_matches\n    for i in range(1, n + 1):\n        if frequency[i] > 0:\n            max_possible_matches += 1  # We can make a match for index i if it's in the sequence but not counted\n    \n    return max_possible_matches\n\n# Read inputs from stdin\nimport sys\ninput = sys.stdin.read\ndef main():\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:n + 1]))\n    \n    # Call the function and print the result\n    result = maximize_f(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1575_M. Managing Telephone Poles", "solution": "from collections import deque\n\ndef calculate_sum_of_distances(n, m, grid):\n    # Create a distance matrix initialized to a large value (infinity)\n    inf = float('inf')\n    distance = [[inf] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with all telephone poles and set their distance to 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == 1:\n                distance[i][j] = 0\n                queue.append((i, j))\n    \n    # Directions for 4 possible moves (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distance[nx][ny] > distance[x][y] + 1:\n                    distance[nx][ny] = distance[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squares = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            sum_of_squares += distance[i][j] ** 2\n            \n    return sum_of_squares\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# First line contains n and m\nn, m = map(int, data[0].split())\ngrid = [list(map(int, data[i + 1])) for i in range(n + 1)]\n\n# Calculate and print the result\nresult = calculate_sum_of_distances(n, m, grid)\nprint(result)"}
{"task_id": "1579_A. Casimir's String Solitaire", "solution": "def can_erase_string(test_cases):\n    results = []\n    for s in test_cases:\n        count_A = s.count('A')\n        count_B = s.count('B')\n        count_C = s.count('C')\n        \n        if count_B >= count_A + count_C:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Reading input\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])  # number of test cases\n    test_cases = data[1:t + 1]  # the actual test cases\n    \n    results = can_erase_string(test_cases)\n    print(\"\\n\".join(results))"}
{"task_id": "1579_B. Shifting Sort", "solution": "def sort_with_cyclic_shifts(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        sorted_a = sorted(a)\n        operations = []\n        \n        for i in range(n):\n            if a[i] == sorted_a[i]:\n                continue\n            \n            # Find the position of the element that should be at index i\n            target = sorted_a[i]\n            target_index = a.index(target, i)  # Find the target in the unsorted part\n            \n            # If the target_index is not the current index, we need to perform shifts\n            if target_index != i:\n                # We will shift the segment a[i:target_index+1]\n                # and we need to shift left by the distance from i to target_index\n                offset = target_index - i\n                \n                # Perform the cyclic shift\n                operations.append((i + 1, target_index + 1, offset))\n                \n                # Execute the shift in array a\n                # a[i:target_index+1] should become a[i+offset:target_index+1] + a[i:i+offset]\n                segment = a[i:target_index + 1]\n                shifted_segment = segment[offset:] + segment[:offset]\n                a[i:target_index + 1] = shifted_segment\n        \n        # Record the result for this test case\n        results.append((len(operations), operations))\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Parse input\nt = int(data[0])\ntest_cases = []\n\nfor i in range(t):\n    n = int(data[2 * i + 1])\n    a = list(map(int, data[2 * i + 2].split()))\n    test_cases.append((n, a))\n\n# Get results\nresults = sort_with_cyclic_shifts(t, test_cases)\n\n# Print results\noutput = []\nfor ops_count, ops in results:\n    output.append(str(ops_count))\n    for l, r, d in ops:\n        output.append(f\"{l} {r} {d}\")\n\nprint(\"\\n\".join(output))"}
{"task_id": "1579_C. Ticks", "solution": "def can_form_ticks(n, m, k, grid):\n    # Create a temporary grid to simulate the painting of ticks\n    temp_grid = [['.' for _ in range(m)] for _ in range(n)]\n    \n    # Check for possible tick centers\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                # Calculate the size of the tick possible at (i, j)\n                size = 0\n                while size < k and (i - size >= 0) and (j - size >= 0) and (j + size < m):\n                    if grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*':\n                        size += 1\n                    else:\n                        break\n                \n                # If we found a valid tick center of at least size k\n                if size >= k:\n                    # Mark the cells in the temp grid\n                    for h in range(size + 1):\n                        temp_grid[i - h][j - h] = '*'\n                        temp_grid[i - h][j + h] = '*'\n    \n    # Now check if temp_grid matches the original grid for '*'\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*' and temp_grid[i][j] != '*':\n                return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        grid = [data[index + i + 1] for i in range(n)]\n        index += n + 1\n        \n        result = can_form_ticks(n, m, k, grid)\n        results.append(result)\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1579_D. Productive Meeting", "solution": "import sys\nimport heapq\n\ndef maximize_talks(test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        # Create a max heap of (sociability, index) pairs\n        max_heap = [(-a[i], i + 1) for i in range(n) if a[i] > 0]\n        heapq.heapify(max_heap)\n        \n        talks = []\n        \n        while len(max_heap) > 1:\n            # Get the two most sociable people\n            first_sociability, first_index = heapq.heappop(max_heap)\n            second_sociability, second_index = heapq.heappop(max_heap)\n            \n            # Log the talk\n            talks.append((first_index, second_index))\n            \n            # Decrease their sociability\n            first_sociability += 1  # since we stored negative, we add 1\n            second_sociability += 1  # similarly\n            \n            # Push them back if they have remaining sociability\n            if first_sociability < 0:\n                heapq.heappush(max_heap, (first_sociability, first_index))\n            if second_sociability < 0:\n                heapq.heappush(max_heap, (second_sociability, second_index))\n        \n        # Prepare the output for this test case\n        results.append(f\"{len(talks)}\")\n        for talk in talks:\n            results.append(f\"{talk[0]} {talk[1]}\")\n    \n    return \"\\n\".join(results)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    output = maximize_talks(test_cases)\n    print(output)"}
{"task_id": "1579_E2. Array Optimization by Deque", "solution": "from sortedcontainers import SortedList\nimport sys\ninput = sys.stdin.read\n\ndef minimal_inversions(test_cases):\n    results = []\n    for n, a in test_cases:\n        sorted_deque = SortedList()\n        inversions = 0\n\n        for value in a:\n            # Count how many elements are greater than the current value\n            count_greater = len(sorted_deque) - sorted_deque.bisect_right(value)\n            # Count how many elements are less than the current value\n            count_less = sorted_deque.bisect_left(value)\n            \n            # We can choose to append or prepend\n            # If we prepend, count_greater becomes inversions\n            # If we append, we would add count_less to inversions\n            # So we take the minimum of both choices\n            inversions += min(count_greater, count_less)\n\n            # Add the current value to the sorted deque\n            sorted_deque.add(value)\n\n        results.append(inversions)\n\n    return results\n\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n\n    results = minimal_inversions(test_cases)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1579_F. Array Stabilization (AND version)", "solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_steps(n, d, a):\n    g = gcd(n, d)\n    m = n // g\n    steps_per_cycle = [0] * g\n    final_values = [-1] * g  # -1 means not yet computed\n\n    for start in range(g):\n        seen = set()\n        current = start\n        steps = 0\n        \n        while current not in seen:\n            seen.add(current)\n            next_value = 1  # Assume it's all ones until we find a zero\n            \n            # Check the entire cycle\n            for i in range(m):\n                index = (current + i * d) % n\n                next_value &= a[index]\n            \n            steps += 1\n            \n            if next_value == 0:\n                break\n            \n            current = (current + d) % g\n        \n        steps_per_cycle[start] = steps\n        \n    max_steps = max(steps_per_cycle)\n    \n    if max_steps == 0:\n        return -1  # The array will never become all zeros\n    \n    # Calculate the final status of each position based on steps taken\n    for i in range(g):\n        if final_values[i] == -1:\n            final_values[i] = 1  # Start with 1 (true)\n            for j in range(steps_per_cycle[i]):\n                next_value = 1\n                for k in range(m):\n                    index = (i + k * d) % n\n                    next_value &= a[index]\n                if next_value == 0:\n                    final_values[i] = 0\n                    break\n    \n    if all(v == 0 for v in final_values):\n        return max_steps\n    else:\n        return -1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    idx = 1\n    for _ in range(t):\n        n, d = map(int, data[idx].split())\n        a = list(map(int, data[idx + 1].split()))\n        result = count_steps(n, d, a)\n        results.append(result)\n        idx += 2\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1579_G. Minimal Coverage", "solution": "def minimal_coverage_length(test_cases):\n    results = []\n    \n    for lengths in test_cases:\n        n = len(lengths)\n        # Initial positions\n        min_end = 0  # The leftmost point on the axis\n        max_end = lengths[0]  # The rightmost point after the first segment\n        \n        for i in range(1, n):\n            segment_length = lengths[i]\n            # Update the min_end and max_end based on the choice of placement\n            new_max_end = max_end + segment_length\n            new_min_end = min_end - segment_length\n            # Update min_end and max_end for the next iteration\n            min_end, max_end = new_min_end, new_max_end\n        \n        # Calculate the length of the coverage\n        total_coverage_length = max_end - min_end\n        results.append(total_coverage_length)\n    \n    return results\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])  # Number of test cases\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])  # Number of segments\n    lengths = list(map(int, data[index + 1].split()))  # Lengths of segments\n    test_cases.append(lengths)\n    index += 2\n\n# Get results\nresults = minimal_coverage_length(test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "1580_A. Portal", "solution": "def min_operations_to_portal(n, m, grid):\n    min_operations = float('inf')\n\n    # Check all possible portal sizes\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            # Check every position where the portal can be placed\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    operations = 0\n                    \n                    # Check borders\n                    # Top border: row i\n                    for col in range(j, j + b):\n                        if i == 0 and col == j:\n                            continue  # Top-left corner, can be anything\n                        if grid[i][col] == '0':\n                            operations += 1  # Needs to be 1 (obsidian)\n\n                    # Bottom border: row i + a - 1\n                    for col in range(j, j + b):\n                        if i + a - 1 == n - 1 and col == j:\n                            continue  # Bottom-left corner, can be anything\n                        if grid[i + a - 1][col] == '0':\n                            operations += 1  # Needs to be 1 (obsidian)\n\n                    # Left border: column j\n                    for row in range(i + 1, i + a - 1):\n                        if row == i + 1 and j == j:\n                            continue  # Top-left corner, can be anything\n                        if grid[row][j] == '0':\n                            operations += 1  # Needs to be 1 (obsidian)\n\n                    # Right border: column j + b - 1\n                    for row in range(i + 1, i + a - 1):\n                        if row == i + 1 and j + b - 1 == j + b - 1:\n                            continue  # Top-right corner, can be anything\n                        if grid[row][j + b - 1] == '0':\n                            operations += 1  # Needs to be 1 (obsidian)\n\n                    # Check inner area (should be all zero)\n                    for row in range(i + 1, i + a - 1):\n                        for col in range(j + 1, j + b - 1):\n                            if grid[row][col] == '1':\n                                operations += 1  # Needs to be 0 (empty)\n\n                    min_operations = min(min_operations, operations)\n\n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[index + i] for i in range(n)]\n        index += n\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n\n    # Print results for all test cases\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1580_B. Mathematics Curriculum", "solution": "def factorial(n, mod):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    return fact\n\ndef count_permutations(n, m, k, p):\n    if m > n or k > n:\n        return 0\n    \n    # Precompute factorials for combinations\n    fact = factorial(n, p)\n    \n    # dp[i][j] = number of permutations of size i with exactly j good numbers\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: 1 way to have 0 elements with 0 good numbers\n    \n    for i in range(1, n + 1):\n        for j in range(0, min(i, k) + 1):\n            # If we don't make the current maximum a good number\n            dp[i][j] = dp[i - 1][j] * (i - 1) % p\n            \n            # If we make the current maximum contribute to a new good number\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (i - 1) % p) % p\n    \n    return dp[n][k]\n\n# Read input\nimport sys\ninput = sys.stdin.read\nn, m, k, p = map(int, input().strip().split())\n\n# Solve the problem\nresult = count_permutations(n, m, k, p)\nprint(result)"}
{"task_id": "1580_C. Train Maintenance", "solution": "def count_trains_in_maintenance(n, m, train_info, operations):\n    from collections import defaultdict\n\n    # Prepare train data\n    trains = {}\n    for i in range(n):\n        x_i, y_i = train_info[i]\n        trains[i + 1] = {\n            'x': x_i,\n            'y': y_i,\n            'added_day': None,\n            'in_maintenance_until': None,\n            'in_work_until': None,\n        }\n\n    # Prepare the result\n    result = []\n    \n    # Process each operation day-by-day\n    for day in range(m):\n        op, k = operations[day]\n        k = int(k)\n        \n        # Track maintenance count\n        maintenance_count = 0\n        \n        if op == 1:  # Add train\n            # Add the train of model k\n            train = trains[k]\n            current_day = day + 1  # Day is 1-indexed for this problem\n            train['added_day'] = current_day\n            train['in_work_until'] = current_day + train['x'] - 1\n            train['in_maintenance_until'] = train['in_work_until'] + train['y']\n            \n        elif op == 2:  # Remove train\n            # Remove the train of model k\n            train = trains[k]\n            train['added_day'] = None\n            train['in_work_until'] = None\n            train['in_maintenance_until'] = None\n        \n        # Count how many trains are in maintenance\n        for train in trains.values():\n            if train['added_day'] is not None:\n                if day + 1 >= train['in_work_until'] + 1 and day + 1 < train['in_maintenance_until'] + 1:\n                    maintenance_count += 1\n        \n        result.append(maintenance_count)\n    \n    return result\n\n# Sample usage\nn, m = 3, 4\ntrain_info = [(10, 15), (12, 10), (0, 0)]\noperations = [(1, 1), (1, 3), (1, 1), (2, 1), (2, 3)]\nresult = count_trains_in_maintenance(n, m, train_info, operations)\nfor r in result:\n    print(r)"}
{"task_id": "1580_D. Subsequence", "solution": "def maximize_value(n, m, a):\n    # Sort the array to find the largest `m` elements\n    sorted_a = sorted(a, reverse=True)\n    largest_m_elements = sorted_a[:m]\n    \n    # Calculate the first term\n    sum_of_selected = sum(largest_m_elements)\n    first_term = m * sum_of_selected\n    \n    # The second term requires us to find the minimums between selected pairs\n    # To compute this efficiently, we can just consider the selected elements.\n    \n    # Position map to get indices of the original elements\n    selected_indices = sorted(a.index(x) for x in largest_m_elements)\n    \n    # Compute the second term\n    second_term = 0\n    for i in range(m):\n        for j in range(i, m):\n            # f(min(b_i, b_j), max(b_i, b_j)) is the minimum of the values in the range\n            min_value = min(largest_m_elements[i:j+1])\n            second_term += min_value\n    \n    # Final value calculation\n    value = first_term - second_term\n    return value\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    a = list(map(int, data[1].split()))\n    \n    result = maximize_value(n, m, a)\n    print(result)"}
{"task_id": "1580_E. Railway Construction", "solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra(n, graph, start):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]  # (distance, node)\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef calculate_min_cost(n, m, q, weights, edges, incidents):\n    graph = defaultdict(list)\n    \n    # Build the graph\n    for u, v, d in edges:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    # Get shortest distances from the main station (1)\n    shortest_paths = dijkstra(n, graph, 1)\n\n    # Calculate the initial minimum cost for one-way railways\n    total_cost = 0\n    for u in range(1, n + 1):\n        for v, d in graph[u]:\n            if shortest_paths[u] + d == shortest_paths[v]:\n                continue\n            total_cost += weights[u-1]\n\n    results = [total_cost]\n    \n    # Process each incident\n    for k, x in incidents:\n        weights[k - 1] += x\n        total_cost = 0\n        \n        for u in range(1, n + 1):\n            for v, d in graph[u]:\n                if shortest_paths[u] + d == shortest_paths[v]:\n                    continue\n                total_cost += weights[u - 1]\n\n        results.append(total_cost)\n    \n    return results\n\n# Read input\ninput_data = sys.stdin.read().splitlines()\nn, m, q = map(int, input_data[0].strip().split())\nweights = list(map(int, input_data[1].strip().split()))\nedges = [tuple(map(int, line.strip().split())) for line in input_data[2:m + 2]]\nincidents = [tuple(map(int, line.strip().split())) for line in input_data[m + 2:m + 2 + q]]\n\n# Calculate the minimal cost after initial setup and after each incident\nresult = calculate_min_cost(n, m, q, weights, edges, incidents)\n\n# Print results\nfor res in result:\n    print(res)"}
{"task_id": "1580_F. Problems for Codeforces", "solution": "def count_difficulty_plans(n, m):\n    MOD = 998244353\n\n    # dp[i][j] means the number of ways to assign difficulties for the first i problems,\n    # with the last difficulty being j.\n    dp = [[0] * m for _ in range(n + 1)]\n    \n    # Initial state, one way to have zero problems\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        prefix_sum = [0] * m\n        \n        # Create a prefix sum for the current state\n        for j in range(m):\n            prefix_sum[j] = (prefix_sum[j - 1] + dp[i - 1][j]) % MOD if j > 0 else dp[i - 1][j]\n        \n        # Fill dp[i][j] according to the conditions\n        for j in range(m):\n            # We can only use j as the last difficulty if we can pick a valid previous\n            max_prev = m - j - 1\n            if max_prev >= 0:\n                dp[i][j] = prefix_sum[max_prev] % MOD\n\n    # Final count considering the wrap condition\n    total = 0\n    for j in range(m):\n        total = (total + dp[n][j]) % MOD\n    \n    # Now we need to subtract the invalid cases where a_1 + a_n >= m\n    for j in range(m):\n        for k in range(m):\n            if j + k >= m:\n                total = (total - dp[n][k]) % MOD\n\n    return total\n\n# Reading input and invoking the function\nimport sys\ninput = sys.stdin.read\nn, m = map(int, input().strip().split())\nprint(count_difficulty_plans(n, m))"}
{"task_id": "1581_A. CQXYM Count Permutations", "solution": "MOD = 1000000007\n\ndef precompute_factorials_and_inverses(max_n):\n    max_factorial = 2 * max_n\n    fact = [1] * (max_factorial + 1)\n    inverse_fact = [1] * (max_factorial + 1)\n    \n    for i in range(2, max_factorial + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inverse_fact[max_factorial] = pow(fact[max_factorial], MOD - 2, MOD)\n    for i in range(max_factorial - 1, 0, -1):\n        inverse_fact[i] = inverse_fact[i + 1] * (i + 1) % MOD\n\n    return fact, inverse_fact\n\ndef catalan_number(n, fact, inverse_fact):\n    if n == 0:\n        return 1\n    return fact[2 * n] * inverse_fact[n + 1] % MOD * inverse_fact[n] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    cases = [int(data[i]) for i in range(1, t + 1)]\n    max_n = max(cases)\n    \n    fact, inverse_fact = precompute_factorials_and_inverses(max_n)\n    \n    results = []\n    for n in cases:\n        results.append(catalan_number(n, fact, inverse_fact))\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1581_B. Diameter of Graph", "solution": "def can_create_graph(n, m, k):\n    # Check for minimum edges needed for connectivity\n    if m < n - 1:\n        return \"NO\"\n    \n    # Check for trivial case where k is less than or equal to 1\n    if k <= 1 and n > 1:\n        return \"NO\"\n    \n    # If we have enough edges, check the diameter condition\n    # To maintain a diameter less than k-1, we can't exceed (k-2) * (n-1) edges\n    if m <= (k - 2) * (n - 1):\n        return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n, m, k = map(int, data[i].split())\n        results.append(can_create_graph(n, m, k))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1582_A. Luntik and Concerts", "solution": "def min_duration_difference(test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Total duration of songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Target duration for one concert\n        target = total_duration // 2\n        \n        # The maximum duration we might consider\n        max_duration = target\n        \n        # Dynamic programming array to track achievable durations\n        dp = [False] * (max_duration + 1)\n        dp[0] = True  # 0 duration is always achievable\n\n        # Process all songs\n        for minute_songs in (a, b, c):\n            if minute_songs == 0:\n                continue\n            song_length = 1 if (minute_songs == a) else (2 if (minute_songs == b) else 3)\n            for _ in range(minute_songs):\n                for j in range(max_duration, song_length - 1, -1):\n                    if dp[j - song_length]:\n                        dp[j] = True\n\n        # Find the closest achievable sum to target\n        for j in range(max_duration, -1, -1):\n            if dp[j]:\n                closest_sum = j\n                break\n\n        # Calculate the minimum difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\n# Reading input and outputting the result\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split(\"\\n\")\n\n    t = int(data[0])  # number of test cases\n    test_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n\n    results = min_duration_difference(test_cases)\n    print(\"\\n\".join(map(str, results)))"}
{"task_id": "1582_B. Luntik and Subsequences", "solution": "def nearly_full_subsequences(t, cases):\n    results = []\n    for case in cases:\n        n, a = case\n        total_sum = sum(a)\n        count_1 = a.count(1)\n        \n        if count_1 == 0:\n            results.append(0)\n        else:\n            results.append(count_1 * (2 ** (n - 1)))\n    \n    return results\n\n# Reading input and outputting results\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ncases = []\n\nfor i in range(t):\n    n = int(data[2 * i + 1])\n    a = list(map(int, data[2 * i + 2].split()))\n    cases.append((n, a))\n\nresults = nearly_full_subsequences(t, cases)\nfor result in results:\n    print(result)"}
{"task_id": "1582_C. Grandma Capa Knits a Scarf", "solution": "def find_min_removals_to_palindrome(t, test_cases):\n    results = []\n    \n    for n, s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n        \n        for char in unique_chars:\n            left, right = 0, n - 1\n            removals = 0\n            \n            while left < right:\n                if s[left] == s[right]:\n                    left += 1\n                    right -= 1\n                elif s[left] == char:\n                    removals += 1\n                    left += 1\n                elif s[right] == char:\n                    removals += 1\n                    right -= 1\n                else:\n                    removals = float('inf')  # Not possible to make it palindrome with this char\n                    break\n            \n            min_removals = min(min_removals, removals)\n        \n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n    \n    return results\n\n# Read input from stdin and execute the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nfor i in range(1, 2 * t, 2):\n    n = int(data[i])\n    s = data[i + 1]\n    test_cases.append((n, s))\n\nresults = find_min_removals_to_palindrome(t, test_cases)\n\nfor result in results:\n    print(result)"}
{"task_id": "1582_D. Vupsen, Pupsen and 0", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0].strip())\n    result = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index].strip())\n        a = list(map(int, data[index + 1].strip().split()))\n        \n        b = [0] * n\n        \n        if n % 2 == 0:  # If n is even\n            for i in range(n // 2):\n                b[i] = 1\n                b[n // 2 + i] = -1\n        else:  # If n is odd\n            for i in range(n // 2):\n                b[i] = 1\n                b[n // 2 + i] = -1\n            b[n - 1] = (n // 2)  # Make the last element a large enough positive number\n        \n        result.append(\" \".join(map(str, b)))\n        index += 2\n    \n    sys.stdout.write(\"\\n\".join(result) + \"\\n\")"}
{"task_id": "1582_E. Pchelyonok and Segments", "solution": "def max_non_overlapping_segments(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        # Step 1: Compute the cumulative sums\n        cum_sum = [0] * (n + 1)\n        for i in range(n):\n            cum_sum[i + 1] = cum_sum[i] + a[i]\n\n        k = 0  # Maximum k found\n        \n        # We will try to find segments of length k, k-1, ..., 1\n        while True:\n            current_k = k + 1  # Try to find k+1 segments\n            last_sum = -1\n            last_end = 0\n            valid_segments = 0\n            \n            for length in range(current_k, 0, -1):  # From k to 1\n                found = False\n                \n                for start in range(last_end + 1, n - length + 2):  # start from end of last segment\n                    end = start + length - 1\n                    segment_sum = cum_sum[end] - cum_sum[start - 1]\n                    \n                    if segment_sum > last_sum:\n                        last_sum = segment_sum\n                        last_end = end\n                        valid_segments += 1\n                        found = True\n                        break\n                \n                if not found:  # If we can't find a segment of this length, break\n                    break\n            \n            if valid_segments < current_k:\n                break  # We can't find k+1 segments, so return k\n            \n            k = current_k  # We found k+1 segments, so update k\n        \n        results.append(k)\n    \n    return results\n\n# Read input and prepare data for test cases\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Get results\nresults = max_non_overlapping_segments(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "1582_F1. Korney Korneevich and XOR (easy version)", "solution": "def find_xor_values(n, a):\n    # Step 1: Create a set to store unique XOR results\n    xor_results = {0}  # Start with 0 from the empty subsequence\n    unique_values = sorted(set(a))  # Get unique values and sort them\n    \n    # Step 2: Process each unique value\n    for value in unique_values:\n        # Create a new set to hold new values\n        new_xor_results = set()\n        for existing_xor in xor_results:\n            new_xor_results.add(existing_xor ^ value)\n        # Update the main set with new values\n        xor_results.update(new_xor_results)\n    \n    # Convert results to a sorted list\n    sorted_results = sorted(xor_results)\n    \n    # Step 3: Return the count and the sorted values\n    return len(sorted_results), sorted_results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n+1]))\n\n# Execute the function\nk, x_values = find_xor_values(n, a)\n\n# Print output\nprint(k)\nprint(' '.join(map(str, x_values)))"}
{"task_id": "1582_F2. Korney Korneevich and XOR (hard version)", "solution": "def find_xor_values(n, a):\n    achievable_xors = {0}  # Start with the XOR value of the empty subsequence\n    unique_numbers = set(a)  # Use a set to consider each number only once\n\n    for number in unique_numbers:\n        new_xors = set()  # To store new achievable XOR values for this number\n        for x in achievable_xors:\n            new_xor = x ^ number  # Compute the new XOR value\n            new_xors.add(new_xor)  # Add to the new_xors set\n        achievable_xors.update(new_xors)  # Update the main set with new values\n\n    result = sorted(achievable_xors)  # Sort the result for output\n    return len(result), result  # Return the size and the sorted list\n\n# The main function to handle input/output\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])  # Read the size of the array\n    a = list(map(int, data[1:n + 1]))  # Read the array elements\n\n    k, x_values = find_xor_values(n, a)  # Compute the results\n    print(k)  # Output the number of unique x values\n    print(\" \".join(map(str, x_values)))  # Output the x values\n\n# Note: The actual function call would be handled when the script is run,\n# but for testing or direct execution, you can call main() if needed."}
{"task_id": "1582_G. Kuzya and Homework", "solution": "def count_simple_segments(n, a, b):\n    count = 0\n    l = 0\n    current_product = 1  # Starting value for the path calculation, x = 1\n    \n    for r in range(n):\n        if b[r] == '*':\n            current_product *= a[r]\n        else:  # b[r] == '/'\n            # Check if we can divide\n            if current_product % a[r] == 0:\n                current_product //= a[r]\n            else:\n                # Move `l` forward until we can get a valid segment\n                while l <= r and current_product % a[r] != 0:\n                    if b[l] == '*':\n                        current_product //= a[l]  # Revert the multiplication\n                    else:  # b[l] == '/'\n                        current_product *= a[l]  # Revert the division\n                    l += 1\n                # Now after moving `l`, we can safely divide\n                if l <= r:\n                    current_product //= a[r]\n        \n        # Count valid segments from l to r\n        count += (r - l + 1)\n        \n    return count\n\n# Read the inputs from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\na = list(map(int, data[1].split()))\nb = data[2]\n\n# Call the function and print the result\nresult = count_simple_segments(n, a, b)\nprint(result)"}
{"task_id": "1586_A. Windblume Ode", "solution": "def is_composite(num):\n    if num < 4:  # the smallest composite number is 4\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_largest_composite_subset(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        total_sum = sum(array)\n        \n        if is_composite(total_sum):\n            # If total sum is composite, take the whole array\n            indices = list(range(1, n + 1))  # 1-based indexing\n            results.append((n, indices))\n        else:\n            # If total sum is prime, try removing the smallest element\n            min_element = min(array)\n            min_index = array.index(min_element) + 1  # 1-based indexing\n            remaining_sum = total_sum - min_element\n            \n            if is_composite(remaining_sum):\n                # The remaining sum after removing the smallest element is composite\n                indices = list(range(1, n + 1))\n                indices.remove(min_index)\n                results.append((n - 1, indices))\n            else:\n                # It should always be possible to get a composite sum according to the problem statement\n                raise RuntimeError(\"Expected to find a composite sum subset but did not.\")\n    \n    return results\n\n# Read input and call the function\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = []\n\nline_idx = 1\nfor _ in range(t):\n    n = int(data[line_idx])\n    array = list(map(int, data[line_idx + 1].split()))\n    test_cases.append((n, array))\n    line_idx += 2\n\nresults = find_largest_composite_subset(test_cases)\n\n# Output results\nfor size, indices in results:\n    print(size)\n    print(' '.join(map(str, indices)))"}
{"task_id": "1586_B. Omkar and Heavenly Tree", "solution": "def construct_tree(test_cases):\n    results = []\n    for n, _ in test_cases:\n        edges = []\n        # Connect all other nodes to node 1\n        for i in range(2, n + 1):\n            edges.append((1, i))\n        results.append(edges)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        for __ in range(m):\n            index += 1  # Skip the restrictions\n        test_cases.append((n, m))\n    \n    results = construct_tree(test_cases)\n    \n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1586_C. Omkar and Determination", "solution": "def is_determinable(n, m, grid, queries):\n    # Track the leftmost empty cell for each row and the topmost empty cell for each column\n    leftmost_empty = [[-1] * m for _ in range(n)]\n    topmost_empty = [[-1] * n for _ in range(m)]\n\n    # Precompute leftmost empty cells for each row\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if leftmost_empty[i][0] == -1:\n                    leftmost_empty[i][0] = j\n\n    # Precompute topmost empty cells for each column\n    for j in range(m):\n        for i in range(n):\n            if grid[i][j] == '.':\n                if topmost_empty[j][0] == -1:\n                    topmost_empty[j][0] = i\n\n    results = []\n    for x1, x2 in queries:\n        x1 -= 1  # Zero-indexing\n        x2 -= 1  # Zero-indexing\n\n        determinable = True\n        \n        # Check rows in the range for any filled cells\n        for i in range(n):\n            if any(grid[i][j] == 'X' for j in range(x1, x2 + 1)):\n                determinable = False\n                break\n\n        if determinable:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Read the inputs and prepare the grid\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\ngrid = [data[i + 1] for i in range(n)]\nq = int(data[n + 1])\nqueries = [tuple(map(int, data[n + 2 + i].split())) for i in range(q)]\n\n# Get the results\nresults = is_determinable(n, m, grid, queries)\n\n# Print results\nprint(\"\\n\".join(results))"}
{"task_id": "1586_D. Omkar and the Meaning of Life", "solution": "import sys\n\ndef flush():\n    sys.stdout.flush()\n\ndef query(a):\n    print(\"? \" + \" \".join(map(str, a)))\n    flush()\n    return int(input().strip())\n\ndef main():\n    n = int(input().strip())\n    \n    # Step 1: First query with all ones\n    a1 = [1] * n\n    answer1 = query(a1)\n    \n    # Step 2: Second query with a known pattern\n    a2 = list(range(1, n + 1))\n    answer2 = query(a2)\n    \n    # We will store the values of p in this list\n    p = [0] * n\n    \n    # Using the two answers to determine possible values for p\n    # We will use the responses to deduce the permutation\n    for i in range(1, n + 1):\n        # We know that s_j = p_j + a1_j (where a1_j is 1 for all j)\n        # Therefore, s_j = p_j + 1\n        # p_j = s_j - 1\n        \n        if answer1 == 0:\n            p[i-1] = (answer2 - i)  # This will deduce the value from the second query\n        else:\n            # From the first query\n            # If answer1 returns an index, we can deduce:\n            # p[answer1 - 1] = (s at answer1) - 1\n            # We need to find the exact value for p at that index\n            p[answer1 - 1] = (answer1 + 1 - 1)  # effectively s[answer1] - 1\n    \n    # Step 3: Output the determined permutation\n    print(\"! \" + \" \".join(map(str, p)))\n    flush()\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1586_E. Moment of Bloom", "solution": "from sys import stdin, stdout\nfrom collections import defaultdict, deque\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef bfs_path(graph, start, end):\n    queue = deque([start])\n    prev = {start: None}\n    \n    while queue:\n        node = queue.popleft()\n        \n        if node == end:\n            path = []\n            while node is not None:\n                path.append(node)\n                node = prev[node]\n            return path[::-1]  # Return reversed path\n        \n        for neighbor in graph[node]:\n            if neighbor not in prev:  # Check if not visited\n                prev[neighbor] = node\n                queue.append(neighbor)\n    \n    return None  # No path found\n\ndef main():\n    input = stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    \n    graph = defaultdict(list)\n    edges = []\n    \n    for i in range(1, m + 1):\n        x, y = map(int, data[i].split())\n        graph[x].append(y)\n        graph[y].append(x)\n        edges.append((x, y))\n    \n    q = int(data[m + 1])\n    queries = []\n    \n    for i in range(m + 2, m + 2 + q):\n        a, b = map(int, data[i].split())\n        queries.append((a, b))\n    \n    # Union-Find structures\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    \n    # Process queries\n    paths = []\n    for a, b in queries:\n        path = bfs_path(graph, a, b)\n        if path is not None:\n            paths.append(path)\n            for i in range(len(path) - 1):\n                union(parent, rank, path[i], path[i + 1])\n    \n    # Check if all edges can be even after processing all queries\n    edge_count = defaultdict(int)\n    \n    for path in paths:\n        l = len(path)\n        for i in range(l - 1):\n            edge_count[(min(path[i], path[i + 1]), max(path[i], path[i + 1]))] += 1\n    \n    odd_edges = sum(1 for count in edge_count.values() if count % 2 == 1)\n    \n    if odd_edges == 0:\n        stdout.write(\"YES\\n\")\n        for path in paths:\n            stdout.write(f\"{len(path)}\\n\")\n            stdout.write(\" \".join(map(str, path)) + \"\\n\")\n    else:\n        stdout.write(\"NO\\n\")\n        stdout.write(f\"{odd_edges}\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1586_F. Defender of Childhood Dreams", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    n, k = map(int, input().strip().split())\n    \n    # Determine the minimum number of colors needed\n    if k <= n // 2:\n        c = 3\n    else:\n        c = 2\n        \n    # Prepare the output for edge coloring\n    colors = []\n    color_pattern = [[1, 2], [1, 3], [2, 3]]\n    \n    color_idx = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if c == 2:\n                # Alternate between 1 and 2 for 2 colors\n                colors.append(1 if (i + j) % 2 == 0 else 2)\n            elif c == 3:\n                # Cycle through 3 colors\n                colors.append(color_pattern[color_idx % 3][0] if (j - i) % 3 == 0 else color_pattern[color_idx % 3][1])\n                color_idx += 1\n    \n    # Output the results\n    print(c)\n    print(\" \".join(map(str, colors)))"}
{"task_id": "1586_G. Omkar and Time Travel", "solution": "def count_time_travels(n, tasks, t, funny_tasks):\n    MOD = 10**9 + 7\n    \n    # Store the tasks with their respective (a_k, b_k)\n    task_info = [(tasks[i][0], tasks[i][1], i + 1) for i in range(n)]\n    \n    # Sort tasks based on b_k\n    task_info.sort(key=lambda x: x[1])  # Sort by b_k\n    \n    completed = [False] * (n + 1)  # Track completion status of tasks (1-indexed)\n    time_travel_count = 0\n    \n    # To check if all funny tasks are completed\n    funny_task_set = set(funny_tasks)\n\n    # Process each task by its realization time (b_k)\n    for b_k, (a_k, _, idx) in enumerate(task_info):\n        if completed[idx]:\n            continue\n        \n        # Okabe needs to time travel back to a_k\n        time_travel_count += 1\n        completed[idx] = True\n        \n        # Check which tasks need to be reverted\n        for j in range(b_k + 1, n):\n            if task_info[j][0] > a_k:  # If a_j > a_k, revert it\n                completed[task_info[j][2]] = False\n\n        # Check if all funny tasks are completed\n        if all(completed[task] for task in funny_task_set):\n            break\n    \n    return time_travel_count % MOD\n\n# Input processing\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0].strip())\ntasks = [tuple(map(int, data[i + 1].strip().split())) for i in range(n)]\nt = int(data[n + 1].strip())\nfunny_tasks = list(map(int, data[n + 2].strip().split()))\n\n# Calculate the result\nresult = count_time_travels(n, tasks, t, funny_tasks)\n\n# Output the result\nprint(result)"}
{"task_id": "1586_H. Omkar and Tours", "solution": "from collections import defaultdict, deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n    \n    enjoyment = list(map(int, data[idx:idx + n]))\n    idx += n\n    \n    edges = []\n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[idx]) - 1\n        b = int(data[idx + 1]) - 1\n        c = int(data[idx + 2])\n        t = int(data[idx + 3])\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n        idx += 4\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[idx])\n        x = int(data[idx + 1]) - 1\n        queries.append((v, x))\n        idx += 2\n    \n    # To store max enjoyment value reachable from each node\n    max_enjoyment = [0] * n\n    max_toll = [0] * n\n    \n    # Function to perform DFS traversal\n    def dfs(node, parent):\n        max_enjoy = enjoyment[node]\n        tolls = []\n        \n        for neighbor, capacity, toll in graph[node]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, node)\n            max_enjoy = max(max_enjoy, max_enjoyment[neighbor])\n            tolls.append((capacity, toll))\n        \n        max_enjoyment[node] = max_enjoy\n        max_toll[node] = tolls\n    \n    dfs(0, -1)\n    \n    # Results list for output\n    results = []\n    \n    for v, x in queries:\n        # BFS to find the maximum enjoyment and minimum toll\n        queue = deque([x])\n        visited = set([x])\n        local_max_enjoy = enjoyment[x]\n        max_toll_value = 0\n        \n        while queue:\n            current = queue.popleft()\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    local_max_enjoy = max(local_max_enjoy, enjoyment[neighbor])\n                    max_toll_value = max(max_toll_value, toll)\n        \n        results.append(f\"{local_max_enjoy} {max_toll_value}\")\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1586_I. Omkar and Mosaic", "solution": "def solve():\n    import sys\n    from collections import deque\n\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    n = int(data[0])\n    grid = [list(data[i + 1]) for i in range(n)]\n\n    # Directions for adjacent tiles (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # To hold if the color is decided\n    decided_colors = [[None for _ in range(n)] for _ in range(n)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Initialize the queue and decided_colors based on existing tiles\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S' or grid[i][j] == 'G':\n                decided_colors[i][j] = grid[i][j]\n                queue.append((i, j))\n    \n    # Process the grid to propagate known colors\n    while queue:\n        x, y = queue.popleft()\n        current_color = decided_colors[x][y]\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            # Check in bounds\n            if 0 <= nx < n and 0 <= ny < n:\n                if decided_colors[nx][ny] is None:\n                    # Decide the color for the adjacent tile\n                    decided_colors[nx][ny] = 'G' if current_color == 'S' else 'S'\n                    queue.append((nx, ny))\n                else:\n                    # Check for contradiction\n                    if (current_color == 'S' and decided_colors[nx][ny] == 'S') or \\\n                       (current_color == 'G' and decided_colors[nx][ny] == 'G'):\n                        # If we have the same color already, it should not be adjacent to it\n                        print(\"NONE\")\n                        return\n\n    # Now we need to check if we can fill remaining empty cells\n    unique = True\n    result_grid = [['.'] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            if decided_colors[i][j] is not None:\n                result_grid[i][j] = decided_colors[i][j]\n            else:\n                # If this cell is undecided, we can choose either S or G\n                count = {'S': 0, 'G': 0}\n                for dx, dy in directions:\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < n and 0 <= ny < n and decided_colors[nx][ny] is not None:\n                        count[decided_colors[nx][ny]] += 1\n                \n                if count['S'] > 0 and count['G'] > 0:\n                    print(\"NONE\")\n                    return\n                \n                if count['S'] > 0:\n                    result_grid[i][j] = 'G'\n                elif count['G'] > 0:\n                    result_grid[i][j] = 'S'\n                else:\n                    # If no neighbors, we can choose freely\n                    unique = False\n                    result_grid[i][j] = 'S'  # Choose one color, say S initially\n\n    # Now we need to check for uniqueness\n    if not unique:\n        print(\"MULTIPLE\")\n    else:\n        print(\"UNIQUE\")\n        for row in result_grid:\n            print(''.join(row))"}
{"task_id": "1591_A. Life of a Flower", "solution": "def flower_growth(test_cases):\n    results = []\n    for n, watering in test_cases:\n        height = 1\n        previous_watered = False\n        \n        for i in range(n):\n            if watering[i] == 1:\n                if previous_watered:\n                    height += 5\n                else:\n                    height += 1\n                previous_watered = True\n            else:  # watering[i] == 0\n                if not previous_watered:\n                    results.append(-1)\n                    break\n                previous_watered = False\n        else:\n            results.append(height)\n    \n    return results\n\n# Reading input from stdin and writing output to stdout\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        watering = list(map(int, data[index + 1].split()))\n        cases.append((n, watering))\n        index += 2\n\n    results = flower_growth(cases)\n    for result in results:\n        print(result)"}
{"task_id": "1591_B. Array Eversion", "solution": "def eversion_count(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        a = case[1]\n        \n        k = 0\n        while True:\n            x = a[-1]\n            left = [val for val in a if val <= x]\n            right = [val for val in a if val > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n            \n        results.append(k)\n    \n    return results\n\n# Read from stdin and process the input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Get the results and print them\nresults = eversion_count(test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1591_C. Minimize Distance", "solution": "def minimum_distance_to_deliver_bags(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, k = case[0]\n        positions = case[1]\n        \n        # Sort the positions\n        positions.sort()\n        \n        total_distance = 0\n        \n        # Process from the farthest depot to the nearest\n        for i in range(n - 1, -1, -k):\n            # The furthest depot we can deliver to in this batch\n            farthest_depot = positions[i]\n            # Each trip to the farthest depot and return (2 * distance)\n            total_distance += 2 * abs(farthest_depot)\n        \n        # Since the last trip does not require a return to origin\n        last_depot = positions[n - 1 - (n - 1) % k]\n        total_distance -= abs(last_depot)\n        \n        results.append(total_distance)\n    \n    return results\n\n# Reading input and invoking the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n, k = map(int, data[index].split())\n    positions = list(map(int, data[index + 1].split()))\n    test_cases.append(((n, k), positions))\n    index += 2\n\nresults = minimum_distance_to_deliver_bags(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1591_D. Yet Another Sorting Problem", "solution": "def can_sort_with_cycles(test_cases):\n    results = []\n    for a in test_cases:\n        n = len(a)\n        sorted_a = sorted(a)\n        \n        # Create a mapping of value to their indices in the original and sorted arrays\n        index_map = {}\n        for i in range(n):\n            if a[i] in index_map:\n                index_map[a[i]].append(i)\n            else:\n                index_map[a[i]] = [i]\n        \n        # Create a visited array to track which indices we have analyzed\n        visited = [False] * n\n        \n        # Check cycles\n        for i in range(n):\n            if visited[i]:\n                continue\n            \n            # Start a cycle\n            cycle_size = 0\n            # Follow the indices until we loop back\n            current = i\n            while not visited[current]:\n                visited[current] = True\n                cycle_size += 1\n                # Move to where current element should go in sorted array\n                current = index_map[sorted_a[current]].pop()\n            \n            # Check if the cycle can be sorted\n            if cycle_size % 3 != 0:\n                results.append(\"NO\")\n                break\n        else:\n            results.append(\"YES\")\n    \n    return results\n\n# Read the input and produce output\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nfor i in range(1, 2 * t, 2):\n    n = int(data[i])  # length of the array\n    array = list(map(int, data[i + 1].split()))\n    test_cases.append(array)\n\nresults = can_sort_with_cycles(test_cases)\nprint(\"\\n\".join(results))"}
{"task_id": "1591_E. Frequency Queries", "solution": "def solve():\n    import sys\n    from collections import defaultdict, Counter\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        q = int(data[index + 1])\n        index += 2\n        \n        values = list(map(int, data[index:index + n]))\n        index += n\n        \n        parent = [0] + list(map(int, data[index:index + n - 1]))  # include dummy 0 for root\n        index += n - 1\n        \n        queries = []\n        for __ in range(q):\n            v, l, k = map(int, data[index:index + 3])\n            queries.append((v, l, k))\n            index += 3\n        \n        # Prepare adjacency list\n        tree = defaultdict(list)\n        for child in range(2, n + 1):\n            tree[parent[child - 1]].append(child)\n        \n        # Answer each query\n        for v, l, k in queries:\n            cur = v\n            path = []\n            \n            # Get the path from v to root\n            while cur > 0:\n                path.append(values[cur - 1])\n                cur = parent[cur - 1]\n            \n            # Count occurrences\n            count = Counter(path)\n            \n            # Filter based on l\n            filtered = [(num, cnt) for num, cnt in count.items() if cnt >= l]\n            filtered.sort(key=lambda x: x[1])  # Sort by count (first element of tuple)\n            \n            # Prepare the answer\n            if len(filtered) < k:\n                results.append(\"-1\")\n            else:\n                results.append(str(filtered[k - 1][0]))\n    \n    # Output the result for all queries\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")"}
{"task_id": "1591_F. Non-equal Neighbours", "solution": "def count_valid_arrays(n, a):\n    MOD = 998244353\n    \n    if a[0] == 1 and n > 1:\n        return 0\n    \n    total_count = a[0]  # choices for b1\n    for i in range(1, n):\n        if a[i] == 1:  # if we have a_i = 1\n            # If previous b was also 1, we cannot choose a valid b_i\n            if total_count > 0:\n                return 0\n            else:\n                total_count = 0\n                break\n        else:\n            total_count = total_count * (a[i] - 1) % MOD\n    \n    return total_count\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Print the result\nprint(count_valid_arrays(n, a))"}
{"task_id": "1594_A. Consecutive Sum Riddle", "solution": "def find_lr(n):\n    # Iterate over possible values for k\n    for k in range(1, 10**6):\n        if (2 * n) % k == 0:  # k must divide 2n\n            sum_lr = (2 * n) // k  # This corresponds to l + r\n            # Calculate l and r based on the formulas derived\n            r = (sum_lr + (k - 1)) // 2\n            l = (sum_lr - (k - 1)) // 2\n            \n            if l < r and -10**18 <= l < r <= 10**18:\n                return l, r\n    return None  # This should not occur as a solution always exists\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n\n    for i in range(1, t + 1):\n        n = int(data[i])\n        l, r = find_lr(n)\n        results.append(f\"{l} {r}\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1594_B. Special Numbers", "solution": "def modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:  # If exp is odd\n            result = (result * base) % mod\n        exp = exp >> 1  # Divide exp by 2\n        base = (base * base) % mod\n    return result\n\ndef find_kth_special_number(n, k):\n    mod = 10**9 + 7\n    result = 0\n    power = 0\n    \n    while k > 0:\n        if k & 1:  # If the least significant bit is set\n            result = (result + modular_exponentiation(n, power, mod)) % mod\n        k >>= 1  # Right shift k to process the next bit\n        power += 1  # Move to the next power of n\n        \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0].strip())\n    results = []\n    \n    for i in range(1, t + 1):\n        n, k = map(int, data[i].strip().split())\n        special_number = find_kth_special_number(n, k)\n        results.append(special_number)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1594_C. Make Them Equal", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Number of test cases\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, c = data[index].split()\n        n = int(n)\n        s = data[index + 1]\n        index += 2\n        \n        # Check which characters are not c\n        not_c_positions = [i + 1 for i in range(n) if s[i] != c]\n        \n        if not not_c_positions:\n            results.append(\"0\")\n            continue\n        \n        operations = []\n        \n        # If there are characters `!= c` at odd indices\n        if any((pos % 2 != 0) for pos in not_c_positions):\n            operations.append(2)  # x = 2 to target even indices\n        \n        # If there are characters `!= c` at even indices\n        if any((pos % 2 == 0) for pos in not_c_positions):\n            operations.append(3)  # x = 3 to target odd indices\n\n        results.append(str(len(operations)))\n        results.append(\" \".join(map(str, operations)))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1594_D. The Number of Imposters", "solution": "def maximum_imposters(t, test_cases):\n    results = []\n    \n    for n, m, comments in test_cases:\n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for i, j, c in comments:\n            if c == \"imposter\":\n                graph[i].append((j, 1))  # 1 means j is an imposter\n                graph[j].append((i, 0))  # 0 means i is a crewmate\n            else:  # c == \"crewmate\"\n                graph[i].append((j, 0))  # 0 means j is a crewmate\n                graph[j].append((i, 1))  # 1 means i is an imposter\n        \n        color = [-1] * (n + 1)  # -1 means unvisited\n        is_possible = True\n        total_imposters = 0\n        \n        def bfs(start):\n            queue = deque([start])\n            color[start] = 0  # Start coloring with 0\n            counts = [0, 0]  # counts[0] for crewmates, counts[1] for imposters\n            counts[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color if relation == 0 else 1 - current_color\n                    \n                    if color[neighbor] == -1:  # If unvisited\n                        color[neighbor] = expected_color\n                        counts[expected_color] += 1\n                        queue.append(neighbor)\n                    elif color[neighbor] != expected_color:\n                        return False, (0, 0)  # Conflict detected\n            \n            return True, counts\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:  # Not visited\n                possible, counts = bfs(player)\n                if not possible:\n                    is_possible = False\n                    break\n                total_imposters += max(counts)\n        \n        if is_possible:\n            results.append(total_imposters)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Read input and run the function\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n, m = map(int, data[index].split())\n    comments = []\n    for j in range(m):\n        i, j, c = data[index + 1 + j].split()\n        comments.append((int(i), int(j), c))\n    test_cases.append((n, m, comments))\n    index += m + 1\n\nresults = maximum_imposters(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1594_E1. Rubik's Cube Coloring (easy version)", "solution": "def count_colorings(k):\n    MOD = 10**9 + 7\n    \n    # Number of colors\n    num_colors = 6\n    \n    # The dp array, where dp[level][color] represents the number of valid colorings at that level\n    dp = [[0] * num_colors for _ in range(k)]\n    \n    # Base case: at the leaf level, every color can be used independently\n    for color in range(num_colors):\n        dp[k-1][color] = 1\n    \n    # Fill dp table from bottom to top\n    for level in range(k-2, -1, -1):\n        for color in range(num_colors):\n            count = 0\n            # Calculate the valid color combinations for children\n            for child_color in range(num_colors):\n                # Check if child_color can be adjacent to color\n                if (color == 0 and (child_color == 0 or child_color == 1)) or \\\n                   (color == 1 and (child_color == 0 or child_color == 1)) or \\\n                   (color == 2 and (child_color == 2 or child_color == 3)) or \\\n                   (color == 3 and (child_color == 2 or child_color == 3)) or \\\n                   (color == 4 and (child_color == 4 or child_color == 5)) or \\\n                   (color == 5 and (child_color == 4 or child_color == 5)):\n                    continue\n                count += dp[level + 1][child_color]\n                count %= MOD\n            dp[level][color] = (count * count) % MOD  # Both children can be any of the valid configurations\n    \n    # The answer is the sum of all valid colorings at the root level (level 0)\n    return sum(dp[0]) % MOD\n\n# Read input and output the result\nimport sys\ninput = sys.stdin.read\n\nk = int(input().strip())\nprint(count_colorings(k))"}
{"task_id": "1594_E2. Rubik's Cube Coloring (hard version)", "solution": "def solve():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    MOD = 10**9 + 7\n    \n    # Read input\n    k = int(data[0])\n    n = int(data[1])\n    \n    # Predefined colors\n    predefined_colors = {}\n    for i in range(n):\n        v, s = data[2 + i].split()\n        predefined_colors[int(v)] = s\n    \n    # Define color restrictions\n    color_neighbors = {\n        \"white\": {\"green\", \"blue\", \"red\", \"orange\"},  # can be with yellow\n        \"yellow\": {\"green\", \"blue\", \"red\", \"orange\"},  # can be with white\n        \"green\": {\"white\", \"yellow\", \"red\", \"orange\"},  # can be with blue\n        \"blue\": {\"white\", \"yellow\", \"red\", \"orange\"},  # can be with green\n        \"red\": {\"white\", \"yellow\", \"green\", \"blue\"},  # can be with orange\n        \"orange\": {\"white\", \"yellow\", \"green\", \"blue\"},  # can be with red\n    }\n\n    colors = [\"white\", \"yellow\", \"green\", \"blue\", \"red\", \"orange\"]\n    \n    # Memoization dictionary\n    memo = {}\n\n    def is_valid(curr_color, neighbor_color):\n        return neighbor_color not in color_neighbors[curr_color]\n\n    def count_colorings(node):\n        if node in predefined_colors:\n            # If this node has a predefined color, we can only use that one\n            color = predefined_colors[node]\n            # Check children\n            left = 2 * node\n            right = 2 * node + 1\n            \n            # If it's a leaf node\n            if left > (2**k - 1) and right > (2**k - 1):\n                return 1  # one way to color a leaf\n            \n            total_ways = 1\n            \n            for child in (left, right):\n                if child <= (2**k - 1):\n                    # Count valid ways for child\n                    child_ways = 0\n                    for c in colors:\n                        if is_valid(color, c):\n                            child_ways = (child_ways + count_colorings(child)) % MOD\n                    total_ways = (total_ways * child_ways) % MOD\n            \n            return total_ways\n        \n        else:\n            # No predefined color, we can choose any color for this node\n            total_ways = 0\n            \n            for color in colors:\n                # Check the colors of the children to count valid ways\n                left = 2 * node\n                right = 2 * node + 1\n                \n                child_ways = 1\n                for child in (left, right):\n                    if child <= (2**k - 1):\n                        if child in predefined_colors:\n                            child_color = predefined_colors[child]\n                            if is_valid(color, child_color):\n                                child_ways = (child_ways * 1) % MOD\n                            else:\n                                child_ways = 0\n                        else:\n                            valid_child_count = sum(is_valid(color, c) for c in colors)\n                            child_ways = (child_ways * valid_child_count) % MOD\n\n                total_ways = (total_ways + child_ways) % MOD\n            \n            return total_ways\n    \n    # Start from root node 1\n    answer = count_colorings(1)\n    print(answer)"}
{"task_id": "1594_F. Ideal Farm", "solution": "def is_farm_ideal(test_cases):\n    results = []\n    for s, n, k in test_cases:\n        if n > s or k < n or k > s - n + 1:\n            results.append(\"NO\")\n        else:\n            results.append(\"YES\")\n    return results\n\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n    \n    results = is_farm_ideal(test_cases)\n    print(\"\\n\".join(results))"}
{"task_id": "1598_A. Computer Game", "solution": "def can_complete_level(test_cases):\n    results = []\n    for (n, row1, row2) in test_cases:\n        # Start in (1, 1), which is safe\n        can_reach_row_1 = True  # can we end up in row 1 at column n\n        can_reach_row_2 = False # can we end up in row 2 at column n (we want this eventually)\n\n        for j in range(n):\n            # Get the current cell states\n            current_row1 = row1[j] == '0'\n            current_row2 = row2[j] == '0'\n\n            # Determine if we can reach the next column\n            new_can_reach_row_1 = (can_reach_row_1 and current_row1) or (can_reach_row_2 and current_row1)\n            new_can_reach_row_2 = (can_reach_row_1 and current_row2) or (can_reach_row_2 and current_row2)\n\n            # Update reachability for the next column\n            can_reach_row_1 = new_can_reach_row_1\n            can_reach_row_2 = new_can_reach_row_2\n\n            # If both rows are blocked, terminate early\n            if not can_reach_row_1 and not can_reach_row_2:\n                results.append(\"NO\")\n                break\n        else:\n            # If we finished the loop without breaking\n            if can_reach_row_2:\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n\n    return results\n\n# Read input and run the solution\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        row1 = data[index + 1].strip()\n        row2 = data[index + 2].strip()\n        test_cases.append((n, row1, row2))\n        index += 3\n    \n    results = can_complete_level(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1598_B. Groups", "solution": "def can_divide_students(n, availability):\n    # Count how many students are available for each day\n    availability_count = [0] * 5\n    for student in availability:\n        for j in range(5):\n            if student[j] == 1:\n                availability_count[j] += 1\n                \n    # Check pairs of days\n    for i in range(5):\n        for j in range(i + 1, 5):\n            group1 = []\n            group2 = []\n            for index in range(n):\n                if availability[index][i] == 1 and len(group1) < n // 2:\n                    group1.append(index)\n                elif availability[index][j] == 1 and len(group2) < n // 2:\n                    group2.append(index)\n                    \n            # Check if we have valid groups of size n / 2\n            if len(group1) == n // 2 and len(group2) == n // 2:\n                return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        availability = []\n        \n        for _ in range(n):\n            availability.append(list(map(int, data[index].split())))\n            index += 1\n        \n        result = can_divide_students(n, availability)\n        results.append(result)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1598_C. Delete Two Elements", "solution": "def count_valid_pairs(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        total_sum = sum(a)\n        if total_sum * 2 % n != 0:  # If 2k isn't an integer, no valid pairs\n            results.append(0)\n            continue\n        \n        k = total_sum / n\n        target_sum = 2 * k\n        \n        count_map = {}\n        valid_pairs_count = 0\n        \n        for number in a:\n            complement = target_sum - number\n            if complement in count_map:\n                valid_pairs_count += count_map[complement]\n            \n            # Update the count of the current number\n            if number in count_map:\n                count_map[number] += 1\n            else:\n                count_map[number] = 1\n        \n        results.append(valid_pairs_count)\n    \n    return results\n\n# Reading input and processing it\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\n# Getting the results\nresults = count_valid_pairs(t, test_cases)\n\n# Printing the results\nfor result in results:\n    print(result)"}
{"task_id": "1598_D. Training Session", "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for i in range(n):\n            a, b = map(int, data[idx].split())\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n            idx += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for count in topics.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n        \n        for count in difficulties.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(str(valid_combinations))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1598_E. Staircases", "solution": "def count_staircases(n, m, queries):\n    # Initialize the matrix as free\n    matrix = [[True] * m for _ in range(n)]\n    total_staircases = 0\n\n    # Functions to calculate staircases based on current matrix state\n    def calculate_staircases():\n        nonlocal total_staircases\n        dp1 = [[0] * m for _ in range(n)]\n        dp2 = [[0] * m for _ in range(n)]\n        \n        # Count staircases of type 1: right then down\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    dp1[i][j] = 1  # single cell counts as staircase\n                    if j > 0:\n                        dp1[i][j] += dp1[i][j - 1]  # extend horizontally\n                    if i > 0 and j < m - 1:\n                        dp1[i][j] += dp1[i - 1][j + 1]  # extend vertically\n                    \n                    total_staircases += dp1[i][j]\n        \n        # Count staircases of type 2: down then right\n        for j in range(m):\n            for i in range(n):\n                if matrix[i][j]:\n                    dp2[i][j] = 1  # single cell counts as staircase\n                    if i > 0:\n                        dp2[i][j] += dp2[i - 1][j]  # extend vertically\n                    if j > 0 and i < n - 1:\n                        dp2[i][j] += dp2[i + 1][j - 1]  # extend horizontally\n                    \n                    total_staircases += dp2[i][j]\n\n    # Initial calculation of staircases\n    calculate_staircases()\n    \n    results = []\n    for x, y in queries:\n        x -= 1  # Convert to zero-indexed\n        y -= 1\n        \n        # Toggle the cell state\n        matrix[x][y] = not matrix[x][y]\n        \n        # Recalculate the staircases after the toggle\n        total_staircases = 0\n        calculate_staircases()\n        \n        # Store the result\n        results.append(total_staircases)\n\n    return results\n\n# Read input and apply the function\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m, q = map(int, data[0].split())\n    queries = [tuple(map(int, line.split())) for line in data[1:q + 1]]\n    \n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1598_F. RBS", "solution": "def max_rbs_prefixes(sequences):\n    from sys import stdin, stdout\n    \n    n = len(sequences)\n    positive = []\n    negative = []\n    \n    for seq in sequences:\n        balance = 0\n        min_balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        \n        if balance >= 0:\n            positive.append((min_balance, balance))\n        else:\n            negative.append((min_balance, balance))\n    \n    # Sort positive by min_balance ascending\n    positive.sort()\n    \n    # Sort negative by balance descending\n    negative.sort(key=lambda x: x[1])\n    \n    total_rbs_prefixes = 0\n    current_balance = 0\n    current_min_balance = 0\n    \n    # Handle positive sequences first\n    for min_balance, balance in positive:\n        current_balance += balance\n        current_min_balance = min(current_min_balance + min_balance, current_balance)\n        if current_min_balance >= 0:\n            total_rbs_prefixes += 1  # At least the empty prefix is valid\n            # Count valid prefixes in this sequence\n            rbs_count = 0\n            running_sum = 0\n            for char in seq:\n                running_sum += 1 if char == '(' else -1\n                if running_sum >= 0:\n                    rbs_count += 1\n            total_rbs_prefixes += rbs_count\n    \n    # Handle negative sequences next\n    for min_balance, balance in negative:\n        if current_balance + balance < 0:\n            break  # If we cannot maintain a valid balance, stop early\n        current_balance += balance\n        current_min_balance = min(current_min_balance + min_balance, current_balance)\n        if current_min_balance >= 0:\n            total_rbs_prefixes += 1  # At least the empty prefix is valid\n    \n    return total_rbs_prefixes\n\n# Reading input and invoking the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\nsequences = data[1:n + 1]\n\nresult = max_rbs_prefixes(sequences)\nprint(result)"}
{"task_id": "1598_G. The Sum of Good Numbers", "solution": "def find_good_numbers(s, x):\n    n = len(s)\n    x = int(x)  # Convert x to an integer for comparison\n\n    # Iterate through the string to find valid pairs\n    for i in range(n):\n        # Start a number with 's[i]'\n        first_num = 0\n        first_start = i\n\n        # Extract first number\n        while i < n and s[i] != '0':\n            first_num = first_num * 10 + int(s[i])\n            i += 1\n\n        # Now i points to the next segment start\n        second_start = i\n\n        # Extract second number\n        second_num = 0\n        while i < n and s[i] != '0':\n            second_num = second_num * 10 + int(s[i])\n            i += 1\n\n        # Check if the sum of the two numbers equals x\n        if first_num + second_num == x:\n            # Output the indices in a 1-based format\n            first_end = first_start + len(str(first_num)) - 1\n            second_end = second_start + len(str(second_num)) - 1\n            print(first_start + 1, first_end + 1)\n            print(second_start + 1, second_end + 1)\n            return\n\n# Read inputs\ns = input().strip()\nx = input().strip()\n\n# Call the function to find and print the good numbers\nfind_good_numbers(s, x)"}
{"task_id": "1599_A. Weights", "solution": "def balance_weights(N, A, S):\n    # Sort the weights for easier access\n    A.sort()\n    \n    # This will hold the chosen weights and their sides\n    result = []\n    \n    # Sums for left and right sides\n    left_sum = 0\n    right_sum = 0\n    \n    # We will use a pointer to track the weights we can use\n    left_index = 0\n    right_index = N - 1\n    \n    for i in range(N):\n        if S[i] == 'L':\n            # We need to make the left side heavier\n            if left_sum <= right_sum:\n                result.append(f\"{A[right_index]} L\")\n                left_sum += A[right_index]\n                right_index -= 1\n            else:\n                # No valid arrangement if we can't satisfy the condition\n                return -1\n        else:\n            # We need to make the right side heavier\n            if right_sum <= left_sum:\n                result.append(f\"{A[left_index]} R\")\n                right_sum += A[left_index]\n                left_index += 1\n            else:\n                # No valid arrangement if we can't satisfy the condition\n                return -1\n    \n    return \"\\n\".join(result)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    A = list(map(int, data[1].split()))\n    S = data[2]\n    \n    answer = balance_weights(N, A, S)\n    print(answer)"}
{"task_id": "1599_B. Restaurant Game", "solution": "def last_remaining_card(T, cases):\n    results = []\n    for case in cases:\n        N, A, B, D_A, D_B = case\n        # Adjust directions to numerical values for easier calculations\n        direction_A = 1 if D_A == \"right\" else -1\n        direction_B = 1 if D_B == \"right\" else -1\n        \n        # Since N can be very large, we cannot simulate every step\n        # Their initial positions and directions will determine the outcome\n        # We will find the last card based on simulation logic\n        while N > 1:\n            # Check if they meet\n            if A == B:\n                # Remove the card at A/B\n                N -= 1\n                if direction_A == 1:\n                    A += 1\n                else:\n                    A -= 1\n                \n                if direction_B == 1:\n                    B += 1\n                else:\n                    B -= 1\n                \n                # Reverse directions if needed\n                if A < 0:\n                    A = 0\n                    direction_A = 1\n                elif A >= N:\n                    A = N - 1\n                    direction_A = -1\n                \n                if B < 0:\n                    B = 0\n                    direction_B = 1\n                elif B >= N:\n                    B = N - 1\n                    direction_B = -1\n            \n            else:\n                # Move both A and B\n                A += direction_A\n                B += direction_B\n                \n                # Handle boundaries\n                if A < 0:\n                    A = 0\n                    direction_A = 1\n                elif A >= N:\n                    A = N - 1\n                    direction_A = -1\n                \n                if B < 0:\n                    B = 0\n                    direction_B = 1\n                elif B >= N:\n                    B = N - 1\n                    direction_B = -1\n        \n        results.append(A)  # or B, since A should equal B when one card remains\n\n    return results\n\n# Read the inputs and process them\nimport sys\n\ninput_data = sys.stdin.read().strip().splitlines()\nT = int(input_data[0])\ncases = []\n\nfor i in range(1, T * 3, 3):\n    N = int(input_data[i])\n    A, B = map(int, input_data[i + 1].split())\n    D_A, D_B = input_data[i + 2].split()\n    cases.append((N, A, B, D_A, D_B))\n\nresults = last_remaining_card(T, cases)\nfor result in results:\n    print(result)"}
{"task_id": "1599_C. Bubble Strike", "solution": "from math import comb\n\ndef minimum_maps_to_study(N, P):\n    if P == 0:\n        return 0\n    if P == 1:\n        return N - 1\n    \n    total_combinations = comb(N, 3)\n    target_ratio = 1 - P\n    \n    for k in range(N - 2):  # k can be from 0 to N-3\n        studied_combinations = comb(N - k, 3)\n        if studied_combinations / total_combinations <= target_ratio:\n            return k\n    \n    return N - 1  # In case the loop doesn't return, we assume worst case\n\n# Read inputs\nimport sys\ninput_data = sys.stdin.read().strip()\nN, P = input_data.split()\nN = int(N)\nP = float(P)\n\n# Get result and print\nresult = minimum_maps_to_study(N, P)\nprint(result)"}
{"task_id": "1599_D. Bubble Popping", "solution": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    bubbles = []\n    for i in range(N):\n        x, y = map(int, data[index].split())\n        bubbles.append((x, y, i + 1))  # Store (x, y, index)\n        index += 1\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(Q):\n        dx, dy, K = map(int, data[index].split())\n        index += 1\n        \n        angles = []\n        \n        for x, y, original_index in bubbles:\n            angle = math.atan2(y, x) - math.atan2(dy, dx)\n            angles.append((angle, original_index))\n        \n        # Sort bubbles based on angle\n        angles.sort()\n        \n        # Get the last bubble popped based on K\n        last_bubble = angles[K - 1][1]\n        results.append(last_bubble)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1599_E. Two Arrays", "solution": "def fib(n, mod):\n    \"\"\" Return the Fibonacci numbers up to n, with F(0)=0, F(1)=1. \"\"\"\n    fibs = [0] * (n + 1)\n    fibs[1] = 1\n    for i in range(2, n + 1):\n        fibs[i] = (fibs[i - 1] + fibs[i - 2]) % mod\n    return fibs\n\ndef process_queries(N, Q, A1, A2, queries):\n    MOD = 10**9 + 7\n    \n    # Precompute Fibonacci numbers up to the maximum possible sum (2*10^6)\n    max_possible_sum = 2 * 10**6\n    fibs = fib(max_possible_sum, MOD)\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:  # min operation\n            k, l, r, x = query[1], query[2] - 1, query[3] - 1, query[4]\n            for i in range(l, r + 1):\n                if k == 1:\n                    A1[i] = min(A1[i], x)\n                else:\n                    A2[i] = min(A2[i], x)\n        \n        elif query[0] == 2:  # max operation\n            k, l, r, x = query[1], query[2] - 1, query[3] - 1, query[4]\n            for i in range(l, r + 1):\n                if k == 1:\n                    A1[i] = max(A1[i], x)\n                else:\n                    A2[i] = max(A2[i], x)\n\n        elif query[0] == 3:  # add operation\n            k, l, r, x = query[1], query[2] - 1, query[3] - 1, query[4]\n            for i in range(l, r + 1):\n                if k == 1:\n                    A1[i] += x\n                else:\n                    A2[i] += x\n\n        elif query[0] == 4:  # sum of Fibonacci\n            l, r = query[1] - 1, query[2] - 1\n            total = 0\n            for i in range(l, r + 1):\n                total = (total + fibs[A1[i] + A2[i]]) % MOD\n            results.append(total)\n\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Process input\nfirst_line = list(map(int, data[0].split()))\nN, Q = first_line[0], first_line[1]\nA1 = list(map(int, data[1].split()))\nA2 = list(map(int, data[2].split()))\nqueries = []\n\nfor line in data[3:]:\n    query = list(map(int, line.split()))\n    queries.append(query)\n\n# Get results\nresults = process_queries(N, Q, A1, A2, queries)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1599_F. Mars", "solution": "def can_connect_cities(N, cities, queries):\n    results = []\n    for L, R, D in queries:\n        # Convert 1-based index to 0-based\n        L -= 1\n        R -= 1\n        \n        # Calculate the differences in the circular section\n        differences = []\n        for i in range(L, R + 1):\n            if i == R:\n                next_city_index = L  # Wrap around\n            else:\n                next_city_index = i + 1\n            diff = (cities[next_city_index] - cities[i]) % D\n            differences.append(diff)\n\n        # The first difference modulo D\n        first_diff = differences[0]\n        # Check if all differences are the same modulo D\n        if all(diff == first_diff for diff in differences):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, Q = map(int, data[0].split())\ncities = list(map(int, data[1].split()))\nqueries = [tuple(map(int, line.split())) for line in data[2:2 + Q]]\n\n# Process the queries\nresults = can_connect_cities(N, cities, queries)\n\n# Output the results\nprint(\"\\n\".join(results))"}
{"task_id": "1599_G. Shortest path", "solution": "import sys\nimport math\n\ndef read_input():\n    data = sys.stdin.read().strip().splitlines()\n    n, k = map(int, data[0].split())\n    points = [tuple(map(int, line.split())) for line in data[1:n+1]]\n    return n, k - 1, points  # convert K to 0-based index\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef solve():\n    n, k, points = read_input()\n    \n    # Identify the point that is not on the line\n    collinear_points = points[:]\n    P = None\n\n    # Find the non-collinear point\n    if n == 3:\n        # If there are only three points, one must be non-collinear\n        P = points[0] if points[1] == points[2] else points[1]\n        collinear_points.remove(P)\n    else:\n        # For general case, we can assume the first point as a reference\n        p1 = points[0]\n        p2 = points[1]\n        p3 = points[2]\n        \n        # Calculate the area to check for collinearity\n        area = (p1[0] * (p2[1] - p3[1]) + \n                 p2[0] * (p3[1] - p1[1]) + \n                 p3[0] * (p1[1] - p2[1]))\n        \n        if area != 0:\n            P = p3  # p3 is non-collinear\n            collinear_points = [p1, p2]\n        else:\n            P = p2  # p2 is non-collinear\n            collinear_points = [p1, p3]\n\n    # Get the endpoints of the collinear segment\n    x_coords = [p[0] for p in collinear_points]\n    y_coords = [p[1] for p in collinear_points]\n    \n    leftmost = min(collinear_points)\n    rightmost = max(collinear_points)\n\n    # Calculate distances\n    min_dist_to_line = min(distance(points[k], p) for p in collinear_points)\n    line_length = distance(leftmost, rightmost)\n\n    # Total path length\n    total_distance = min_dist_to_line + line_length + min_dist_to_line\n    print(f\"{total_distance:.10f}\")"}
{"task_id": "1599_H. Hidden Fortress", "solution": "def find_enemy_fortress():\n    import sys\n    input = sys.stdin.readline\n    \n    # Function to query the device and return the distance\n    def query(x, y):\n        print(f\"? {x} {y}\")\n        sys.stdout.flush()\n        return int(input().strip())\n    \n    # Initialize the range for binary search\n    min_val, max_val = 2, 10**9 - 1  # Start from 2 because the base cannot include 1 or 10^9\n    \n    # Locate x_left\n    x_left = max_val\n    for x in range(min_val, max_val + 1):\n        if query(x, (min_val + max_val) // 2) == 0:\n            x_left = x\n            break\n    \n    # Locate x_right\n    x_right = min_val\n    for x in range(max_val, min_val - 1, -1):\n        if query(x, (min_val + max_val) // 2) == 0:\n            x_right = x\n            break\n    \n    # Locate y_bottom\n    y_bottom = max_val\n    for y in range(min_val, max_val + 1):\n        if query((min_val + max_val) // 2, y) == 0:\n            y_bottom = y\n            break\n    \n    # Locate y_top\n    y_top = min_val\n    for y in range(max_val, min_val - 1, -1):\n        if query((min_val + max_val) // 2, y) == 0:\n            y_top = y\n            break\n    \n    # Output the results\n    print(f\"! {x_left} {y_bottom} {x_right} {y_top}\")\n    sys.stdout.flush()\n\n# Run the function\nfind_enemy_fortress()"}
{"task_id": "1599_I. Desert", "solution": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef is_desert(n, edges):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    count_cycles = 0\n\n    for u, v in edges:\n        rootU = find(parent, u)\n        rootV = find(parent, v)\n\n        if rootU == rootV:\n            count_cycles += 1  # Cycle detected\n        else:\n            union(parent, rank, u, v)\n    \n    return count_cycles == 0\n\ndef count_desert_pairs(n, m, edge_list):\n    answer = 0\n    l = 0\n    \n    for r in range(m):\n        current_edges = edge_list[l:r + 1]\n        if is_desert(n, current_edges):\n            answer += (r - l + 1)\n        else:\n            while l <= r and not is_desert(n, edge_list[l:r + 1]):\n                l += 1\n            answer += (r - l + 1) if l <= r else 0\n    \n    return answer\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().splitlines()\n    n, m = map(int, data[0].split())\n    edge_list = [tuple(map(int, line.split())) for line in data[1:]]\n\n    result = count_desert_pairs(n, m, edge_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1599_J. Bob's Beautiful Array", "solution": "def find_original_array(N, B):\n    # Check if all elements in B are even\n    if any(b % 2 != 0 for b in B):\n        return \"NO\"\n    \n    # Generate A by halving each element in B\n    A = [b // 2 for b in B]\n    \n    # Now to check if A can generate all B[i]\n    from collections import Counter\n    \n    # Create a frequency dictionary of sums from A\n    possible_sums = Counter()\n    \n    for i in range(N):\n        for j in range(N):\n            possible_sums[A[i] + A[j]] += 1\n    \n    # Check if all B[i] can be formed from the possible sums\n    for b in B:\n        if possible_sums[b] > 0:\n            possible_sums[b] -= 1\n        else:\n            return \"NO\"\n    \n    return \"YES\", A\n\n# Read inputs\nN = int(input().strip())\nB = list(map(int, input().strip().split()))\n\n# Find the original array\nresult = find_original_array(N, B)\n\n# Print output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(*result[1])"}
{"task_id": "1600_E. Array Game", "solution": "def find_winner(N, A):\n    left = 0\n    right = N - 1\n    last_added = -1  # Start with a value less than any possible A[i]\n    moves = 0\n\n    while left <= right:\n        can_take_left = A[left] > last_added\n        can_take_right = A[right] > last_added\n        \n        if can_take_left and (not can_take_right or A[left] < A[right]):\n            last_added = A[left]\n            left += 1\n        elif can_take_right:\n            last_added = A[right]\n            right -= 1\n        else:\n            break\n        \n        moves += 1\n\n    return \"Alice\" if moves % 2 == 1 else \"Bob\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Output the result\nprint(find_winner(N, A))"}
{"task_id": "1600_F. Party Organization", "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    first_line = data[0].split()\n    N = int(first_line[0])\n    M = int(first_line[1])\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    for i in range(1, M + 1):\n        u, v = map(int, data[i].split())\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for complete friendship\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:  # We need at least 4 friends to form K5\n            friend_list = list(friends[person])\n            k = len(friend_list)\n            # Check combinations of friends for a complete friendship party\n            for i in range(k):\n                for j in range(i + 1, k):\n                    for l in range(j + 1, k):\n                        for m in range(l + 1, k):\n                            if (friend_list[i] in friends[friend_list[j]] and\n                                friend_list[i] in friends[friend_list[l]] and\n                                friend_list[i] in friends[friend_list[m]] and\n                                friend_list[j] in friends[friend_list[l]] and\n                                friend_list[j] in friends[friend_list[m]] and\n                                friend_list[l] in friends[friend_list[m]]):\n                                # Found a valid complete friendship party\n                                print(person, friend_list[i], friend_list[j], friend_list[l], friend_list[m])\n                                return\n    \n    # Check for no friendship\n    no_friend_people = [i for i in range(1, N + 1) if len(friends[i]) == 0]\n    if len(no_friend_people) >= 5:\n        print(no_friend_people[0], no_friend_people[1], no_friend_people[2], no_friend_people[3], no_friend_people[4])\n        return\n    \n    # If no successful party could be organized\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1600_J. Robot Factory", "solution": "def main():\n    import sys\n    from collections import deque\n\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    # Read dimensions\n    N, M = map(int, data[0].split())\n    \n    # Read the grid and convert to tile numbers\n    tiles = [list(map(int, line.split())) for line in data[1:N + 1]]\n    \n    # Directions for North, East, South, West (N, E, S, W)\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Function to check if there is a wall in the given direction\n    def has_wall(x, y, direction):\n        bit = 1 << direction\n        return (tiles[x][y] & bit) != 0\n\n    # To keep track of visited tiles\n    visited = [[False] * M for _ in range(N)]\n\n    # Function for BFS to explore a room\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        room_size = 0\n\n        while queue:\n            x, y = queue.popleft()\n            room_size += 1\n            \n            # Check all four directions\n            for d in range(4):\n                nx, ny = x + directions[d][0], y + directions[d][1]\n                if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny]:\n                    # Check if there is a wall in the direction we want to go\n                    if not has_wall(x, y, d):\n                        visited[nx][ny] = True\n                        queue.append((nx, ny))\n\n        return room_size\n\n    room_sizes = []\n\n    # Go through each tile in the grid\n    for i in range(N):\n        for j in range(M):\n            if not visited[i][j]:\n                size_of_room = bfs(i, j)\n                room_sizes.append(size_of_room)\n\n    # Sort room sizes in descending order\n    room_sizes.sort(reverse=True)\n\n    # Print the result\n    print(' '.join(map(str, room_sizes)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1601_A. Array Elimination", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index].split()))\n        index += 1\n        \n        total_and = a[0]\n        for num in a[1:]:\n            total_and &= num\n        \n        valid_k = []\n        \n        # k = 1 is always valid\n        valid_k.append(1)\n        \n        # k = 2 is generally valid if we have at least two non-zero elements\n        if n >= 2:\n            valid_k.append(2)\n        \n        # Determine the range of k values based on AND result\n        if total_and == 0:\n            # If AND of all elements is 0, all k from 1 to n are valid\n            valid_k.extend(range(3, n + 1))\n        else:\n            # If AND is non-zero, only k = 1 and k = 2 are valid\n            pass\n        \n        results.append(\" \".join(map(str, valid_k)))\n    \n    # Output all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")"}
{"task_id": "1601_B. Frog Traveler", "solution": "from collections import deque\n\ndef min_jumps_to_surface(n, a, b):\n    # Queue for BFS: each entry is (current_depth, jumps_taken, path)\n    queue = deque([(n, 0, [])])\n    visited = set([n])  # Keep track of visited depths\n\n    while queue:\n        current_depth, jumps_taken, path = queue.popleft()\n        \n        # Try all possible jumps from the current depth\n        max_jump = a[current_depth - 1]\n        for jump in range(max_jump + 1):\n            next_depth = current_depth - jump\n            if next_depth <= 0:\n                # If we can reach ground level\n                print(jumps_taken + 1)\n                print(' '.join(map(str, path + [next_depth])))\n                return\n            \n            # After jumping, we need to account for slipping back\n            slipped_depth = next_depth + b[next_depth - 1]\n            if slipped_depth not in visited:\n                visited.add(slipped_depth)\n                queue.append((slipped_depth, jumps_taken + 1, path + [next_depth]))\n\n    # If we exhaust the queue without finding a way to ground level\n    print(-1)\n\n# Read inputs\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\n\n# Call the function with the inputs\nmin_jumps_to_surface(n, a, b)"}
{"task_id": "1601_C. Optimal Insertion", "solution": "import sys\nimport bisect\n\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        a = list(map(int, data[index:index + n]))\n        index += n\n        b = list(map(int, data[index:index + m]))\n        index += m\n        \n        # Sort array b\n        b.sort()\n        \n        inversions = 0\n        \n        for num in a:\n            # Count elements in b that are greater than num using bisect\n            count_after = len(b) - bisect.bisect_right(b, num)\n            inversions += count_after\n        \n        results.append(inversions)\n    \n    # Output all results at once\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1601_D. Difficult Mountain", "solution": "def max_alpinists(n, d, alpinists):\n    # Sort alpinists based on their skill level\n    alpinists.sort()\n    \n    current_difficulty = d\n    count = 0\n    \n    for skill, neatness in alpinists:\n        if skill >= current_difficulty:\n            count += 1\n            current_difficulty = max(current_difficulty, neatness)\n    \n    return count\n\n# Input handling\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\nn, d = map(int, data[0].split())\nalpinists = [tuple(map(int, line.split())) for line in data[1:]]\n\n# Calculate and print the result\nresult = max_alpinists(n, d, alpinists)\nprint(result)"}
{"task_id": "1601_E. Phys Ed Online", "solution": "def minimum_gym_cost(n, q, k, ticket_costs, queries):\n    # Create a list to store minimum cost starting from each day\n    min_cost = [0] * (n + 1)\n\n    # Fill min_cost from the end to the start\n    for i in range(n, 0, -1):\n        # Base case: ticket cost on day i\n        min_cost[i] = ticket_costs[i - 1]\n        if i + 1 <= n:\n            min_cost[i] = min(min_cost[i], ticket_costs[i - 1] + min_cost[i + 1])\n        # Check valid range for the ticket\n        if i + k <= n:\n            min_cost[i] = min(min_cost[i], ticket_costs[i - 1] + min_cost[i + k])\n\n    # Prepare the result for each query\n    results = []\n    for l, r in queries:\n        # The cost to start visiting the gym from day l\n        results.append(min_cost[l])\n\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    q = int(data[1])\n    k = int(data[2])\n    ticket_costs = list(map(int, data[3:n+3]))\n    queries = []\n    \n    index = n + 3\n    for _ in range(q):\n        l = int(data[index])\n        r = int(data[index + 1])\n        queries.append((l, r))\n        index += 2\n    \n    results = minimum_gym_cost(n, q, k, ticket_costs, queries)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1601_F. Two Sorts", "solution": "def calculate_sum(n):\n    M = 998244353\n    MOD = 10**9 + 7\n    total_sum = 0\n\n    # Convert n to string to determine the number of digits.\n    n_str = str(n)\n    length = len(n_str)\n    \n    # Compute contributions for lengths from 1 to (length - 1)\n    # Length 1: all numbers from 1 to 9\n    for digit_length in range(1, length):\n        start = 10 ** (digit_length - 1)\n        end = min(n, 10 ** digit_length - 1)  # upper limit\n        num_count = end - start + 1\n        \n        # Calculate a_i for these numbers, which are just the numbers themselves\n        for i in range(start, end + 1):\n            a_i = i  # i is in its original position because it's the same as itself\n            total_sum += (i - a_i) % M\n        \n    # Now handle the last length specifically (the numbers from 10**(length - 1) to n)\n    start = 10 ** (length - 1)\n    end = n\n    \n    # Process the remaining numbers\n    for i in range(start, end + 1):\n        a_i = i  # again a_i is itself\n        total_sum += (i - a_i) % M\n        \n    total_sum %= MOD\n    return total_sum\n\n# Main execution to read input and print output\nif __name__ == \"__main__\":\n    import sys\n    n = int(sys.stdin.read().strip())\n    result = calculate_sum(n)\n    print(result)"}
{"task_id": "1603_D. Artistic Partition", "solution": "import sys\nfrom math import gcd\n\ninput = sys.stdin.read\n\ndef precompute_c(n):\n    c = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for l in range(1, n + 1):\n        for r in range(l, n + 1):\n            count_gcd = 0\n            for i in range(l, r + 1):\n                for j in range(i, r + 1):\n                    if gcd(i, j) >= l:\n                        count_gcd += 1\n            c[l][r] = count_gcd\n    \n    return c\n\ndef solve(n, k, c):\n    min_sum = float('inf')\n    \n    # Using a greedy approach to minimize the partitions\n    # We will use the fact that we can cover n with k segments\n    interval_length = n // k\n    for i in range(k):\n        left = i * interval_length + 1\n        right = n if i == k - 1 else (i + 1) * interval_length\n        min_sum += c[left][right]\n        \n    return min_sum\n\ndef main():\n    data = input().strip().split()\n    t = int(data[0])\n    queries = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(t)]\n    \n    max_n = max(n for n, k in queries)\n    c = precompute_c(max_n)\n    \n    results = []\n    for n, k in queries:\n        results.append(solve(n, k, c))\n    \n    print(\"\\n\".join(map(str, results)))\n\nmain()"}
{"task_id": "1603_E. A Perfect Problem", "solution": "def count_perfect_sequences(n, M):\n    # Calculate n^n % M using Python's pow function for efficiency\n    return pow(n, n, M)\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().strip()\nn, M = map(int, data.split())\n\n# Calculate the result and print it\nresult = count_perfect_sequences(n, M)\nprint(result)"}
{"task_id": "1603_F. October 18, 2017", "solution": "def mod_exp(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\ndef count_valid_sequences(n, k, x):\n    MOD = 998244353\n    total_values = 1 << k  # This is 2^k\n    total_sequences = mod_exp(total_values, n, MOD)  # (2^k)^n mod 998244353\n    \n    # To count how many values are excluded (those that can form XOR = x)\n    if k < 1:\n        return total_sequences  # No valid values can be formed if k=0\n    \n    # Count valid numbers that cannot form XOR x\n    valid_count = total_values\n    if x < total_values:\n        valid_count -= 1  # Exclude x itself as it can form XOR=x\n    \n    # If valid_count <= 0, return total_sequences since no numbers can form XOR=x\n    if valid_count <= 0:\n        return total_sequences\n\n    # Calculate valid configurations\n    valid_sequences = mod_exp(valid_count, n, MOD)\n    \n    return valid_sequences\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n, k, x = map(int, data[i].split())\n        result = count_valid_sequences(n, k, x)\n        results.append(result)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "1604_A. Era", "solution": "def min_operations_to_satisfy_condition(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        operations = 0  # Count of operations needed\n        for i in range(n):\n            # Check if a[i] > (i + 1) because i is 0-indexed\n            if a[i] > (i + 1):\n                operations += a[i] - (i + 1)\n        results.append(operations)\n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Parse input\nt = int(data[0])\ntest_cases = []\nline_idx = 1\nfor _ in range(t):\n    n = int(data[line_idx])\n    a = list(map(int, data[line_idx + 1].split()))\n    test_cases.append((n, a))\n    line_idx += 2\n\n# Solve the cases\nresults = min_operations_to_satisfy_condition(t, test_cases)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "1604_B. XOR Specia-LIS-t", "solution": "def longest_increasing_subsequence_length(arr):\n    from bisect import bisect_left\n    if not arr:\n        return 0\n    lis = []\n    for x in arr:\n        pos = bisect_left(lis, x)\n        if pos == len(lis):\n            lis.append(x)\n        else:\n            lis[pos] = x\n    return len(lis)\n\ndef can_split_sequence(test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        lis_length = longest_increasing_subsequence_length(a)\n        \n        # Count the frequency of the LIS length\n        frequency = {}\n        frequency[lis_length] = frequency.get(lis_length, 0) + 1\n        \n        # Check if all LIS lengths can be paired\n        # Since we only compute LIS once, the parity of the frequency is enough\n        if frequency[lis_length] % 2 == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Reading input and processing the test cases\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n        \n    results = can_split_sequence(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1604_C. Di-visible Confusion", "solution": "def can_erase_sequence(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        possible = True\n        for i in range(n):\n            if a[i] % (i + 1) == 0:\n                possible = False\n                break\n        results.append(\"YES\" if possible else \"NO\")\n    return results\n\n# Read input from standard input\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n        \n    results = can_erase_sequence(t, test_cases)\n    print(\"\\n\".join(results))"}
{"task_id": "1604_D. Moderate Modular Mode", "solution": "def find_n(t, cases):\n    results = []\n    for i in range(t):\n        x, y = cases[i]\n        n = y + x  # Ensure n is greater than y, and n is even\n        results.append(n)\n    return results\n\n# Read the inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ncases = [tuple(map(int, line.split())) for line in data[1:t+1]]\n\n# Find n for each test case and print the results\nresults = find_n(t, cases)\nfor result in results:\n    print(result)"}
{"task_id": "1604_E. Extreme Extension", "solution": "def count_inversions_and_sum(a):\n    n = len(a)\n    total_extreme_value = 0\n\n    # Count inversions using a modified merge sort\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    for start in range(n):\n        # For each starting index, use a new list to work with\n        temp_arr = [0] * n\n        current_subarray = a[start:]\n        inversions = merge_sort_and_count(current_subarray, temp_arr, 0, len(current_subarray) - 1)\n        total_extreme_value += inversions\n        total_extreme_value %= 998244353\n\n    return total_extreme_value\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        result = count_inversions_and_sum(a)\n        results.append(result)\n\n    print('\\n'.join(map(str, results)))"}
{"task_id": "1606_A. AB Balance", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        s = data[i]\n        n = len(s)\n        \n        # Count occurrences of 'ab' and 'ba'\n        AB_count = sum(1 for j in range(n - 1) if s[j:j + 2] == 'ab')\n        BA_count = sum(1 for j in range(n - 1) if s[j:j + 2] == 'ba')\n        \n        # Determine the resulting string\n        if AB_count > BA_count:\n            results.append('b' * n)  # Convert to all 'b's\n        elif BA_count > AB_count:\n            results.append('a' * n)  # Convert to all 'a's\n        else:\n            results.append(s)  # No change needed, counts are equal\n\n    # Print all results for the test cases\n    print('\\n'.join(results))"}
{"task_id": "1606_B. Update Files", "solution": "def min_hours(n, k):\n    if n == 1:\n        return 0\n    \n    if k == 1:\n        return n - 1  # Only one cable, we need n - 1 separate transfers\n\n    hours = 0\n    total = 1  # initially only the first computer has the update\n    current_copies = 1  # In the first hour, we can only copy to 1 other computer\n\n    while total < n:\n        hours += 1\n        current_copies *= k  # in each hour, each updated computer can update k others\n        total += current_copies  # update the total number of updated computers\n\n    return hours\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n, k = map(int, data[i].split())\n        results.append(str(min_hours(n, k)))\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1606_C. Banknotes", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    results = []\n    index = 1\n\n    for _ in range(t):\n        n, k = map(int, data[index].split())\n        a = list(map(int, data[index + 1].split()))\n        index += 2\n        \n        # Calculate the maximum value that can be formed with k banknotes\n        max_value = 0\n        remaining_k = k\n        \n        # Start from the largest denomination down to the smallest\n        for i in range(n - 1, -1, -1):\n            denomination = 10 ** a[i]\n            # Maximum banknotes we can use for this denomination\n            if remaining_k > 0:\n                # We can use at most remaining_k banknotes of this denomination\n                max_use = remaining_k\n                max_value += max_use * denomination\n                remaining_k -= max_use\n        \n        # The minimum positive number that cannot be represented\n        results.append(max_value + 1)\n\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1606_D. Red-Blue Matrix", "solution": "def perfect_cut_and_coloring(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, matrix = case\n        red_max = float('-inf')\n        blue_max = float('-inf')\n        \n        # Alternating colors R and B\n        colors = []\n        for i in range(n):\n            if i % 2 == 0:\n                colors.append('R')\n            else:\n                colors.append('B')\n        \n        # Check for valid cut\n        possible = False\n        \n        for k in range(1, m):\n            max_R_L = float('-inf')\n            max_B_L = float('-inf')\n            max_R_R = float('-inf')\n            max_B_R = float('-inf')\n\n            for i in range(n):\n                if colors[i] == 'R':\n                    max_R_L = max(max_R_L, max(matrix[i][:k]))\n                    max_R_R = max(max_R_R, max(matrix[i][k:]))\n                else:\n                    max_B_L = max(max_B_L, max(matrix[i][:k]))\n                    max_B_R = max(max_B_R, max(matrix[i][k:]))\n\n            if max_R_L > max_B_L and max_B_R > max_R_R:\n                possible = True\n                results.append(f\"YES\\n{''.join(colors)} {k}\")\n                break\n\n        if not possible:\n            results.append(\"NO\")\n\n    return results\n\n# Reading input and running the function\nimport sys\n\ninput_data = sys.stdin.read().strip().splitlines()\nt = int(input_data[0])\ntest_cases = []\nline_index = 1\n\nfor _ in range(t):\n    n, m = map(int, input_data[line_index].split())\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, input_data[line_index + 1 + i].split())))\n    test_cases.append((n, m, matrix))\n    line_index += n + 1\n\nresults = perfect_cut_and_coloring(test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1606_E. Arena", "solution": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 998244353\n    return result\n\ndef permutations(n, r):\n    if r > n:\n        return 0\n    return (factorial(n) * pow(factorial(n - r), 998244353 - 2, 998244353)) % 998244353\n\ndef count_non_winning_configurations(n, x):\n    total_configurations = pow(x, n, 998244353)\n    if n <= x:\n        winning_configurations = permutations(x, n)\n    else:\n        winning_configurations = 0\n    non_winning_configurations = (total_configurations - winning_configurations) % 998244353\n    return non_winning_configurations\n\n# Read input\nn, x = map(int, input().strip().split())\n# Calculate and print the result\nprint(count_non_winning_configurations(n, x))"}
{"task_id": "1606_F. Tree Queries", "solution": "def solve():\n    import sys\n    from collections import defaultdict\n    import heapq\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    tree = defaultdict(list)\n    \n    # Building the tree\n    for i in range(1, n):\n        x, y = map(int, data[i].split())\n        tree[x].append(y)\n        tree[y].append(x)\n    \n    q = int(data[n])\n    queries = []\n    for i in range(n + 1, n + 1 + q):\n        v, k = map(int, data[i].split())\n        queries.append((v, k))\n    \n    # Prepare children information and parent tracking\n    children = defaultdict(list)\n    parent = [None] * (n + 1)\n    visited = [False] * (n + 1)\n\n    def dfs(node, par):\n        visited[node] = True\n        parent[node] = par\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                children[node].append(neighbor)\n                dfs(neighbor, node)\n\n    # Start DFS from the root node which is 1\n    dfs(1, -1)\n\n    results = []\n    \n    for v, k in queries:\n        c_v = len(children[v])\n        \n        if k == 0:\n            results.append(c_v)\n            continue\n        \n        # If k > 0, we need to calculate the maximum value of c(v) - m * k\n        child_counts = [len(children[child]) for child in children[v]]\n        \n        if not child_counts:\n            # There are no children, so c(v) = 0, and m must be 0\n            results.append(0)\n            continue\n        \n        # Sort child counts in descending order\n        child_counts.sort(reverse=True)\n        \n        max_value = c_v\n        m = 0\n        \n        # Evaluate the maximum score when deleting children\n        for count in child_counts:\n            # Calculate current value\n            current_value = max_value - m * k\n            # Check if we delete this child\n            m += 1  # we are deleting one more vertex\n            max_value -= 1  # we lose one child\n            \n            # New score after deletion\n            new_value = max_value - m * k\n            \n            # Break if the score is not improving\n            if new_value < current_value:\n                break\n            \n            # Update max_value for next iteration\n            max_value = new_value\n        \n        results.append(max_value)\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')"}
{"task_id": "1607_A. Linear Keyboard", "solution": "def calculate_typing_time(test_cases):\n    results = []\n    \n    for keyboard, word in test_cases:\n        # Create a mapping of each character to its position on the keyboard\n        position = {char: idx for idx, char in enumerate(keyboard)}\n        \n        # Initialize the current position (not needed for the first character)\n        current_position = 0\n        total_time = 0\n        \n        for char in word:\n            new_position = position[char]\n            total_time += abs(new_position - current_position)\n            current_position = new_position\n        \n        results.append(total_time)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    for i in range(t):\n        keyboard = data[2 * i + 1]\n        word = data[2 * i + 2]\n        test_cases.append((keyboard, word))\n    \n    results = calculate_typing_time(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1607_B. Odd Grasshopper", "solution": "def calculate_final_position(t, test_cases):\n    results = []\n    \n    for x0, n in test_cases:\n        if n == 0:\n            results.append(x0)\n            continue\n        \n        S = n * (n + 1) // 2  # Total distance jumped\n        if x0 % 2 == 0:  # x0 is even\n            if n % 2 == 0:  # n is even\n                results.append(x0 + S)\n            else:  # n is odd\n                results.append(x0 - S)\n        else:  # x0 is odd\n            if n % 2 == 0:  # n is even\n                results.append(x0 + S)\n            else:  # n is odd\n                results.append(x0 - S)\n    \n    return results\n\n# Reading inputs\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = [tuple(map(int, line.split())) for line in data[1:t+1]]\n\n# Getting results\nresults = calculate_final_position(t, test_cases)\n\n# Printing outputs\nfor result in results:\n    print(result)"}
{"task_id": "1607_C. Minimum Extraction", "solution": "def maximal_possible_minimum(test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        if n == 1:\n            results.append(a[0])\n        else:\n            a.sort()\n            # The maximum possible minimum after extraction\n            max_min = a[-1] - (n - 1)\n            results.append(max_min)\n    return results\n\n# Reading input and executing the solution\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])  # length of the array\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    results = maximal_possible_minimum(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1607_D. Blue-Red Permutation", "solution": "def can_form_permutation(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a, colors = case\n        blue_count = 0\n        red_count = 0\n        excess = 0\n        deficit = 0\n        \n        # Initialize counts for numbers 1 to n\n        count = [0] * (n + 1)\n\n        for i in range(n):\n            if 1 <= a[i] <= n:\n                count[a[i]] += 1\n            if colors[i] == 'B':\n                blue_count += 1\n            else:  # colors[i] == 'R'\n                red_count += 1\n\n        # Check for excess and deficit\n        for i in range(1, n + 1):\n            if count[i] == 0:\n                deficit += 1\n            elif count[i] > 1:\n                excess += count[i] - 1\n\n        # Calculate values outside of [1, n]\n        for value in a:\n            if value < 1:\n                deficit += 1\n            elif value > n:\n                excess += 1\n        \n        # Determine if we can form the permutation\n        if excess <= blue_count and deficit <= red_count:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input and process the problem\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        colors = data[index + 2]\n        test_cases.append((n, a, colors))\n        index += 3\n    \n    results = can_form_permutation(t, test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1607_E. Robot on the Board 1", "solution": "def find_starting_position(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, commands = case\n        min_row = 0  # Represents upward movement\n        max_row = 0  # Represents downward movement\n        min_col = 0  # Represents leftward movement\n        max_col = 0  # Represents rightward movement\n        \n        # Track the robot's movements based on the commands\n        current_row = 0\n        current_col = 0\n        \n        for command in commands:\n            if command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            elif command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            \n            # Update the movement bounds\n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n\n        # Calculate the valid starting position\n        # It can be positioned as low as 1 - min_row and as high as n - max_row\n        start_row = 1 - min_row  # This is the minimum row we can start\n        start_col = 1 - min_col  # This is the minimum column we can start\n        \n        # Ensure the starting position is within the board limits\n        if start_row < 1:\n            start_row = 1\n        if start_col < 1:\n            start_col = 1\n        if start_row > n - max_row:\n            start_row = n - max_row\n        if start_col > m - max_col:\n            start_col = m - max_col\n\n        results.append(f\"{start_row} {start_col}\")\n    \n    return results\n\n# Reading inputs and executing the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        commands = data[index + 1]\n        test_cases.append((n, m, commands))\n        index += 2\n\n    results = find_starting_position(t, test_cases)\n    print(\"\\n\".join(results))"}
{"task_id": "1607_F. Robot on the Board 2", "solution": "def max_robot_moves(t, test_cases):\n    results = []\n    \n    # Directions map\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for case in test_cases:\n        n, m, board = case['n'], case['m'], case['board']\n        max_steps = 0\n        best_position = (1, 1)  # default to the first cell\n        \n        # To store the maximum moves from each cell\n        memo = [[-1] * m for _ in range(n)]\n        \n        def dfs(x, y):\n            visited = set()\n            steps = 0\n            \n            while True:\n                if (x, y) in visited:  # revisiting the same cell\n                    break\n                if x < 0 or x >= n or y < 0 or y >= m:  # out of bounds\n                    break\n                \n                visited.add((x, y))\n                steps += 1\n                \n                # Move in the direction specified by the current cell\n                dx, dy = direction_map[board[x][y]]\n                x += dx\n                y += dy\n            \n            # Mark all visited cells with the number of steps\n            for vx, vy in visited:\n                memo[vx][vy] = steps\n            \n            return steps\n        \n        for i in range(n):\n            for j in range(m):\n                if memo[i][j] == -1:  # if not already calculated\n                    steps = dfs(i, j)\n                    if steps > max_steps:\n                        max_steps = steps\n                        best_position = (i + 1, j + 1)  # converting to 1-indexed\n        \n        results.append((best_position[0], best_position[1], max_steps))\n    \n    return results\n\n# Reading input and formatting the output\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split(\"\\n\")\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    if not data[index].strip():  # skip the blank line\n        index += 1\n    \n    n, m = map(int, data[index].strip().split())\n    index += 1\n    board = []\n    \n    for _ in range(n):\n        board.append(data[index].strip())\n        index += 1\n    \n    test_cases.append({'n': n, 'm': m, 'board': board})\n\n# Get results\nresults = max_robot_moves(t, test_cases)\n\n# Print results\nfor r, c, d in results:\n    print(r, c, d)"}
{"task_id": "1607_G. Banquet Preparations 1", "solution": "def minimize_balance(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, dishes = case\n        total_fish = sum(dish[0] for dish in dishes)\n        total_meat = sum(dish[1] for dish in dishes)\n        \n        final_fish_eaten = 0\n        final_meat_eaten = 0\n        x_y_pairs = []\n        \n        for a_i, b_i in dishes:\n            # Determine how much fish and meat to eat\n            if total_fish - final_fish_eaten > total_meat - final_meat_eaten:\n                fish_eaten = min(m, a_i)\n                meat_eaten = m - fish_eaten\n            else:\n                meat_eaten = min(m, b_i)\n                fish_eaten = m - meat_eaten\n            \n            final_fish_eaten += fish_eaten\n            final_meat_eaten += meat_eaten\n            x_y_pairs.append((fish_eaten, meat_eaten))\n        \n        # Compute the minimal balance\n        balance = abs((total_fish - final_fish_eaten) - (total_meat - final_meat_eaten))\n        \n        results.append((balance, x_y_pairs))\n    \n    return results\n\n# Read input and format output\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while index < len(data) and not data[index].strip():\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        dishes = []\n        \n        for _ in range(n):\n            a_i, b_i = map(int, data[index].strip().split())\n            dishes.append((a_i, b_i))\n            index += 1\n        \n        test_cases.append((n, m, dishes))\n    \n    results = minimize_balance(t, test_cases)\n    \n    output = []\n    for balance, x_y_pairs in results:\n        output.append(str(balance))\n        for x, y in x_y_pairs:\n            output.append(f\"{x} {y}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1607_H. Banquet Preparations 2", "solution": "def minimize_variety(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, dishes = case\n        eaten = []\n        unique_dishes = set()\n        \n        for a_i, b_i, m_i in dishes:\n            # We can take as much fish as we can, then take the rest from meat\n            if m_i <= a_i:\n                x_i = m_i\n                y_i = 0\n            else:\n                x_i = a_i\n                y_i = m_i - x_i\n                if y_i > b_i:\n                    y_i = b_i\n                    x_i = m_i - y_i\n            \n            eaten.append((x_i, y_i))\n            unique_dishes.add((a_i - x_i, b_i - y_i))\n\n        results.append(f\"{len(unique_dishes)}\")\n        for x_i, y_i in eaten:\n            results.append(f\"{x_i} {y_i}\")\n    \n    return \"\\n\".join(results)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split(\"\\n\")\n\nt = int(data[0])\nidx = 1\ntest_cases = []\n\nfor _ in range(t):\n    if data[idx] == '':\n        idx += 1\n    n = int(data[idx])\n    idx += 1\n    dishes = []\n    for _ in range(n):\n        a_i, b_i, m_i = map(int, data[idx].split())\n        dishes.append((a_i, b_i, m_i))\n        idx += 1\n    test_cases.append((n, dishes))\n\n# Process the test cases and print the result\nprint(minimize_variety(t, test_cases))"}
{"task_id": "1608_A. Find Array", "solution": "def generate_array(n):\n    # Generate an array starting from 2 to n + 1\n    return list(range(2, n + 2))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])  # number of test cases\n    results = []\n    \n    for i in range(1, t + 1):\n        n = int(data[i])\n        result = generate_array(n)\n        results.append(\" \".join(map(str, result)))\n    \n    # Print all results for each test case\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1608_B. Build the Permutation", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for case in range(1, t + 1):\n        n, a, b = map(int, data[case].split())\n        \n        if a + b > (n - 2) or (n - 2) // 2 < a or (n - 2) // 2 < b:\n            results.append(\"-1\")\n            continue\n        \n        # Initialize the permutation\n        permutation = list(range(1, n + 1))\n        \n        # Create local maxima\n        for i in range(2, 2 * a + 2, 2):\n            permutation[i-1], permutation[i] = permutation[i], permutation[i-1]\n        \n        # Create local minima\n        for i in range(2 * a + 3, 2 * a + 3 + 2 * b, 2):\n            permutation[i-1], permutation[i] = permutation[i], permutation[i-1]\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1608_C. Game Master", "solution": "def can_players_win(t, test_cases):\n    results = []\n    \n    for n, strengths_a, strengths_b in test_cases:\n        players = [(strengths_a[i], strengths_b[i], i) for i in range(n)]\n        # Sort players based on their strength on map A\n        players.sort()\n        \n        can_win = [1] * n  # Initially assume everyone can win\n        max_b = -1  # Maximum strength on map B seen so far\n        \n        for strength_a, strength_b, index in players:\n            # If current player's strength on B is less than or equal to max_b,\n            # they cannot win the tournament\n            if strength_b <= max_b:\n                can_win[index] = 0\n            else:\n                max_b = strength_b\n        \n        results.append(''.join(map(str, can_win)))\n    \n    return results\n\n# The function expects to read inputs from stdin and write outputs to stdout.\n# Here, the following code can be used to run the above function with inputs.\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])  # number of players\n        strengths_a = list(map(int, data[index + 1].split()))\n        strengths_b = list(map(int, data[index + 2].split()))\n        test_cases.append((n, strengths_a, strengths_b))\n        index += 3\n    \n    results = can_players_win(t, test_cases)\n    for result in results:\n        print(result)\n\n# The main function will not run unless it's called in an appropriate environment.\n# Remember to uncomment below when running in a proper environment.\n# if __name__ == \"__main__\":\n#     main()"}
{"task_id": "1608_D. Dominoes", "solution": "def count_valid_colorings(n, dominoes):\n    MOD = 998244353\n\n    # To track the possible ways to color\n    total_ways = 1\n\n    # This will track the last colored domino's color\n    last_left = None\n    last_right = None\n\n    # We need to handle the first domino separately to establish the circular constraint.\n    first_left = dominoes[0][0]\n    first_right = dominoes[0][1]\n\n    for i in range(n):\n        left = dominoes[i][0]\n        right = dominoes[i][1]\n\n        # Determine the colors of the left and right based on the current domino\n        if left == '?' and right == '?':\n            total_ways = (total_ways * 2) % MOD  # Can be BW or WB\n        elif left == '?':\n            # We can deduce the left based on the right and the previous domino\n            if last_right == 'B':\n                left = 'W'\n            else:\n                left = 'B'\n        elif right == '?':\n            # We can deduce the right based on the left and the previous domino\n            if last_left == 'B':\n                right = 'W'\n            else:\n                right = 'B'\n        else:\n            # Both are already colored\n            if left == right:\n                return 0  # Invalid coloring as same colors in adjacent dominoes\n\n        # Now we set the last left and right\n        last_left = left\n        last_right = right\n\n        # Check the circular condition for the last domino\n        if i == n - 1:\n            if last_right == first_left:\n                return 0  # Invalid because right of last and left of first are the same\n\n    return total_ways\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\ndominoes = [line.strip() for line in data[1:n+1]]\n\n# Get the result\nresult = count_valid_colorings(n, dominoes)\n# Output the result\nprint(result)"}
{"task_id": "1608_E. The Cells on the Paper", "solution": "def max_cells(n, cells):\n    # Separate cells by color\n    color_cells = {1: [], 2: [], 3: []}\n    \n    for (x, y, c) in cells:\n        color_cells[c].append((x, y))\n    \n    # To store bounds for each color\n    bounds = {}\n    \n    for c in range(1, 4):\n        xs = [cell[0] for cell in color_cells[c]]\n        ys = [cell[1] for cell in color_cells[c]]\n        bounds[c] = (min(xs), max(xs), min(ys), max(ys))\n    \n    # Check for non-intersecting rectangles\n    rect1 = bounds[1]\n    rect2 = bounds[2]\n    rect3 = bounds[3]\n    \n    # Check if we can arrange rectangles 1, 2, 3 such that they don't intersect\n    def can_place_rects(rect1, rect2, rect3):\n        # Check all pairwise combinations\n        conditions = [\n            (rect1[1] < rect2[0]),  # rect1 right < rect2 left\n            (rect2[1] < rect1[0]),  # rect2 right < rect1 left\n            (rect1[1] < rect3[0]),  # rect1 right < rect3 left\n            (rect3[1] < rect1[0]),  # rect3 right < rect1 left\n            (rect2[1] < rect3[0]),  # rect2 right < rect3 left\n            (rect3[1] < rect2[0]),  # rect3 right < rect2 left\n        ]\n        return any(conditions)\n    \n    if can_place_rects(rect1, rect2, rect3):\n        return n  # We can keep all cells\n    \n    # If we can't place all, we need to find the maximum `k`.\n    # Check the intersection conditions in more detail could be added here.\n    return n - 3  # At least one cell has to be removed per color in worst case\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\ncells = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n\n# Get the result and print it\nresult = max_cells(n, cells)\nprint(result)"}
{"task_id": "1608_F. MEX counting", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    b = list(map(int, data[2:n+2]))\n    \n    MOD = 998244353\n    \n    # Dynamic programming table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: one way to have MEX 0 with 0 elements\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        b_i = b[i - 1]\n        for mex in range(n + 1):\n            # The valid range for MEX is [b_i - k, b_i + k]\n            low = max(0, b_i - k)\n            high = min(n, b_i + k)\n            \n            if low <= mex <= high:\n                # MEX can be mex, count the ways\n                # The counts that can contribute to dp[i][mex]\n                for m in range(mex + 1):\n                    dp[i][mex] = (dp[i][mex] + dp[i - 1][m]) % MOD\n            \n            # Now, we need to ensure that the current MEX is valid\n            # If mex is exactly m, we can choose from 0 to mex-1\n            # and optionally include mex\n            if mex > 0:\n                dp[i][mex] = (dp[i][mex] * pow(2, mex - 1, MOD)) % MOD\n    \n    # The answer is the sum of valid MEX configurations at the last index\n    result = sum(dp[n]) % MOD\n    print(result)"}
{"task_id": "1608_G. Alphabetic Tree", "solution": "from sys import stdin, stdout\nimport sys\nfrom collections import defaultdict, deque\n\ninput = stdin.read\nsys.setrecursionlimit(200000)\n\n# Preprocessing for LCA\nclass LCA:\n    def __init__(self, n, edges):\n        self.n = n\n        self.tree = defaultdict(list)\n        self.parent = [[-1] * (n.bit_length()) for _ in range(n)]\n        self.depth = [-1] * n\n        self.path_char = defaultdict(list)\n        \n        for u, v, c in edges:\n            self.tree[u-1].append((v-1, c))\n            self.tree[v-1].append((u-1, c))\n        \n        self.dfs(0, -1, 0)\n        self.build_lca()\n\n    def dfs(self, node, par, d):\n        self.depth[node] = d\n        self.parent[node][0] = par\n        for (neighbor, char) in self.tree[node]:\n            if neighbor == par:\n                continue\n            self.path_char[neighbor] = self.path_char[node] + [char]\n            self.dfs(neighbor, node, d + 1)\n\n    def build_lca(self):\n        for j in range(1, len(self.parent[0])):\n            for i in range(self.n):\n                if self.parent[i][j-1] != -1:\n                    self.parent[i][j] = self.parent[self.parent[i][j-1]][j-1]\n\n    def get_lca(self, u, v):\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(diff.bit_length()):\n            if (diff >> i) & 1:\n                u = self.parent[u][i]\n        if u == v:\n            return u\n        for i in range(len(self.parent[0])-1, -1, -1):\n            if self.parent[u][i] != self.parent[v][i]:\n                u = self.parent[u][i]\n                v = self.parent[v][i]\n        return self.parent[u][0]\n\ndef count_occurrences(strings, path_string):\n    count = 0\n    for s in strings:\n        count += s.count(path_string)\n    return count\n\ndef main():\n    data = input().splitlines()\n    n, m, q = map(int, data[0].split())\n    \n    edges = []\n    for i in range(1, n):\n        u, v, c = data[i].split()\n        edges.append((int(u), int(v), c))\n    \n    strings = [data[i] for i in range(n, n + m)]\n    \n    queries = []\n    for i in range(n + m, n + m + q):\n        u, v, l, r = map(int, data[i].split())\n        queries.append((u-1, v-1, l-1, r-1))\n    \n    lca = LCA(n, edges)\n    \n    results = []\n    for u, v, l, r in queries:\n        lca_node = lca.get_lca(u, v)\n        path_string = ''.join(lca.path_char[u]) + ''.join(reversed(lca.path_char[v]))\n        results.append(count_occurrences(strings[l:r+1], path_string))\n    \n    stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1613_A. Long Comparison", "solution": "def compare_numbers(test_cases):\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        if p1 > p2:\n            results.append('>')\n        elif p1 < p2:\n            results.append('<')\n        else:  # p1 == p2\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    \n    for i in range(t):\n        x1, p1 = map(int, data[2*i + 1].split())\n        x2, p2 = map(int, data[2*i + 2].split())\n        test_cases.append((x1, p1, x2, p2))\n    \n    results = compare_numbers(test_cases)\n    print(\"\\n\".join(results))"}
{"task_id": "1613_B. Absent Remainder", "solution": "def find_pairs(test_cases):\n    output = []\n    for n, a in test_cases:\n        a_set = set(a)\n        pairs = []\n        \n        # Try to find valid pairs\n        for i in range(n):\n            if len(pairs) >= n // 2:\n                break\n            for j in range(n):\n                if i != j:\n                    x = a[i]\n                    y = a[j]\n                    if (x % y) not in a_set:\n                        pairs.append((x, y))\n                        if len(pairs) >= n // 2:\n                            break\n            \n        output.extend(f\"{x} {y}\" for x, y in pairs)\n\n    return \"\\n\".join(output)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    result = find_pairs(test_cases)\n    print(result)"}
{"task_id": "1613_C. Poisoned Dagger", "solution": "def canDealAtLeastHDamage(k, n, h, a):\n    damage = 0\n    last_poison_end = -1  # This will store when the last poison effect ends\n    \n    for attack in a:\n        if attack > last_poison_end:\n            # If the attack happens after the last poison effect ended\n            damage += k  # We can deal k damage for this attack\n            last_poison_end = attack + k - 1  # Update the end of the poison effect\n        else:\n            # The attack is during the poison period\n            damage += (attack + k - 1) - last_poison_end  # Add the new damage contributed\n            last_poison_end = max(last_poison_end, attack + k - 1)  # Update the end of the poison effect\n    \n    return damage >= h\n\ndef minimumK(n, h, a):\n    left, right = 1, h  # Start with 1 and go up to h (worst case)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if canDealAtLeastHDamage(mid, n, h, a):\n            right = mid  # We can deal enough damage with mid, try smaller\n        else:\n            left = mid + 1  # We can't deal enough damage with mid, try larger\n    \n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        n, h = map(int, data[index].split())\n        a = list(map(int, data[index + 1].split()))\n        index += 2\n        \n        result = minimumK(n, h, a)\n        results.append(result)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1613_D. MEX Sequences", "solution": "def count_mex_correct_subsequences(n, a):\n    MOD = 998244353\n    \n    # Count the frequency of each number in the array\n    count = [0] * (n + 1)\n    for number in a:\n        if number <= n:\n            count[number] += 1\n    \n    # Determine the MEX\n    mex = 0\n    while mex <= n and count[mex] > 0:\n        mex += 1\n    \n    # Calculate the number of MEX-correct subsequences\n    total_subsequences = 1  # Start with 1 for the empty product\n    for i in range(mex):\n        total_subsequences *= (pow(2, count[i], MOD) - 1) % MOD\n        total_subsequences %= MOD\n    \n    # If MEX is present in the array, we can either include it or not\n    if mex <= n and count[mex] > 0:\n        total_subsequences = (total_subsequences * 2) % MOD\n    \n    return total_subsequences\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        \n        results.append(count_mex_correct_subsequences(n, a))\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1613_E. Crazy Robot", "solution": "def solve():\n    import sys\n    from collections import deque\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        grid = []\n        lab_position = None\n        \n        for i in range(n):\n            row = list(data[index])\n            grid.append(row)\n            if 'L' in row:\n                lab_position = (i, row.index('L'))\n            index += 1\n\n        # Directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # BFS to find all reachable cells\n        queue = deque()\n        visited = set()\n        \n        # Start from the lab's position\n        queue.append(lab_position)\n        visited.add(lab_position)\n\n        while queue:\n            x, y = queue.popleft()\n            # Check all four directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        # Mark all the visited free cells with '+'\n        for x, y in visited:\n            if grid[x][y] == '.':\n                grid[x][y] = '+'\n\n        # Store the result for this test case\n        results.append('\\n'.join(''.join(row) for row in grid))\n\n    # Print all results together\n    print('\\n'.join(results))"}
{"task_id": "1613_F. Tree Coloring", "solution": "def solve():\n    import sys\n    from sys import stdin, stdout\n    from collections import defaultdict\n    import math\n\n    input = stdin.read\n    MOD = 998244353\n\n    # Read input\n    data = input().splitlines()\n    n = int(data[0])\n    \n    # Adjacency list for the tree\n    tree = defaultdict(list)\n    \n    for i in range(1, n):\n        x, y = map(int, data[i].split())\n        tree[x].append(y)\n        tree[y].append(x)\n    \n    # Precompute factorials and inverses\n    factorial = [1] * (n + 1)\n    for i in range(2, n + 1):\n        factorial[i] = factorial[i - 1] * i % MOD\n    \n    inv_factorial = [1] * (n + 1)\n    inv_factorial[n] = pow(factorial[n], MOD - 2, MOD)\n    for i in range(n - 1, 0, -1):\n        inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD\n    \n    # DFS to calculate sizes and dp values\n    size = [0] * (n + 1)  # Size of the subtree for each vertex\n    dp = [0] * (n + 1)    # dp[v] will hold the number of valid colorings for vertex v's subtree\n    visited = [False] * (n + 1)\n\n    def dfs(v):\n        visited[v] = True\n        total_size = 1\n        total_ways = 1\n\n        for u in tree[v]:\n            if not visited[u]:\n                child_size = dfs(u)\n                total_size += child_size\n                total_ways *= dp[u] * factorial[child_size] % MOD\n                total_ways %= MOD\n        \n        size[v] = total_size\n        remaining_colors = n - total_size\n        dp[v] = (remaining_colors * total_ways) % MOD\n        \n        return total_size\n    \n    # Start DFS from the root\n    dfs(1)\n\n    # The answer is the number of colorings for the subtree rooted at vertex 1\n    stdout.write(f\"{dp[1]}\\n\")"}
{"task_id": "1615_A. Closing The Gap", "solution": "def minimum_ugliness(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i][0]\n        heights = test_cases[i][1]\n        \n        total_height = sum(heights)\n        \n        # Determine minimum possible ugliness\n        if total_height % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\n# Example usage of the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        heights = list(map(int, data[index + 1].split()))\n        test_cases.append((n, heights))\n        index += 2\n\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)"}
{"task_id": "1615_B. And It's Non-Zero", "solution": "def minimum_deletions(t, test_cases):\n    results = []\n    for l, r in test_cases:\n        if l == r:\n            results.append(0)  # When l == r, no deletions needed, AND is non-zero\n            continue\n        \n        # Calculate the XOR to find differing bits\n        xor_value = l ^ r\n        \n        # Find the position of the most significant bit in xor_value\n        msb_position = xor_value.bit_length() - 1\n        \n        # The range [l, r] has (r - l + 1) numbers\n        total_count = r - l + 1\n        \n        # The count of numbers that can remain is 1 << msb_position\n        # because we can keep numbers that share the same prefix up to the highest differing bit.\n        remaining_count = total_count - (1 << msb_position)\n        \n        # Minimum deletions required\n        results.append(remaining_count)\n    \n    return results\n\n# Reading input and executing the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\nanswers = minimum_deletions(t, test_cases)\n\n# Output results\nfor answer in answers:\n    print(answer)"}
{"task_id": "1615_C. Menorah", "solution": "def min_operations_to_transform(t, cases):\n    results = []\n    \n    for n, a, b in cases:\n        if a == b:\n            results.append(0)\n            continue\n        \n        change_to_1 = 0\n        change_to_0 = 0\n        \n        for char_a, char_b in zip(a, b):\n            if char_a == '0' and char_b == '1':\n                change_to_1 += 1\n            elif char_a == '1' and char_b == '0':\n                change_to_0 += 1\n        \n        if '1' not in a and change_to_1 > 0:\n            results.append(-1)\n        else:\n            results.append(max(change_to_1, change_to_0))\n    \n    return results\n\n\n# Read inputs and execute function\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = data[index + 1]\n        b = data[index + 2]\n        cases.append((n, a, b))\n        index += 3\n    \n    results = min_operations_to_transform(t, cases)\n    \n    for result in results:\n        print(result)\n\nmain()"}
{"task_id": "1615_D. X(or)-mas Tree", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[idx].split())\n        idx += 1\n        \n        edges = []\n        tree = [[] for _ in range(n + 1)]\n        edge_values = {}\n\n        for __ in range(n - 1):\n            x, y, v = map(int, data[idx].split())\n            edges.append((x, y, v))\n            tree[x].append((y, v))\n            tree[y].append((x, v))\n            if v != -1:\n                edge_values[(x, y)] = v\n                edge_values[(y, x)] = v\n            idx += 1\n        \n        # Queries of elves\n        queries = []\n        for __ in range(m):\n            a, b, p = map(int, data[idx].split())\n            queries.append((a, b, p))\n            idx += 1\n\n        # To store the value of each edge\n        edge_map = {}\n        parity = [None] * (n + 1)  # Will store the parity of the XOR path to root\n\n        # Use a DFS to initialize the parities\n        def dfs(node, parent, current_xor):\n            parity[node] = current_xor\n            for neighbor, value in tree[node]:\n                if neighbor != parent:\n                    if value != -1:\n                        dfs(neighbor, node, current_xor ^ value)\n                    else:  # value is -1, we need to handle later\n                        dfs(neighbor, node, current_xor)\n\n        dfs(1, -1, 0)\n\n        valid = True\n        for a, b, p in queries:\n            # Compute the XOR value along the path a -> b\n            path_xor = parity[a] ^ parity[b]\n            if (bin(path_xor).count('1') % 2) != p:\n                valid = False\n                break\n\n        if not valid:\n            results.append(\"NO\")\n            continue\n\n        # Now assign values to edges that are unknown\n        for x, y, v in edges:\n            if v == -1:\n                # If the value is unknown, we can set it to 0 (or any valid number)\n                edge_map[(x, y)] = 0\n                edge_map[(y, x)] = 0\n            else:\n                edge_map[(x, y)] = v\n                edge_map[(y, x)] = v\n\n        results.append(\"YES\")\nTo solve the problem, we will follow a structured approach to process each test case involving the tree and queries regarding the elves' favorite numbers based on the XOR of edge values. Below is the step-by-step breakdown:\n\n# Approach:\n\n1. **Understanding the Tree Structure**:\n   - The tree consists of `n` nodes and `n-1` edges. Each edge may have a known value or be unknown (indicated by `-1`).\n   - Each elf provides a pair of nodes and the expected parity (odd/even) of the XOR of the edge values along the path connecting those nodes.\n\n2. **Parsing Input**:\n   - For each test case, read `n` (number of nodes) and `m` (number of elves).\n   - Store the edges and their values in a list. If a value is `-1`, mark it as unknown.\n\n3. **Building the Tree**:\n   - Use an adjacency list to represent the tree, which will help in traversing the tree for answering elf queries.\n\n4. **Handling Queries**:\n   - For each elf's query, determine the XOR along the path between the two nodes. This can be achieved using Depth-First Search (DFS) or Breadth-First Search (BFS) to compute the XOR value along the path.\n   - Maintain a record of the accumulated XOR value and its parity.\n\n5. **Consistency Check**:\n   - If any edge has a known value, it influences the paths that include this edge. We derive unknown values based on the XOR conditions provided by the elves.\n   - Check for contradictions based on the computed and remembered parities.\n\n6. **Final Output**:\n   - If a consistent configuration is possible, print \"YES\" followed by the edge values. If not possible, print \"NO\".\n\n# Implementation:"}
{"task_id": "1615_E. Purple Crayon", "solution": "def main():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, k = map(int, data[0].split())\n    graph = defaultdict(list)\n\n    for i in range(1, n):\n        u, v = map(int, data[i].split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent):\n        size = 1  # count this node itself\n        subtree_sizes = []\n        \n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            child_size = dfs(neighbor, node)\n            size += child_size\n            subtree_sizes.append(child_size)\n        \n        subtree_sizes.sort(reverse=True)  # Sort sizes in descending order\n        return size, subtree_sizes\n\n    total_size, subtree_sizes = dfs(1, -1)\n    \n    # Red colors up to k largest subtrees\n    red_nodes = 0\n    for i in range(min(k, len(subtree_sizes))):\n        red_nodes += subtree_sizes[i]\n    \n    # After Red's move\n    remaining_white_nodes = n - red_nodes\n    white_nodes_remaining = remaining_white_nodes\n\n    # Blue colors all remaining nodes, after Red's k nodes\n    blue_nodes = total_size - (red_nodes + white_nodes_remaining)\n\n    # Calculate score\n    score = white_nodes_remaining * (red_nodes - blue_nodes)\n    print(score)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1615_F. LEGOndary Grandmaster", "solution": "def count_configurations(start, end):\n    MOD = 1000000007\n    count = 0\n    \n    # Count the number of `1`s and `0`s in both start and end\n    start_ones = start.count('1')\n    start_zeros = start.count('0')\n    end_ones = end.count('1')\n    end_zeros = end.count('0')\n    \n    # Count the number of `?` in both strings\n    start_questions = start.count('?')\n    end_questions = end.count('?')\n    \n    # We can have a total of 2^(start_questions + end_questions) configurations\n    total_questions = start_questions + end_questions\n\n    # Iterate over all possible configurations for the `?` in both strings\n    for mask in range(1 << total_questions):\n        # Compute current counts based on the mask\n        current_start_ones = start_ones\n        current_start_zeros = start_zeros\n        current_end_ones = end_ones\n        current_end_zeros = end_zeros\n        \n        # Interpret the mask for start and end states\n        k = 0  # `?` index\n        for i in range(len(start)):\n            if start[i] == '?':\n                if (mask >> k) & 1:  # If the k-th bit is set, treat it as `1`\n                    current_start_ones += 1\n                else:  # Otherwise treat it as `0`\n                    current_start_zeros += 1\n                k += 1\n        \n        k = 0\n        for i in range(len(end)):\n            if end[i] == '?':\n                if (mask >> k) & 1:  # If the k-th bit is set, treat it as `1`\n                    current_end_ones += 1\n                else:  # Otherwise treat it as `0`\n                    current_end_zeros += 1\n                k += 1\n\n        # Now we have the counts of `1`s and `0`s for current configuration\n        if current_start_ones == current_end_ones and current_start_zeros == current_end_zeros:\n            # Calculate the cost to transform current_start to current_end\n            transitions = abs(current_start_ones - current_end_ones) // 2\n            count = (count + transitions) % MOD\n\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    results = []\n    index = 1\n\n    for _ in range(t):\n        n = int(data[index])\n        s = data[index + 1]\n        t = data[index + 2]\n        index += 3\n        \n        result = count_configurations(s, t)\n        results.append(result)\n\n    print(\"\\n\".join(map(str, results)))"}
{"task_id": "1615_G. Maximum Adjacent Pairs", "solution": "def maximize_adjacent_pairs(n, a):\n    # Step 1: Initialize a result array\n    result = a[:]\n    \n    # Step 2: Create a set to track used numbers\n    used_numbers = set(x for x in result if x != 0)\n    \n    # Step 3: Fill in the zeros\n    for i in range(n):\n        if result[i] == 0:\n            # Try to fill from the left side\n            if i > 0 and result[i - 1] != 0:\n                result[i] = result[i - 1]\n            else:\n                # If there's no left neighbor or it's 0, try to fill from the right side\n                if i < n - 1 and result[i + 1] != 0:\n                    result[i] = result[i + 1]\n                else:\n                    # Use a new number if still zero\n                    for num in range(1, n + 1):\n                        if num not in used_numbers:\n                            result[i] = num\n                            used_numbers.add(num)\n                            break\n    \n    # Step 4: Final pass to ensure pairs\n    for i in range(n - 1):\n        if result[i] != result[i + 1]:\n            if result[i + 1] in used_numbers and result[i] not in used_numbers:\n                result[i] = result[i + 1]\n    \n    return result\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\na = list(map(int, data[1].split()))\n\nresult = maximize_adjacent_pairs(n, a)\nprint(' '.join(map(str, result)))"}
{"task_id": "1615_H. Reindeer Games", "solution": "def solve():\n    import sys\n    from collections import defaultdict, deque\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    scores = list(map(int, data[1].split()))\n    \n    # Build the graph\n    graph = defaultdict(list)\n    in_degree = [0] * n\n    \n    for i in range(2, 2 + m):\n        u, v = map(int, data[i].split())\n        graph[u - 1].append(v - 1)  # converting to 0-indexed\n        in_degree[v - 1] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    \n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Adjust scores according to the topological order\n    result_scores = scores[:]\n    \n    for u in topo_order:\n        for v in graph[u]:\n            if result_scores[u] > result_scores[v]:\n                result_scores[u] = result_scores[v]\n    \n    print(' '.join(map(str, result_scores)))"}
{"task_id": "1617_A. Forbidden Subsequence", "solution": "def is_subsequence(S, T):\n    \"\"\" Check if T is a subsequence of S. \"\"\"\n    it = iter(S)\n    return all(char in it for char in T)\n\ndef smallest_permutation_without_subsequence(S, T):\n    sorted_S = ''.join(sorted(S))\n    \n    if not is_subsequence(sorted_S, T):\n        return sorted_S\n    \n    # If T is a subsequence, we need to modify sorted_S\n    count = {}\n    for char in sorted_S:\n        count[char] = count.get(char, 0) + 1\n    \n    # We need to find a position to break the subsequence\n    # We'll go through T and remove one of its characters\n    for char in reversed(T):  # Start from last character of T\n        if count.get(char, 0) > 0:\n            count[char] -= 1  # Decrease count of this character\n            if count[char] == 0:\n                del count[char]  # Remove char if its count drops to 0\n            break  # Exit after removing one character\n    \n    # Reconstruct the smallest string with updated counts\n    result = []\n    for char in sorted(count.keys()):\n        result.append(char * count[char])\n    \n    return ''.join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        T = data[index + 1]\n        index += 2\n        \n        result = smallest_permutation_without_subsequence(S, T)\n        results.append(result)\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1617_B. GCD Problem", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n = int(data[i])\n        a = 2\n        b = n - 3\n        c = 1\n        results.append(f\"{a} {b} {c}\")\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1617_C. Paprika and Permutation", "solution": "def min_operations_to_permutation(t, test_cases):\n    results = []\n    \n    for n, arr in test_cases:\n        frequency = {}\n        excess_count = 0\n        for num in arr:\n            if num > n:\n                excess_count += 1\n            elif num in frequency:\n                frequency[num] += 1\n            else:\n                frequency[num] = 1\n\n        # Count duplicates\n        duplicate_count = 0\n        for count in frequency.values():\n            if count > 1:\n                duplicate_count += count - 1  # count how many duplicates we have\n\n        # Count missing numbers\n        missing_count = 0\n        for i in range(1, n + 1):\n            if i not in frequency:\n                missing_count += 1\n\n        # The number of operations needed is the number of excess numbers plus the number of duplicates\n        operations_needed = duplicate_count + excess_count\n        if operations_needed > missing_count:\n            results.append(-1)\n        else:\n            results.append(operations_needed)\n\n    return results\n\n# Reading input data and invoking the function\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        arr = list(map(int, data[index + 1].split()))\n        test_cases.append((n, arr))\n        index += 2\n    \n    results = min_operations_to_permutation(t, test_cases)\n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1617_D2. Too Many Impostors (hard version)", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n\n        # To determine the number of impostors and their indices\n        responses = []\n        impostor_count = 0\n        potential_impostors = set(range(1, n + 1))\n\n        # Ask the first n/3 queries with overlapping groups\n        for i in range(1, n + 1, 3):\n            # Query players i, i+1, i+2\n            if i + 2 <= n:\n                print(f\"? {i} {i + 1} {i + 2}\")\n                sys.stdout.flush()\n                response = int(input())\n                responses.append((i, i + 1, i + 2, response))\n        \n        # Analyze responses to find impostor candidates\n        for a, b, c, response in responses:\n            if response == 0:  # More impostors\n                potential_impostors.intersection_update({a, b, c})\n                impostor_count += 1\n            else:  # More crewmates\n                # We can discount these players from potential impostors\n                potential_impostors.difference_update({a, b, c})\n\n        # At this stage we may still not have the exact impostors\n        # But we can assume whoever is left in potential_impostors are impostors\n        impostors = list(potential_impostors)\n\n        if len(impostors) >= 1:\n            # It is guaranteed that we will have k impostors, where n/3 < k < 2n/3\n            k = len(impostors)\n            results.append(f\"! {k} \" + ' '.join(map(str, impostors)))\n\n    # Print all results for each test case\n    print(\"\\n\".join(results))"}
{"task_id": "1617_E. Christmas Chocolates", "solution": "def min_exchanges(a_x, a_y):\n    exchanges = 0\n    while a_x != a_y:\n        k = 0\n        while (1 << k) < a_x:  # 2^k < a_x\n            k += 1\n        a_x = (1 << k) - a_x  # Perform exchange\n        exchanges += 1\n    return exchanges\n\ndef find_optimal_pair(n, chocolates):\n    max_min_exchanges = -1\n    best_pair = (1, 2)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            exchanges = min_exchanges(chocolates[i], chocolates[j])\n            if exchanges > max_min_exchanges:\n                max_min_exchanges = exchanges\n                best_pair = (i + 1, j + 1)  # Convert to 1-based index\n\n    return best_pair[0], best_pair[1], max_min_exchanges\n\n# Input reading\nn = int(input())\nchocolates = list(map(int, input().split()))\n\n# Find the optimal pair\nx, y, m = find_optimal_pair(n, chocolates)\n\n# Output the result\nprint(x, y, m)"}
{"task_id": "1618_A. Polycarp and Sums of Subsequences", "solution": "def restore_array(test_cases):\n    results = []\n    for b in test_cases:\n        b0 = b[0]\n        b1 = b[1]\n        b3 = b[3]\n        b4 = b[4]\n\n        x = b0\n        y = b3 - b0\n        z = b4 - b0\n\n        results.append((x, y, z))\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = [list(map(int, input().strip().split())) for _ in range(t)]\n\n# Get results\nresults = restore_array(test_cases)\n\n# Print output\nfor res in results:\n    print(*res)"}
{"task_id": "1618_B. Missing Bigram", "solution": "def reconstruct_word(test_cases):\n    results = []\n    \n    for n, bigrams in test_cases:\n        # Start with the first bigram\n        first_bigram = bigrams[0]\n        reconstructed_word = first_bigram[0] + first_bigram[1]  # Initialize with the first bigram\n        \n        # Append the second character of each subsequent bigram to the reconstructed word\n        for bigram in bigrams[1:]:\n            reconstructed_word += bigram[1]  # Take the second character of the current bigram\n        \n        results.append(reconstructed_word)\n    \n    return results\n\n# Read the input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split('\\n')\n\n# Parse the input\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    bigrams = data[index + 1].strip().split()\n    test_cases.append((n, bigrams))\n    index += 2\n\n# Get the results\nresults = reconstruct_word(test_cases)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "1618_C. Paint the Array", "solution": "def beautiful_coloring(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        found = False\n        \n        for i in range(n - 1):\n            if (a[i] % 2) == (a[i + 1] % 2):  # both even or both odd\n                d = abs(a[i] - a[i + 1])  # take the absolute difference\n                if d > 0:\n                    results.append(d)\n                    found = True\n                    break\n        \n        if not found:\n            results.append(1)  # If no adjacent with the same parity, d=1 works\n    \n    return results\n\n# Input reading and function calling for testing\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1].split()))\n        test_cases.append((n, a))\n        index += 2\n    \n    results = beautiful_coloring(t, test_cases)\n    \n    for result in results:\n        print(result)"}
{"task_id": "1618_D. Array and Operations", "solution": "def min_score_after_operations(t, test_cases):\n    results = []\n    for n, k, a in test_cases:\n        # Sort the array\n        a.sort()\n        \n        # Initialize score from the remaining elements\n        score = sum(a)\n        \n        # Perform k operations\n        for i in range(k):\n            # Pick the i-th smallest and i-th largest\n            x = a[i]       # Smallest element\n            y = a[n - 1 - i]  # Largest element\n            score -= (x + y)  # Remove both elements from the sum\n            score += (x // y)  # Add the contribution to the score\n            \n        results.append(score)\n    \n    return results\n\n# Read inputs and execute the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nline_num = 1\nfor _ in range(t):\n    n, k = map(int, data[line_num].split())\n    a = list(map(int, data[line_num + 1].split()))\n    test_cases.append((n, k, a))\n    line_num += 2\n\nresults = min_score_after_operations(t, test_cases)\nfor res in results:\n    print(res)"}
{"task_id": "1618_E. Singers' Tour", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index].split()))\n        index += 1\n        \n        # Special case for n == 1\n        if n == 1:\n            if b[0] >= 1:\n                results.append(\"YES\")\n                results.append(str(b[0]))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Calculate differences\n        a = [0] * n\n        for i in range(n):\n            a[i] = b[i] - b[(i - 1) % n]\n        \n        # We need to ensure all a[i] are positive\n        min_a = min(a)\n        if min_a <= 0:\n            # We need to increase all a[i] by (1 - min_a) to ensure all are positive\n            increment = 1 - min_a\n            a = [x + increment for x in a]\n        \n        # Check if all a[i] are within the allowed range\n        if all(1 <= x <= 10**9 for x in a):\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")"}
{"task_id": "1618_F. Reverse", "solution": "def can_transform(x, y):\n    if x == y:\n        return \"YES\"\n    \n    from collections import deque\n    \n    # Set to keep track of visited numbers\n    visited = set()\n    queue = deque([x])\n    visited.add(x)\n    \n    while queue:\n        current = queue.popleft()\n        \n        # Generate the binary representation without leading zeros\n        binary_current = bin(current)[2:]\n        \n        # Generate new numbers by appending 0 and 1 and reversing\n        for bit in ('0', '1'):\n            new_binary = binary_current + bit\n            reversed_binary = new_binary[::-1]\n            new_number = int(reversed_binary, 2)\n            \n            if new_number == y:\n                return \"YES\"\n            if new_number not in visited and new_number <= 10**18:  # Limit to prevent overflow\n                visited.add(new_number)\n                queue.append(new_number)\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\nx, y = map(int, input().strip().split())\n\n# Solve the problem and print the result\nresult = can_transform(x, y)\nprint(result)"}
{"task_id": "1618_G. Trader Problem", "solution": "import sys\nfrom bisect import bisect_right\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    q = int(data[2])\n    \n    a = list(map(int, data[3:n+3]))\n    b = list(map(int, data[n+3:n+3+m]))\n    queries = list(map(int, data[n+3+m:n+3+m+q]))\n    \n    # Sort Monocarp's items and the character's items\n    a.sort()\n    b.sort()\n    \n    # Calculate the base total cost of Monocarp's items\n    base_total = sum(a)\n    \n    # Prepare a list of results for each query\n    results = []\n    \n    # Process each query\n    for k in queries:\n        total_value = base_total\n        \n        # For each item in a, find the best tradeable item from b\n        for x in a:\n            max_trade_value = x + k\n            # Find the position in b where items are <= max_trade_value\n            pos = bisect_right(b, max_trade_value)\n            if pos > 0:  # There is at least one item that can be traded for\n                best_possible_value = b[pos - 1]\n                total_value += best_possible_value - x  # Replace x with the best item possible\n        \n        results.append(total_value)\n    \n    # Output all results\n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")"}
{"task_id": "1619_A. Square String?", "solution": "def is_square_string(s):\n    n = len(s)\n    if n % 2 != 0:  # Length is odd, cannot be square\n        return \"NO\"\n    mid = n // 2\n    if s[:mid] == s[mid:]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # number of test cases\n    results = []\n    \n    for i in range(1, t + 1):\n        results.append(is_square_string(data[i]))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_B. Squares and Cubes", "solution": "import sys\nimport math\n\ndef count_polycarps_likes(n):\n    count_squares = int(math.isqrt(n))  # number of perfect squares <= n\n    count_cubes = int(n ** (1/3))      # number of perfect cubes <= n\n    count_sixth_powers = int(n ** (1/6))  # number of perfect sixth powers <= n\n    return count_squares + count_cubes - count_sixth_powers\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        results.append(count_polycarps_likes(n))\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_C. Wrong Addition", "solution": "def find_b(t, test_cases):\n    results = []\n    \n    for a, s in test_cases:\n        a_str = str(a)\n        s_str = str(s)\n        \n        # Pad the shorter one with leading zeros\n        max_length = max(len(a_str), len(s_str))\n        a_str = a_str.zfill(max_length)\n        s_str = s_str.zfill(max_length)\n        \n        b_digits = []\n        valid = True\n        \n        # Process from the last digit to the first\n        for i in range(max_length - 1, -1, -1):\n            s_digit = int(s_str[i])\n            a_digit = int(a_str[i])\n            # Calculate the required digit for b\n            b_digit = s_digit - a_digit\n            \n            if b_digit < 0:\n                valid = False\n                break\n            \n            b_digits.append(b_digit)\n        \n        if valid:\n            # We need to reverse b_digits to form the correct number\n            b_digits.reverse()\n            # Convert to string and then to integer to remove leading zeros\n            b = int(''.join(map(str, b_digits)))\n            results.append(b)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Read input and run the function\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    \n    test_cases = []\n    for i in range(1, t + 1):\n        a, s = map(int, data[i].split())\n        test_cases.append((a, s))\n    \n    results = find_b(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_D. New Year's Problem", "solution": "def can_assign_gifts(joy_matrix, n, m, alpha):\n    from collections import defaultdict, deque\n    \n    # Create a graph where edges exist for joy values >= alpha\n    graph = defaultdict(list)\n    for shop in range(m):\n        for friend in range(n):\n            if joy_matrix[shop][friend] >= alpha:\n                graph[friend].append(shop)\n    \n    # Bipartite matching\n    match_friend = [-1] * n\n    match_shop = [-1] * m\n    \n    def bfs():\n        queue = deque()\n        for friend in range(n):\n            if match_friend[friend] == -1:  # Free friend\n                queue.append(friend)\n        \n        visited = [False] * n\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    next_friend = match_shop[v]\n                    if next_friend == -1 or bfs_matching(next_friend):\n                        match_friend[u] = v\n                        match_shop[v] = u\n                        return True\n        return False\n\n    def bfs_matching(u):\n        for v in graph[u]:\n            next_friend = match_shop[v]\n            if next_friend == -1 or (not visited[next_friend] and bfs_matching(next_friend)):\n                match_friend[u] = v\n                match_shop[v] = u\n                return True\n        return False\n    \n    # Count maximum matches\n    match_count = 0\n    for friend in range(n):\n        visited = [False] * n\n        if bfs():\n            match_count += 1\n    \n    return match_count >= n  # We need to match all n friends\n\ndef max_min_joy(test_cases):\n    results = []\n    for joy_matrix, n, m in test_cases:\n        low, high = 1, 10**9\n        best_alpha = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if can_assign_gifts(joy_matrix, n, m, mid):\n                best_alpha = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        results.append(best_alpha)\n    return results\n\n# Read input and execute the function\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nindex = 0\nt = int(data[index].strip())\nindex += 1\ntest_cases = []\n\nfor _ in range(t):\n    while not data[index].strip():  # Skip empty lines\n        index += 1\n    m, n = map(int, data[index].strip().split())\n    index += 1\n    joy_matrix = []\n    \n    for _ in range(m):\n        joys = list(map(int, data[index].strip().split()))\n        joy_matrix.append(joys)\n        index += 1\n        \n    test_cases.append((joy_matrix, n, m))\n\nresults = max_min_joy(test_cases)\nprint(\"\\n\".join(map(str, results)))"}
{"task_id": "1619_E. MEX and Increments", "solution": "def mex_operations(test_cases):\n    results = []\n    for n, a in test_cases:\n        count = [0] * (n + 1)\n        for number in a:\n            if number <= n:\n                count[number] += 1\n        \n        operations = [0] * (n + 1)\n        current_operations = 0\n        \n        for i in range(n + 1):\n            if i > 0:\n                # Calculate required operations to ensure all [0...i-1] are present\n                if count[i - 1] == 0:\n                    current_operations += 1  # Need to create i-1\n            # Calculate the operations needed for the current MEX\n            if count[i] > 0:\n                operations[i] = -1  # Can't have i as MEX because it's present\n            else:\n                operations[i] = current_operations\n            \n        results.append(operations)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\n\ndata = input().split()\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    test_cases.append((n, a))\n\n# Process\nresults = mex_operations(test_cases)\n\n# Output\nfor res in results:\n    print(\" \".join(map(str, res)))"}
{"task_id": "1619_F. Let's Play the Hat?", "solution": "def generate_schedule(n, m, k):\n    # Calculate the sizes of low and high tables\n    low = n // m\n    high = (n + m - 1) // m  # This is equivalent to ceil(n / m)\n    \n    # Count how many low and high tables\n    count_high = n % m\n    count_low = m - count_high\n\n    schedule = []\n    \n    # Generate the schedule for `k` games\n    for game in range(k):\n        game_tables = []\n        \n        # Assign players to the tables\n        for table in range(m):\n            if table < count_high:\n                num_players = high\n            else:\n                num_players = low\n            \n            # Calculate the starting index for this game and table\n            start_index = (game * low + table * (high if table < count_high else low)) % n\n            \n            # Collect the players for this table\n            players = [(start_index + i) % n + 1 for i in range(num_players)]\n            \n            # Format the table output\n            game_tables.append(f\"{num_players} \" + \" \".join(map(str, players)))\n        \n        # Add the game tables to the schedule\n        schedule.append(\"\\n\".join(game_tables))\n    \n    return \"\\n\".join(schedule)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Read number of test cases\n    results = []\n    \n    for i in range(1, t + 1):\n        n, m, k = map(int, data[i].split())\n        result = generate_schedule(n, m, k)\n        results.append(result)\n    \n    print(\"\\n\\n\".join(results))  # Separate test cases with a blank line\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_G. Unusual Minesweeper", "solution": "from collections import defaultdict\nimport heapq\nimport sys\ninput = sys.stdin.read\n\ndef process_case(n, k, mines):\n    # Create a mapping from coordinates to timer\n    mine_map = {}\n    for (x, y, timer) in mines:\n        mine_map[(x, y)] = timer\n\n    # Prepare a min-heap for processing mines based on their explosion timers\n    heap = []\n    \n    for (x, y), timer in mine_map.items():\n        # Push each mine into the heap\n        heapq.heappush(heap, (timer, x, y))\n\n    # Keep track of when we've detonated mines\n    detonated = set()\n    \n    # Track the maximum time taken to detonate all mines\n    max_time = 0\n    \n    while heap:\n        time, x, y = heapq.heappop(heap)\n\n        # If we've already detonated this mine, we skip it\n        if (x, y) in detonated:\n            continue\n        \n        # Record the time of detonation\n        detonated.add((x, y))\n        max_time = max(max_time, time)\n\n        # Now we need to trigger explosions for other mines in range\n        for dx in range(-k, k + 1):\n            if abs(dx) == k:  # Only horizontal line\n                if (x + dx, y) in mine_map and (x + dx, y) not in detonated:\n                    # Update the timer for the mine if this explosion detonates it sooner\n                    new_time = time + 1\n                    if mine_map[(x + dx, y)] > new_time:\n                        mine_map[(x + dx, y)] = new_time\n                        heapq.heappush(heap, (new_time, x + dx, y))\n\n        for dy in range(-k, k + 1):\n            if abs(dy) == k:  # Only vertical line\n                if (x, y + dy) in mine_map and (x, y + dy) not in detonated:\n                    new_time = time + 1\n                    if mine_map[(x, y + dy)] > new_time:\n                        mine_map[(x, y + dy)] = new_time\n                        heapq.heappush(heap, (new_time, x, y + dy))\n\n    return max_time\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1  # Skip empty lines\n        n, k = map(int, data[index].strip().split())\n        index += 1\n        \n        mines = []\n        for __ in range(n):\n            x, y, timer = map(int, data[index].strip().split())\n            mines.append((x, y, timer))\n            index += 1\n        \n        result = process_case(n, k, mines)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\n# This is the main function that will invoke the solution when run.\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1619_H. Permutation and Queries", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read the permutation\n    p = list(map(int, data[index:index + n]))\n    index += n\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            # Swap operation\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            # Evaluate operation\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            \n            # To find where `i` goes after `k` applications\n            visited = []\n            current = i\n            \n            # Track the sequence of indices until we revisit\n            while current not in visited:\n                visited.append(current)\n                current = p[current] - 1\n            \n            cycle_length = len(visited)\n            effective_position = visited[k % cycle_length]\n            \n            results.append(p[effective_position])\n            index += 3\n            \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1620_A. Equal or Not Equal", "solution": "def can_construct_array(test_cases):\n    results = []\n    \n    for s in test_cases:\n        n = len(s)\n        \n        # Check for 'N' transitions\n        if 'N' in s:\n            # Check if it wraps around\n            if s[0] == 'N' and s[-1] == 'N':\n                results.append(\"NO\")\n                continue\n            \n            # Check for consecutive N's in the string\n            for i in range(n):\n                if s[i] == 'N' and s[(i + 1) % n] == 'N':\n                    results.append(\"YES\")\n                    break\n            else:\n                results.append(\"NO\")\n        else:\n            # All are 'E's\n            results.append(\"YES\")\n    \n    return results\n\n# Main execution block\nif __name__ == \"__main__\":\n    import sys\n    \n    input = sys.stdin.read\n    data = input().splitlines()\n    t = int(data[0])\n    test_cases = data[1:t + 1]\n    \n    results = can_construct_array(test_cases)\n    for result in results:\n        print(result)"}
{"task_id": "1620_B. Triangles on a Rectangle", "solution": "def calculate_max_doubled_area(w, h, horizontal_0, horizontal_h, vertical_0, vertical_w):\n    max_area = 0\n    \n    # Check points from the horizontal side at y=0\n    k_0 = len(horizontal_0)\n    k_h = len(horizontal_h)\n\n    # Check pairs on horizontal sides y=0 and find maximum with points on y=h\n    for i in range(k_0):\n        for j in range(i + 1, k_0):\n            x1, x2 = horizontal_0[i], horizontal_0[j]\n            for yh in vertical_h:\n                area = abs(x1 * (0 - yh) + x2 * (yh - 0) + 0 * (0 - 0))\n                max_area = max(max_area, area)\n\n    # Check pairs on horizontal sides y=h and find maximum with points on y=0\n    for i in range(k_h):\n        for j in range(i + 1, k_h):\n            x1, x2 = horizontal_h[i], horizontal_h[j]\n            for y0 in vertical_0:\n                area = abs(x1 * (h - y0) + x2 * (y0 - h) + w * (y0 - 0))\n                max_area = max(max_area, area)\n\n    # Check points from the vertical side at x=0\n    k_0 = len(vertical_0)\n    k_w = len(vertical_w)\n\n    # Check pairs on vertical sides x=0 and find maximum with points on x=w\n    for i in range(k_0):\n        for j in range(i + 1, k_0):\n            y1, y2 = vertical_0[i], vertical_0[j]\n            for xw in horizontal_w:\n                area = abs(0 * (y1 - y2) + xw * (y2 - 0) + xw * (0 - y1))\n                max_area = max(max_area, area)\n\n    # Check pairs on vertical sides x=w and find maximum with points on x=0\n    for i in range(k_w):\n        for j in range(i + 1, k_w):\n            y1, y2 = vertical_w[i], vertical_w[j]\n            for x0 in horizontal_0:\n                area = abs(w * (y1 - y2) + x0 * (y2 - h) + x0 * (h - y1))\n                max_area = max(max_area, area)\n\n    return max_area\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split(\"\\n\")\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w, h = map(int, data[index].split())\n        index += 1\n        \n        k_0 = int(data[index])\n        horizontal_0 = list(map(int, data[index + 1].split()))[1:]  # list of points on y=0\n        index += 2\n        \n        k_h = int(data[index])\n        horizontal_h = list(map(int, data[index + 1].split()))[1:]  # list of points on y=h\n        index += 2\n        \n        k_0_v = int(data[index])\n        vertical_0 = list(map(int, data[index + 1].split()))[1:]  # list of points on x=0\n        index += 2\n        \n        k_w = int(data[index])\n        vertical_w = list(map(int, data[index + 1].split()))[1:]  # list of points on x=w\n        index += 2\n        \n        max_double_area = calculate_max_doubled_area(w, h, horizontal_0, horizontal_h, vertical_0, vertical_w)\n        results.append(max_double_area)\n    \n    print(\"\\n\".join(map(str, results)))"}
{"task_id": "1620_C. BA-String", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n, k, x = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        \n        result = []\n        asterisk_count = 0\n        \n        for char in s:\n            if char == 'a':\n                result.append('a')\n            elif char == '*':\n                asterisk_count += 1\n        \n        # We need to decide how many `b`s to place at each asterisk position\n        for i in range(asterisk_count):\n            total_combinations = (k + 1) ** (asterisk_count - i - 1)\n            for b_count in range(k + 1):\n                if x <= total_combinations:\n                    result.append('b' * b_count)\n                    break\n                else:\n                    x -= total_combinations\n        \n        results.append(''.join(result))\n    \n    print('\\n'.join(results))"}
{"task_id": "1620_D. Exact Change", "solution": "def min_coins_needed(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i][0]\n        a = test_cases[i][1]\n        max_coins = 0\n        \n        for price in a:\n            count3 = price // 3\n            remaining = price % 3\n            if remaining == 0:\n                total_coins = count3\n            elif remaining == 1:\n                total_coins = count3 + 1 # Need one 1-burle coin\n            else: # remaining == 2\n                total_coins = count3 + 1 # Need one 2-burle coin\n            \n            max_coins = max(max_coins, total_coins)\n        \n        results.append(max_coins)\n    \n    return results\n\n# Read input and execute the function\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, a))\n    index += 2\n\nresults = min_coins_needed(t, test_cases)\nfor result in results:\n    print(result)"}
{"task_id": "1620_E. Replace the Numbers", "solution": "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    q = int(data[0])  # Number of queries\n    result = []\n    replacements = {}\n    \n    for i in range(1, q + 1):\n        query = data[i].split()\n        if query[0] == \"1\":\n            # Add element to the array\n            x = int(query[1])\n            result.append(x)\n        elif query[0] == \"2\":\n            # Replace all occurrences of x with y\n            x = int(query[1])\n            y = int(query[2])\n            replacements[x] = y\n    \n    # Final pass to apply replacements\n    final_result = []\n    for number in result:\n        # Find the final value after replacements\n        while number in replacements:\n            number = replacements[number]\n        final_result.append(number)\n    \n    # Print the resulting array\n    print(' '.join(map(str, final_result)))"}
{"task_id": "1620_F. Bipartite Array", "solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index + n]))\n        index += n\n        \n        a = [0] * n\n        for i in range(n):\n            if i % 2 == 0:\n                a[i] = p[i]\n            else:\n                a[i] = -p[i]\n        \n        results.append(\"YES\")\n        results.append(\" \".join(map(str, a)))\n    \n    print(\"\\n\".join(results))"}
{"task_id": "1620_G. Subsequences Galore", "solution": "def count_distinct_subsequences(s):\n    from collections import Counter\n    \n    counts = Counter(s)\n    result = 1\n    for count in counts.values():\n        result *= (count + 1)\n        result %= 998244353\n    return (result - 1 + 998244353) % 998244353  # Subtracting 1 for excluding the empty subsequence\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    strings = data[1:n+1]\n    \n    total_xor = 0\n    modulo = 998244353\n    \n    # Iterate over all possible subsets\n    from itertools import combinations\n    \n    for subset_mask in range(1, 1 << n):\n        combined_string = \"\"\n        indices_sum = 0\n        count_k = 0\n        \n        for i in range(n):\n            if subset_mask & (1 << i):  # If i-th string is included\n                combined_string += strings[i]\n                indices_sum += (i + 1)\n                count_k += 1\n        \n        distinct_count = count_distinct_subsequences(combined_string)\n        total_value = distinct_count * count_k * indices_sum % modulo\n        \n        total_xor ^= total_value\n    \n    print(total_xor)\n\n# Make sure to call the main function\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1622_A. Construct a Rectangle", "solution": "def can_form_rectangle(test_cases):\n    results = []\n    for l1, l2, l3 in test_cases:\n        a, b, c = sorted([l1, l2, l3])\n        # Check if the sum of the two smaller lengths is greater than or equal to the largest length\n        if a + b >= c:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\n# Read inputs from stdin and solve the problem\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    for i in range(1, t + 1):\n        l1, l2, l3 = map(int, data[i].split())\n        test_cases.append((l1, l2, l3))\n    \n    results = can_form_rectangle(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1622_B. Berland Music", "solution": "def re_evaluate_ratings(test_cases):\n    results = []\n    \n    for n, p, s in test_cases:\n        # Separate indices based on Monocarp's likes and dislikes\n        liked_indices = []\n        disliked_indices = []\n        \n        for i in range(n):\n            if s[i] == '1':\n                liked_indices.append(i)\n            else:\n                disliked_indices.append(i)\n        \n        # Sort the original predicted ratings\n        sorted_p = sorted(p)\n        \n        # Allocate ratings\n        m = len(liked_indices)\n        k = len(disliked_indices)\n        \n        # Assign the smallest `k` ratings to disliked songs\n        disliked_ratings = sorted_p[:k]\n        # Assign the largest `m` ratings to liked songs\n        liked_ratings = sorted_p[k:]\n        \n        # Prepare the result array\n        q = [0] * n\n        \n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n        \n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n\n        results.append(\" \".join(map(str, q)))\n    \n    return results\n\n# To handle input/output\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    \n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        p = list(map(int, data[index + 1].split()))\n        s = data[index + 2]\n        test_cases.append((n, p, s))\n        index += 3\n    \n    results = re_evaluate_ratings(test_cases)\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1622_C. Set or Decrease", "solution": "def minimum_steps_to_reduce_sum(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, k, a = case\n        current_sum = sum(a)\n        \n        if current_sum <= k:\n            results.append(0)\n            continue\n        \n        excess = current_sum - k\n        results.append(excess)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\ntest_cases = []\nline_index = 1\n\nfor _ in range(t):\n    n, k = map(int, data[line_index].split())\n    a = list(map(int, data[line_index + 1].split()))\n    test_cases.append((n, k, a))\n    line_index += 2\n\nresults = minimum_steps_to_reduce_sum(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"task_id": "1622_D. Shuffle", "solution": "def factorial_mod(n, mod):\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\ndef count_unique_binary_strings(n, k, s):\n    MOD = 998244353\n    \n    if k == 0:\n        return 1  # Only the original string is valid\n\n    total_ones = s.count('1')\n    \n    if total_ones < k:\n        return 1  # Original string only, as we can't form any valid substring with k '1's\n    \n    unique_strings = set()\n    original_string = s\n    unique_strings.add(original_string)\n\n    # Sliding window to find substrings with exactly k '1's\n    for start in range(n):\n        count_ones = 0\n        count_zeros = 0\n        for end in range(start, n):\n            if s[end] == '1':\n                count_ones += 1\n            else:\n                count_zeros += 1\n            \n            if count_ones > k:\n                break  # No need to continue if we already have more than k '1's\n            \n            if count_ones == k:\n                # We found a substring with exactly k '1's\n                # Calculate the number of unique arrangements we can create\n                total_length = count_zeros + count_ones\n                arrangements = (factorial_mod(total_length, MOD) *\n                                pow(factorial_mod(count_zeros, MOD), MOD - 2, MOD) % MOD *\n                                pow(factorial_mod(count_ones, MOD), MOD - 2, MOD) % MOD) % MOD\n                \n                # Create the new string with the rearrangement\n                new_string = s[:start] + '1' * count_ones + '0' * count_zeros + s[end + 1:]\n                unique_strings.add(new_string)\n\n    return len(unique_strings)\n\n# Read inputs\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(count_unique_binary_strings(n, k, s))"}
{"task_id": "1622_E. Math Test", "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        x = list(map(int, data[index].split()))\n        index += 1 + n  # Skip expected scores and student answers\n        \n        # Create a permutation from m to 1\n        permutation = list(range(m, 0, -1))\n        results.append(\" \".join(map(str, permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1622_F. Quadratic Set", "solution": "def find_quadratic_subset(n):\n    subset = []\n    \n    # Start by including all odd numbers\n    for num in range(1, n + 1):\n        if num % 2 == 1:  # Odd numbers\n            subset.append(num)\n    \n    # Include specific even numbers\n    # We can include all evens from 2 to n when n is even, else from 2 to n - 1\n    if n >= 2:\n        if n % 2 == 0:\n            subset.append(2)  # Include 2 if n is even\n        if n >= 4:\n            subset.append(4)  # Include 4 if n >= 4\n        if n >= 6:\n            subset.append(6)  # Include 6 if n >= 6\n            \n    # Print the size and the subset\n    print(len(subset))\n    print(\" \".join(map(str, subset)))\n\n# Input reading\nn = int(input().strip())\nfind_quadratic_subset(n)"}
{"task_id": "1623_A. Robot Cleaner", "solution": "def time_to_clean(t, test_cases):\n    result = []\n    \n    for case in test_cases:\n        n, m, r_b, c_b, r_d, c_d = case\n        time = 0\n        \n        # If the robot is already in the same row or column as the dirty cell\n        if r_b == r_d or c_b == c_d:\n            result.append(0)\n            continue\n        \n        # Initial movements\n        dr = 1\n        dc = 1\n        \n        while True:\n            # Clean the current position\n            if r_b == r_d or c_b == c_d:\n                result.append(time)\n                break\n            \n            # Move the robot\n            r_b += dr\n            c_b += dc\n            time += 1\n            \n            # Reflect if it hits the walls\n            if r_b < 1:  # hit top wall\n                r_b = 1\n                dr = -dr\n            elif r_b > n:  # hit bottom wall\n                r_b = n\n                dr = -dr\n            \n            if c_b < 1:  # hit left wall\n                c_b = 1\n                dc = -dc\n            elif c_b > m:  # hit right wall\n                c_b = m\n                dc = -dc\n    \n    return result\n\n# Reading input and output\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nt = int(data[0])\ntest_cases = [tuple(map(int, line.split())) for line in data[1:t+1]]\n\n# Get the results\nresults = time_to_clean(t, test_cases)\n\n# Print the results\nfor res in results:\n    print(res)"}
{"task_id": "1623_B. Game on Ranges", "solution": "def find_numbers_in_ranges(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        ranges = case[1]\n        \n        # Sort ranges based on their starting value\n        ranges.sort()\n        \n        # To keep track of which numbers are chosen\n        chosen = [False] * (n + 1)\n        current_results = []\n        \n        for l, r in ranges:\n            # Find the smallest available number in the range [l, r]\n            for d in range(l, r + 1):\n                if not chosen[d]:\n                    chosen[d] = True\n                    current_results.append((l, r, d))\n                    break\n        \n        # Store the results\n        results.append(current_results)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        ranges = []\n        for _ in range(n):\n            l, r = map(int, data[index].split())\n            ranges.append((l, r))\n            index += 1\n        test_cases.append((n, ranges))\n    \n    results = find_numbers_in_ranges(t, test_cases)\n    \n    for result in results:\n        for l, r, d in result:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1623_C. Balanced Stone Heaps", "solution": "def max_min_heap_size(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        heaps = case[1]\n        \n        lo, hi = 0, max(heaps)\n        \n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            # Check if we can make all heaps at least mid\n            extra = 0\n            possible = True\n            \n            for i in range(2, n):  # Start from the 3rd heap (index 2)\n                current = heaps[i] + extra\n                if current < mid:\n                    # Not enough stones in the current heap to be at least mid\n                    possible = False\n                    break\n                \n                # Calculate how much we can move\n                d = (current - mid) // 3\n                extra = d * 3\n            \n            # Check the last two heaps\n            if possible:\n                last_heap = heaps[n-1] + extra\n                if last_heap < mid:\n                    possible = False\n            \n            if possible:\n                lo = mid  # mid is possible, search higher\n            else:\n                hi = mid - 1  # mid is not possible, search lower\n        \n        results.append(lo)\n    \n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nt = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    heaps = list(map(int, data[index + 1].split()))\n    test_cases.append((n, heaps))\n    index += 2\n\nresults = max_min_heap_size(t, test_cases)\n\n# Writing output\nfor res in results:\n    print(res)"}
{"task_id": "1623_D. Robot Cleaner Revisit", "solution": "def modular_inverse(a, mod):\n    # Calculate a^(mod-2) % mod using Fermat's Little Theorem\n    return pow(a, mod - 2, mod)\n\ndef expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    MOD = 10**9 + 7\n    \n    # Calculate the number of opportunities\n    k = 0\n\n    # Check if the dirty cell is in the same row as the initial position\n    if r_b == r_d or c_b == c_d:\n        k += 1  # The first cleaning opportunity\n    \n    # Calculate the distance to wall in each direction\n    dist_top = r_b - 1\n    dist_bottom = n - r_b\n    dist_left = c_b - 1\n    dist_right = m - c_b\n    \n    # Calculate maximum steps before hitting walls\n    steps = min(dist_bottom, dist_right) + min(dist_top, dist_left)  # Diagonal moves\n    \n    # Each diagonal step gives an opportunity to clean the dirty cell if within bounds\n    if r_d >= r_b and c_d >= c_b:\n        k += steps\n    elif r_d >= r_b and c_d <= c_b:\n        k += steps\n    elif r_d <= r_b and c_d >= c_b:\n        k += steps\n    elif r_d <= r_b and c_d <= c_b:\n        k += steps\n\n    # Calculate the expected time\n    if p == 0:\n        return float('inf')  # Impossible to clean\n    else:\n        expected_value = (k * 100) * modular_inverse(p, MOD) % MOD\n        return expected_value\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        n, m, r_b, c_b, r_d, c_d, p = map(int, data[i].split())\n        result = expected_time(n, m, r_b, c_b, r_d, c_d, p)\n        results.append(result)\n    \n    # Print all results, one per line\n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "1623_E. Middle Duplication", "solution": "def smallest_string_with_duplicates(n, k, labels, children):\n    # Convert labels to a list of characters for easier manipulation\n    label_list = list(labels)\n    \n    # A function to perform DFS and compute the minimum string \n    def dfs(node, duplicates_used):\n        if node == 0:  # If the node is None\n            return \"\"\n        \n        l, r = children[node - 1]  # Get left and right children\n        \n        # Get the strings resulting from left and right subtrees\n        left_string = dfs(l, duplicates_used)\n        right_string = dfs(r, duplicates_used)\n        \n        # Current label\n        current_label = label_list[node - 1]\n        \n        # Result without duplication\n        result_without_duplication = left_string + current_label + right_string\n        \n        # If we can duplicate this node's label\n        if duplicates_used < k:\n            # Result with duplication\n            result_with_duplication = left_string + current_label + current_label + right_string\n            \n            # Return the lexicographically smallest string\n            return min(result_without_duplication, result_with_duplication)\n        \n        return result_without_duplication\n\n    # Start DFS from the root (node 1) with 0 duplicates used\n    return dfs(1, 0)\n\n# Read inputs\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nlabels = data[1].strip()\nchildren = []\n\nfor i in range(2, n + 2):\n    l, r = map(int, data[i].split())\n    children.append((l, r))\n\n# Get the result and print it\nresult = smallest_string_with_duplicates(n, k, labels, children)\nprint(result)"}
