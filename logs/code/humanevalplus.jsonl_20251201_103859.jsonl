{"task_id": "HumanEval/0", "code": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:  # Check for edge case\n        return False\n\n    numbers.sort()  # Step 1: Sort the list\n\n    for i in range(len(numbers) - 1):  # Step 2: Check adjacent elements\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True  # Found a pair that is too close\n\n    return False  # No pairs found that are closer than the threshold\n\nThis implementation follows the approach outlined and checks for pairs of numbers that are closer than the specified threshold. It handles sorting the numbers, checking for adjacency, and includes an edge case for lists with fewer than two elements."}
{"task_id": "HumanEval/1", "code": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Step 1: Remove spaces from the input string\n    cleaned_string = ''.join(paren_string.split())\n    \n    # Initialize variables\n    result = []\n    balance = 0\n    start = 0\n    \n    # Step 2: Iterate through each character in the cleaned string\n    for i, char in enumerate(cleaned_string):\n        if char == '(':\n            # Increment balance for an opening parenthesis\n            if balance == 0:\n                start = i  # Start of a new group\n            balance += 1\n        elif char == ')':\n            # Decrement balance for a closing parenthesis\n            balance -= 1\n            \n            # Step 4: Check if we have a complete group\n            if balance == 0:\n                result.append(cleaned_string[start:i + 1])  # Include current closing parenthesis\n                \n    # Step 5: Return the result\n    return result"}
{"task_id": "HumanEval/2", "code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    integer_part = int(number)  # Get the integer part\n    decimal_part = number - integer_part  # Calculate the decimal part\n    return decimal_part  # Return the decimal part"}
{"task_id": "HumanEval/3", "code": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "code": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:  # Handle the case of an empty list\n        return 0.0\n    \n    n = len(numbers)\n    mean = sum(numbers) / n  # Step 1: Calculate the mean\n    \n    absolute_deviations = [abs(x - mean) for x in numbers]  # Step 2: Calculate absolute deviations\n    \n    mad = sum(absolute_deviations) / n  # Step 3: Calculate mean absolute deviation\n    \n    return mad  # Step 4: Return the result"}
{"task_id": "HumanEval/5", "code": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:  # Check for the empty list case\n        return []\n    \n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])  # Add the current element\n        if i < len(numbers) - 1:  # If it's not the last element, add the delimiter\n            result.append(delimeter)\n    \n    return result"}
{"task_id": "HumanEval/6", "code": "def parse_nested_parens(paren_string: str) -> List[int]:\n    results = []\n    groups = paren_string.split()\n\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n                # Ensure we do not go below zero depth\n                if current_depth < 0:\n                    current_depth = 0\n\n        results.append(max_depth)\n\n    return results\n\n# Test case\nassert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n\nIn this implementation, we handle each group of parentheses separately, calculating the maximum depth for each group and then returning a list of those maximum depths. We also ensure that the depth does not go negative, which would indicate an unmatched closing parenthesis."}
