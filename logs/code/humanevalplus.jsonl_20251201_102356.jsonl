{"task_id": "HumanEval/0", "code": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"task_id": "HumanEval/1", "code": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Step 1: Remove spaces from the input string\n    paren_string = paren_string.replace(' ', '')\n    \n    result = []\n    balance = 0\n    start_index = 0\n    \n    # Step 2: Iterate through the string\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if balance == 0:\n                start_index = i  # Record the start of a new group\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        \n        # Step 3: Check if we have a complete group\n        if balance == 0:\n            result.append(paren_string[start_index:i + 1])  # Extract and store the complete group\n    \n    # Step 4: Return the result\n    return result"}
{"task_id": "HumanEval/2", "code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    integer_part = int(number)  # Get the integer part\n    decimal_part = number - integer_part  # Calculate the decimal part\n    return decimal_part"}
{"task_id": "HumanEval/3", "code": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "code": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:  # Handle the empty list case\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)  # Step 1: Calculate Mean\n    absolute_deviations = [abs(x - mean) for x in numbers]  # Step 2: Calculate Absolute Deviations\n    mad = sum(absolute_deviations) / len(numbers)  # Step 3: Calculate Average of Absolute Deviations\n    \n    return mad  # Step 4: Return the result"}
{"task_id": "HumanEval/5", "code": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:  # Don't append delimiter after the last element\n            result.append(delimeter)\n\n    return result"}
{"task_id": "HumanEval/6", "code": "def parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()  # Split the input string into groups by spaces\n    depths = []  # This will hold the maximum depths for each group\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        depths.append(max_depth)  # Append the maximum depth of the current group to the list\n    \n    return depths"}
{"task_id": "HumanEval/7", "code": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "code": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    total_sum = 0\n    total_product = 1\n    \n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    \n    return (total_sum, total_product)"}
{"task_id": "HumanEval/9", "code": "def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Handle case for empty list\n        return []\n    \n    rolling_max_list = []\n    current_max = numbers[0]  # Initialize with the first element\n\n    for number in numbers:\n        if number > current_max:\n            current_max = number  # Update current max if current number is greater\n        rolling_max_list.append(current_max)  # Append the current max to the result list\n\n    return rolling_max_list"}
{"task_id": "HumanEval/10", "code": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string. \"\"\"\n    # Helper function to check if a string is a palindrome\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    # Length of the input string\n    n = len(string)\n\n    # Find the longest palindromic suffix\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            # Found the longest palindromic suffix\n            suffix_start = i\n            break\n    else:\n        # If no palindromic suffix is found (which shouldn't happen), default to the full string\n        suffix_start = n\n\n    # The non-palindromic prefix\n    non_palindromic_prefix = string[:suffix_start]\n\n    # Construct the shortest palindrome\n    # Append the reverse of the non-palindromic prefix\n    shortest_palindrome = string + non_palindromic_prefix[::-1]\n\n    return shortest_palindrome"}
{"task_id": "HumanEval/11", "code": "def string_xor(a: str, b: str) -> str:\n    result = []\n    for bit_a, bit_b in zip(a, b):\n        # Applying XOR: append '1' if bits are different, '0' if they are the same\n        if bit_a == bit_b:\n            result.append('0')\n        else:\n            result.append('1')\n    return ''.join(result)"}
{"task_id": "HumanEval/12", "code": "def longest(strings: List[str]) -> Optional[str]:\n    if not strings:  # Check if the list is empty\n        return None\n    \n    longest_string = strings[0]  # Initialize with the first string\n    \n    for string in strings:  # Iterate through each string\n        if len(string) > len(longest_string):  # Compare lengths\n            longest_string = string  # Update longest string\n    \n    return longest_string  # Return the longest string found"}
{"task_id": "HumanEval/13", "code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)"}
{"task_id": "HumanEval/14", "code": "def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i + 1] for i in range(len(string))]"}
