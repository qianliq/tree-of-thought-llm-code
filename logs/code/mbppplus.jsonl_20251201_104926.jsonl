{"task_id": "Mbpp/2", "code": "def similar_elements(list1, list2):\n    # Convert lists to sets and find the intersection\n    shared_elements = set(list1) & set(list2)\n    # Sort the shared elements and convert to a tuple\n    return tuple(sorted(shared_elements))\n\nThis implementation correctly identifies and returns the shared elements from the two input lists in the required format."}
{"task_id": "Mbpp/3", "code": "def is_not_prime(n):\n    if n <= 1:\n        return True  # 0, 1, and negative numbers are not prime\n    if n == 2:\n        return False  # 2 is prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a factor, hence n is not prime\n    return False  # No factors found, hence n is prime"}
{"task_id": "Mbpp/4", "code": "def heap_queue_largest(numbers, n):\n    if not numbers or n <= 0:\n        return []\n    return heapq.nlargest(n, numbers)\n\n### Explanation:\n- We first check if `numbers` is empty or if `n` is less than or equal to zero. If either condition is true, we return an empty list.\n- We then use `heapq.nlargest(n, numbers)` which efficiently finds the `n` largest elements in the list `numbers` and returns them in descending order. This function is optimized for performance and handles the task in a straightforward manner.\n\n### Testing the Implementation:\nYou can run the provided assertions to verify that the function behaves as expected. For example:\nassert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\nassert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\nassert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]"}
{"task_id": "Mbpp/6", "code": "def differ_At_One_Bit_Pos(num1, num2):\n    xor_result = num1 ^ num2  # Perform XOR on the two numbers\n    # Check if the result is a power of two\n    return xor_result > 0 and (xor_result & (xor_result - 1)) == 0\n\nThis function will return `True` if the two numbers differ at exactly one bit position and `False` otherwise."}
{"task_id": "Mbpp/7", "code": "def find_char_long(input_string):\n    # Step 2: Split the string into words\n    words = input_string.split()\n    # Step 3: Filter words that are at least 4 characters long\n    long_words = [word for word in words if len(word) >= 4]\n    # Step 4: Return the result\n    return long_words"}
{"task_id": "Mbpp/8", "code": "def square_nums(nums):\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "code": "def find_Rotations(s):\n    n = len(s)\n    original = s\n    rotations = 0\n    \n    for i in range(1, n + 1):\n        # Rotate the string\n        s = s[1:] + s[0]  # Move the first character to the end\n        rotations += 1\n        \n        if s == original:\n            return rotations\n    \n    return n  # This should not be reached, but in case, return n"}
{"task_id": "Mbpp/11", "code": "def remove_Occ(s, ch):\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n\n    # If the character does not exist in the string\n    if first_index == -1:\n        return s\n\n    # If the first and last indices are the same, it means there's only one occurrence.\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n\n    # Construct the new string\n    result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    \n    return result"}
{"task_id": "Mbpp/12", "code": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))"}
{"task_id": "Mbpp/14", "code": "def find_Volume(base, height_triangle, height_prism):\n    # Calculate the base area of the triangle\n    base_area = 0.5 * base * height_triangle\n    # Calculate the volume of the prism\n    volume = base_area * height_prism\n    return volume"}
